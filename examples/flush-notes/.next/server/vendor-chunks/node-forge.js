"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-forge";
exports.ids = ["vendor-chunks/node-forge"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-forge/lib/aes.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/aes.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Advanced Encryption Standard (AES) implementation.\n *\n * This implementation is based on the public domain library 'jscrypto' which\n * was written by:\n *\n * Emily Stark (estark@stanford.edu)\n * Mike Hamburg (mhamburg@stanford.edu)\n * Dan Boneh (dabo@cs.stanford.edu)\n *\n * Parts of this code are based on the OpenSSL implementation of AES:\n * http://www.openssl.org\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./cipher */ \"(ssr)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! ./cipherModes */ \"(ssr)/./node_modules/node-forge/lib/cipherModes.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n/* AES API */ module.exports = forge.aes = forge.aes || {};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('AES-<mode>', key);\n * cipher.start({iv: iv});\n *\n * Creates an AES cipher object to encrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as a string of bytes, an array of bytes,\n * a byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.startEncrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: false,\n        mode: mode\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('AES-<mode>', key);\n *\n * Creates an AES cipher object to encrypt data using the given symmetric key.\n *\n * The key may be given as a string of bytes, an array of bytes, a\n * byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.createEncryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: false,\n        mode: mode\n    });\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\n * decipher.start({iv: iv});\n *\n * Creates an AES cipher object to decrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as a string of bytes, an array of bytes,\n * a byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.startDecrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: true,\n        mode: mode\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\n *\n * Creates an AES cipher object to decrypt data using the given symmetric key.\n *\n * The key may be given as a string of bytes, an array of bytes, a\n * byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.createDecryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: true,\n        mode: mode\n    });\n};\n/**\n * Creates a new AES cipher algorithm object.\n *\n * @param name the name of the algorithm.\n * @param mode the mode factory function.\n *\n * @return the AES algorithm object.\n */ forge.aes.Algorithm = function(name, mode) {\n    if (!init) {\n        initialize();\n    }\n    var self = this;\n    self.name = name;\n    self.mode = new mode({\n        blockSize: 16,\n        cipher: {\n            encrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._w, inBlock, outBlock, false);\n            },\n            decrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._w, inBlock, outBlock, true);\n            }\n        }\n    });\n    self._init = false;\n};\n/**\n * Initializes this AES algorithm by expanding its key.\n *\n * @param options the options to use.\n *          key the key to use with this algorithm.\n *          decrypt true if the algorithm should be initialized for decryption,\n *            false for encryption.\n */ forge.aes.Algorithm.prototype.initialize = function(options) {\n    if (this._init) {\n        return;\n    }\n    var key = options.key;\n    var tmp;\n    /* Note: The key may be a string of bytes, an array of bytes, a byte\n    buffer, or an array of 32-bit integers. If the key is in bytes, then\n    it must be 16, 24, or 32 bytes in length. If it is in 32-bit\n    integers, it must be 4, 6, or 8 integers long. */ if (typeof key === \"string\" && (key.length === 16 || key.length === 24 || key.length === 32)) {\n        // convert key string into byte buffer\n        key = forge.util.createBuffer(key);\n    } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {\n        // convert key integer array into byte buffer\n        tmp = key;\n        key = forge.util.createBuffer();\n        for(var i = 0; i < tmp.length; ++i){\n            key.putByte(tmp[i]);\n        }\n    }\n    // convert key byte buffer into 32-bit integer array\n    if (!forge.util.isArray(key)) {\n        tmp = key;\n        key = [];\n        // key lengths of 16, 24, 32 bytes allowed\n        var len = tmp.length();\n        if (len === 16 || len === 24 || len === 32) {\n            len = len >>> 2;\n            for(var i = 0; i < len; ++i){\n                key.push(tmp.getInt32());\n            }\n        }\n    }\n    // key must be an array of 32-bit integers by now\n    if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {\n        throw new Error(\"Invalid key parameter.\");\n    }\n    // encryption operation is always used for these modes\n    var mode = this.mode.name;\n    var encryptOp = [\n        \"CFB\",\n        \"OFB\",\n        \"CTR\",\n        \"GCM\"\n    ].indexOf(mode) !== -1;\n    // do key expansion\n    this._w = _expandKey(key, options.decrypt && !encryptOp);\n    this._init = true;\n};\n/**\n * Expands a key. Typically only used for testing.\n *\n * @param key the symmetric key to expand, as an array of 32-bit words.\n * @param decrypt true to expand for decryption, false for encryption.\n *\n * @return the expanded key.\n */ forge.aes._expandKey = function(key, decrypt) {\n    if (!init) {\n        initialize();\n    }\n    return _expandKey(key, decrypt);\n};\n/**\n * Updates a single block. Typically only used for testing.\n *\n * @param w the expanded key to use.\n * @param input an array of block-size 32-bit words.\n * @param output an array of block-size 32-bit words.\n * @param decrypt true to decrypt, false to encrypt.\n */ forge.aes._updateBlock = _updateBlock;\n/** Register AES algorithms **/ registerAlgorithm(\"AES-ECB\", forge.cipher.modes.ecb);\nregisterAlgorithm(\"AES-CBC\", forge.cipher.modes.cbc);\nregisterAlgorithm(\"AES-CFB\", forge.cipher.modes.cfb);\nregisterAlgorithm(\"AES-OFB\", forge.cipher.modes.ofb);\nregisterAlgorithm(\"AES-CTR\", forge.cipher.modes.ctr);\nregisterAlgorithm(\"AES-GCM\", forge.cipher.modes.gcm);\nfunction registerAlgorithm(name, mode) {\n    var factory = function() {\n        return new forge.aes.Algorithm(name, mode);\n    };\n    forge.cipher.registerAlgorithm(name, factory);\n}\n/** AES implementation **/ var init = false; // not yet initialized\nvar Nb = 4; // number of words comprising the state (AES = 4)\nvar sbox; // non-linear substitution table used in key expansion\nvar isbox; // inversion of sbox\nvar rcon; // round constant word array\nvar mix; // mix-columns table\nvar imix; // inverse mix-columns table\n/**\n * Performs initialization, ie: precomputes tables to optimize for speed.\n *\n * One way to understand how AES works is to imagine that 'addition' and\n * 'multiplication' are interfaces that require certain mathematical\n * properties to hold true (ie: they are associative) but they might have\n * different implementations and produce different kinds of results ...\n * provided that their mathematical properties remain true. AES defines\n * its own methods of addition and multiplication but keeps some important\n * properties the same, ie: associativity and distributivity. The\n * explanation below tries to shed some light on how AES defines addition\n * and multiplication of bytes and 32-bit words in order to perform its\n * encryption and decryption algorithms.\n *\n * The basics:\n *\n * The AES algorithm views bytes as binary representations of polynomials\n * that have either 1 or 0 as the coefficients. It defines the addition\n * or subtraction of two bytes as the XOR operation. It also defines the\n * multiplication of two bytes as a finite field referred to as GF(2^8)\n * (Note: 'GF' means \"Galois Field\" which is a field that contains a finite\n * number of elements so GF(2^8) has 256 elements).\n *\n * This means that any two bytes can be represented as binary polynomials;\n * when they multiplied together and modularly reduced by an irreducible\n * polynomial of the 8th degree, the results are the field GF(2^8). The\n * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.\n * This multiplication is associative with 0x01 as the identity:\n *\n * (b * 0x01 = GF(b, 0x01) = b).\n *\n * The operation GF(b, 0x02) can be performed at the byte level by left\n * shifting b once and then XOR'ing it (to perform the modular reduction)\n * with 0x11b if b is >= 128. Repeated application of the multiplication\n * of 0x02 can be used to implement the multiplication of any two bytes.\n *\n * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can\n * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these\n * factors can each be multiplied by 0x57 and then added together. To do\n * the multiplication, values for 0x57 multiplied by each of these 3 factors\n * can be precomputed and stored in a table. To add them, the values from\n * the table are XOR'd together.\n *\n * AES also defines addition and multiplication of words, that is 4-byte\n * numbers represented as polynomials of 3 degrees where the coefficients\n * are the values of the bytes.\n *\n * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.\n *\n * Addition is performed by XOR'ing like powers of x. Multiplication\n * is performed in two steps, the first is an algebriac expansion as\n * you would do normally (where addition is XOR). But the result is\n * a polynomial larger than 3 degrees and thus it cannot fit in a word. So\n * next the result is modularly reduced by an AES-specific polynomial of\n * degree 4 which will always produce a polynomial of less than 4 degrees\n * such that it will fit in a word. In AES, this polynomial is x^4 + 1.\n *\n * The modular product of two polynomials 'a' and 'b' is thus:\n *\n * d(x) = d3x^3 + d2x^2 + d1x + d0\n * with\n * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)\n * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)\n * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)\n * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)\n *\n * As a matrix:\n *\n * [d0] = [a0 a3 a2 a1][b0]\n * [d1]   [a1 a0 a3 a2][b1]\n * [d2]   [a2 a1 a0 a3][b2]\n * [d3]   [a3 a2 a1 a0][b3]\n *\n * Special polynomials defined by AES (0x02 == {02}):\n * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}\n * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.\n *\n * These polynomials are used in the MixColumns() and InverseMixColumns()\n * operations, respectively, to cause each element in the state to affect\n * the output (referred to as diffusing).\n *\n * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the\n * polynomial x3.\n *\n * The ShiftRows() method modifies the last 3 rows in the state (where\n * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.\n * The 1st byte in the second row is moved to the end of the row. The 1st\n * and 2nd bytes in the third row are moved to the end of the row. The 1st,\n * 2nd, and 3rd bytes are moved in the fourth row.\n *\n * More details on how AES arithmetic works:\n *\n * In the polynomial representation of binary numbers, XOR performs addition\n * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)\n * corresponds with the multiplication of polynomials modulo an irreducible\n * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply\n * polynomial 'a' with polynomial 'b' and then do a modular reduction by\n * an AES-specific irreducible polynomial of degree 8.\n *\n * A polynomial is irreducible if its only divisors are one and itself. For\n * the AES algorithm, this irreducible polynomial is:\n *\n * m(x) = x^8 + x^4 + x^3 + x + 1,\n *\n * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:\n * 100011011 = 283 = 0x11b.\n *\n * For example, GF(0x57, 0x83) = 0xc1 because\n *\n * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1\n * 0x85 = 131 = 10000101 = x^7 + x + 1\n *\n * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)\n * =  x^13 + x^11 + x^9 + x^8 + x^7 +\n *    x^7 + x^5 + x^3 + x^2 + x +\n *    x^6 + x^4 + x^2 + x + 1\n * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y\n *    y modulo (x^8 + x^4 + x^3 + x + 1)\n * =  x^7 + x^6 + 1.\n *\n * The modular reduction by m(x) guarantees the result will be a binary\n * polynomial of less than degree 8, so that it can fit in a byte.\n *\n * The operation to multiply a binary polynomial b with x (the polynomial\n * x in binary representation is 00000010) is:\n *\n * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1\n *\n * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the\n * most significant bit is 0 in b) then the result is already reduced. If\n * it is 1, then we can reduce it by subtracting m(x) via an XOR.\n *\n * It follows that multiplication by x (00000010 or 0x02) can be implemented\n * by performing a left shift followed by a conditional bitwise XOR with\n * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by\n * higher powers of x can be implemented by repeated application of xtime().\n *\n * By adding intermediate results, multiplication by any constant can be\n * implemented. For instance:\n *\n * GF(0x57, 0x13) = 0xfe because:\n *\n * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)\n *\n * Note: We XOR with 0x11b instead of 0x1b because in javascript our\n * datatype for b can be larger than 1 byte, so a left shift will not\n * automatically eliminate bits that overflow a byte ... by XOR'ing the\n * overflow bit with 1 (the extra one from 0x11b) we zero it out.\n *\n * GF(0x57, 0x02) = xtime(0x57) = 0xae\n * GF(0x57, 0x04) = xtime(0xae) = 0x47\n * GF(0x57, 0x08) = xtime(0x47) = 0x8e\n * GF(0x57, 0x10) = xtime(0x8e) = 0x07\n *\n * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))\n *\n * And by the distributive property (since XOR is addition and GF() is\n * multiplication):\n *\n * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)\n * = 0x57 ^ 0xae ^ 0x07\n * = 0xfe.\n */ function initialize() {\n    init = true;\n    /* Populate the Rcon table. These are the values given by\n    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)\n    in the field of GF(2^8), where i starts at 1.\n\n    rcon[0] = [0x00, 0x00, 0x00, 0x00]\n    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1\n    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2\n    ...\n    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B\n    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36\n\n    We only store the first byte because it is the only one used.\n  */ rcon = [\n        0x00,\n        0x01,\n        0x02,\n        0x04,\n        0x08,\n        0x10,\n        0x20,\n        0x40,\n        0x80,\n        0x1B,\n        0x36\n    ];\n    // compute xtime table which maps i onto GF(i, 0x02)\n    var xtime = new Array(256);\n    for(var i = 0; i < 128; ++i){\n        xtime[i] = i << 1;\n        xtime[i + 128] = i + 128 << 1 ^ 0x11B;\n    }\n    // compute all other tables\n    sbox = new Array(256);\n    isbox = new Array(256);\n    mix = new Array(4);\n    imix = new Array(4);\n    for(var i = 0; i < 4; ++i){\n        mix[i] = new Array(256);\n        imix[i] = new Array(256);\n    }\n    var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;\n    for(var i = 0; i < 256; ++i){\n        /* We need to generate the SubBytes() sbox and isbox tables so that\n      we can perform byte substitutions. This requires us to traverse\n      all of the elements in GF, find their multiplicative inverses,\n      and apply to each the following affine transformation:\n\n      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^\n            b(i + 7) mod 8 ^ ci\n      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the\n      ith bit of a byte c with the value {63} or {01100011}.\n\n      It is possible to traverse every possible value in a Galois field\n      using what is referred to as a 'generator'. There are many\n      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully\n      traverse GF we iterate 255 times, multiplying by our generator\n      each time.\n\n      On each iteration we can determine the multiplicative inverse for\n      the current element.\n\n      Suppose there is an element in GF 'e'. For a given generator 'g',\n      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns\n      out that if use the inverse of a generator as another generator\n      it will produce all of the corresponding multiplicative inverses\n      at the same time. For this reason, we choose 5 as our inverse\n      generator because it only requires 2 multiplies and 1 add and its\n      inverse, 82, requires relatively few operations as well.\n\n      In order to apply the affine transformation, the multiplicative\n      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a\n      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and\n      'x'. Then 's' is left shifted and the high bit of 's' is made the\n      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd\n      with 's' and stored in 'x'. On each subsequent iteration the same\n      operation is performed. When 4 iterations are complete, 'x' is\n      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.\n      For example:\n\n      s = 01000001\n      x = 01000001\n\n      iteration 1: s = 10000010, x ^= s\n      iteration 2: s = 00000101, x ^= s\n      iteration 3: s = 00001010, x ^= s\n      iteration 4: s = 00010100, x ^= s\n      x ^= 0x63\n\n      This can be done with a loop where s = (s << 1) | (s >> 7). However,\n      it can also be done by using a single 16-bit (in this case 32-bit)\n      number 'sx'. Since XOR is an associative operation, we can set 'sx'\n      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.\n      The most significant bits will flow into the high 8 bit positions\n      and be correctly XOR'd with one another. All that remains will be\n      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits\n      afterwards.\n\n      At the same time we're populating sbox and isbox we can precompute\n      the multiplication we'll need to do to do MixColumns() later.\n    */ // apply affine transformation\n        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;\n        sx = sx >> 8 ^ sx & 255 ^ 0x63;\n        // update tables\n        sbox[e] = sx;\n        isbox[sx] = e;\n        /* Mixing columns is done using matrix multiplication. The columns\n      that are to be mixed are each a single word in the current state.\n      The state has Nb columns (4 columns). Therefore each column is a\n      4 byte word. So to mix the columns in a single column 'c' where\n      its rows are r0, r1, r2, and r3, we use the following matrix\n      multiplication:\n\n      [2 3 1 1]*[r0,c]=[r'0,c]\n      [1 2 3 1] [r1,c] [r'1,c]\n      [1 1 2 3] [r2,c] [r'2,c]\n      [3 1 1 2] [r3,c] [r'3,c]\n\n      r0, r1, r2, and r3 are each 1 byte of one of the words in the\n      state (a column). To do matrix multiplication for each mixed\n      column c' we multiply the corresponding row from the left matrix\n      with the corresponding column from the right matrix. In total, we\n      get 4 equations:\n\n      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c\n      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c\n      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c\n      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c\n\n      As usual, the multiplication is as previously defined and the\n      addition is XOR. In order to optimize mixing columns we can store\n      the multiplication results in tables. If you think of the whole\n      column as a word (it might help to visualize by mentally rotating\n      the equations above by counterclockwise 90 degrees) then you can\n      see that it would be useful to map the multiplications performed on\n      each byte (r0, r1, r2, r3) onto a word as well. For instance, we\n      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the\n      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two\n      respectively in the middle). This means that a table can be\n      constructed that uses r0 as an index to the word. We can do the\n      same with r1, r2, and r3, creating a total of 4 tables.\n\n      To construct a full c', we can just look up each byte of c in\n      their respective tables and XOR the results together.\n\n      Also, to build each table we only have to calculate the word\n      for 2,1,1,3 for every byte ... which we can do on each iteration\n      of this loop since we will iterate over every byte. After we have\n      calculated 2,1,1,3 we can get the results for the other tables\n      by cycling the byte at the end to the beginning. For instance\n      we can take the result of table 2,1,1,3 and produce table 3,2,1,1\n      by moving the right most byte to the left most position just like\n      how you can imagine the 3 moved out of 2,1,1,3 and to the front\n      to produce 3,2,1,1.\n\n      There is another optimization in that the same multiples of\n      the current element we need in order to advance our generator\n      to the next iteration can be reused in performing the 2,1,1,3\n      calculation. We also calculate the inverse mix column tables,\n      with e,9,d,b being the inverse of 2,1,1,3.\n\n      When we're done, and we need to actually mix columns, the first\n      byte of each state word should be put through mix[0] (2,1,1,3),\n      the second through mix[1] (3,2,1,1) and so forth. Then they should\n      be XOR'd together to produce the fully mixed column.\n    */ // calculate mix and imix table values\n        sx2 = xtime[sx];\n        e2 = xtime[e];\n        e4 = xtime[e2];\n        e8 = xtime[e4];\n        me = sx2 << 24 ^ // 2\n        sx << 16 ^ // 1\n        sx << 8 ^ // 1\n        (sx ^ sx2); // 3\n        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)\n        (e ^ e8) << 16 ^ // 9\n        (e ^ e4 ^ e8) << 8 ^ // D (13)\n        (e ^ e2 ^ e8); // B (11)\n        // produce each of the mix tables by rotating the 2,1,1,3 value\n        for(var n = 0; n < 4; ++n){\n            mix[n][e] = me;\n            imix[n][sx] = ime;\n            // cycle the right most byte to the left most position\n            // ie: 2,1,1,3 becomes 3,2,1,1\n            me = me << 24 | me >>> 8;\n            ime = ime << 24 | ime >>> 8;\n        }\n        // get next element and inverse\n        if (e === 0) {\n            // 1 is the inverse of 1\n            e = ei = 1;\n        } else {\n            // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)\n            // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)\n            e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];\n            ei ^= xtime[xtime[ei]];\n        }\n    }\n}\n/**\n * Generates a key schedule using the AES key expansion algorithm.\n *\n * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion\n * routine to generate a key schedule. The Key Expansion generates a total\n * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,\n * and each of the Nr rounds requires Nb words of key data. The resulting\n * key schedule consists of a linear array of 4-byte words, denoted [wi ],\n * with i in the range 0 <= i < Nb(Nr + 1).\n *\n * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)\n * AES-128 (Nb=4, Nk=4, Nr=10)\n * AES-192 (Nb=4, Nk=6, Nr=12)\n * AES-256 (Nb=4, Nk=8, Nr=14)\n * Note: Nr=Nk+6.\n *\n * Nb is the number of columns (32-bit words) comprising the State (or\n * number of bytes in a block). For AES, Nb=4.\n *\n * @param key the key to schedule (as an array of 32-bit words).\n * @param decrypt true to modify the key schedule to decrypt, false not to.\n *\n * @return the generated key schedule.\n */ function _expandKey(key, decrypt) {\n    // copy the key's words to initialize the key schedule\n    var w = key.slice(0);\n    /* RotWord() will rotate a word, moving the first byte to the last\n    byte's position (shifting the other bytes left).\n\n    We will be getting the value of Rcon at i / Nk. 'i' will iterate\n    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in\n    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from\n    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will\n    increase by 1. We use a counter iNk to keep track of this.\n   */ // go through the rounds expanding the key\n    var temp, iNk = 1;\n    var Nk = w.length;\n    var Nr1 = Nk + 6 + 1;\n    var end = Nb * Nr1;\n    for(var i = Nk; i < end; ++i){\n        temp = w[i - 1];\n        if (i % Nk === 0) {\n            // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]\n            temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;\n            iNk++;\n        } else if (Nk > 6 && i % Nk === 4) {\n            // temp = SubWord(temp)\n            temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];\n        }\n        w[i] = w[i - Nk] ^ temp;\n    }\n    /* When we are updating a cipher block we always use the code path for\n     encryption whether we are decrypting or not (to shorten code and\n     simplify the generation of look up tables). However, because there\n     are differences in the decryption algorithm, other than just swapping\n     in different look up tables, we must transform our key schedule to\n     account for these changes:\n\n     1. The decryption algorithm gets its key rounds in reverse order.\n     2. The decryption algorithm adds the round key before mixing columns\n       instead of afterwards.\n\n     We don't need to modify our key schedule to handle the first case,\n     we can just traverse the key schedule in reverse order when decrypting.\n\n     The second case requires a little work.\n\n     The tables we built for performing rounds will take an input and then\n     perform SubBytes() and MixColumns() or, for the decrypt version,\n     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires\n     us to AddRoundKey() before InvMixColumns(). This means we'll need to\n     apply some transformations to the round key to inverse-mix its columns\n     so they'll be correct for moving AddRoundKey() to after the state has\n     had its columns inverse-mixed.\n\n     To inverse-mix the columns of the state when we're decrypting we use a\n     lookup table that will apply InvSubBytes() and InvMixColumns() at the\n     same time. However, the round key's bytes are not inverse-substituted\n     in the decryption algorithm. To get around this problem, we can first\n     substitute the bytes in the round key so that when we apply the\n     transformation via the InvSubBytes()+InvMixColumns() table, it will\n     undo our substitution leaving us with the original value that we\n     want -- and then inverse-mix that value.\n\n     This change will correctly alter our key schedule so that we can XOR\n     each round key with our already transformed decryption state. This\n     allows us to use the same code path as the encryption algorithm.\n\n     We make one more change to the decryption key. Since the decryption\n     algorithm runs in reverse from the encryption algorithm, we reverse\n     the order of the round keys to avoid having to iterate over the key\n     schedule backwards when running the encryption algorithm later in\n     decryption mode. In addition to reversing the order of the round keys,\n     we also swap each round key's 2nd and 4th rows. See the comments\n     section where rounds are performed for more details about why this is\n     done. These changes are done inline with the other substitution\n     described above.\n  */ if (decrypt) {\n        var tmp;\n        var m0 = imix[0];\n        var m1 = imix[1];\n        var m2 = imix[2];\n        var m3 = imix[3];\n        var wnew = w.slice(0);\n        end = w.length;\n        for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb){\n            // do not sub the first or last round key (round keys are Nb\n            // words) as no column mixing is performed before they are added,\n            // but do change the key order\n            if (i === 0 || i === end - Nb) {\n                wnew[i] = w[wi];\n                wnew[i + 1] = w[wi + 3];\n                wnew[i + 2] = w[wi + 2];\n                wnew[i + 3] = w[wi + 1];\n            } else {\n                // substitute each round key byte because the inverse-mix\n                // table will inverse-substitute it (effectively cancel the\n                // substitution because round key bytes aren't sub'd in\n                // decryption mode) and swap indexes 3 and 1\n                for(var n = 0; n < Nb; ++n){\n                    tmp = w[wi + n];\n                    wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];\n                }\n            }\n        }\n        w = wnew;\n    }\n    return w;\n}\n/**\n * Updates a single block (16 bytes) using AES. The update will either\n * encrypt or decrypt the block.\n *\n * @param w the key schedule.\n * @param input the input block (an array of 32-bit words).\n * @param output the updated output block.\n * @param decrypt true to decrypt the block, false to encrypt it.\n */ function _updateBlock(w, input, output, decrypt) {\n    /*\n  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\n  begin\n    byte state[4,Nb]\n    state = in\n    AddRoundKey(state, w[0, Nb-1])\n    for round = 1 step 1 to Nr-1\n      SubBytes(state)\n      ShiftRows(state)\n      MixColumns(state)\n      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\n    end for\n    SubBytes(state)\n    ShiftRows(state)\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n    out = state\n  end\n\n  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\n  begin\n    byte state[4,Nb]\n    state = in\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n    for round = Nr-1 step -1 downto 1\n      InvShiftRows(state)\n      InvSubBytes(state)\n      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\n      InvMixColumns(state)\n    end for\n    InvShiftRows(state)\n    InvSubBytes(state)\n    AddRoundKey(state, w[0, Nb-1])\n    out = state\n  end\n  */ // Encrypt: AddRoundKey(state, w[0, Nb-1])\n    // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n    var Nr = w.length / 4 - 1;\n    var m0, m1, m2, m3, sub;\n    if (decrypt) {\n        m0 = imix[0];\n        m1 = imix[1];\n        m2 = imix[2];\n        m3 = imix[3];\n        sub = isbox;\n    } else {\n        m0 = mix[0];\n        m1 = mix[1];\n        m2 = mix[2];\n        m3 = mix[3];\n        sub = sbox;\n    }\n    var a, b, c, d, a2, b2, c2;\n    a = input[0] ^ w[0];\n    b = input[decrypt ? 3 : 1] ^ w[1];\n    c = input[2] ^ w[2];\n    d = input[decrypt ? 1 : 3] ^ w[3];\n    var i = 3;\n    /* In order to share code we follow the encryption algorithm when both\n    encrypting and decrypting. To account for the changes required in the\n    decryption algorithm, we use different lookup tables when decrypting\n    and use a modified key schedule to account for the difference in the\n    order of transformations applied when performing rounds. We also get\n    key rounds in reverse order (relative to encryption). */ for(var round = 1; round < Nr; ++round){\n        /* As described above, we'll be using table lookups to perform the\n      column mixing. Each column is stored as a word in the state (the\n      array 'input' has one column as a word at each index). In order to\n      mix a column, we perform these transformations on each row in c,\n      which is 1 byte in each word. The new column for c0 is c'0:\n\n               m0      m1      m2      m3\n      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0\n      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0\n      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0\n      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0\n\n      So using mix tables where c0 is a word with r0 being its upper\n      8 bits and r3 being its lower 8 bits:\n\n      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]\n      ...\n      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]\n\n      Therefore to mix the columns in each word in the state we\n      do the following (& 255 omitted for brevity):\n      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n\n      However, before mixing, the algorithm requires us to perform\n      ShiftRows(). The ShiftRows() transformation cyclically shifts the\n      last 3 rows of the state over different offsets. The first row\n      (r = 0) is not shifted.\n\n      s'_r,c = s_r,(c + shift(r, Nb) mod Nb\n      for 0 < r < 4 and 0 <= c < Nb and\n      shift(1, 4) = 1\n      shift(2, 4) = 2\n      shift(3, 4) = 3.\n\n      This causes the first byte in r = 1 to be moved to the end of\n      the row, the first 2 bytes in r = 2 to be moved to the end of\n      the row, the first 3 bytes in r = 3 to be moved to the end of\n      the row:\n\n      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]\n      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]\n      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]\n\n      We can make these substitutions inline with our column mixing to\n      generate an updated set of equations to produce each word in the\n      state (note the columns have changed positions):\n\n      c0 c1 c2 c3 => c0 c1 c2 c3\n      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)\n      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)\n      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)\n\n      Therefore:\n\n      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3\n      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3\n      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3\n      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3\n\n      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0\n      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0\n      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0\n      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0\n\n      ... and so forth for c'2 and c'3. The important distinction is\n      that the columns are cycling, with c0 being used with the m0\n      map when calculating c0, but c1 being used with the m0 map when\n      calculating c1 ... and so forth.\n\n      When performing the inverse we transform the mirror image and\n      skip the bottom row, instead of the top one, and move upwards:\n\n      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption\n      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)\n      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption\n      c3 c2 c1 c0    c3 c2 c1 c0\n\n      If you compare the resulting matrices for ShiftRows()+MixColumns()\n      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are\n      different (in encrypt mode vs. decrypt mode). So in order to use\n      the same code to handle both encryption and decryption, we will\n      need to do some mapping.\n\n      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be\n      a row number in the state, then the resulting matrix in encryption\n      mode for applying the above transformations would be:\n\n      r1: a b c d\n      r2: b c d a\n      r3: c d a b\n      r4: d a b c\n\n      If we did the same in decryption mode we would get:\n\n      r1: a d c b\n      r2: b a d c\n      r3: c b a d\n      r4: d c b a\n\n      If instead we swap d and b (set b=c3 and d=c1), then we get:\n\n      r1: a b c d\n      r2: d a b c\n      r3: c d a b\n      r4: b c d a\n\n      Now the 1st and 3rd rows are the same as the encryption matrix. All\n      we need to do then to make the mapping exactly the same is to swap\n      the 2nd and 4th rows when in decryption mode. To do this without\n      having to do it on each iteration, we swapped the 2nd and 4th rows\n      in the decryption key schedule. We also have to do the swap above\n      when we first pull in the input and when we set the final output. */ a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];\n        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];\n        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];\n        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];\n        a = a2;\n        b = b2;\n        c = c2;\n    }\n    /*\n    Encrypt:\n    SubBytes(state)\n    ShiftRows(state)\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n\n    Decrypt:\n    InvShiftRows(state)\n    InvSubBytes(state)\n    AddRoundKey(state, w[0, Nb-1])\n   */ // Note: rows are shifted inline\n    output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];\n    output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];\n    output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];\n    output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];\n}\n/**\n * Deprecated. Instead, use:\n *\n * forge.cipher.createCipher('AES-<mode>', key);\n * forge.cipher.createDecipher('AES-<mode>', key);\n *\n * Creates a deprecated AES cipher object. This object's mode will default to\n * CBC (cipher-block-chaining).\n *\n * The key and iv may be given as a string of bytes, an array of bytes, a\n * byte buffer, or an array of 32-bit words.\n *\n * @param options the options to use.\n *          key the symmetric key to use.\n *          output the buffer to write to.\n *          decrypt true for decryption, false for encryption.\n *          mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ function _createCipher(options) {\n    options = options || {};\n    var mode = (options.mode || \"CBC\").toUpperCase();\n    var algorithm = \"AES-\" + mode;\n    var cipher;\n    if (options.decrypt) {\n        cipher = forge.cipher.createDecipher(algorithm, options.key);\n    } else {\n        cipher = forge.cipher.createCipher(algorithm, options.key);\n    }\n    // backwards compatible start API\n    var start = cipher.start;\n    cipher.start = function(iv, options) {\n        // backwards compatibility: support second arg as output buffer\n        var output = null;\n        if (options instanceof forge.util.ByteBuffer) {\n            output = options;\n            options = {};\n        }\n        options = options || {};\n        options.output = output;\n        options.iv = iv;\n        start.call(cipher, options);\n    };\n    return cipher;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsV0FBVyxHQUNYQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLEdBQUcsR0FBR0osTUFBTUksR0FBRyxJQUFJLENBQUM7QUFFM0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNESixNQUFNSSxHQUFHLENBQUNDLGVBQWUsR0FBRyxTQUFTQyxHQUFHLEVBQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQ3hELElBQUlDLFNBQVNDLGNBQWM7UUFDekJMLEtBQUtBO1FBQ0xFLFFBQVFBO1FBQ1JJLFNBQVM7UUFDVEgsTUFBTUE7SUFDUjtJQUNBQyxPQUFPRyxLQUFLLENBQUNOO0lBQ2IsT0FBT0c7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RWLE1BQU1JLEdBQUcsQ0FBQ1Usc0JBQXNCLEdBQUcsU0FBU1IsR0FBRyxFQUFFRyxJQUFJO0lBQ25ELE9BQU9FLGNBQWM7UUFDbkJMLEtBQUtBO1FBQ0xFLFFBQVE7UUFDUkksU0FBUztRQUNUSCxNQUFNQTtJQUNSO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0RULE1BQU1JLEdBQUcsQ0FBQ1csZUFBZSxHQUFHLFNBQVNULEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7SUFDeEQsSUFBSUMsU0FBU0MsY0FBYztRQUN6QkwsS0FBS0E7UUFDTEUsUUFBUUE7UUFDUkksU0FBUztRQUNUSCxNQUFNQTtJQUNSO0lBQ0FDLE9BQU9HLEtBQUssQ0FBQ047SUFDYixPQUFPRztBQUNUO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRFYsTUFBTUksR0FBRyxDQUFDWSxzQkFBc0IsR0FBRyxTQUFTVixHQUFHLEVBQUVHLElBQUk7SUFDbkQsT0FBT0UsY0FBYztRQUNuQkwsS0FBS0E7UUFDTEUsUUFBUTtRQUNSSSxTQUFTO1FBQ1RILE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRFQsTUFBTUksR0FBRyxDQUFDYSxTQUFTLEdBQUcsU0FBU0MsSUFBSSxFQUFFVCxJQUFJO0lBQ3ZDLElBQUcsQ0FBQ1UsTUFBTTtRQUNSQztJQUNGO0lBQ0EsSUFBSUMsT0FBTyxJQUFJO0lBQ2ZBLEtBQUtILElBQUksR0FBR0E7SUFDWkcsS0FBS1osSUFBSSxHQUFHLElBQUlBLEtBQUs7UUFDbkJhLFdBQVc7UUFDWFosUUFBUTtZQUNOYSxTQUFTLFNBQVNDLE9BQU8sRUFBRUMsUUFBUTtnQkFDakMsT0FBT0MsYUFBYUwsS0FBS00sRUFBRSxFQUFFSCxTQUFTQyxVQUFVO1lBQ2xEO1lBQ0FiLFNBQVMsU0FBU1ksT0FBTyxFQUFFQyxRQUFRO2dCQUNqQyxPQUFPQyxhQUFhTCxLQUFLTSxFQUFFLEVBQUVILFNBQVNDLFVBQVU7WUFDbEQ7UUFDRjtJQUNGO0lBQ0FKLEtBQUtPLEtBQUssR0FBRztBQUNmO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNENUIsTUFBTUksR0FBRyxDQUFDYSxTQUFTLENBQUNZLFNBQVMsQ0FBQ1QsVUFBVSxHQUFHLFNBQVNVLE9BQU87SUFDekQsSUFBRyxJQUFJLENBQUNGLEtBQUssRUFBRTtRQUNiO0lBQ0Y7SUFFQSxJQUFJdEIsTUFBTXdCLFFBQVF4QixHQUFHO0lBQ3JCLElBQUl5QjtJQUVKOzs7bURBR2lELEdBRWpELElBQUcsT0FBT3pCLFFBQVEsWUFDZkEsQ0FBQUEsSUFBSTBCLE1BQU0sS0FBSyxNQUFNMUIsSUFBSTBCLE1BQU0sS0FBSyxNQUFNMUIsSUFBSTBCLE1BQU0sS0FBSyxFQUFDLEdBQUk7UUFDL0Qsc0NBQXNDO1FBQ3RDMUIsTUFBTU4sTUFBTWlDLElBQUksQ0FBQ0MsWUFBWSxDQUFDNUI7SUFDaEMsT0FBTyxJQUFHTixNQUFNaUMsSUFBSSxDQUFDRSxPQUFPLENBQUM3QixRQUMxQkEsQ0FBQUEsSUFBSTBCLE1BQU0sS0FBSyxNQUFNMUIsSUFBSTBCLE1BQU0sS0FBSyxNQUFNMUIsSUFBSTBCLE1BQU0sS0FBSyxFQUFDLEdBQUk7UUFDL0QsNkNBQTZDO1FBQzdDRCxNQUFNekI7UUFDTkEsTUFBTU4sTUFBTWlDLElBQUksQ0FBQ0MsWUFBWTtRQUM3QixJQUFJLElBQUlFLElBQUksR0FBR0EsSUFBSUwsSUFBSUMsTUFBTSxFQUFFLEVBQUVJLEVBQUc7WUFDbEM5QixJQUFJK0IsT0FBTyxDQUFDTixHQUFHLENBQUNLLEVBQUU7UUFDcEI7SUFDRjtJQUVBLG9EQUFvRDtJQUNwRCxJQUFHLENBQUNwQyxNQUFNaUMsSUFBSSxDQUFDRSxPQUFPLENBQUM3QixNQUFNO1FBQzNCeUIsTUFBTXpCO1FBQ05BLE1BQU0sRUFBRTtRQUVSLDBDQUEwQztRQUMxQyxJQUFJZ0MsTUFBTVAsSUFBSUMsTUFBTTtRQUNwQixJQUFHTSxRQUFRLE1BQU1BLFFBQVEsTUFBTUEsUUFBUSxJQUFJO1lBQ3pDQSxNQUFNQSxRQUFRO1lBQ2QsSUFBSSxJQUFJRixJQUFJLEdBQUdBLElBQUlFLEtBQUssRUFBRUYsRUFBRztnQkFDM0I5QixJQUFJaUMsSUFBSSxDQUFDUixJQUFJUyxRQUFRO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUVBLGlEQUFpRDtJQUNqRCxJQUFHLENBQUN4QyxNQUFNaUMsSUFBSSxDQUFDRSxPQUFPLENBQUM3QixRQUNyQixDQUFFQSxDQUFBQSxJQUFJMEIsTUFBTSxLQUFLLEtBQUsxQixJQUFJMEIsTUFBTSxLQUFLLEtBQUsxQixJQUFJMEIsTUFBTSxLQUFLLElBQUk7UUFDN0QsTUFBTSxJQUFJUyxNQUFNO0lBQ2xCO0lBRUEsc0RBQXNEO0lBQ3RELElBQUloQyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDUyxJQUFJO0lBQ3pCLElBQUl3QixZQUFhO1FBQUM7UUFBTztRQUFPO1FBQU87S0FBTSxDQUFDQyxPQUFPLENBQUNsQyxVQUFVLENBQUM7SUFFakUsbUJBQW1CO0lBQ25CLElBQUksQ0FBQ2tCLEVBQUUsR0FBR2lCLFdBQVd0QyxLQUFLd0IsUUFBUWxCLE9BQU8sSUFBSSxDQUFDOEI7SUFDOUMsSUFBSSxDQUFDZCxLQUFLLEdBQUc7QUFDZjtBQUVBOzs7Ozs7O0NBT0MsR0FDRDVCLE1BQU1JLEdBQUcsQ0FBQ3dDLFVBQVUsR0FBRyxTQUFTdEMsR0FBRyxFQUFFTSxPQUFPO0lBQzFDLElBQUcsQ0FBQ08sTUFBTTtRQUNSQztJQUNGO0lBQ0EsT0FBT3dCLFdBQVd0QyxLQUFLTTtBQUN6QjtBQUVBOzs7Ozs7O0NBT0MsR0FDRFosTUFBTUksR0FBRyxDQUFDc0IsWUFBWSxHQUFHQTtBQUV6Qiw2QkFBNkIsR0FFN0JtQixrQkFBa0IsV0FBVzdDLE1BQU1VLE1BQU0sQ0FBQ29DLEtBQUssQ0FBQ0MsR0FBRztBQUNuREYsa0JBQWtCLFdBQVc3QyxNQUFNVSxNQUFNLENBQUNvQyxLQUFLLENBQUNFLEdBQUc7QUFDbkRILGtCQUFrQixXQUFXN0MsTUFBTVUsTUFBTSxDQUFDb0MsS0FBSyxDQUFDRyxHQUFHO0FBQ25ESixrQkFBa0IsV0FBVzdDLE1BQU1VLE1BQU0sQ0FBQ29DLEtBQUssQ0FBQ0ksR0FBRztBQUNuREwsa0JBQWtCLFdBQVc3QyxNQUFNVSxNQUFNLENBQUNvQyxLQUFLLENBQUNLLEdBQUc7QUFDbkROLGtCQUFrQixXQUFXN0MsTUFBTVUsTUFBTSxDQUFDb0MsS0FBSyxDQUFDTSxHQUFHO0FBRW5ELFNBQVNQLGtCQUFrQjNCLElBQUksRUFBRVQsSUFBSTtJQUNuQyxJQUFJNEMsVUFBVTtRQUNaLE9BQU8sSUFBSXJELE1BQU1JLEdBQUcsQ0FBQ2EsU0FBUyxDQUFDQyxNQUFNVDtJQUN2QztJQUNBVCxNQUFNVSxNQUFNLENBQUNtQyxpQkFBaUIsQ0FBQzNCLE1BQU1tQztBQUN2QztBQUVBLHdCQUF3QixHQUV4QixJQUFJbEMsT0FBTyxPQUFPLHNCQUFzQjtBQUN4QyxJQUFJbUMsS0FBSyxHQUFTLGlEQUFpRDtBQUNuRSxJQUFJQyxNQUFjLHNEQUFzRDtBQUN4RSxJQUFJQyxPQUFjLG9CQUFvQjtBQUN0QyxJQUFJQyxNQUFjLDRCQUE0QjtBQUM5QyxJQUFJQyxLQUFjLG9CQUFvQjtBQUN0QyxJQUFJQyxNQUFjLDRCQUE0QjtBQUU5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0tDLEdBQ0QsU0FBU3ZDO0lBQ1BELE9BQU87SUFFUDs7Ozs7Ozs7Ozs7O0VBWUEsR0FDQXNDLE9BQU87UUFBQztRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFFekUsb0RBQW9EO0lBQ3BELElBQUlHLFFBQVEsSUFBSUMsTUFBTTtJQUN0QixJQUFJLElBQUl6QixJQUFJLEdBQUdBLElBQUksS0FBSyxFQUFFQSxFQUFHO1FBQzNCd0IsS0FBSyxDQUFDeEIsRUFBRSxHQUFHQSxLQUFLO1FBQ2hCd0IsS0FBSyxDQUFDeEIsSUFBSSxJQUFJLEdBQUcsSUFBSyxPQUFRLElBQUk7SUFDcEM7SUFFQSwyQkFBMkI7SUFDM0JtQixPQUFPLElBQUlNLE1BQU07SUFDakJMLFFBQVEsSUFBSUssTUFBTTtJQUNsQkgsTUFBTSxJQUFJRyxNQUFNO0lBQ2hCRixPQUFPLElBQUlFLE1BQU07SUFDakIsSUFBSSxJQUFJekIsSUFBSSxHQUFHQSxJQUFJLEdBQUcsRUFBRUEsRUFBRztRQUN6QnNCLEdBQUcsQ0FBQ3RCLEVBQUUsR0FBRyxJQUFJeUIsTUFBTTtRQUNuQkYsSUFBSSxDQUFDdkIsRUFBRSxHQUFHLElBQUl5QixNQUFNO0lBQ3RCO0lBQ0EsSUFBSUMsSUFBSSxHQUFHQyxLQUFLLEdBQUdDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLEtBQUtDLElBQUlDO0lBQzVDLElBQUksSUFBSWxDLElBQUksR0FBR0EsSUFBSSxLQUFLLEVBQUVBLEVBQUc7UUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXlEQSxHQUVBLDhCQUE4QjtRQUM5QitCLEtBQUtKLEtBQU1BLE1BQU0sSUFBTUEsTUFBTSxJQUFNQSxNQUFNLElBQU1BLE1BQU07UUFDckRJLEtBQUssTUFBTyxJQUFNQSxLQUFLLE1BQU87UUFFOUIsZ0JBQWdCO1FBQ2hCWixJQUFJLENBQUNPLEVBQUUsR0FBR0s7UUFDVlgsS0FBSyxDQUFDVyxHQUFHLEdBQUdMO1FBRVo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkRBLEdBRUEsc0NBQXNDO1FBQ3RDTSxNQUFNUixLQUFLLENBQUNPLEdBQUc7UUFDZkgsS0FBS0osS0FBSyxDQUFDRSxFQUFFO1FBQ2JHLEtBQUtMLEtBQUssQ0FBQ0ksR0FBRztRQUNkRSxLQUFLTixLQUFLLENBQUNLLEdBQUc7UUFDZEksS0FDRSxPQUFRLEtBQU8sSUFBSTtRQUNsQkYsTUFBTSxLQUFRLElBQUk7UUFDbEJBLE1BQU0sSUFBUSxJQUFJO1FBQ2xCQSxDQUFBQSxLQUFLQyxHQUFFLEdBQU8sSUFBSTtRQUNyQkUsTUFDRSxDQUFDTixLQUFLQyxLQUFLQyxFQUFDLEtBQU0sS0FDbEIsU0FEaUM7UUFDaENKLENBQUFBLElBQUlJLEVBQUMsS0FBTSxLQUNaLElBRDRCO1FBQzNCSixDQUFBQSxJQUFJRyxLQUFLQyxFQUFDLEtBQU0sSUFBTyxTQUFTO1FBQ2hDSixDQUFBQSxJQUFJRSxLQUFLRSxFQUFDLEdBQWEsU0FBUztRQUNuQywrREFBK0Q7UUFDL0QsSUFBSSxJQUFJSyxJQUFJLEdBQUdBLElBQUksR0FBRyxFQUFFQSxFQUFHO1lBQ3pCYixHQUFHLENBQUNhLEVBQUUsQ0FBQ1QsRUFBRSxHQUFHTztZQUNaVixJQUFJLENBQUNZLEVBQUUsQ0FBQ0osR0FBRyxHQUFHRztZQUNkLHNEQUFzRDtZQUN0RCw4QkFBOEI7WUFDOUJELEtBQUtBLE1BQU0sS0FBS0EsT0FBTztZQUN2QkMsTUFBTUEsT0FBTyxLQUFLQSxRQUFRO1FBQzVCO1FBRUEsK0JBQStCO1FBQy9CLElBQUdSLE1BQU0sR0FBRztZQUNWLHdCQUF3QjtZQUN4QkEsSUFBSUMsS0FBSztRQUNYLE9BQU87WUFDTCw4REFBOEQ7WUFDOUQsMERBQTBEO1lBQzFERCxJQUFJRSxLQUFLSixLQUFLLENBQUNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDSSxLQUFLRSxHQUFHLENBQUMsQ0FBQztZQUNyQ0gsTUFBTUgsS0FBSyxDQUFDQSxLQUFLLENBQUNHLEdBQUcsQ0FBQztRQUN4QjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTbkIsV0FBV3RDLEdBQUcsRUFBRU0sT0FBTztJQUM5QixzREFBc0Q7SUFDdEQsSUFBSTRELElBQUlsRSxJQUFJbUUsS0FBSyxDQUFDO0lBRWxCOzs7Ozs7OztHQVFDLEdBRUQsMENBQTBDO0lBQzFDLElBQUlDLE1BQU1DLE1BQU07SUFDaEIsSUFBSUMsS0FBS0osRUFBRXhDLE1BQU07SUFDakIsSUFBSTZDLE1BQU1ELEtBQUssSUFBSTtJQUNuQixJQUFJRSxNQUFNeEIsS0FBS3VCO0lBQ2YsSUFBSSxJQUFJekMsSUFBSXdDLElBQUl4QyxJQUFJMEMsS0FBSyxFQUFFMUMsRUFBRztRQUM1QnNDLE9BQU9GLENBQUMsQ0FBQ3BDLElBQUksRUFBRTtRQUNmLElBQUdBLElBQUl3QyxPQUFPLEdBQUc7WUFDZiwrQ0FBK0M7WUFDL0NGLE9BQ0VuQixJQUFJLENBQUNtQixTQUFTLEtBQUssSUFBSSxJQUFJLEtBQzNCbkIsSUFBSSxDQUFDbUIsU0FBUyxJQUFJLElBQUksSUFBSSxLQUMxQm5CLElBQUksQ0FBQ21CLE9BQU8sSUFBSSxJQUFJLElBQ3BCbkIsSUFBSSxDQUFDbUIsU0FBUyxHQUFHLEdBQUlqQixJQUFJLENBQUNrQixJQUFJLElBQUk7WUFDcENBO1FBQ0YsT0FBTyxJQUFHQyxLQUFLLEtBQU14QyxJQUFJd0MsT0FBTyxHQUFJO1lBQ2xDLHVCQUF1QjtZQUN2QkYsT0FDRW5CLElBQUksQ0FBQ21CLFNBQVMsR0FBRyxJQUFJLEtBQ3JCbkIsSUFBSSxDQUFDbUIsU0FBUyxLQUFLLElBQUksSUFBSSxLQUMzQm5CLElBQUksQ0FBQ21CLFNBQVMsSUFBSSxJQUFJLElBQUksSUFDMUJuQixJQUFJLENBQUNtQixPQUFPLElBQUk7UUFDcEI7UUFDQUYsQ0FBQyxDQUFDcEMsRUFBRSxHQUFHb0MsQ0FBQyxDQUFDcEMsSUFBSXdDLEdBQUcsR0FBR0Y7SUFDckI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQThDQSxHQUNBLElBQUc5RCxTQUFTO1FBQ1YsSUFBSW1CO1FBQ0osSUFBSWdELEtBQUtwQixJQUFJLENBQUMsRUFBRTtRQUNoQixJQUFJcUIsS0FBS3JCLElBQUksQ0FBQyxFQUFFO1FBQ2hCLElBQUlzQixLQUFLdEIsSUFBSSxDQUFDLEVBQUU7UUFDaEIsSUFBSXVCLEtBQUt2QixJQUFJLENBQUMsRUFBRTtRQUNoQixJQUFJd0IsT0FBT1gsRUFBRUMsS0FBSyxDQUFDO1FBQ25CSyxNQUFNTixFQUFFeEMsTUFBTTtRQUNkLElBQUksSUFBSUksSUFBSSxHQUFHZ0QsS0FBS04sTUFBTXhCLElBQUlsQixJQUFJMEMsS0FBSzFDLEtBQUtrQixJQUFJOEIsTUFBTTlCLEdBQUk7WUFDeEQsNERBQTREO1lBQzVELGlFQUFpRTtZQUNqRSw4QkFBOEI7WUFDOUIsSUFBR2xCLE1BQU0sS0FBS0EsTUFBTzBDLE1BQU14QixJQUFLO2dCQUM5QjZCLElBQUksQ0FBQy9DLEVBQUUsR0FBR29DLENBQUMsQ0FBQ1ksR0FBRztnQkFDZkQsSUFBSSxDQUFDL0MsSUFBSSxFQUFFLEdBQUdvQyxDQUFDLENBQUNZLEtBQUssRUFBRTtnQkFDdkJELElBQUksQ0FBQy9DLElBQUksRUFBRSxHQUFHb0MsQ0FBQyxDQUFDWSxLQUFLLEVBQUU7Z0JBQ3ZCRCxJQUFJLENBQUMvQyxJQUFJLEVBQUUsR0FBR29DLENBQUMsQ0FBQ1ksS0FBSyxFQUFFO1lBQ3pCLE9BQU87Z0JBQ0wseURBQXlEO2dCQUN6RCwyREFBMkQ7Z0JBQzNELHVEQUF1RDtnQkFDdkQsNENBQTRDO2dCQUM1QyxJQUFJLElBQUliLElBQUksR0FBR0EsSUFBSWpCLElBQUksRUFBRWlCLEVBQUc7b0JBQzFCeEMsTUFBTXlDLENBQUMsQ0FBQ1ksS0FBS2IsRUFBRTtvQkFDZlksSUFBSSxDQUFDL0MsSUFBSyxLQUFFLENBQUNtQyxDQUFBQSxFQUFHLEdBQ2RRLEVBQUUsQ0FBQ3hCLElBQUksQ0FBQ3hCLFFBQVEsR0FBRyxDQUFDLEdBQ3BCaUQsRUFBRSxDQUFDekIsSUFBSSxDQUFDeEIsUUFBUSxLQUFLLElBQUksQ0FBQyxHQUMxQmtELEVBQUUsQ0FBQzFCLElBQUksQ0FBQ3hCLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FDekJtRCxFQUFFLENBQUMzQixJQUFJLENBQUN4QixNQUFNLElBQUksQ0FBQztnQkFDdkI7WUFDRjtRQUNGO1FBQ0F5QyxJQUFJVztJQUNOO0lBRUEsT0FBT1g7QUFDVDtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBUzlDLGFBQWE4QyxDQUFDLEVBQUVhLEtBQUssRUFBRTdFLE1BQU0sRUFBRUksT0FBTztJQUM3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWtDQSxHQUVBLDBDQUEwQztJQUMxQyxxREFBcUQ7SUFDckQsSUFBSTBFLEtBQUtkLEVBQUV4QyxNQUFNLEdBQUcsSUFBSTtJQUN4QixJQUFJK0MsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUs7SUFDcEIsSUFBRzNFLFNBQVM7UUFDVm1FLEtBQUtwQixJQUFJLENBQUMsRUFBRTtRQUNacUIsS0FBS3JCLElBQUksQ0FBQyxFQUFFO1FBQ1pzQixLQUFLdEIsSUFBSSxDQUFDLEVBQUU7UUFDWnVCLEtBQUt2QixJQUFJLENBQUMsRUFBRTtRQUNaNEIsTUFBTS9CO0lBQ1IsT0FBTztRQUNMdUIsS0FBS3JCLEdBQUcsQ0FBQyxFQUFFO1FBQ1hzQixLQUFLdEIsR0FBRyxDQUFDLEVBQUU7UUFDWHVCLEtBQUt2QixHQUFHLENBQUMsRUFBRTtRQUNYd0IsS0FBS3hCLEdBQUcsQ0FBQyxFQUFFO1FBQ1g2QixNQUFNaEM7SUFDUjtJQUNBLElBQUlpQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxJQUFJQyxJQUFJQztJQUN4Qk4sSUFBSUgsS0FBSyxDQUFDLEVBQUUsR0FBR2IsQ0FBQyxDQUFDLEVBQUU7SUFDbkJpQixJQUFJSixLQUFLLENBQUN6RSxVQUFVLElBQUksRUFBRSxHQUFHNEQsQ0FBQyxDQUFDLEVBQUU7SUFDakNrQixJQUFJTCxLQUFLLENBQUMsRUFBRSxHQUFHYixDQUFDLENBQUMsRUFBRTtJQUNuQm1CLElBQUlOLEtBQUssQ0FBQ3pFLFVBQVUsSUFBSSxFQUFFLEdBQUc0RCxDQUFDLENBQUMsRUFBRTtJQUNqQyxJQUFJcEMsSUFBSTtJQUVSOzs7OzswREFLd0QsR0FDeEQsSUFBSSxJQUFJMkQsUUFBUSxHQUFHQSxRQUFRVCxJQUFJLEVBQUVTLE1BQU87UUFDdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RUFrSG9FLEdBQ3BFSCxLQUNFYixFQUFFLENBQUNTLE1BQU0sR0FBRyxHQUNaUixFQUFFLENBQUNTLE1BQU0sS0FBSyxJQUFJLEdBQ2xCUixFQUFFLENBQUNTLE1BQU0sSUFBSSxJQUFJLEdBQ2pCUixFQUFFLENBQUNTLElBQUksSUFBSSxHQUFHbkIsQ0FBQyxDQUFDLEVBQUVwQyxFQUFFO1FBQ3RCeUQsS0FDRWQsRUFBRSxDQUFDVSxNQUFNLEdBQUcsR0FDWlQsRUFBRSxDQUFDVSxNQUFNLEtBQUssSUFBSSxHQUNsQlQsRUFBRSxDQUFDVSxNQUFNLElBQUksSUFBSSxHQUNqQlQsRUFBRSxDQUFDTSxJQUFJLElBQUksR0FBR2hCLENBQUMsQ0FBQyxFQUFFcEMsRUFBRTtRQUN0QjBELEtBQ0VmLEVBQUUsQ0FBQ1csTUFBTSxHQUFHLEdBQ1pWLEVBQUUsQ0FBQ1csTUFBTSxLQUFLLElBQUksR0FDbEJWLEVBQUUsQ0FBQ08sTUFBTSxJQUFJLElBQUksR0FDakJOLEVBQUUsQ0FBQ08sSUFBSSxJQUFJLEdBQUdqQixDQUFDLENBQUMsRUFBRXBDLEVBQUU7UUFDdEJ1RCxJQUNFWixFQUFFLENBQUNZLE1BQU0sR0FBRyxHQUNaWCxFQUFFLENBQUNRLE1BQU0sS0FBSyxJQUFJLEdBQ2xCUCxFQUFFLENBQUNRLE1BQU0sSUFBSSxJQUFJLEdBQ2pCUCxFQUFFLENBQUNRLElBQUksSUFBSSxHQUFHbEIsQ0FBQyxDQUFDLEVBQUVwQyxFQUFFO1FBQ3RCb0QsSUFBSUk7UUFDSkgsSUFBSUk7UUFDSkgsSUFBSUk7SUFDTjtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDRCxnQ0FBZ0M7SUFDaEN0RixNQUFNLENBQUMsRUFBRSxHQUNQLEdBQUksQ0FBQ2dGLE1BQU0sR0FBRyxJQUFJLEtBQ2pCRCxHQUFHLENBQUNFLE1BQU0sS0FBSyxJQUFJLElBQUksS0FDdkJGLEdBQUcsQ0FBQ0csTUFBTSxJQUFJLElBQUksSUFBSSxJQUN0QkgsR0FBRyxDQUFDSSxJQUFJLElBQUksR0FBSW5CLENBQUMsQ0FBQyxFQUFFcEMsRUFBRTtJQUN6QjVCLE1BQU0sQ0FBQ0ksVUFBVSxJQUFJLEVBQUUsR0FDckIsR0FBSSxDQUFDNkUsTUFBTSxHQUFHLElBQUksS0FDakJGLEdBQUcsQ0FBQ0csTUFBTSxLQUFLLElBQUksSUFBSSxLQUN2QkgsR0FBRyxDQUFDSSxNQUFNLElBQUksSUFBSSxJQUFJLElBQ3RCSixHQUFHLENBQUNDLElBQUksSUFBSSxHQUFJaEIsQ0FBQyxDQUFDLEVBQUVwQyxFQUFFO0lBQ3pCNUIsTUFBTSxDQUFDLEVBQUUsR0FDUCxHQUFJLENBQUNrRixNQUFNLEdBQUcsSUFBSSxLQUNqQkgsR0FBRyxDQUFDSSxNQUFNLEtBQUssSUFBSSxJQUFJLEtBQ3ZCSixHQUFHLENBQUNDLE1BQU0sSUFBSSxJQUFJLElBQUksSUFDdEJELEdBQUcsQ0FBQ0UsSUFBSSxJQUFJLEdBQUlqQixDQUFDLENBQUMsRUFBRXBDLEVBQUU7SUFDekI1QixNQUFNLENBQUNJLFVBQVUsSUFBSSxFQUFFLEdBQ3JCLEdBQUksQ0FBQytFLE1BQU0sR0FBRyxJQUFJLEtBQ2pCSixHQUFHLENBQUNDLE1BQU0sS0FBSyxJQUFJLElBQUksS0FDdkJELEdBQUcsQ0FBQ0UsTUFBTSxJQUFJLElBQUksSUFBSSxJQUN0QkYsR0FBRyxDQUFDRyxJQUFJLElBQUksR0FBSWxCLENBQUMsQ0FBQyxFQUFFcEMsRUFBRTtBQUMzQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU3pCLGNBQWNtQixPQUFPO0lBQzVCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFBSXJCLE9BQU8sQ0FBQ3FCLFFBQVFyQixJQUFJLElBQUksS0FBSSxFQUFHdUYsV0FBVztJQUM5QyxJQUFJQyxZQUFZLFNBQVN4RjtJQUV6QixJQUFJQztJQUNKLElBQUdvQixRQUFRbEIsT0FBTyxFQUFFO1FBQ2xCRixTQUFTVixNQUFNVSxNQUFNLENBQUN3RixjQUFjLENBQUNELFdBQVduRSxRQUFReEIsR0FBRztJQUM3RCxPQUFPO1FBQ0xJLFNBQVNWLE1BQU1VLE1BQU0sQ0FBQ3lGLFlBQVksQ0FBQ0YsV0FBV25FLFFBQVF4QixHQUFHO0lBQzNEO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUlPLFFBQVFILE9BQU9HLEtBQUs7SUFDeEJILE9BQU9HLEtBQUssR0FBRyxTQUFTTixFQUFFLEVBQUV1QixPQUFPO1FBQ2pDLCtEQUErRDtRQUMvRCxJQUFJdEIsU0FBUztRQUNiLElBQUdzQixtQkFBbUI5QixNQUFNaUMsSUFBSSxDQUFDbUUsVUFBVSxFQUFFO1lBQzNDNUYsU0FBU3NCO1lBQ1RBLFVBQVUsQ0FBQztRQUNiO1FBQ0FBLFVBQVVBLFdBQVcsQ0FBQztRQUN0QkEsUUFBUXRCLE1BQU0sR0FBR0E7UUFDakJzQixRQUFRdkIsRUFBRSxHQUFHQTtRQUNiTSxNQUFNd0YsSUFBSSxDQUFDM0YsUUFBUW9CO0lBQ3JCO0lBRUEsT0FBT3BCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hZXMuanM/ODI2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFkdmFuY2VkIEVuY3J5cHRpb24gU3RhbmRhcmQgKEFFUykgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgcHVibGljIGRvbWFpbiBsaWJyYXJ5ICdqc2NyeXB0bycgd2hpY2hcbiAqIHdhcyB3cml0dGVuIGJ5OlxuICpcbiAqIEVtaWx5IFN0YXJrIChlc3RhcmtAc3RhbmZvcmQuZWR1KVxuICogTWlrZSBIYW1idXJnIChtaGFtYnVyZ0BzdGFuZm9yZC5lZHUpXG4gKiBEYW4gQm9uZWggKGRhYm9AY3Muc3RhbmZvcmQuZWR1KVxuICpcbiAqIFBhcnRzIG9mIHRoaXMgY29kZSBhcmUgYmFzZWQgb24gdGhlIE9wZW5TU0wgaW1wbGVtZW50YXRpb24gb2YgQUVTOlxuICogaHR0cDovL3d3dy5vcGVuc3NsLm9yZ1xuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9jaXBoZXInKTtcbnJlcXVpcmUoJy4vY2lwaGVyTW9kZXMnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKiBBRVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmFlcyA9IGZvcmdlLmFlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsXG4gKiBhIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLCBhXG4gKiBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsXG4gKiBhIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLCBhXG4gKiBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQUVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIEFFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5hZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICBpZighaW5pdCkge1xuICAgIGluaXRpYWxpemUoKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDE2LFxuICAgIGNpcGhlcjoge1xuICAgICAgZW5jcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZi5fdywgaW5CbG9jaywgb3V0QmxvY2ssIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNlbGYuX2luaXQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhpcyBBRVMgYWxnb3JpdGhtIGJ5IGV4cGFuZGluZyBpdHMga2V5LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIGtleSB0aGUga2V5IHRvIHVzZSB3aXRoIHRoaXMgYWxnb3JpdGhtLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGlmIHRoZSBhbGdvcml0aG0gc2hvdWxkIGJlIGluaXRpYWxpemVkIGZvciBkZWNyeXB0aW9uLFxuICogICAgICAgICAgICBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqL1xuZm9yZ2UuYWVzLkFsZ29yaXRobS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYodGhpcy5faW5pdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHRtcDtcblxuICAvKiBOb3RlOiBUaGUga2V5IG1heSBiZSBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGEgYnl0ZVxuICAgIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzLiBJZiB0aGUga2V5IGlzIGluIGJ5dGVzLCB0aGVuXG4gICAgaXQgbXVzdCBiZSAxNiwgMjQsIG9yIDMyIGJ5dGVzIGluIGxlbmd0aC4gSWYgaXQgaXMgaW4gMzItYml0XG4gICAgaW50ZWdlcnMsIGl0IG11c3QgYmUgNCwgNiwgb3IgOCBpbnRlZ2VycyBsb25nLiAqL1xuXG4gIGlmKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmXG4gICAgKGtleS5sZW5ndGggPT09IDE2IHx8IGtleS5sZW5ndGggPT09IDI0IHx8IGtleS5sZW5ndGggPT09IDMyKSkge1xuICAgIC8vIGNvbnZlcnQga2V5IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShrZXkpICYmXG4gICAgKGtleS5sZW5ndGggPT09IDE2IHx8IGtleS5sZW5ndGggPT09IDI0IHx8IGtleS5sZW5ndGggPT09IDMyKSkge1xuICAgIC8vIGNvbnZlcnQga2V5IGludGVnZXIgYXJyYXkgaW50byBieXRlIGJ1ZmZlclxuICAgIHRtcCA9IGtleTtcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleS5wdXRCeXRlKHRtcFtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gY29udmVydCBrZXkgYnl0ZSBidWZmZXIgaW50byAzMi1iaXQgaW50ZWdlciBhcnJheVxuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICB0bXAgPSBrZXk7XG4gICAga2V5ID0gW107XG5cbiAgICAvLyBrZXkgbGVuZ3RocyBvZiAxNiwgMjQsIDMyIGJ5dGVzIGFsbG93ZWRcbiAgICB2YXIgbGVuID0gdG1wLmxlbmd0aCgpO1xuICAgIGlmKGxlbiA9PT0gMTYgfHwgbGVuID09PSAyNCB8fCBsZW4gPT09IDMyKSB7XG4gICAgICBsZW4gPSBsZW4gPj4+IDI7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5LnB1c2godG1wLmdldEludDMyKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtleSBtdXN0IGJlIGFuIGFycmF5IG9mIDMyLWJpdCBpbnRlZ2VycyBieSBub3dcbiAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShrZXkpIHx8XG4gICAgIShrZXkubGVuZ3RoID09PSA0IHx8IGtleS5sZW5ndGggPT09IDYgfHwga2V5Lmxlbmd0aCA9PT0gOCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHBhcmFtZXRlci4nKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHRpb24gb3BlcmF0aW9uIGlzIGFsd2F5cyB1c2VkIGZvciB0aGVzZSBtb2Rlc1xuICB2YXIgbW9kZSA9IHRoaXMubW9kZS5uYW1lO1xuICB2YXIgZW5jcnlwdE9wID0gKFsnQ0ZCJywgJ09GQicsICdDVFInLCAnR0NNJ10uaW5kZXhPZihtb2RlKSAhPT0gLTEpO1xuXG4gIC8vIGRvIGtleSBleHBhbnNpb25cbiAgdGhpcy5fdyA9IF9leHBhbmRLZXkoa2V5LCBvcHRpb25zLmRlY3J5cHQgJiYgIWVuY3J5cHRPcCk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBFeHBhbmRzIGEga2V5LiBUeXBpY2FsbHkgb25seSB1c2VkIGZvciB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gZXhwYW5kLCBhcyBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIGV4cGFuZCBmb3IgZGVjcnlwdGlvbiwgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKlxuICogQHJldHVybiB0aGUgZXhwYW5kZWQga2V5LlxuICovXG5mb3JnZS5hZXMuX2V4cGFuZEtleSA9IGZ1bmN0aW9uKGtleSwgZGVjcnlwdCkge1xuICBpZighaW5pdCkge1xuICAgIGluaXRpYWxpemUoKTtcbiAgfVxuICByZXR1cm4gX2V4cGFuZEtleShrZXksIGRlY3J5cHQpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGEgc2luZ2xlIGJsb2NrLiBUeXBpY2FsbHkgb25seSB1c2VkIGZvciB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSB3IHRoZSBleHBhbmRlZCBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGlucHV0IGFuIGFycmF5IG9mIGJsb2NrLXNpemUgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIG91dHB1dCBhbiBhcnJheSBvZiBibG9jay1zaXplIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCwgZmFsc2UgdG8gZW5jcnlwdC5cbiAqL1xuZm9yZ2UuYWVzLl91cGRhdGVCbG9jayA9IF91cGRhdGVCbG9jaztcblxuLyoqIFJlZ2lzdGVyIEFFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtR0NNJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmdjbSk7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIG1vZGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGZvcmdlLmFlcy5BbGdvcml0aG0obmFtZSwgbW9kZSk7XG4gIH07XG4gIGZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobShuYW1lLCBmYWN0b3J5KTtcbn1cblxuLyoqIEFFUyBpbXBsZW1lbnRhdGlvbiAqKi9cblxudmFyIGluaXQgPSBmYWxzZTsgLy8gbm90IHlldCBpbml0aWFsaXplZFxudmFyIE5iID0gNDsgICAgICAgLy8gbnVtYmVyIG9mIHdvcmRzIGNvbXByaXNpbmcgdGhlIHN0YXRlIChBRVMgPSA0KVxudmFyIHNib3g7ICAgICAgICAgLy8gbm9uLWxpbmVhciBzdWJzdGl0dXRpb24gdGFibGUgdXNlZCBpbiBrZXkgZXhwYW5zaW9uXG52YXIgaXNib3g7ICAgICAgICAvLyBpbnZlcnNpb24gb2Ygc2JveFxudmFyIHJjb247ICAgICAgICAgLy8gcm91bmQgY29uc3RhbnQgd29yZCBhcnJheVxudmFyIG1peDsgICAgICAgICAgLy8gbWl4LWNvbHVtbnMgdGFibGVcbnZhciBpbWl4OyAgICAgICAgIC8vIGludmVyc2UgbWl4LWNvbHVtbnMgdGFibGVcblxuLyoqXG4gKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiwgaWU6IHByZWNvbXB1dGVzIHRhYmxlcyB0byBvcHRpbWl6ZSBmb3Igc3BlZWQuXG4gKlxuICogT25lIHdheSB0byB1bmRlcnN0YW5kIGhvdyBBRVMgd29ya3MgaXMgdG8gaW1hZ2luZSB0aGF0ICdhZGRpdGlvbicgYW5kXG4gKiAnbXVsdGlwbGljYXRpb24nIGFyZSBpbnRlcmZhY2VzIHRoYXQgcmVxdWlyZSBjZXJ0YWluIG1hdGhlbWF0aWNhbFxuICogcHJvcGVydGllcyB0byBob2xkIHRydWUgKGllOiB0aGV5IGFyZSBhc3NvY2lhdGl2ZSkgYnV0IHRoZXkgbWlnaHQgaGF2ZVxuICogZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBhbmQgcHJvZHVjZSBkaWZmZXJlbnQga2luZHMgb2YgcmVzdWx0cyAuLi5cbiAqIHByb3ZpZGVkIHRoYXQgdGhlaXIgbWF0aGVtYXRpY2FsIHByb3BlcnRpZXMgcmVtYWluIHRydWUuIEFFUyBkZWZpbmVzXG4gKiBpdHMgb3duIG1ldGhvZHMgb2YgYWRkaXRpb24gYW5kIG11bHRpcGxpY2F0aW9uIGJ1dCBrZWVwcyBzb21lIGltcG9ydGFudFxuICogcHJvcGVydGllcyB0aGUgc2FtZSwgaWU6IGFzc29jaWF0aXZpdHkgYW5kIGRpc3RyaWJ1dGl2aXR5LiBUaGVcbiAqIGV4cGxhbmF0aW9uIGJlbG93IHRyaWVzIHRvIHNoZWQgc29tZSBsaWdodCBvbiBob3cgQUVTIGRlZmluZXMgYWRkaXRpb25cbiAqIGFuZCBtdWx0aXBsaWNhdGlvbiBvZiBieXRlcyBhbmQgMzItYml0IHdvcmRzIGluIG9yZGVyIHRvIHBlcmZvcm0gaXRzXG4gKiBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uIGFsZ29yaXRobXMuXG4gKlxuICogVGhlIGJhc2ljczpcbiAqXG4gKiBUaGUgQUVTIGFsZ29yaXRobSB2aWV3cyBieXRlcyBhcyBiaW5hcnkgcmVwcmVzZW50YXRpb25zIG9mIHBvbHlub21pYWxzXG4gKiB0aGF0IGhhdmUgZWl0aGVyIDEgb3IgMCBhcyB0aGUgY29lZmZpY2llbnRzLiBJdCBkZWZpbmVzIHRoZSBhZGRpdGlvblxuICogb3Igc3VidHJhY3Rpb24gb2YgdHdvIGJ5dGVzIGFzIHRoZSBYT1Igb3BlcmF0aW9uLiBJdCBhbHNvIGRlZmluZXMgdGhlXG4gKiBtdWx0aXBsaWNhdGlvbiBvZiB0d28gYnl0ZXMgYXMgYSBmaW5pdGUgZmllbGQgcmVmZXJyZWQgdG8gYXMgR0YoMl44KVxuICogKE5vdGU6ICdHRicgbWVhbnMgXCJHYWxvaXMgRmllbGRcIiB3aGljaCBpcyBhIGZpZWxkIHRoYXQgY29udGFpbnMgYSBmaW5pdGVcbiAqIG51bWJlciBvZiBlbGVtZW50cyBzbyBHRigyXjgpIGhhcyAyNTYgZWxlbWVudHMpLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCBhbnkgdHdvIGJ5dGVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBiaW5hcnkgcG9seW5vbWlhbHM7XG4gKiB3aGVuIHRoZXkgbXVsdGlwbGllZCB0b2dldGhlciBhbmQgbW9kdWxhcmx5IHJlZHVjZWQgYnkgYW4gaXJyZWR1Y2libGVcbiAqIHBvbHlub21pYWwgb2YgdGhlIDh0aCBkZWdyZWUsIHRoZSByZXN1bHRzIGFyZSB0aGUgZmllbGQgR0YoMl44KS4gVGhlXG4gKiBzcGVjaWZpYyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIHRoYXQgQUVTIHVzZXMgaW4gaGV4YWRlY2ltYWwgaXMgMHgxMWIuXG4gKiBUaGlzIG11bHRpcGxpY2F0aW9uIGlzIGFzc29jaWF0aXZlIHdpdGggMHgwMSBhcyB0aGUgaWRlbnRpdHk6XG4gKlxuICogKGIgKiAweDAxID0gR0YoYiwgMHgwMSkgPSBiKS5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIEdGKGIsIDB4MDIpIGNhbiBiZSBwZXJmb3JtZWQgYXQgdGhlIGJ5dGUgbGV2ZWwgYnkgbGVmdFxuICogc2hpZnRpbmcgYiBvbmNlIGFuZCB0aGVuIFhPUidpbmcgaXQgKHRvIHBlcmZvcm0gdGhlIG1vZHVsYXIgcmVkdWN0aW9uKVxuICogd2l0aCAweDExYiBpZiBiIGlzID49IDEyOC4gUmVwZWF0ZWQgYXBwbGljYXRpb24gb2YgdGhlIG11bHRpcGxpY2F0aW9uXG4gKiBvZiAweDAyIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCB0aGUgbXVsdGlwbGljYXRpb24gb2YgYW55IHR3byBieXRlcy5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIG11bHRpcGx5aW5nIDB4NTcgYW5kIDB4MTMsIGRlbm90ZWQgYXMgR0YoMHg1NywgMHgxMyksIGNhblxuICogYmUgcGVyZm9ybWVkIGJ5IGZhY3RvcmluZyAweDEzIGludG8gMHgwMSwgMHgwMiwgYW5kIDB4MTAuIFRoZW4gdGhlc2VcbiAqIGZhY3RvcnMgY2FuIGVhY2ggYmUgbXVsdGlwbGllZCBieSAweDU3IGFuZCB0aGVuIGFkZGVkIHRvZ2V0aGVyLiBUbyBkb1xuICogdGhlIG11bHRpcGxpY2F0aW9uLCB2YWx1ZXMgZm9yIDB4NTcgbXVsdGlwbGllZCBieSBlYWNoIG9mIHRoZXNlIDMgZmFjdG9yc1xuICogY2FuIGJlIHByZWNvbXB1dGVkIGFuZCBzdG9yZWQgaW4gYSB0YWJsZS4gVG8gYWRkIHRoZW0sIHRoZSB2YWx1ZXMgZnJvbVxuICogdGhlIHRhYmxlIGFyZSBYT1InZCB0b2dldGhlci5cbiAqXG4gKiBBRVMgYWxzbyBkZWZpbmVzIGFkZGl0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBvZiB3b3JkcywgdGhhdCBpcyA0LWJ5dGVcbiAqIG51bWJlcnMgcmVwcmVzZW50ZWQgYXMgcG9seW5vbWlhbHMgb2YgMyBkZWdyZWVzIHdoZXJlIHRoZSBjb2VmZmljaWVudHNcbiAqIGFyZSB0aGUgdmFsdWVzIG9mIHRoZSBieXRlcy5cbiAqXG4gKiBUaGUgd29yZCBbYTAsIGExLCBhMiwgYTNdIGlzIGEgcG9seW5vbWlhbCBhM3heMyArIGEyeF4yICsgYTF4ICsgYTAuXG4gKlxuICogQWRkaXRpb24gaXMgcGVyZm9ybWVkIGJ5IFhPUidpbmcgbGlrZSBwb3dlcnMgb2YgeC4gTXVsdGlwbGljYXRpb25cbiAqIGlzIHBlcmZvcm1lZCBpbiB0d28gc3RlcHMsIHRoZSBmaXJzdCBpcyBhbiBhbGdlYnJpYWMgZXhwYW5zaW9uIGFzXG4gKiB5b3Ugd291bGQgZG8gbm9ybWFsbHkgKHdoZXJlIGFkZGl0aW9uIGlzIFhPUikuIEJ1dCB0aGUgcmVzdWx0IGlzXG4gKiBhIHBvbHlub21pYWwgbGFyZ2VyIHRoYW4gMyBkZWdyZWVzIGFuZCB0aHVzIGl0IGNhbm5vdCBmaXQgaW4gYSB3b3JkLiBTb1xuICogbmV4dCB0aGUgcmVzdWx0IGlzIG1vZHVsYXJseSByZWR1Y2VkIGJ5IGFuIEFFUy1zcGVjaWZpYyBwb2x5bm9taWFsIG9mXG4gKiBkZWdyZWUgNCB3aGljaCB3aWxsIGFsd2F5cyBwcm9kdWNlIGEgcG9seW5vbWlhbCBvZiBsZXNzIHRoYW4gNCBkZWdyZWVzXG4gKiBzdWNoIHRoYXQgaXQgd2lsbCBmaXQgaW4gYSB3b3JkLiBJbiBBRVMsIHRoaXMgcG9seW5vbWlhbCBpcyB4XjQgKyAxLlxuICpcbiAqIFRoZSBtb2R1bGFyIHByb2R1Y3Qgb2YgdHdvIHBvbHlub21pYWxzICdhJyBhbmQgJ2InIGlzIHRodXM6XG4gKlxuICogZCh4KSA9IGQzeF4zICsgZDJ4XjIgKyBkMXggKyBkMFxuICogd2l0aFxuICogZDAgPSBHRihhMCwgYjApIF4gR0YoYTMsIGIxKSBeIEdGKGEyLCBiMikgXiBHRihhMSwgYjMpXG4gKiBkMSA9IEdGKGExLCBiMCkgXiBHRihhMCwgYjEpIF4gR0YoYTMsIGIyKSBeIEdGKGEyLCBiMylcbiAqIGQyID0gR0YoYTIsIGIwKSBeIEdGKGExLCBiMSkgXiBHRihhMCwgYjIpIF4gR0YoYTMsIGIzKVxuICogZDMgPSBHRihhMywgYjApIF4gR0YoYTIsIGIxKSBeIEdGKGExLCBiMikgXiBHRihhMCwgYjMpXG4gKlxuICogQXMgYSBtYXRyaXg6XG4gKlxuICogW2QwXSA9IFthMCBhMyBhMiBhMV1bYjBdXG4gKiBbZDFdICAgW2ExIGEwIGEzIGEyXVtiMV1cbiAqIFtkMl0gICBbYTIgYTEgYTAgYTNdW2IyXVxuICogW2QzXSAgIFthMyBhMiBhMSBhMF1bYjNdXG4gKlxuICogU3BlY2lhbCBwb2x5bm9taWFscyBkZWZpbmVkIGJ5IEFFUyAoMHgwMiA9PSB7MDJ9KTpcbiAqIGEoeCkgICAgPSB7MDN9eF4zICsgezAxfXheMiArIHswMX14ICsgezAyfVxuICogYV4tMSh4KSA9IHswYn14XjMgKyB7MGR9eF4yICsgezA5fXggKyB7MGV9LlxuICpcbiAqIFRoZXNlIHBvbHlub21pYWxzIGFyZSB1c2VkIGluIHRoZSBNaXhDb2x1bW5zKCkgYW5kIEludmVyc2VNaXhDb2x1bW5zKClcbiAqIG9wZXJhdGlvbnMsIHJlc3BlY3RpdmVseSwgdG8gY2F1c2UgZWFjaCBlbGVtZW50IGluIHRoZSBzdGF0ZSB0byBhZmZlY3RcbiAqIHRoZSBvdXRwdXQgKHJlZmVycmVkIHRvIGFzIGRpZmZ1c2luZykuXG4gKlxuICogUm90V29yZCgpIHVzZXM6IGEwID0gYTEgPSBhMiA9IHswMH0gYW5kIGEzID0gezAxfSwgd2hpY2ggaXMgdGhlXG4gKiBwb2x5bm9taWFsIHgzLlxuICpcbiAqIFRoZSBTaGlmdFJvd3MoKSBtZXRob2QgbW9kaWZpZXMgdGhlIGxhc3QgMyByb3dzIGluIHRoZSBzdGF0ZSAod2hlcmVcbiAqIHRoZSBzdGF0ZSBpcyA0IHdvcmRzIHdpdGggNCBieXRlcyBwZXIgd29yZCkgYnkgc2hpZnRpbmcgYnl0ZXMgY3ljbGljYWxseS5cbiAqIFRoZSAxc3QgYnl0ZSBpbiB0aGUgc2Vjb25kIHJvdyBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSByb3cuIFRoZSAxc3RcbiAqIGFuZCAybmQgYnl0ZXMgaW4gdGhlIHRoaXJkIHJvdyBhcmUgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGUgcm93LiBUaGUgMXN0LFxuICogMm5kLCBhbmQgM3JkIGJ5dGVzIGFyZSBtb3ZlZCBpbiB0aGUgZm91cnRoIHJvdy5cbiAqXG4gKiBNb3JlIGRldGFpbHMgb24gaG93IEFFUyBhcml0aG1ldGljIHdvcmtzOlxuICpcbiAqIEluIHRoZSBwb2x5bm9taWFsIHJlcHJlc2VudGF0aW9uIG9mIGJpbmFyeSBudW1iZXJzLCBYT1IgcGVyZm9ybXMgYWRkaXRpb25cbiAqIGFuZCBzdWJ0cmFjdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gaW4gR0YoMl44KSBkZW5vdGVkIGFzIEdGKGEsIGIpXG4gKiBjb3JyZXNwb25kcyB3aXRoIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBwb2x5bm9taWFscyBtb2R1bG8gYW4gaXJyZWR1Y2libGVcbiAqIHBvbHlub21pYWwgb2YgZGVncmVlIDguIEluIG90aGVyIHdvcmRzLCBmb3IgQUVTLCBHRihhLCBiKSB3aWxsIG11bHRpcGx5XG4gKiBwb2x5bm9taWFsICdhJyB3aXRoIHBvbHlub21pYWwgJ2InIGFuZCB0aGVuIGRvIGEgbW9kdWxhciByZWR1Y3Rpb24gYnlcbiAqIGFuIEFFUy1zcGVjaWZpYyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIG9mIGRlZ3JlZSA4LlxuICpcbiAqIEEgcG9seW5vbWlhbCBpcyBpcnJlZHVjaWJsZSBpZiBpdHMgb25seSBkaXZpc29ycyBhcmUgb25lIGFuZCBpdHNlbGYuIEZvclxuICogdGhlIEFFUyBhbGdvcml0aG0sIHRoaXMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCBpczpcbiAqXG4gKiBtKHgpID0geF44ICsgeF40ICsgeF4zICsgeCArIDEsXG4gKlxuICogb3IgezAxfXsxYn0gaW4gaGV4YWRlY2ltYWwgbm90YXRpb24sIHdoZXJlIGVhY2ggY29lZmZpY2llbnQgaXMgYSBiaXQ6XG4gKiAxMDAwMTEwMTEgPSAyODMgPSAweDExYi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgR0YoMHg1NywgMHg4MykgPSAweGMxIGJlY2F1c2VcbiAqXG4gKiAweDU3ID0gODcgID0gMDEwMTAxMTEgPSB4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMVxuICogMHg4NSA9IDEzMSA9IDEwMDAwMTAxID0geF43ICsgeCArIDFcbiAqXG4gKiAoeF42ICsgeF40ICsgeF4yICsgeCArIDEpICogKHheNyArIHggKyAxKVxuICogPSAgeF4xMyArIHheMTEgKyB4XjkgKyB4XjggKyB4XjcgK1xuICogICAgeF43ICsgeF41ICsgeF4zICsgeF4yICsgeCArXG4gKiAgICB4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMVxuICogPSAgeF4xMyArIHheMTEgKyB4XjkgKyB4XjggKyB4XjYgKyB4XjUgKyB4XjQgKyB4XjMgKyAxID0geVxuICogICAgeSBtb2R1bG8gKHheOCArIHheNCArIHheMyArIHggKyAxKVxuICogPSAgeF43ICsgeF42ICsgMS5cbiAqXG4gKiBUaGUgbW9kdWxhciByZWR1Y3Rpb24gYnkgbSh4KSBndWFyYW50ZWVzIHRoZSByZXN1bHQgd2lsbCBiZSBhIGJpbmFyeVxuICogcG9seW5vbWlhbCBvZiBsZXNzIHRoYW4gZGVncmVlIDgsIHNvIHRoYXQgaXQgY2FuIGZpdCBpbiBhIGJ5dGUuXG4gKlxuICogVGhlIG9wZXJhdGlvbiB0byBtdWx0aXBseSBhIGJpbmFyeSBwb2x5bm9taWFsIGIgd2l0aCB4ICh0aGUgcG9seW5vbWlhbFxuICogeCBpbiBiaW5hcnkgcmVwcmVzZW50YXRpb24gaXMgMDAwMDAwMTApIGlzOlxuICpcbiAqIGJfN3heOCArIGJfNnheNyArIGJfNXheNiArIGJfNHheNSArIGJfM3heNCArIGJfMnheMyArIGJfMXheMiArIGJfMHheMVxuICpcbiAqIFRvIGdldCBHRihiLCB4KSB3ZSBtdXN0IHJlZHVjZSB0aGF0IGJ5IG0oeCkuIElmIGJfNyBpcyAwICh0aGF0IGlzIHRoZVxuICogbW9zdCBzaWduaWZpY2FudCBiaXQgaXMgMCBpbiBiKSB0aGVuIHRoZSByZXN1bHQgaXMgYWxyZWFkeSByZWR1Y2VkLiBJZlxuICogaXQgaXMgMSwgdGhlbiB3ZSBjYW4gcmVkdWNlIGl0IGJ5IHN1YnRyYWN0aW5nIG0oeCkgdmlhIGFuIFhPUi5cbiAqXG4gKiBJdCBmb2xsb3dzIHRoYXQgbXVsdGlwbGljYXRpb24gYnkgeCAoMDAwMDAwMTAgb3IgMHgwMikgY2FuIGJlIGltcGxlbWVudGVkXG4gKiBieSBwZXJmb3JtaW5nIGEgbGVmdCBzaGlmdCBmb2xsb3dlZCBieSBhIGNvbmRpdGlvbmFsIGJpdHdpc2UgWE9SIHdpdGhcbiAqIDB4MWIuIFRoaXMgb3BlcmF0aW9uIG9uIGJ5dGVzIGlzIGRlbm90ZWQgYnkgeHRpbWUoKS4gTXVsdGlwbGljYXRpb24gYnlcbiAqIGhpZ2hlciBwb3dlcnMgb2YgeCBjYW4gYmUgaW1wbGVtZW50ZWQgYnkgcmVwZWF0ZWQgYXBwbGljYXRpb24gb2YgeHRpbWUoKS5cbiAqXG4gKiBCeSBhZGRpbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMsIG11bHRpcGxpY2F0aW9uIGJ5IGFueSBjb25zdGFudCBjYW4gYmVcbiAqIGltcGxlbWVudGVkLiBGb3IgaW5zdGFuY2U6XG4gKlxuICogR0YoMHg1NywgMHgxMykgPSAweGZlIGJlY2F1c2U6XG4gKlxuICogeHRpbWUoYikgPSAoYiAmIDEyOCkgPyAoYiA8PCAxIF4gMHgxMWIpIDogKGIgPDwgMSlcbiAqXG4gKiBOb3RlOiBXZSBYT1Igd2l0aCAweDExYiBpbnN0ZWFkIG9mIDB4MWIgYmVjYXVzZSBpbiBqYXZhc2NyaXB0IG91clxuICogZGF0YXR5cGUgZm9yIGIgY2FuIGJlIGxhcmdlciB0aGFuIDEgYnl0ZSwgc28gYSBsZWZ0IHNoaWZ0IHdpbGwgbm90XG4gKiBhdXRvbWF0aWNhbGx5IGVsaW1pbmF0ZSBiaXRzIHRoYXQgb3ZlcmZsb3cgYSBieXRlIC4uLiBieSBYT1InaW5nIHRoZVxuICogb3ZlcmZsb3cgYml0IHdpdGggMSAodGhlIGV4dHJhIG9uZSBmcm9tIDB4MTFiKSB3ZSB6ZXJvIGl0IG91dC5cbiAqXG4gKiBHRigweDU3LCAweDAyKSA9IHh0aW1lKDB4NTcpID0gMHhhZVxuICogR0YoMHg1NywgMHgwNCkgPSB4dGltZSgweGFlKSA9IDB4NDdcbiAqIEdGKDB4NTcsIDB4MDgpID0geHRpbWUoMHg0NykgPSAweDhlXG4gKiBHRigweDU3LCAweDEwKSA9IHh0aW1lKDB4OGUpID0gMHgwN1xuICpcbiAqIEdGKDB4NTcsIDB4MTMpID0gR0YoMHg1NywgKDB4MDEgXiAweDAyIF4gMHgxMCkpXG4gKlxuICogQW5kIGJ5IHRoZSBkaXN0cmlidXRpdmUgcHJvcGVydHkgKHNpbmNlIFhPUiBpcyBhZGRpdGlvbiBhbmQgR0YoKSBpc1xuICogbXVsdGlwbGljYXRpb24pOlxuICpcbiAqID0gR0YoMHg1NywgMHgwMSkgXiBHRigweDU3LCAweDAyKSBeIEdGKDB4NTcsIDB4MTApXG4gKiA9IDB4NTcgXiAweGFlIF4gMHgwN1xuICogPSAweGZlLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICBpbml0ID0gdHJ1ZTtcblxuICAvKiBQb3B1bGF0ZSB0aGUgUmNvbiB0YWJsZS4gVGhlc2UgYXJlIHRoZSB2YWx1ZXMgZ2l2ZW4gYnlcbiAgICBbeF4oaS0xKSx7MDB9LHswMH0sezAwfV0gd2hlcmUgeF4oaS0xKSBhcmUgcG93ZXJzIG9mIHggKGFuZCB4ID0gMHgwMilcbiAgICBpbiB0aGUgZmllbGQgb2YgR0YoMl44KSwgd2hlcmUgaSBzdGFydHMgYXQgMS5cblxuICAgIHJjb25bMF0gPSBbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF1cbiAgICByY29uWzFdID0gWzB4MDEsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDEtMSkgPSAyXjAgPSAxXG4gICAgcmNvblsyXSA9IFsweDAyLCAweDAwLCAweDAwLCAweDAwXSAyXigyLTEpID0gMl4xID0gMlxuICAgIC4uLlxuICAgIHJjb25bOV0gID0gWzB4MUIsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDktMSkgID0gMl44ID0gMHgxQlxuICAgIHJjb25bMTBdID0gWzB4MzYsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDEwLTEpID0gMl45ID0gMHgzNlxuXG4gICAgV2Ugb25seSBzdG9yZSB0aGUgZmlyc3QgYnl0ZSBiZWNhdXNlIGl0IGlzIHRoZSBvbmx5IG9uZSB1c2VkLlxuICAqL1xuICByY29uID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MUIsIDB4MzZdO1xuXG4gIC8vIGNvbXB1dGUgeHRpbWUgdGFibGUgd2hpY2ggbWFwcyBpIG9udG8gR0YoaSwgMHgwMilcbiAgdmFyIHh0aW1lID0gbmV3IEFycmF5KDI1Nik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxMjg7ICsraSkge1xuICAgIHh0aW1lW2ldID0gaSA8PCAxO1xuICAgIHh0aW1lW2kgKyAxMjhdID0gKGkgKyAxMjgpIDw8IDEgXiAweDExQjtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgYWxsIG90aGVyIHRhYmxlc1xuICBzYm94ID0gbmV3IEFycmF5KDI1Nik7XG4gIGlzYm94ID0gbmV3IEFycmF5KDI1Nik7XG4gIG1peCA9IG5ldyBBcnJheSg0KTtcbiAgaW1peCA9IG5ldyBBcnJheSg0KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIG1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGltaXhbaV0gPSBuZXcgQXJyYXkoMjU2KTtcbiAgfVxuICB2YXIgZSA9IDAsIGVpID0gMCwgZTIsIGU0LCBlOCwgc3gsIHN4MiwgbWUsIGltZTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgLyogV2UgbmVlZCB0byBnZW5lcmF0ZSB0aGUgU3ViQnl0ZXMoKSBzYm94IGFuZCBpc2JveCB0YWJsZXMgc28gdGhhdFxuICAgICAgd2UgY2FuIHBlcmZvcm0gYnl0ZSBzdWJzdGl0dXRpb25zLiBUaGlzIHJlcXVpcmVzIHVzIHRvIHRyYXZlcnNlXG4gICAgICBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIEdGLCBmaW5kIHRoZWlyIG11bHRpcGxpY2F0aXZlIGludmVyc2VzLFxuICAgICAgYW5kIGFwcGx5IHRvIGVhY2ggdGhlIGZvbGxvd2luZyBhZmZpbmUgdHJhbnNmb3JtYXRpb246XG5cbiAgICAgIGJpJyA9IGJpIF4gYihpICsgNCkgbW9kIDggXiBiKGkgKyA1KSBtb2QgOCBeIGIoaSArIDYpIG1vZCA4IF5cbiAgICAgICAgICAgIGIoaSArIDcpIG1vZCA4IF4gY2lcbiAgICAgIGZvciAwIDw9IGkgPCA4LCB3aGVyZSBiaSBpcyB0aGUgaXRoIGJpdCBvZiB0aGUgYnl0ZSwgYW5kIGNpIGlzIHRoZVxuICAgICAgaXRoIGJpdCBvZiBhIGJ5dGUgYyB3aXRoIHRoZSB2YWx1ZSB7NjN9IG9yIHswMTEwMDAxMX0uXG5cbiAgICAgIEl0IGlzIHBvc3NpYmxlIHRvIHRyYXZlcnNlIGV2ZXJ5IHBvc3NpYmxlIHZhbHVlIGluIGEgR2Fsb2lzIGZpZWxkXG4gICAgICB1c2luZyB3aGF0IGlzIHJlZmVycmVkIHRvIGFzIGEgJ2dlbmVyYXRvcicuIFRoZXJlIGFyZSBtYW55XG4gICAgICBnZW5lcmF0b3JzICgxMjggb3V0IG9mIDI1Nik6IDMsNSw2LDksMTEsODIgdG8gbmFtZSBhIGZldy4gVG8gZnVsbHlcbiAgICAgIHRyYXZlcnNlIEdGIHdlIGl0ZXJhdGUgMjU1IHRpbWVzLCBtdWx0aXBseWluZyBieSBvdXIgZ2VuZXJhdG9yXG4gICAgICBlYWNoIHRpbWUuXG5cbiAgICAgIE9uIGVhY2ggaXRlcmF0aW9uIHdlIGNhbiBkZXRlcm1pbmUgdGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2UgZm9yXG4gICAgICB0aGUgY3VycmVudCBlbGVtZW50LlxuXG4gICAgICBTdXBwb3NlIHRoZXJlIGlzIGFuIGVsZW1lbnQgaW4gR0YgJ2UnLiBGb3IgYSBnaXZlbiBnZW5lcmF0b3IgJ2cnLFxuICAgICAgZSA9IGdeeC4gVGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgZSBpcyBnXigyNTUgLSB4KS4gSXQgdHVybnNcbiAgICAgIG91dCB0aGF0IGlmIHVzZSB0aGUgaW52ZXJzZSBvZiBhIGdlbmVyYXRvciBhcyBhbm90aGVyIGdlbmVyYXRvclxuICAgICAgaXQgd2lsbCBwcm9kdWNlIGFsbCBvZiB0aGUgY29ycmVzcG9uZGluZyBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlc1xuICAgICAgYXQgdGhlIHNhbWUgdGltZS4gRm9yIHRoaXMgcmVhc29uLCB3ZSBjaG9vc2UgNSBhcyBvdXIgaW52ZXJzZVxuICAgICAgZ2VuZXJhdG9yIGJlY2F1c2UgaXQgb25seSByZXF1aXJlcyAyIG11bHRpcGxpZXMgYW5kIDEgYWRkIGFuZCBpdHNcbiAgICAgIGludmVyc2UsIDgyLCByZXF1aXJlcyByZWxhdGl2ZWx5IGZldyBvcGVyYXRpb25zIGFzIHdlbGwuXG5cbiAgICAgIEluIG9yZGVyIHRvIGFwcGx5IHRoZSBhZmZpbmUgdHJhbnNmb3JtYXRpb24sIHRoZSBtdWx0aXBsaWNhdGl2ZVxuICAgICAgaW52ZXJzZSAnZWknIG9mICdlJyBjYW4gYmUgcmVwZWF0ZWRseSBYT1InZCAoNCB0aW1lcykgd2l0aCBhXG4gICAgICBiaXQtY3ljbGluZyBvZiAnZWknLiBUbyBkbyB0aGlzICdlaScgaXMgZmlyc3Qgc3RvcmVkIGluICdzJyBhbmRcbiAgICAgICd4Jy4gVGhlbiAncycgaXMgbGVmdCBzaGlmdGVkIGFuZCB0aGUgaGlnaCBiaXQgb2YgJ3MnIGlzIG1hZGUgdGhlXG4gICAgICBsb3cgYml0LiBUaGUgcmVzdWx0aW5nIHZhbHVlIGlzIHN0b3JlZCBpbiAncycuIFRoZW4gJ3gnIGlzIFhPUidkXG4gICAgICB3aXRoICdzJyBhbmQgc3RvcmVkIGluICd4Jy4gT24gZWFjaCBzdWJzZXF1ZW50IGl0ZXJhdGlvbiB0aGUgc2FtZVxuICAgICAgb3BlcmF0aW9uIGlzIHBlcmZvcm1lZC4gV2hlbiA0IGl0ZXJhdGlvbnMgYXJlIGNvbXBsZXRlLCAneCcgaXNcbiAgICAgIFhPUidkIHdpdGggJ2MnICgweDYzKSBhbmQgdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGlzIHN0b3JlZCBpbiAneCcuXG4gICAgICBGb3IgZXhhbXBsZTpcblxuICAgICAgcyA9IDAxMDAwMDAxXG4gICAgICB4ID0gMDEwMDAwMDFcblxuICAgICAgaXRlcmF0aW9uIDE6IHMgPSAxMDAwMDAxMCwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gMjogcyA9IDAwMDAwMTAxLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiAzOiBzID0gMDAwMDEwMTAsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDQ6IHMgPSAwMDAxMDEwMCwgeCBePSBzXG4gICAgICB4IF49IDB4NjNcblxuICAgICAgVGhpcyBjYW4gYmUgZG9uZSB3aXRoIGEgbG9vcCB3aGVyZSBzID0gKHMgPDwgMSkgfCAocyA+PiA3KS4gSG93ZXZlcixcbiAgICAgIGl0IGNhbiBhbHNvIGJlIGRvbmUgYnkgdXNpbmcgYSBzaW5nbGUgMTYtYml0IChpbiB0aGlzIGNhc2UgMzItYml0KVxuICAgICAgbnVtYmVyICdzeCcuIFNpbmNlIFhPUiBpcyBhbiBhc3NvY2lhdGl2ZSBvcGVyYXRpb24sIHdlIGNhbiBzZXQgJ3N4J1xuICAgICAgdG8gJ2VpJyBhbmQgdGhlbiBYT1IgaXQgd2l0aCAnc3gnIGxlZnQtc2hpZnRlZCAxLDIsMywgYW5kIDQgdGltZXMuXG4gICAgICBUaGUgbW9zdCBzaWduaWZpY2FudCBiaXRzIHdpbGwgZmxvdyBpbnRvIHRoZSBoaWdoIDggYml0IHBvc2l0aW9uc1xuICAgICAgYW5kIGJlIGNvcnJlY3RseSBYT1InZCB3aXRoIG9uZSBhbm90aGVyLiBBbGwgdGhhdCByZW1haW5zIHdpbGwgYmVcbiAgICAgIHRvIGN5Y2xlIHRoZSBoaWdoIDggYml0cyBieSBYT1InaW5nIHRoZW0gYWxsIHdpdGggdGhlIGxvd2VyIDggYml0c1xuICAgICAgYWZ0ZXJ3YXJkcy5cblxuICAgICAgQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBwb3B1bGF0aW5nIHNib3ggYW5kIGlzYm94IHdlIGNhbiBwcmVjb21wdXRlXG4gICAgICB0aGUgbXVsdGlwbGljYXRpb24gd2UnbGwgbmVlZCB0byBkbyB0byBkbyBNaXhDb2x1bW5zKCkgbGF0ZXIuXG4gICAgKi9cblxuICAgIC8vIGFwcGx5IGFmZmluZSB0cmFuc2Zvcm1hdGlvblxuICAgIHN4ID0gZWkgXiAoZWkgPDwgMSkgXiAoZWkgPDwgMikgXiAoZWkgPDwgMykgXiAoZWkgPDwgNCk7XG4gICAgc3ggPSAoc3ggPj4gOCkgXiAoc3ggJiAyNTUpIF4gMHg2MztcblxuICAgIC8vIHVwZGF0ZSB0YWJsZXNcbiAgICBzYm94W2VdID0gc3g7XG4gICAgaXNib3hbc3hdID0gZTtcblxuICAgIC8qIE1peGluZyBjb2x1bW5zIGlzIGRvbmUgdXNpbmcgbWF0cml4IG11bHRpcGxpY2F0aW9uLiBUaGUgY29sdW1uc1xuICAgICAgdGhhdCBhcmUgdG8gYmUgbWl4ZWQgYXJlIGVhY2ggYSBzaW5nbGUgd29yZCBpbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgIFRoZSBzdGF0ZSBoYXMgTmIgY29sdW1ucyAoNCBjb2x1bW5zKS4gVGhlcmVmb3JlIGVhY2ggY29sdW1uIGlzIGFcbiAgICAgIDQgYnl0ZSB3b3JkLiBTbyB0byBtaXggdGhlIGNvbHVtbnMgaW4gYSBzaW5nbGUgY29sdW1uICdjJyB3aGVyZVxuICAgICAgaXRzIHJvd3MgYXJlIHIwLCByMSwgcjIsIGFuZCByMywgd2UgdXNlIHRoZSBmb2xsb3dpbmcgbWF0cml4XG4gICAgICBtdWx0aXBsaWNhdGlvbjpcblxuICAgICAgWzIgMyAxIDFdKltyMCxjXT1bcicwLGNdXG4gICAgICBbMSAyIDMgMV0gW3IxLGNdIFtyJzEsY11cbiAgICAgIFsxIDEgMiAzXSBbcjIsY10gW3InMixjXVxuICAgICAgWzMgMSAxIDJdIFtyMyxjXSBbciczLGNdXG5cbiAgICAgIHIwLCByMSwgcjIsIGFuZCByMyBhcmUgZWFjaCAxIGJ5dGUgb2Ygb25lIG9mIHRoZSB3b3JkcyBpbiB0aGVcbiAgICAgIHN0YXRlIChhIGNvbHVtbikuIFRvIGRvIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBmb3IgZWFjaCBtaXhlZFxuICAgICAgY29sdW1uIGMnIHdlIG11bHRpcGx5IHRoZSBjb3JyZXNwb25kaW5nIHJvdyBmcm9tIHRoZSBsZWZ0IG1hdHJpeFxuICAgICAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBjb2x1bW4gZnJvbSB0aGUgcmlnaHQgbWF0cml4LiBJbiB0b3RhbCwgd2VcbiAgICAgIGdldCA0IGVxdWF0aW9uczpcblxuICAgICAgcjAsYycgPSAyKnIwLGMgKyAzKnIxLGMgKyAxKnIyLGMgKyAxKnIzLGNcbiAgICAgIHIxLGMnID0gMSpyMCxjICsgMipyMSxjICsgMypyMixjICsgMSpyMyxjXG4gICAgICByMixjJyA9IDEqcjAsYyArIDEqcjEsYyArIDIqcjIsYyArIDMqcjMsY1xuICAgICAgcjMsYycgPSAzKnIwLGMgKyAxKnIxLGMgKyAxKnIyLGMgKyAyKnIzLGNcblxuICAgICAgQXMgdXN1YWwsIHRoZSBtdWx0aXBsaWNhdGlvbiBpcyBhcyBwcmV2aW91c2x5IGRlZmluZWQgYW5kIHRoZVxuICAgICAgYWRkaXRpb24gaXMgWE9SLiBJbiBvcmRlciB0byBvcHRpbWl6ZSBtaXhpbmcgY29sdW1ucyB3ZSBjYW4gc3RvcmVcbiAgICAgIHRoZSBtdWx0aXBsaWNhdGlvbiByZXN1bHRzIGluIHRhYmxlcy4gSWYgeW91IHRoaW5rIG9mIHRoZSB3aG9sZVxuICAgICAgY29sdW1uIGFzIGEgd29yZCAoaXQgbWlnaHQgaGVscCB0byB2aXN1YWxpemUgYnkgbWVudGFsbHkgcm90YXRpbmdcbiAgICAgIHRoZSBlcXVhdGlvbnMgYWJvdmUgYnkgY291bnRlcmNsb2Nrd2lzZSA5MCBkZWdyZWVzKSB0aGVuIHlvdSBjYW5cbiAgICAgIHNlZSB0aGF0IGl0IHdvdWxkIGJlIHVzZWZ1bCB0byBtYXAgdGhlIG11bHRpcGxpY2F0aW9ucyBwZXJmb3JtZWQgb25cbiAgICAgIGVhY2ggYnl0ZSAocjAsIHIxLCByMiwgcjMpIG9udG8gYSB3b3JkIGFzIHdlbGwuIEZvciBpbnN0YW5jZSwgd2VcbiAgICAgIGNvdWxkIG1hcCAyKnIwLDEqcjAsMSpyMCwzKnIwIG9udG8gYSB3b3JkIGJ5IHN0b3JpbmcgMipyMCBpbiB0aGVcbiAgICAgIGhpZ2hlc3QgOCBiaXRzIGFuZCAzKnIwIGluIHRoZSBsb3dlc3QgOCBiaXRzICh3aXRoIHRoZSBvdGhlciB0d29cbiAgICAgIHJlc3BlY3RpdmVseSBpbiB0aGUgbWlkZGxlKS4gVGhpcyBtZWFucyB0aGF0IGEgdGFibGUgY2FuIGJlXG4gICAgICBjb25zdHJ1Y3RlZCB0aGF0IHVzZXMgcjAgYXMgYW4gaW5kZXggdG8gdGhlIHdvcmQuIFdlIGNhbiBkbyB0aGVcbiAgICAgIHNhbWUgd2l0aCByMSwgcjIsIGFuZCByMywgY3JlYXRpbmcgYSB0b3RhbCBvZiA0IHRhYmxlcy5cblxuICAgICAgVG8gY29uc3RydWN0IGEgZnVsbCBjJywgd2UgY2FuIGp1c3QgbG9vayB1cCBlYWNoIGJ5dGUgb2YgYyBpblxuICAgICAgdGhlaXIgcmVzcGVjdGl2ZSB0YWJsZXMgYW5kIFhPUiB0aGUgcmVzdWx0cyB0b2dldGhlci5cblxuICAgICAgQWxzbywgdG8gYnVpbGQgZWFjaCB0YWJsZSB3ZSBvbmx5IGhhdmUgdG8gY2FsY3VsYXRlIHRoZSB3b3JkXG4gICAgICBmb3IgMiwxLDEsMyBmb3IgZXZlcnkgYnl0ZSAuLi4gd2hpY2ggd2UgY2FuIGRvIG9uIGVhY2ggaXRlcmF0aW9uXG4gICAgICBvZiB0aGlzIGxvb3Agc2luY2Ugd2Ugd2lsbCBpdGVyYXRlIG92ZXIgZXZlcnkgYnl0ZS4gQWZ0ZXIgd2UgaGF2ZVxuICAgICAgY2FsY3VsYXRlZCAyLDEsMSwzIHdlIGNhbiBnZXQgdGhlIHJlc3VsdHMgZm9yIHRoZSBvdGhlciB0YWJsZXNcbiAgICAgIGJ5IGN5Y2xpbmcgdGhlIGJ5dGUgYXQgdGhlIGVuZCB0byB0aGUgYmVnaW5uaW5nLiBGb3IgaW5zdGFuY2VcbiAgICAgIHdlIGNhbiB0YWtlIHRoZSByZXN1bHQgb2YgdGFibGUgMiwxLDEsMyBhbmQgcHJvZHVjZSB0YWJsZSAzLDIsMSwxXG4gICAgICBieSBtb3ZpbmcgdGhlIHJpZ2h0IG1vc3QgYnl0ZSB0byB0aGUgbGVmdCBtb3N0IHBvc2l0aW9uIGp1c3QgbGlrZVxuICAgICAgaG93IHlvdSBjYW4gaW1hZ2luZSB0aGUgMyBtb3ZlZCBvdXQgb2YgMiwxLDEsMyBhbmQgdG8gdGhlIGZyb250XG4gICAgICB0byBwcm9kdWNlIDMsMiwxLDEuXG5cbiAgICAgIFRoZXJlIGlzIGFub3RoZXIgb3B0aW1pemF0aW9uIGluIHRoYXQgdGhlIHNhbWUgbXVsdGlwbGVzIG9mXG4gICAgICB0aGUgY3VycmVudCBlbGVtZW50IHdlIG5lZWQgaW4gb3JkZXIgdG8gYWR2YW5jZSBvdXIgZ2VuZXJhdG9yXG4gICAgICB0byB0aGUgbmV4dCBpdGVyYXRpb24gY2FuIGJlIHJldXNlZCBpbiBwZXJmb3JtaW5nIHRoZSAyLDEsMSwzXG4gICAgICBjYWxjdWxhdGlvbi4gV2UgYWxzbyBjYWxjdWxhdGUgdGhlIGludmVyc2UgbWl4IGNvbHVtbiB0YWJsZXMsXG4gICAgICB3aXRoIGUsOSxkLGIgYmVpbmcgdGhlIGludmVyc2Ugb2YgMiwxLDEsMy5cblxuICAgICAgV2hlbiB3ZSdyZSBkb25lLCBhbmQgd2UgbmVlZCB0byBhY3R1YWxseSBtaXggY29sdW1ucywgdGhlIGZpcnN0XG4gICAgICBieXRlIG9mIGVhY2ggc3RhdGUgd29yZCBzaG91bGQgYmUgcHV0IHRocm91Z2ggbWl4WzBdICgyLDEsMSwzKSxcbiAgICAgIHRoZSBzZWNvbmQgdGhyb3VnaCBtaXhbMV0gKDMsMiwxLDEpIGFuZCBzbyBmb3J0aC4gVGhlbiB0aGV5IHNob3VsZFxuICAgICAgYmUgWE9SJ2QgdG9nZXRoZXIgdG8gcHJvZHVjZSB0aGUgZnVsbHkgbWl4ZWQgY29sdW1uLlxuICAgICovXG5cbiAgICAvLyBjYWxjdWxhdGUgbWl4IGFuZCBpbWl4IHRhYmxlIHZhbHVlc1xuICAgIHN4MiA9IHh0aW1lW3N4XTtcbiAgICBlMiA9IHh0aW1lW2VdO1xuICAgIGU0ID0geHRpbWVbZTJdO1xuICAgIGU4ID0geHRpbWVbZTRdO1xuICAgIG1lID1cbiAgICAgIChzeDIgPDwgMjQpIF4gIC8vIDJcbiAgICAgIChzeCA8PCAxNikgXiAgIC8vIDFcbiAgICAgIChzeCA8PCA4KSBeICAgIC8vIDFcbiAgICAgIChzeCBeIHN4Mik7ICAgIC8vIDNcbiAgICBpbWUgPVxuICAgICAgKGUyIF4gZTQgXiBlOCkgPDwgMjQgXiAgLy8gRSAoMTQpXG4gICAgICAoZSBeIGU4KSA8PCAxNiBeICAgICAgICAvLyA5XG4gICAgICAoZSBeIGU0IF4gZTgpIDw8IDggXiAgICAvLyBEICgxMylcbiAgICAgIChlIF4gZTIgXiBlOCk7ICAgICAgICAgIC8vIEIgKDExKVxuICAgIC8vIHByb2R1Y2UgZWFjaCBvZiB0aGUgbWl4IHRhYmxlcyBieSByb3RhdGluZyB0aGUgMiwxLDEsMyB2YWx1ZVxuICAgIGZvcih2YXIgbiA9IDA7IG4gPCA0OyArK24pIHtcbiAgICAgIG1peFtuXVtlXSA9IG1lO1xuICAgICAgaW1peFtuXVtzeF0gPSBpbWU7XG4gICAgICAvLyBjeWNsZSB0aGUgcmlnaHQgbW9zdCBieXRlIHRvIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb25cbiAgICAgIC8vIGllOiAyLDEsMSwzIGJlY29tZXMgMywyLDEsMVxuICAgICAgbWUgPSBtZSA8PCAyNCB8IG1lID4+PiA4O1xuICAgICAgaW1lID0gaW1lIDw8IDI0IHwgaW1lID4+PiA4O1xuICAgIH1cblxuICAgIC8vIGdldCBuZXh0IGVsZW1lbnQgYW5kIGludmVyc2VcbiAgICBpZihlID09PSAwKSB7XG4gICAgICAvLyAxIGlzIHRoZSBpbnZlcnNlIG9mIDFcbiAgICAgIGUgPSBlaSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGUgPSAyZSArIDIqMioyKigxMGUpKSA9IG11bHRpcGx5IGUgYnkgODIgKGNob3NlbiBnZW5lcmF0b3IpXG4gICAgICAvLyBlaSA9IGVpICsgMioyKmVpID0gbXVsdGlwbHkgZWkgYnkgNSAoaW52ZXJzZSBnZW5lcmF0b3IpXG4gICAgICBlID0gZTIgXiB4dGltZVt4dGltZVt4dGltZVtlMiBeIGU4XV1dO1xuICAgICAgZWkgXj0geHRpbWVbeHRpbWVbZWldXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBrZXkgc2NoZWR1bGUgdXNpbmcgdGhlIEFFUyBrZXkgZXhwYW5zaW9uIGFsZ29yaXRobS5cbiAqXG4gKiBUaGUgQUVTIGFsZ29yaXRobSB0YWtlcyB0aGUgQ2lwaGVyIEtleSwgSywgYW5kIHBlcmZvcm1zIGEgS2V5IEV4cGFuc2lvblxuICogcm91dGluZSB0byBnZW5lcmF0ZSBhIGtleSBzY2hlZHVsZS4gVGhlIEtleSBFeHBhbnNpb24gZ2VuZXJhdGVzIGEgdG90YWxcbiAqIG9mIE5iKihOciArIDEpIHdvcmRzOiB0aGUgYWxnb3JpdGhtIHJlcXVpcmVzIGFuIGluaXRpYWwgc2V0IG9mIE5iIHdvcmRzLFxuICogYW5kIGVhY2ggb2YgdGhlIE5yIHJvdW5kcyByZXF1aXJlcyBOYiB3b3JkcyBvZiBrZXkgZGF0YS4gVGhlIHJlc3VsdGluZ1xuICoga2V5IHNjaGVkdWxlIGNvbnNpc3RzIG9mIGEgbGluZWFyIGFycmF5IG9mIDQtYnl0ZSB3b3JkcywgZGVub3RlZCBbd2kgXSxcbiAqIHdpdGggaSBpbiB0aGUgcmFuZ2UgMCA8PSBpIDwgTmIoTnIgKyAxKS5cbiAqXG4gKiBLZXlFeHBhbnNpb24oYnl0ZSBrZXlbNCpOa10sIHdvcmQgd1tOYiooTnIrMSldLCBOaylcbiAqIEFFUy0xMjggKE5iPTQsIE5rPTQsIE5yPTEwKVxuICogQUVTLTE5MiAoTmI9NCwgTms9NiwgTnI9MTIpXG4gKiBBRVMtMjU2IChOYj00LCBOaz04LCBOcj0xNClcbiAqIE5vdGU6IE5yPU5rKzYuXG4gKlxuICogTmIgaXMgdGhlIG51bWJlciBvZiBjb2x1bW5zICgzMi1iaXQgd29yZHMpIGNvbXByaXNpbmcgdGhlIFN0YXRlIChvclxuICogbnVtYmVyIG9mIGJ5dGVzIGluIGEgYmxvY2spLiBGb3IgQUVTLCBOYj00LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzY2hlZHVsZSAoYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gbW9kaWZ5IHRoZSBrZXkgc2NoZWR1bGUgdG8gZGVjcnlwdCwgZmFsc2Ugbm90IHRvLlxuICpcbiAqIEByZXR1cm4gdGhlIGdlbmVyYXRlZCBrZXkgc2NoZWR1bGUuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KSB7XG4gIC8vIGNvcHkgdGhlIGtleSdzIHdvcmRzIHRvIGluaXRpYWxpemUgdGhlIGtleSBzY2hlZHVsZVxuICB2YXIgdyA9IGtleS5zbGljZSgwKTtcblxuICAvKiBSb3RXb3JkKCkgd2lsbCByb3RhdGUgYSB3b3JkLCBtb3ZpbmcgdGhlIGZpcnN0IGJ5dGUgdG8gdGhlIGxhc3RcbiAgICBieXRlJ3MgcG9zaXRpb24gKHNoaWZ0aW5nIHRoZSBvdGhlciBieXRlcyBsZWZ0KS5cblxuICAgIFdlIHdpbGwgYmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgUmNvbiBhdCBpIC8gTmsuICdpJyB3aWxsIGl0ZXJhdGVcbiAgICBmcm9tIE5rIHRvIChOYiAqIE5yKzEpLiBOayA9IDQgKDQgYnl0ZSBrZXkpLCBOYiA9IDQgKDQgd29yZHMgaW5cbiAgICBhIGJsb2NrKSwgTnIgPSBOayArIDYgKDEwKS4gVGhlcmVmb3JlICdpJyB3aWxsIGl0ZXJhdGUgZnJvbVxuICAgIDQgdG8gNDQgKGV4Y2x1c2l2ZSkuIEVhY2ggdGltZSB3ZSBpdGVyYXRlIDQgdGltZXMsIGkgLyBOayB3aWxsXG4gICAgaW5jcmVhc2UgYnkgMS4gV2UgdXNlIGEgY291bnRlciBpTmsgdG8ga2VlcCB0cmFjayBvZiB0aGlzLlxuICAgKi9cblxuICAvLyBnbyB0aHJvdWdoIHRoZSByb3VuZHMgZXhwYW5kaW5nIHRoZSBrZXlcbiAgdmFyIHRlbXAsIGlOayA9IDE7XG4gIHZhciBOayA9IHcubGVuZ3RoO1xuICB2YXIgTnIxID0gTmsgKyA2ICsgMTtcbiAgdmFyIGVuZCA9IE5iICogTnIxO1xuICBmb3IodmFyIGkgPSBOazsgaSA8IGVuZDsgKytpKSB7XG4gICAgdGVtcCA9IHdbaSAtIDFdO1xuICAgIGlmKGkgJSBOayA9PT0gMCkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQoUm90V29yZCh0ZW1wKSkgXiBSY29uW2kgLyBOa11cbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgMTYgXlxuICAgICAgICBzYm94W3RlbXAgJiAyNTVdIDw8IDggXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSBeIChyY29uW2lOa10gPDwgMjQpO1xuICAgICAgaU5rKys7XG4gICAgfSBlbHNlIGlmKE5rID4gNiAmJiAoaSAlIE5rID09PSA0KSkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQodGVtcClcbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XTtcbiAgICB9XG4gICAgd1tpXSA9IHdbaSAtIE5rXSBeIHRlbXA7XG4gIH1cblxuICAvKiBXaGVuIHdlIGFyZSB1cGRhdGluZyBhIGNpcGhlciBibG9jayB3ZSBhbHdheXMgdXNlIHRoZSBjb2RlIHBhdGggZm9yXG4gICAgIGVuY3J5cHRpb24gd2hldGhlciB3ZSBhcmUgZGVjcnlwdGluZyBvciBub3QgKHRvIHNob3J0ZW4gY29kZSBhbmRcbiAgICAgc2ltcGxpZnkgdGhlIGdlbmVyYXRpb24gb2YgbG9vayB1cCB0YWJsZXMpLiBIb3dldmVyLCBiZWNhdXNlIHRoZXJlXG4gICAgIGFyZSBkaWZmZXJlbmNlcyBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0sIG90aGVyIHRoYW4ganVzdCBzd2FwcGluZ1xuICAgICBpbiBkaWZmZXJlbnQgbG9vayB1cCB0YWJsZXMsIHdlIG11c3QgdHJhbnNmb3JtIG91ciBrZXkgc2NoZWR1bGUgdG9cbiAgICAgYWNjb3VudCBmb3IgdGhlc2UgY2hhbmdlczpcblxuICAgICAxLiBUaGUgZGVjcnlwdGlvbiBhbGdvcml0aG0gZ2V0cyBpdHMga2V5IHJvdW5kcyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAyLiBUaGUgZGVjcnlwdGlvbiBhbGdvcml0aG0gYWRkcyB0aGUgcm91bmQga2V5IGJlZm9yZSBtaXhpbmcgY29sdW1uc1xuICAgICAgIGluc3RlYWQgb2YgYWZ0ZXJ3YXJkcy5cblxuICAgICBXZSBkb24ndCBuZWVkIHRvIG1vZGlmeSBvdXIga2V5IHNjaGVkdWxlIHRvIGhhbmRsZSB0aGUgZmlyc3QgY2FzZSxcbiAgICAgd2UgY2FuIGp1c3QgdHJhdmVyc2UgdGhlIGtleSBzY2hlZHVsZSBpbiByZXZlcnNlIG9yZGVyIHdoZW4gZGVjcnlwdGluZy5cblxuICAgICBUaGUgc2Vjb25kIGNhc2UgcmVxdWlyZXMgYSBsaXR0bGUgd29yay5cblxuICAgICBUaGUgdGFibGVzIHdlIGJ1aWx0IGZvciBwZXJmb3JtaW5nIHJvdW5kcyB3aWxsIHRha2UgYW4gaW5wdXQgYW5kIHRoZW5cbiAgICAgcGVyZm9ybSBTdWJCeXRlcygpIGFuZCBNaXhDb2x1bW5zKCkgb3IsIGZvciB0aGUgZGVjcnlwdCB2ZXJzaW9uLFxuICAgICBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkuIEJ1dCB0aGUgZGVjcnlwdCBhbGdvcml0aG0gcmVxdWlyZXNcbiAgICAgdXMgdG8gQWRkUm91bmRLZXkoKSBiZWZvcmUgSW52TWl4Q29sdW1ucygpLiBUaGlzIG1lYW5zIHdlJ2xsIG5lZWQgdG9cbiAgICAgYXBwbHkgc29tZSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIHJvdW5kIGtleSB0byBpbnZlcnNlLW1peCBpdHMgY29sdW1uc1xuICAgICBzbyB0aGV5J2xsIGJlIGNvcnJlY3QgZm9yIG1vdmluZyBBZGRSb3VuZEtleSgpIHRvIGFmdGVyIHRoZSBzdGF0ZSBoYXNcbiAgICAgaGFkIGl0cyBjb2x1bW5zIGludmVyc2UtbWl4ZWQuXG5cbiAgICAgVG8gaW52ZXJzZS1taXggdGhlIGNvbHVtbnMgb2YgdGhlIHN0YXRlIHdoZW4gd2UncmUgZGVjcnlwdGluZyB3ZSB1c2UgYVxuICAgICBsb29rdXAgdGFibGUgdGhhdCB3aWxsIGFwcGx5IEludlN1YkJ5dGVzKCkgYW5kIEludk1peENvbHVtbnMoKSBhdCB0aGVcbiAgICAgc2FtZSB0aW1lLiBIb3dldmVyLCB0aGUgcm91bmQga2V5J3MgYnl0ZXMgYXJlIG5vdCBpbnZlcnNlLXN1YnN0aXR1dGVkXG4gICAgIGluIHRoZSBkZWNyeXB0aW9uIGFsZ29yaXRobS4gVG8gZ2V0IGFyb3VuZCB0aGlzIHByb2JsZW0sIHdlIGNhbiBmaXJzdFxuICAgICBzdWJzdGl0dXRlIHRoZSBieXRlcyBpbiB0aGUgcm91bmQga2V5IHNvIHRoYXQgd2hlbiB3ZSBhcHBseSB0aGVcbiAgICAgdHJhbnNmb3JtYXRpb24gdmlhIHRoZSBJbnZTdWJCeXRlcygpK0ludk1peENvbHVtbnMoKSB0YWJsZSwgaXQgd2lsbFxuICAgICB1bmRvIG91ciBzdWJzdGl0dXRpb24gbGVhdmluZyB1cyB3aXRoIHRoZSBvcmlnaW5hbCB2YWx1ZSB0aGF0IHdlXG4gICAgIHdhbnQgLS0gYW5kIHRoZW4gaW52ZXJzZS1taXggdGhhdCB2YWx1ZS5cblxuICAgICBUaGlzIGNoYW5nZSB3aWxsIGNvcnJlY3RseSBhbHRlciBvdXIga2V5IHNjaGVkdWxlIHNvIHRoYXQgd2UgY2FuIFhPUlxuICAgICBlYWNoIHJvdW5kIGtleSB3aXRoIG91ciBhbHJlYWR5IHRyYW5zZm9ybWVkIGRlY3J5cHRpb24gc3RhdGUuIFRoaXNcbiAgICAgYWxsb3dzIHVzIHRvIHVzZSB0aGUgc2FtZSBjb2RlIHBhdGggYXMgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtLlxuXG4gICAgIFdlIG1ha2Ugb25lIG1vcmUgY2hhbmdlIHRvIHRoZSBkZWNyeXB0aW9uIGtleS4gU2luY2UgdGhlIGRlY3J5cHRpb25cbiAgICAgYWxnb3JpdGhtIHJ1bnMgaW4gcmV2ZXJzZSBmcm9tIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSwgd2UgcmV2ZXJzZVxuICAgICB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMgdG8gYXZvaWQgaGF2aW5nIHRvIGl0ZXJhdGUgb3ZlciB0aGUga2V5XG4gICAgIHNjaGVkdWxlIGJhY2t3YXJkcyB3aGVuIHJ1bm5pbmcgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIGxhdGVyIGluXG4gICAgIGRlY3J5cHRpb24gbW9kZS4gSW4gYWRkaXRpb24gdG8gcmV2ZXJzaW5nIHRoZSBvcmRlciBvZiB0aGUgcm91bmQga2V5cyxcbiAgICAgd2UgYWxzbyBzd2FwIGVhY2ggcm91bmQga2V5J3MgMm5kIGFuZCA0dGggcm93cy4gU2VlIHRoZSBjb21tZW50c1xuICAgICBzZWN0aW9uIHdoZXJlIHJvdW5kcyBhcmUgcGVyZm9ybWVkIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgd2h5IHRoaXMgaXNcbiAgICAgZG9uZS4gVGhlc2UgY2hhbmdlcyBhcmUgZG9uZSBpbmxpbmUgd2l0aCB0aGUgb3RoZXIgc3Vic3RpdHV0aW9uXG4gICAgIGRlc2NyaWJlZCBhYm92ZS5cbiAgKi9cbiAgaWYoZGVjcnlwdCkge1xuICAgIHZhciB0bXA7XG4gICAgdmFyIG0wID0gaW1peFswXTtcbiAgICB2YXIgbTEgPSBpbWl4WzFdO1xuICAgIHZhciBtMiA9IGltaXhbMl07XG4gICAgdmFyIG0zID0gaW1peFszXTtcbiAgICB2YXIgd25ldyA9IHcuc2xpY2UoMCk7XG4gICAgZW5kID0gdy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgd2kgPSBlbmQgLSBOYjsgaSA8IGVuZDsgaSArPSBOYiwgd2kgLT0gTmIpIHtcbiAgICAgIC8vIGRvIG5vdCBzdWIgdGhlIGZpcnN0IG9yIGxhc3Qgcm91bmQga2V5IChyb3VuZCBrZXlzIGFyZSBOYlxuICAgICAgLy8gd29yZHMpIGFzIG5vIGNvbHVtbiBtaXhpbmcgaXMgcGVyZm9ybWVkIGJlZm9yZSB0aGV5IGFyZSBhZGRlZCxcbiAgICAgIC8vIGJ1dCBkbyBjaGFuZ2UgdGhlIGtleSBvcmRlclxuICAgICAgaWYoaSA9PT0gMCB8fCBpID09PSAoZW5kIC0gTmIpKSB7XG4gICAgICAgIHduZXdbaV0gPSB3W3dpXTtcbiAgICAgICAgd25ld1tpICsgMV0gPSB3W3dpICsgM107XG4gICAgICAgIHduZXdbaSArIDJdID0gd1t3aSArIDJdO1xuICAgICAgICB3bmV3W2kgKyAzXSA9IHdbd2kgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN1YnN0aXR1dGUgZWFjaCByb3VuZCBrZXkgYnl0ZSBiZWNhdXNlIHRoZSBpbnZlcnNlLW1peFxuICAgICAgICAvLyB0YWJsZSB3aWxsIGludmVyc2Utc3Vic3RpdHV0ZSBpdCAoZWZmZWN0aXZlbHkgY2FuY2VsIHRoZVxuICAgICAgICAvLyBzdWJzdGl0dXRpb24gYmVjYXVzZSByb3VuZCBrZXkgYnl0ZXMgYXJlbid0IHN1YidkIGluXG4gICAgICAgIC8vIGRlY3J5cHRpb24gbW9kZSkgYW5kIHN3YXAgaW5kZXhlcyAzIGFuZCAxXG4gICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBOYjsgKytuKSB7XG4gICAgICAgICAgdG1wID0gd1t3aSArIG5dO1xuICAgICAgICAgIHduZXdbaSArICgzJi1uKV0gPVxuICAgICAgICAgICAgbTBbc2JveFt0bXAgPj4+IDI0XV0gXlxuICAgICAgICAgICAgbTFbc2JveFt0bXAgPj4+IDE2ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTJbc2JveFt0bXAgPj4+IDggJiAyNTVdXSBeXG4gICAgICAgICAgICBtM1tzYm94W3RtcCAmIDI1NV1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHcgPSB3bmV3O1xuICB9XG5cbiAgcmV0dXJuIHc7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNpbmdsZSBibG9jayAoMTYgYnl0ZXMpIHVzaW5nIEFFUy4gVGhlIHVwZGF0ZSB3aWxsIGVpdGhlclxuICogZW5jcnlwdCBvciBkZWNyeXB0IHRoZSBibG9jay5cbiAqXG4gKiBAcGFyYW0gdyB0aGUga2V5IHNjaGVkdWxlLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKHcsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLypcbiAgQ2lwaGVyKGJ5dGUgaW5bNCpOYl0sIGJ5dGUgb3V0WzQqTmJdLCB3b3JkIHdbTmIqKE5yKzEpXSlcbiAgYmVnaW5cbiAgICBieXRlIHN0YXRlWzQsTmJdXG4gICAgc3RhdGUgPSBpblxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgIGZvciByb3VuZCA9IDEgc3RlcCAxIHRvIE5yLTFcbiAgICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgICAgTWl4Q29sdW1ucyhzdGF0ZSlcbiAgICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W3JvdW5kKk5iLCAocm91bmQrMSkqTmItMV0pXG4gICAgZW5kIGZvclxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuXG4gIEludkNpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIGZvciByb3VuZCA9IE5yLTEgc3RlcCAtMSBkb3dudG8gMVxuICAgICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgICAgSW52TWl4Q29sdW1ucyhzdGF0ZSlcbiAgICBlbmQgZm9yXG4gICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuICAqL1xuXG4gIC8vIEVuY3J5cHQ6IEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAvLyBEZWNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICB2YXIgTnIgPSB3Lmxlbmd0aCAvIDQgLSAxO1xuICB2YXIgbTAsIG0xLCBtMiwgbTMsIHN1YjtcbiAgaWYoZGVjcnlwdCkge1xuICAgIG0wID0gaW1peFswXTtcbiAgICBtMSA9IGltaXhbMV07XG4gICAgbTIgPSBpbWl4WzJdO1xuICAgIG0zID0gaW1peFszXTtcbiAgICBzdWIgPSBpc2JveDtcbiAgfSBlbHNlIHtcbiAgICBtMCA9IG1peFswXTtcbiAgICBtMSA9IG1peFsxXTtcbiAgICBtMiA9IG1peFsyXTtcbiAgICBtMyA9IG1peFszXTtcbiAgICBzdWIgPSBzYm94O1xuICB9XG4gIHZhciBhLCBiLCBjLCBkLCBhMiwgYjIsIGMyO1xuICBhID0gaW5wdXRbMF0gXiB3WzBdO1xuICBiID0gaW5wdXRbZGVjcnlwdCA/IDMgOiAxXSBeIHdbMV07XG4gIGMgPSBpbnB1dFsyXSBeIHdbMl07XG4gIGQgPSBpbnB1dFtkZWNyeXB0ID8gMSA6IDNdIF4gd1szXTtcbiAgdmFyIGkgPSAzO1xuXG4gIC8qIEluIG9yZGVyIHRvIHNoYXJlIGNvZGUgd2UgZm9sbG93IHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB3aGVuIGJvdGhcbiAgICBlbmNyeXB0aW5nIGFuZCBkZWNyeXB0aW5nLiBUbyBhY2NvdW50IGZvciB0aGUgY2hhbmdlcyByZXF1aXJlZCBpbiB0aGVcbiAgICBkZWNyeXB0aW9uIGFsZ29yaXRobSwgd2UgdXNlIGRpZmZlcmVudCBsb29rdXAgdGFibGVzIHdoZW4gZGVjcnlwdGluZ1xuICAgIGFuZCB1c2UgYSBtb2RpZmllZCBrZXkgc2NoZWR1bGUgdG8gYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gdGhlXG4gICAgb3JkZXIgb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHJvdW5kcy4gV2UgYWxzbyBnZXRcbiAgICBrZXkgcm91bmRzIGluIHJldmVyc2Ugb3JkZXIgKHJlbGF0aXZlIHRvIGVuY3J5cHRpb24pLiAqL1xuICBmb3IodmFyIHJvdW5kID0gMTsgcm91bmQgPCBOcjsgKytyb3VuZCkge1xuICAgIC8qIEFzIGRlc2NyaWJlZCBhYm92ZSwgd2UnbGwgYmUgdXNpbmcgdGFibGUgbG9va3VwcyB0byBwZXJmb3JtIHRoZVxuICAgICAgY29sdW1uIG1peGluZy4gRWFjaCBjb2x1bW4gaXMgc3RvcmVkIGFzIGEgd29yZCBpbiB0aGUgc3RhdGUgKHRoZVxuICAgICAgYXJyYXkgJ2lucHV0JyBoYXMgb25lIGNvbHVtbiBhcyBhIHdvcmQgYXQgZWFjaCBpbmRleCkuIEluIG9yZGVyIHRvXG4gICAgICBtaXggYSBjb2x1bW4sIHdlIHBlcmZvcm0gdGhlc2UgdHJhbnNmb3JtYXRpb25zIG9uIGVhY2ggcm93IGluIGMsXG4gICAgICB3aGljaCBpcyAxIGJ5dGUgaW4gZWFjaCB3b3JkLiBUaGUgbmV3IGNvbHVtbiBmb3IgYzAgaXMgYycwOlxuXG4gICAgICAgICAgICAgICBtMCAgICAgIG0xICAgICAgbTIgICAgICBtM1xuICAgICAgcjAsYycwID0gMipyMCxjMCArIDMqcjEsYzAgKyAxKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjEsYycwID0gMSpyMCxjMCArIDIqcjEsYzAgKyAzKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjIsYycwID0gMSpyMCxjMCArIDEqcjEsYzAgKyAyKnIyLGMwICsgMypyMyxjMFxuICAgICAgcjMsYycwID0gMypyMCxjMCArIDEqcjEsYzAgKyAxKnIyLGMwICsgMipyMyxjMFxuXG4gICAgICBTbyB1c2luZyBtaXggdGFibGVzIHdoZXJlIGMwIGlzIGEgd29yZCB3aXRoIHIwIGJlaW5nIGl0cyB1cHBlclxuICAgICAgOCBiaXRzIGFuZCByMyBiZWluZyBpdHMgbG93ZXIgOCBiaXRzOlxuXG4gICAgICBtMFtjMCA+PiAyNF0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsyKnIwLDEqcjAsMSpyMCwzKnIwXVxuICAgICAgLi4uXG4gICAgICBtM1tjMCAmIDI1NV0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsxKnIzLDEqcjMsMypyMywyKnIzXVxuXG4gICAgICBUaGVyZWZvcmUgdG8gbWl4IHRoZSBjb2x1bW5zIGluIGVhY2ggd29yZCBpbiB0aGUgc3RhdGUgd2VcbiAgICAgIGRvIHRoZSBmb2xsb3dpbmcgKCYgMjU1IG9taXR0ZWQgZm9yIGJyZXZpdHkpOlxuICAgICAgYycwLHIwID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMSA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjIgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIzID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cblxuICAgICAgSG93ZXZlciwgYmVmb3JlIG1peGluZywgdGhlIGFsZ29yaXRobSByZXF1aXJlcyB1cyB0byBwZXJmb3JtXG4gICAgICBTaGlmdFJvd3MoKS4gVGhlIFNoaWZ0Um93cygpIHRyYW5zZm9ybWF0aW9uIGN5Y2xpY2FsbHkgc2hpZnRzIHRoZVxuICAgICAgbGFzdCAzIHJvd3Mgb2YgdGhlIHN0YXRlIG92ZXIgZGlmZmVyZW50IG9mZnNldHMuIFRoZSBmaXJzdCByb3dcbiAgICAgIChyID0gMCkgaXMgbm90IHNoaWZ0ZWQuXG5cbiAgICAgIHMnX3IsYyA9IHNfciwoYyArIHNoaWZ0KHIsIE5iKSBtb2QgTmJcbiAgICAgIGZvciAwIDwgciA8IDQgYW5kIDAgPD0gYyA8IE5iIGFuZFxuICAgICAgc2hpZnQoMSwgNCkgPSAxXG4gICAgICBzaGlmdCgyLCA0KSA9IDJcbiAgICAgIHNoaWZ0KDMsIDQpID0gMy5cblxuICAgICAgVGhpcyBjYXVzZXMgdGhlIGZpcnN0IGJ5dGUgaW4gciA9IDEgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDIgYnl0ZXMgaW4gciA9IDIgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDMgYnl0ZXMgaW4gciA9IDMgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdzpcblxuICAgICAgcjE6IFtjMCBjMSBjMiBjM10gPT4gW2MxIGMyIGMzIGMwXVxuICAgICAgcjI6IFtjMCBjMSBjMiBjM10gICAgW2MyIGMzIGMwIGMxXVxuICAgICAgcjM6IFtjMCBjMSBjMiBjM10gICAgW2MzIGMwIGMxIGMyXVxuXG4gICAgICBXZSBjYW4gbWFrZSB0aGVzZSBzdWJzdGl0dXRpb25zIGlubGluZSB3aXRoIG91ciBjb2x1bW4gbWl4aW5nIHRvXG4gICAgICBnZW5lcmF0ZSBhbiB1cGRhdGVkIHNldCBvZiBlcXVhdGlvbnMgdG8gcHJvZHVjZSBlYWNoIHdvcmQgaW4gdGhlXG4gICAgICBzdGF0ZSAobm90ZSB0aGUgY29sdW1ucyBoYXZlIGNoYW5nZWQgcG9zaXRpb25zKTpcblxuICAgICAgYzAgYzEgYzIgYzMgPT4gYzAgYzEgYzIgYzNcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMxIGMyIGMzIGMwICAoY3ljbGVkIDEgYnl0ZSlcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMyIGMzIGMwIGMxICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMyBjMCBjMSBjMiAgKGN5Y2xlZCAzIGJ5dGVzKVxuXG4gICAgICBUaGVyZWZvcmU6XG5cbiAgICAgIGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMxICsgMSpyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMxICsgMypyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMxICsgMipyMixjMiArIDMqcjMsYzNcbiAgICAgIGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMxICsgMSpyMixjMiArIDIqcjMsYzNcblxuICAgICAgYycxID0gMipyMCxjMSArIDMqcjEsYzIgKyAxKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDIqcjEsYzIgKyAzKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDEqcjEsYzIgKyAyKnIyLGMzICsgMypyMyxjMFxuICAgICAgYycxID0gMypyMCxjMSArIDEqcjEsYzIgKyAxKnIyLGMzICsgMipyMyxjMFxuXG4gICAgICAuLi4gYW5kIHNvIGZvcnRoIGZvciBjJzIgYW5kIGMnMy4gVGhlIGltcG9ydGFudCBkaXN0aW5jdGlvbiBpc1xuICAgICAgdGhhdCB0aGUgY29sdW1ucyBhcmUgY3ljbGluZywgd2l0aCBjMCBiZWluZyB1c2VkIHdpdGggdGhlIG0wXG4gICAgICBtYXAgd2hlbiBjYWxjdWxhdGluZyBjMCwgYnV0IGMxIGJlaW5nIHVzZWQgd2l0aCB0aGUgbTAgbWFwIHdoZW5cbiAgICAgIGNhbGN1bGF0aW5nIGMxIC4uLiBhbmQgc28gZm9ydGguXG5cbiAgICAgIFdoZW4gcGVyZm9ybWluZyB0aGUgaW52ZXJzZSB3ZSB0cmFuc2Zvcm0gdGhlIG1pcnJvciBpbWFnZSBhbmRcbiAgICAgIHNraXAgdGhlIGJvdHRvbSByb3csIGluc3RlYWQgb2YgdGhlIHRvcCBvbmUsIGFuZCBtb3ZlIHVwd2FyZHM6XG5cbiAgICAgIGMzIGMyIGMxIGMwID0+IGMwIGMzIGMyIGMxICAoY3ljbGVkIDMgYnl0ZXMpICpzYW1lIGFzIGVuY3J5cHRpb25cbiAgICAgIGMzIGMyIGMxIGMwICAgIGMxIGMwIGMzIGMyICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMiBjMSBjMCBjMyAgKGN5Y2xlZCAxIGJ5dGUpICAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMyBjMiBjMSBjMFxuXG4gICAgICBJZiB5b3UgY29tcGFyZSB0aGUgcmVzdWx0aW5nIG1hdHJpY2VzIGZvciBTaGlmdFJvd3MoKStNaXhDb2x1bW5zKClcbiAgICAgIGFuZCBmb3IgSW52U2hpZnRSb3dzKCkrSW52TWl4Q29sdW1ucygpIHRoZSAybmQgYW5kIDR0aCBjb2x1bW5zIGFyZVxuICAgICAgZGlmZmVyZW50IChpbiBlbmNyeXB0IG1vZGUgdnMuIGRlY3J5cHQgbW9kZSkuIFNvIGluIG9yZGVyIHRvIHVzZVxuICAgICAgdGhlIHNhbWUgY29kZSB0byBoYW5kbGUgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCB3ZSB3aWxsXG4gICAgICBuZWVkIHRvIGRvIHNvbWUgbWFwcGluZy5cblxuICAgICAgSWYgaW4gZW5jcnlwdGlvbiBtb2RlIHdlIGxldCBhPWMwLCBiPWMxLCBjPWMyLCBkPWMzLCBhbmQgcjxOPiBiZVxuICAgICAgYSByb3cgbnVtYmVyIGluIHRoZSBzdGF0ZSwgdGhlbiB0aGUgcmVzdWx0aW5nIG1hdHJpeCBpbiBlbmNyeXB0aW9uXG4gICAgICBtb2RlIGZvciBhcHBseWluZyB0aGUgYWJvdmUgdHJhbnNmb3JtYXRpb25zIHdvdWxkIGJlOlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGIgYyBkIGFcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogZCBhIGIgY1xuXG4gICAgICBJZiB3ZSBkaWQgdGhlIHNhbWUgaW4gZGVjcnlwdGlvbiBtb2RlIHdlIHdvdWxkIGdldDpcblxuICAgICAgcjE6IGEgZCBjIGJcbiAgICAgIHIyOiBiIGEgZCBjXG4gICAgICByMzogYyBiIGEgZFxuICAgICAgcjQ6IGQgYyBiIGFcblxuICAgICAgSWYgaW5zdGVhZCB3ZSBzd2FwIGQgYW5kIGIgKHNldCBiPWMzIGFuZCBkPWMxKSwgdGhlbiB3ZSBnZXQ6XG5cbiAgICAgIHIxOiBhIGIgYyBkXG4gICAgICByMjogZCBhIGIgY1xuICAgICAgcjM6IGMgZCBhIGJcbiAgICAgIHI0OiBiIGMgZCBhXG5cbiAgICAgIE5vdyB0aGUgMXN0IGFuZCAzcmQgcm93cyBhcmUgdGhlIHNhbWUgYXMgdGhlIGVuY3J5cHRpb24gbWF0cml4LiBBbGxcbiAgICAgIHdlIG5lZWQgdG8gZG8gdGhlbiB0byBtYWtlIHRoZSBtYXBwaW5nIGV4YWN0bHkgdGhlIHNhbWUgaXMgdG8gc3dhcFxuICAgICAgdGhlIDJuZCBhbmQgNHRoIHJvd3Mgd2hlbiBpbiBkZWNyeXB0aW9uIG1vZGUuIFRvIGRvIHRoaXMgd2l0aG91dFxuICAgICAgaGF2aW5nIHRvIGRvIGl0IG9uIGVhY2ggaXRlcmF0aW9uLCB3ZSBzd2FwcGVkIHRoZSAybmQgYW5kIDR0aCByb3dzXG4gICAgICBpbiB0aGUgZGVjcnlwdGlvbiBrZXkgc2NoZWR1bGUuIFdlIGFsc28gaGF2ZSB0byBkbyB0aGUgc3dhcCBhYm92ZVxuICAgICAgd2hlbiB3ZSBmaXJzdCBwdWxsIGluIHRoZSBpbnB1dCBhbmQgd2hlbiB3ZSBzZXQgdGhlIGZpbmFsIG91dHB1dC4gKi9cbiAgICBhMiA9XG4gICAgICBtMFthID4+PiAyNF0gXlxuICAgICAgbTFbYiA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2MgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgIGIyID1cbiAgICAgIG0wW2IgPj4+IDI0XSBeXG4gICAgICBtMVtjID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbZCA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYSAmIDI1NV0gXiB3WysraV07XG4gICAgYzIgPVxuICAgICAgbTBbYyA+Pj4gMjRdIF5cbiAgICAgIG0xW2QgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMlthID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tiICYgMjU1XSBeIHdbKytpXTtcbiAgICBkID1cbiAgICAgIG0wW2QgPj4+IDI0XSBeXG4gICAgICBtMVthID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYiA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYyAmIDI1NV0gXiB3WysraV07XG4gICAgYSA9IGEyO1xuICAgIGIgPSBiMjtcbiAgICBjID0gYzI7XG4gIH1cblxuICAvKlxuICAgIEVuY3J5cHQ6XG4gICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG5cbiAgICBEZWNyeXB0OlxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICovXG4gIC8vIE5vdGU6IHJvd3MgYXJlIHNoaWZ0ZWQgaW5saW5lXG4gIG91dHB1dFswXSA9XG4gICAgKHN1YlthID4+PiAyNF0gPDwgMjQpIF5cbiAgICAoc3ViW2IgPj4+IDE2ICYgMjU1XSA8PCAxNikgXlxuICAgIChzdWJbYyA+Pj4gOCAmIDI1NV0gPDwgOCkgXlxuICAgIChzdWJbZCAmIDI1NV0pIF4gd1srK2ldO1xuICBvdXRwdXRbZGVjcnlwdCA/IDMgOiAxXSA9XG4gICAgKHN1YltiID4+PiAyNF0gPDwgMjQpIF5cbiAgICAoc3ViW2MgPj4+IDE2ICYgMjU1XSA8PCAxNikgXlxuICAgIChzdWJbZCA+Pj4gOCAmIDI1NV0gPDwgOCkgXlxuICAgIChzdWJbYSAmIDI1NV0pIF4gd1srK2ldO1xuICBvdXRwdXRbMl0gPVxuICAgIChzdWJbYyA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltkID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2EgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2IgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAxIDogM10gPVxuICAgIChzdWJbZCA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YlthID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2IgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2MgJiAyNTVdKSBeIHdbKytpXTtcbn1cblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYSBkZXByZWNhdGVkIEFFUyBjaXBoZXIgb2JqZWN0LiBUaGlzIG9iamVjdCdzIG1vZGUgd2lsbCBkZWZhdWx0IHRvXG4gKiBDQkMgKGNpcGhlci1ibG9jay1jaGFpbmluZykuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdBRVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiYWVzIiwic3RhcnRFbmNyeXB0aW5nIiwia2V5IiwiaXYiLCJvdXRwdXQiLCJtb2RlIiwiY2lwaGVyIiwiX2NyZWF0ZUNpcGhlciIsImRlY3J5cHQiLCJzdGFydCIsImNyZWF0ZUVuY3J5cHRpb25DaXBoZXIiLCJzdGFydERlY3J5cHRpbmciLCJjcmVhdGVEZWNyeXB0aW9uQ2lwaGVyIiwiQWxnb3JpdGhtIiwibmFtZSIsImluaXQiLCJpbml0aWFsaXplIiwic2VsZiIsImJsb2NrU2l6ZSIsImVuY3J5cHQiLCJpbkJsb2NrIiwib3V0QmxvY2siLCJfdXBkYXRlQmxvY2siLCJfdyIsIl9pbml0IiwicHJvdG90eXBlIiwib3B0aW9ucyIsInRtcCIsImxlbmd0aCIsInV0aWwiLCJjcmVhdGVCdWZmZXIiLCJpc0FycmF5IiwiaSIsInB1dEJ5dGUiLCJsZW4iLCJwdXNoIiwiZ2V0SW50MzIiLCJFcnJvciIsImVuY3J5cHRPcCIsImluZGV4T2YiLCJfZXhwYW5kS2V5IiwicmVnaXN0ZXJBbGdvcml0aG0iLCJtb2RlcyIsImVjYiIsImNiYyIsImNmYiIsIm9mYiIsImN0ciIsImdjbSIsImZhY3RvcnkiLCJOYiIsInNib3giLCJpc2JveCIsInJjb24iLCJtaXgiLCJpbWl4IiwieHRpbWUiLCJBcnJheSIsImUiLCJlaSIsImUyIiwiZTQiLCJlOCIsInN4Iiwic3gyIiwibWUiLCJpbWUiLCJuIiwidyIsInNsaWNlIiwidGVtcCIsImlOayIsIk5rIiwiTnIxIiwiZW5kIiwibTAiLCJtMSIsIm0yIiwibTMiLCJ3bmV3Iiwid2kiLCJpbnB1dCIsIk5yIiwic3ViIiwiYSIsImIiLCJjIiwiZCIsImEyIiwiYjIiLCJjMiIsInJvdW5kIiwidG9VcHBlckNhc2UiLCJhbGdvcml0aG0iLCJjcmVhdGVEZWNpcGhlciIsImNyZWF0ZUNpcGhlciIsIkJ5dGVCdWZmZXIiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/aes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/asn1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/asn1.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Javascript implementation of Abstract Syntax Notation Number One.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n *\n * An API for storing data using the Abstract Syntax Notation Number One\n * format using DER (Distinguished Encoding Rules) encoding. This encoding is\n * commonly used to store data for PKI, i.e. X.509 Certificates, and this\n * implementation exists for that purpose.\n *\n * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract\n * syntax of information without restricting the way the information is encoded\n * for transmission. It provides a standard that allows for open systems\n * communication. ASN.1 defines the syntax of information data and a number of\n * simple data types as well as a notation for describing them and specifying\n * values for them.\n *\n * The RSA algorithm creates public and private keys that are often stored in\n * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This\n * class provides the most basic functionality required to store and load DSA\n * keys that are encoded according to ASN.1.\n *\n * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)\n * and DER (Distinguished Encoding Rules). DER is just a subset of BER that\n * has stricter requirements for how data must be encoded.\n *\n * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)\n * and a byte array for the value of this ASN1 structure which may be data or a\n * list of ASN.1 structures.\n *\n * Each ASN.1 structure using BER is (Tag-Length-Value):\n *\n * | byte 0 | bytes X | bytes Y |\n * |--------|---------|----------\n * |  tag   | length  |  value  |\n *\n * ASN.1 allows for tags to be of \"High-tag-number form\" which allows a tag to\n * be two or more octets, but that is not supported by this class. A tag is\n * only 1 byte. Bits 1-5 give the tag number (ie the data type within a\n * particular 'class'), 6 indicates whether or not the ASN.1 value is\n * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If\n * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,\n * then the class is APPLICATION. If only bit 8 is set, then the class is\n * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.\n * The tag numbers for the data types for the class UNIVERSAL are listed below:\n *\n * UNIVERSAL 0 Reserved for use by the encoding rules\n * UNIVERSAL 1 Boolean type\n * UNIVERSAL 2 Integer type\n * UNIVERSAL 3 Bitstring type\n * UNIVERSAL 4 Octetstring type\n * UNIVERSAL 5 Null type\n * UNIVERSAL 6 Object identifier type\n * UNIVERSAL 7 Object descriptor type\n * UNIVERSAL 8 External type and Instance-of type\n * UNIVERSAL 9 Real type\n * UNIVERSAL 10 Enumerated type\n * UNIVERSAL 11 Embedded-pdv type\n * UNIVERSAL 12 UTF8String type\n * UNIVERSAL 13 Relative object identifier type\n * UNIVERSAL 14-15 Reserved for future editions\n * UNIVERSAL 16 Sequence and Sequence-of types\n * UNIVERSAL 17 Set and Set-of types\n * UNIVERSAL 18-22, 25-30 Character string types\n * UNIVERSAL 23-24 Time types\n *\n * The length of an ASN.1 structure is specified after the tag identifier.\n * There is a definite form and an indefinite form. The indefinite form may\n * be used if the encoding is constructed and not all immediately available.\n * The indefinite form is encoded using a length byte with only the 8th bit\n * set. The end of the constructed object is marked using end-of-contents\n * octets (two zero bytes).\n *\n * The definite form looks like this:\n *\n * The length may take up 1 or more bytes, it depends on the length of the\n * value of the ASN.1 structure. DER encoding requires that if the ASN.1\n * structure has a value that has a length greater than 127, more than 1 byte\n * will be used to store its length, otherwise just one byte will be used.\n * This is strict.\n *\n * In the case that the length of the ASN.1 value is less than 127, 1 octet\n * (byte) is used to store the \"short form\" length. The 8th bit has a value of\n * 0 indicating the length is \"short form\" and not \"long form\" and bits 7-1\n * give the length of the data. (The 8th bit is the left-most, most significant\n * bit: also known as big endian or network format).\n *\n * In the case that the length of the ASN.1 value is greater than 127, 2 to\n * 127 octets (bytes) are used to store the \"long form\" length. The first\n * byte's 8th bit is set to 1 to indicate the length is \"long form.\" Bits 7-1\n * give the number of additional octets. All following octets are in base 256\n * with the most significant digit first (typical big-endian binary unsigned\n * integer storage). So, for instance, if the length of a value was 257, the\n * first byte would be set to:\n *\n * 10000010 = 130 = 0x82.\n *\n * This indicates there are 2 octets (base 256) for the length. The second and\n * third bytes (the octets just mentioned) would store the length in base 256:\n *\n * octet 2: 00000001 = 1 * 256^1 = 256\n * octet 3: 00000001 = 1 * 256^0 = 1\n * total = 257\n *\n * The algorithm for converting a js integer value of 257 to base-256 is:\n *\n * var value = 257;\n * var bytes = [];\n * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first\n * bytes[1] = value & 0xFF;        // least significant byte last\n *\n * On the ASN.1 UNIVERSAL Object Identifier (OID) type:\n *\n * An OID can be written like: \"value1.value2.value3...valueN\"\n *\n * The DER encoding rules:\n *\n * The first byte has the value 40 * value1 + value2.\n * The following bytes, if any, encode the remaining values. Each value is\n * encoded in base 128, most significant digit first (big endian), with as\n * few digits as possible, and the most significant bit of each byte set\n * to 1 except the last in each value's encoding. For example: Given the\n * OID \"1.2.840.113549\", its DER encoding is (remember each byte except the\n * last one in each encoding is OR'd with 0x80):\n *\n * byte 1: 40 * 1 + 2 = 42 = 0x2A.\n * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648\n * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D\n *\n * The final value is: 0x2A864886F70D.\n * The full OID (including ASN.1 tag and length of 6 bytes) is:\n * 0x06062A864886F70D\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./oids */ \"(ssr)/./node_modules/node-forge/lib/oids.js\");\n/* ASN.1 API */ var asn1 = module.exports = forge.asn1 = forge.asn1 || {};\n/**\n * ASN.1 classes.\n */ asn1.Class = {\n    UNIVERSAL: 0x00,\n    APPLICATION: 0x40,\n    CONTEXT_SPECIFIC: 0x80,\n    PRIVATE: 0xC0\n};\n/**\n * ASN.1 types. Not all types are supported by this implementation, only\n * those necessary to implement a simple PKI are implemented.\n */ asn1.Type = {\n    NONE: 0,\n    BOOLEAN: 1,\n    INTEGER: 2,\n    BITSTRING: 3,\n    OCTETSTRING: 4,\n    NULL: 5,\n    OID: 6,\n    ODESC: 7,\n    EXTERNAL: 8,\n    REAL: 9,\n    ENUMERATED: 10,\n    EMBEDDED: 11,\n    UTF8: 12,\n    ROID: 13,\n    SEQUENCE: 16,\n    SET: 17,\n    PRINTABLESTRING: 19,\n    IA5STRING: 22,\n    UTCTIME: 23,\n    GENERALIZEDTIME: 24,\n    BMPSTRING: 30\n};\n/**\n * Creates a new asn1 object.\n *\n * @param tagClass the tag class for the object.\n * @param type the data type (tag number) for the object.\n * @param constructed true if the asn1 object is in constructed form.\n * @param value the value for the object, if it is not constructed.\n * @param [options] the options to use:\n *          [bitStringContents] the plain BIT STRING content including padding\n *            byte.\n *\n * @return the asn1 object.\n */ asn1.create = function(tagClass, type, constructed, value, options) {\n    /* An asn1 object has a tagClass, a type, a constructed flag, and a\n    value. The value's type depends on the constructed flag. If\n    constructed, it will contain a list of other asn1 objects. If not,\n    it will contain the ASN.1 value as an array of bytes formatted\n    according to the ASN.1 data type. */ // remove undefined values\n    if (forge.util.isArray(value)) {\n        var tmp = [];\n        for(var i = 0; i < value.length; ++i){\n            if (value[i] !== undefined) {\n                tmp.push(value[i]);\n            }\n        }\n        value = tmp;\n    }\n    var obj = {\n        tagClass: tagClass,\n        type: type,\n        constructed: constructed,\n        composed: constructed || forge.util.isArray(value),\n        value: value\n    };\n    if (options && \"bitStringContents\" in options) {\n        // TODO: copy byte buffer if it's a buffer not a string\n        obj.bitStringContents = options.bitStringContents;\n        // TODO: add readonly flag to avoid this overhead\n        // save copy to detect changes\n        obj.original = asn1.copy(obj);\n    }\n    return obj;\n};\n/**\n * Copies an asn1 object.\n *\n * @param obj the asn1 object.\n * @param [options] copy options:\n *          [excludeBitStringContents] true to not copy bitStringContents\n *\n * @return the a copy of the asn1 object.\n */ asn1.copy = function(obj, options) {\n    var copy;\n    if (forge.util.isArray(obj)) {\n        copy = [];\n        for(var i = 0; i < obj.length; ++i){\n            copy.push(asn1.copy(obj[i], options));\n        }\n        return copy;\n    }\n    if (typeof obj === \"string\") {\n        // TODO: copy byte buffer if it's a buffer not a string\n        return obj;\n    }\n    copy = {\n        tagClass: obj.tagClass,\n        type: obj.type,\n        constructed: obj.constructed,\n        composed: obj.composed,\n        value: asn1.copy(obj.value, options)\n    };\n    if (options && !options.excludeBitStringContents) {\n        // TODO: copy byte buffer if it's a buffer not a string\n        copy.bitStringContents = obj.bitStringContents;\n    }\n    return copy;\n};\n/**\n * Compares asn1 objects for equality.\n *\n * Note this function does not run in constant time.\n *\n * @param obj1 the first asn1 object.\n * @param obj2 the second asn1 object.\n * @param [options] compare options:\n *          [includeBitStringContents] true to compare bitStringContents\n *\n * @return true if the asn1 objects are equal.\n */ asn1.equals = function(obj1, obj2, options) {\n    if (forge.util.isArray(obj1)) {\n        if (!forge.util.isArray(obj2)) {\n            return false;\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for(var i = 0; i < obj1.length; ++i){\n            if (!asn1.equals(obj1[i], obj2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof obj1 !== typeof obj2) {\n        return false;\n    }\n    if (typeof obj1 === \"string\") {\n        return obj1 === obj2;\n    }\n    var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);\n    if (options && options.includeBitStringContents) {\n        equal = equal && obj1.bitStringContents === obj2.bitStringContents;\n    }\n    return equal;\n};\n/**\n * Gets the length of a BER-encoded ASN.1 value.\n *\n * In case the length is not specified, undefined is returned.\n *\n * @param b the BER-encoded ASN.1 byte buffer, starting with the first\n *          length byte.\n *\n * @return the length of the BER-encoded ASN.1 value or undefined.\n */ asn1.getBerValueLength = function(b) {\n    // TODO: move this function and related DER/BER functions to a der.js\n    // file; better abstract ASN.1 away from der/ber.\n    var b2 = b.getByte();\n    if (b2 === 0x80) {\n        return undefined;\n    }\n    // see if the length is \"short form\" or \"long form\" (bit 8 set)\n    var length;\n    var longForm = b2 & 0x80;\n    if (!longForm) {\n        // length is just the first byte\n        length = b2;\n    } else {\n        // the number of bytes the length is specified in bits 7 through 1\n        // and each length byte is in big-endian base-256\n        length = b.getInt((b2 & 0x7F) << 3);\n    }\n    return length;\n};\n/**\n * Check if the byte buffer has enough bytes. Throws an Error if not.\n *\n * @param bytes the byte buffer to parse from.\n * @param remaining the bytes remaining in the current parsing state.\n * @param n the number of bytes the buffer must have.\n */ function _checkBufferLength(bytes, remaining, n) {\n    if (n > remaining) {\n        var error = new Error(\"Too few bytes to parse DER.\");\n        error.available = bytes.length();\n        error.remaining = remaining;\n        error.requested = n;\n        throw error;\n    }\n}\n/**\n * Gets the length of a BER-encoded ASN.1 value.\n *\n * In case the length is not specified, undefined is returned.\n *\n * @param bytes the byte buffer to parse from.\n * @param remaining the bytes remaining in the current parsing state.\n *\n * @return the length of the BER-encoded ASN.1 value or undefined.\n */ var _getValueLength = function(bytes, remaining) {\n    // TODO: move this function and related DER/BER functions to a der.js\n    // file; better abstract ASN.1 away from der/ber.\n    // fromDer already checked that this byte exists\n    var b2 = bytes.getByte();\n    remaining--;\n    if (b2 === 0x80) {\n        return undefined;\n    }\n    // see if the length is \"short form\" or \"long form\" (bit 8 set)\n    var length;\n    var longForm = b2 & 0x80;\n    if (!longForm) {\n        // length is just the first byte\n        length = b2;\n    } else {\n        // the number of bytes the length is specified in bits 7 through 1\n        // and each length byte is in big-endian base-256\n        var longFormBytes = b2 & 0x7F;\n        _checkBufferLength(bytes, remaining, longFormBytes);\n        length = bytes.getInt(longFormBytes << 3);\n    }\n    // FIXME: this will only happen for 32 bit getInt with high bit set\n    if (length < 0) {\n        throw new Error(\"Negative length: \" + length);\n    }\n    return length;\n};\n/**\n * Parses an asn1 object from a byte buffer in DER format.\n *\n * @param bytes the byte buffer to parse from.\n * @param [strict] true to be strict when checking value lengths, false to\n *          allow truncated values (default: true).\n * @param [options] object with options or boolean strict flag\n *          [strict] true to be strict when checking value lengths, false to\n *            allow truncated values (default: true).\n *          [parseAllBytes] true to ensure all bytes are parsed\n *            (default: true)\n *          [decodeBitStrings] true to attempt to decode the content of\n *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that\n *            without schema support to understand the data context this can\n *            erroneously decode values that happen to be valid ASN.1. This\n *            flag will be deprecated or removed as soon as schema support is\n *            available. (default: true)\n *\n * @throws Will throw an error for various malformed input conditions.\n *\n * @return the parsed asn1 object.\n */ asn1.fromDer = function(bytes, options) {\n    if (options === undefined) {\n        options = {\n            strict: true,\n            parseAllBytes: true,\n            decodeBitStrings: true\n        };\n    }\n    if (typeof options === \"boolean\") {\n        options = {\n            strict: options,\n            parseAllBytes: true,\n            decodeBitStrings: true\n        };\n    }\n    if (!(\"strict\" in options)) {\n        options.strict = true;\n    }\n    if (!(\"parseAllBytes\" in options)) {\n        options.parseAllBytes = true;\n    }\n    if (!(\"decodeBitStrings\" in options)) {\n        options.decodeBitStrings = true;\n    }\n    // wrap in buffer if needed\n    if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n    }\n    var byteCount = bytes.length();\n    var value = _fromDer(bytes, bytes.length(), 0, options);\n    if (options.parseAllBytes && bytes.length() !== 0) {\n        var error = new Error(\"Unparsed DER bytes remain after ASN.1 parsing.\");\n        error.byteCount = byteCount;\n        error.remaining = bytes.length();\n        throw error;\n    }\n    return value;\n};\n/**\n * Internal function to parse an asn1 object from a byte buffer in DER format.\n *\n * @param bytes the byte buffer to parse from.\n * @param remaining the number of bytes remaining for this chunk.\n * @param depth the current parsing depth.\n * @param options object with same options as fromDer().\n *\n * @return the parsed asn1 object.\n */ function _fromDer(bytes, remaining, depth, options) {\n    // temporary storage for consumption calculations\n    var start;\n    // minimum length for ASN.1 DER structure is 2\n    _checkBufferLength(bytes, remaining, 2);\n    // get the first byte\n    var b1 = bytes.getByte();\n    // consumed one byte\n    remaining--;\n    // get the tag class\n    var tagClass = b1 & 0xC0;\n    // get the type (bits 1-5)\n    var type = b1 & 0x1F;\n    // get the variable value length and adjust remaining bytes\n    start = bytes.length();\n    var length = _getValueLength(bytes, remaining);\n    remaining -= start - bytes.length();\n    // ensure there are enough bytes to get the value\n    if (length !== undefined && length > remaining) {\n        if (options.strict) {\n            var error = new Error(\"Too few bytes to read ASN.1 value.\");\n            error.available = bytes.length();\n            error.remaining = remaining;\n            error.requested = length;\n            throw error;\n        }\n        // Note: be lenient with truncated values and use remaining state bytes\n        length = remaining;\n    }\n    // value storage\n    var value;\n    // possible BIT STRING contents storage\n    var bitStringContents;\n    // constructed flag is bit 6 (32 = 0x20) of the first byte\n    var constructed = (b1 & 0x20) === 0x20;\n    if (constructed) {\n        // parse child asn1 objects from the value\n        value = [];\n        if (length === undefined) {\n            // asn1 object of indefinite length, read until end tag\n            for(;;){\n                _checkBufferLength(bytes, remaining, 2);\n                if (bytes.bytes(2) === String.fromCharCode(0, 0)) {\n                    bytes.getBytes(2);\n                    remaining -= 2;\n                    break;\n                }\n                start = bytes.length();\n                value.push(_fromDer(bytes, remaining, depth + 1, options));\n                remaining -= start - bytes.length();\n            }\n        } else {\n            // parsing asn1 object of definite length\n            while(length > 0){\n                start = bytes.length();\n                value.push(_fromDer(bytes, length, depth + 1, options));\n                remaining -= start - bytes.length();\n                length -= start - bytes.length();\n            }\n        }\n    }\n    // if a BIT STRING, save the contents including padding\n    if (value === undefined && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {\n        bitStringContents = bytes.bytes(length);\n    }\n    // determine if a non-constructed value should be decoded as a composed\n    // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)\n    // can be used this way.\n    if (value === undefined && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here\n    // .. other parts of forge expect to decode OCTET STRINGs manually\n    type === asn1.Type.BITSTRING /*|| type === asn1.Type.OCTETSTRING*/  && length > 1) {\n        // save read position\n        var savedRead = bytes.read;\n        var savedRemaining = remaining;\n        var unused = 0;\n        if (type === asn1.Type.BITSTRING) {\n            /* The first octet gives the number of bits by which the length of the\n        bit string is less than the next multiple of eight (this is called\n        the \"number of unused bits\").\n\n        The second and following octets give the value of the bit string\n        converted to an octet string. */ _checkBufferLength(bytes, remaining, 1);\n            unused = bytes.getByte();\n            remaining--;\n        }\n        // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs\n        if (unused === 0) {\n            try {\n                // attempt to parse child asn1 object from the value\n                // (stored in array to signal composed value)\n                start = bytes.length();\n                var subOptions = {\n                    // enforce strict mode to avoid parsing ASN.1 from plain data\n                    strict: true,\n                    decodeBitStrings: true\n                };\n                var composed = _fromDer(bytes, remaining, depth + 1, subOptions);\n                var used = start - bytes.length();\n                remaining -= used;\n                if (type == asn1.Type.BITSTRING) {\n                    used++;\n                }\n                // if the data all decoded and the class indicates UNIVERSAL or\n                // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object\n                var tc = composed.tagClass;\n                if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {\n                    value = [\n                        composed\n                    ];\n                }\n            } catch (ex) {}\n        }\n        if (value === undefined) {\n            // restore read position\n            bytes.read = savedRead;\n            remaining = savedRemaining;\n        }\n    }\n    if (value === undefined) {\n        // asn1 not constructed or composed, get raw value\n        // TODO: do DER to OID conversion and vice-versa in .toDer?\n        if (length === undefined) {\n            if (options.strict) {\n                throw new Error(\"Non-constructed ASN.1 object of indefinite length.\");\n            }\n            // be lenient and use remaining state bytes\n            length = remaining;\n        }\n        if (type === asn1.Type.BMPSTRING) {\n            value = \"\";\n            for(; length > 0; length -= 2){\n                _checkBufferLength(bytes, remaining, 2);\n                value += String.fromCharCode(bytes.getInt16());\n                remaining -= 2;\n            }\n        } else {\n            value = bytes.getBytes(length);\n            remaining -= length;\n        }\n    }\n    // add BIT STRING contents if available\n    var asn1Options = bitStringContents === undefined ? null : {\n        bitStringContents: bitStringContents\n    };\n    // create and return asn1 object\n    return asn1.create(tagClass, type, constructed, value, asn1Options);\n}\n/**\n * Converts the given asn1 object to a buffer of bytes in DER format.\n *\n * @param asn1 the asn1 object to convert to bytes.\n *\n * @return the buffer of bytes.\n */ asn1.toDer = function(obj) {\n    var bytes = forge.util.createBuffer();\n    // build the first byte\n    var b1 = obj.tagClass | obj.type;\n    // for storing the ASN.1 value\n    var value = forge.util.createBuffer();\n    // use BIT STRING contents if available and data not changed\n    var useBitStringContents = false;\n    if (\"bitStringContents\" in obj) {\n        useBitStringContents = true;\n        if (obj.original) {\n            useBitStringContents = asn1.equals(obj, obj.original);\n        }\n    }\n    if (useBitStringContents) {\n        value.putBytes(obj.bitStringContents);\n    } else if (obj.composed) {\n        // if composed, use each child asn1 object's DER bytes as value\n        // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed\n        // from other asn1 objects\n        if (obj.constructed) {\n            b1 |= 0x20;\n        } else {\n            // type is a bit string, add unused bits of 0x00\n            value.putByte(0x00);\n        }\n        // add all of the child DER bytes together\n        for(var i = 0; i < obj.value.length; ++i){\n            if (obj.value[i] !== undefined) {\n                value.putBuffer(asn1.toDer(obj.value[i]));\n            }\n        }\n    } else {\n        // use asn1.value directly\n        if (obj.type === asn1.Type.BMPSTRING) {\n            for(var i = 0; i < obj.value.length; ++i){\n                value.putInt16(obj.value.charCodeAt(i));\n            }\n        } else {\n            // ensure integer is minimally-encoded\n            // TODO: should all leading bytes be stripped vs just one?\n            // .. ex '00 00 01' => '01'?\n            if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer\n            (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 0x80) === 0 || // leading 0xFF for negative integer\n            obj.value.charCodeAt(0) === 0xFF && (obj.value.charCodeAt(1) & 0x80) === 0x80)) {\n                value.putBytes(obj.value.substr(1));\n            } else {\n                value.putBytes(obj.value);\n            }\n        }\n    }\n    // add tag byte\n    bytes.putByte(b1);\n    // use \"short form\" encoding\n    if (value.length() <= 127) {\n        // one byte describes the length\n        // bit 8 = 0 and bits 7-1 = length\n        bytes.putByte(value.length() & 0x7F);\n    } else {\n        // use \"long form\" encoding\n        // 2 to 127 bytes describe the length\n        // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes\n        // other bytes: length in base 256, big-endian\n        var len = value.length();\n        var lenBytes = \"\";\n        do {\n            lenBytes += String.fromCharCode(len & 0xFF);\n            len = len >>> 8;\n        }while (len > 0);\n        // set first byte to # bytes used to store the length and turn on\n        // bit 8 to indicate long-form length is used\n        bytes.putByte(lenBytes.length | 0x80);\n        // concatenate length bytes in reverse since they were generated\n        // little endian and we need big endian\n        for(var i = lenBytes.length - 1; i >= 0; --i){\n            bytes.putByte(lenBytes.charCodeAt(i));\n        }\n    }\n    // concatenate value bytes\n    bytes.putBuffer(value);\n    return bytes;\n};\n/**\n * Converts an OID dot-separated string to a byte buffer. The byte buffer\n * contains only the DER-encoded value, not any tag or length bytes.\n *\n * @param oid the OID dot-separated string.\n *\n * @return the byte buffer.\n */ asn1.oidToDer = function(oid) {\n    // split OID into individual values\n    var values = oid.split(\".\");\n    var bytes = forge.util.createBuffer();\n    // first byte is 40 * value1 + value2\n    bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));\n    // other bytes are each value in base 128 with 8th bit set except for\n    // the last byte for each value\n    var last, valueBytes, value, b;\n    for(var i = 2; i < values.length; ++i){\n        // produce value bytes in reverse because we don't know how many\n        // bytes it will take to store the value\n        last = true;\n        valueBytes = [];\n        value = parseInt(values[i], 10);\n        do {\n            b = value & 0x7F;\n            value = value >>> 7;\n            // if value is not last, then turn on 8th bit\n            if (!last) {\n                b |= 0x80;\n            }\n            valueBytes.push(b);\n            last = false;\n        }while (value > 0);\n        // add value bytes in reverse (needs to be in big endian)\n        for(var n = valueBytes.length - 1; n >= 0; --n){\n            bytes.putByte(valueBytes[n]);\n        }\n    }\n    return bytes;\n};\n/**\n * Converts a DER-encoded byte buffer to an OID dot-separated string. The\n * byte buffer should contain only the DER-encoded value, not any tag or\n * length bytes.\n *\n * @param bytes the byte buffer.\n *\n * @return the OID dot-separated string.\n */ asn1.derToOid = function(bytes) {\n    var oid;\n    // wrap in buffer if needed\n    if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n    }\n    // first byte is 40 * value1 + value2\n    var b = bytes.getByte();\n    oid = Math.floor(b / 40) + \".\" + b % 40;\n    // other bytes are each value in base 128 with 8th bit set except for\n    // the last byte for each value\n    var value = 0;\n    while(bytes.length() > 0){\n        b = bytes.getByte();\n        value = value << 7;\n        // not the last byte for the value\n        if (b & 0x80) {\n            value += b & 0x7F;\n        } else {\n            // last byte\n            oid += \".\" + (value + b);\n            value = 0;\n        }\n    }\n    return oid;\n};\n/**\n * Converts a UTCTime value to a date.\n *\n * Note: GeneralizedTime has 4 digits for the year and is used for X.509\n * dates past 2049. Parsing that structure hasn't been implemented yet.\n *\n * @param utc the UTCTime value to convert.\n *\n * @return the date.\n */ asn1.utcTimeToDate = function(utc) {\n    /* The following formats can be used:\n\n    YYMMDDhhmmZ\n    YYMMDDhhmm+hh'mm'\n    YYMMDDhhmm-hh'mm'\n    YYMMDDhhmmssZ\n    YYMMDDhhmmss+hh'mm'\n    YYMMDDhhmmss-hh'mm'\n\n    Where:\n\n    YY is the least significant two digits of the year\n    MM is the month (01 to 12)\n    DD is the day (01 to 31)\n    hh is the hour (00 to 23)\n    mm are the minutes (00 to 59)\n    ss are the seconds (00 to 59)\n    Z indicates that local time is GMT, + indicates that local time is\n    later than GMT, and - indicates that local time is earlier than GMT\n    hh' is the absolute value of the offset from GMT in hours\n    mm' is the absolute value of the offset from GMT in minutes */ var date = new Date();\n    // if YY >= 50 use 19xx, if YY < 50 use 20xx\n    var year = parseInt(utc.substr(0, 2), 10);\n    year = year >= 50 ? 1900 + year : 2000 + year;\n    var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month\n    var DD = parseInt(utc.substr(4, 2), 10);\n    var hh = parseInt(utc.substr(6, 2), 10);\n    var mm = parseInt(utc.substr(8, 2), 10);\n    var ss = 0;\n    // not just YYMMDDhhmmZ\n    if (utc.length > 11) {\n        // get character after minutes\n        var c = utc.charAt(10);\n        var end = 10;\n        // see if seconds are present\n        if (c !== \"+\" && c !== \"-\") {\n            // get seconds\n            ss = parseInt(utc.substr(10, 2), 10);\n            end += 2;\n        }\n    }\n    // update date\n    date.setUTCFullYear(year, MM, DD);\n    date.setUTCHours(hh, mm, ss, 0);\n    if (end) {\n        // get +/- after end of time\n        c = utc.charAt(end);\n        if (c === \"+\" || c === \"-\") {\n            // get hours+minutes offset\n            var hhoffset = parseInt(utc.substr(end + 1, 2), 10);\n            var mmoffset = parseInt(utc.substr(end + 4, 2), 10);\n            // calculate offset in milliseconds\n            var offset = hhoffset * 60 + mmoffset;\n            offset *= 60000;\n            // apply offset\n            if (c === \"+\") {\n                date.setTime(+date - offset);\n            } else {\n                date.setTime(+date + offset);\n            }\n        }\n    }\n    return date;\n};\n/**\n * Converts a GeneralizedTime value to a date.\n *\n * @param gentime the GeneralizedTime value to convert.\n *\n * @return the date.\n */ asn1.generalizedTimeToDate = function(gentime) {\n    /* The following formats can be used:\n\n    YYYYMMDDHHMMSS\n    YYYYMMDDHHMMSS.fff\n    YYYYMMDDHHMMSSZ\n    YYYYMMDDHHMMSS.fffZ\n    YYYYMMDDHHMMSS+hh'mm'\n    YYYYMMDDHHMMSS.fff+hh'mm'\n    YYYYMMDDHHMMSS-hh'mm'\n    YYYYMMDDHHMMSS.fff-hh'mm'\n\n    Where:\n\n    YYYY is the year\n    MM is the month (01 to 12)\n    DD is the day (01 to 31)\n    hh is the hour (00 to 23)\n    mm are the minutes (00 to 59)\n    ss are the seconds (00 to 59)\n    .fff is the second fraction, accurate to three decimal places\n    Z indicates that local time is GMT, + indicates that local time is\n    later than GMT, and - indicates that local time is earlier than GMT\n    hh' is the absolute value of the offset from GMT in hours\n    mm' is the absolute value of the offset from GMT in minutes */ var date = new Date();\n    var YYYY = parseInt(gentime.substr(0, 4), 10);\n    var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month\n    var DD = parseInt(gentime.substr(6, 2), 10);\n    var hh = parseInt(gentime.substr(8, 2), 10);\n    var mm = parseInt(gentime.substr(10, 2), 10);\n    var ss = parseInt(gentime.substr(12, 2), 10);\n    var fff = 0;\n    var offset = 0;\n    var isUTC = false;\n    if (gentime.charAt(gentime.length - 1) === \"Z\") {\n        isUTC = true;\n    }\n    var end = gentime.length - 5, c = gentime.charAt(end);\n    if (c === \"+\" || c === \"-\") {\n        // get hours+minutes offset\n        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);\n        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);\n        // calculate offset in milliseconds\n        offset = hhoffset * 60 + mmoffset;\n        offset *= 60000;\n        // apply offset\n        if (c === \"+\") {\n            offset *= -1;\n        }\n        isUTC = true;\n    }\n    // check for second fraction\n    if (gentime.charAt(14) === \".\") {\n        fff = parseFloat(gentime.substr(14), 10) * 1000;\n    }\n    if (isUTC) {\n        date.setUTCFullYear(YYYY, MM, DD);\n        date.setUTCHours(hh, mm, ss, fff);\n        // apply offset\n        date.setTime(+date + offset);\n    } else {\n        date.setFullYear(YYYY, MM, DD);\n        date.setHours(hh, mm, ss, fff);\n    }\n    return date;\n};\n/**\n * Converts a date to a UTCTime value.\n *\n * Note: GeneralizedTime has 4 digits for the year and is used for X.509\n * dates past 2049. Converting to a GeneralizedTime hasn't been\n * implemented yet.\n *\n * @param date the date to convert.\n *\n * @return the UTCTime value.\n */ asn1.dateToUtcTime = function(date) {\n    // TODO: validate; currently assumes proper format\n    if (typeof date === \"string\") {\n        return date;\n    }\n    var rval = \"\";\n    // create format YYMMDDhhmmssZ\n    var format = [];\n    format.push((\"\" + date.getUTCFullYear()).substr(2));\n    format.push(\"\" + (date.getUTCMonth() + 1));\n    format.push(\"\" + date.getUTCDate());\n    format.push(\"\" + date.getUTCHours());\n    format.push(\"\" + date.getUTCMinutes());\n    format.push(\"\" + date.getUTCSeconds());\n    // ensure 2 digits are used for each format entry\n    for(var i = 0; i < format.length; ++i){\n        if (format[i].length < 2) {\n            rval += \"0\";\n        }\n        rval += format[i];\n    }\n    rval += \"Z\";\n    return rval;\n};\n/**\n * Converts a date to a GeneralizedTime value.\n *\n * @param date the date to convert.\n *\n * @return the GeneralizedTime value as a string.\n */ asn1.dateToGeneralizedTime = function(date) {\n    // TODO: validate; currently assumes proper format\n    if (typeof date === \"string\") {\n        return date;\n    }\n    var rval = \"\";\n    // create format YYYYMMDDHHMMSSZ\n    var format = [];\n    format.push(\"\" + date.getUTCFullYear());\n    format.push(\"\" + (date.getUTCMonth() + 1));\n    format.push(\"\" + date.getUTCDate());\n    format.push(\"\" + date.getUTCHours());\n    format.push(\"\" + date.getUTCMinutes());\n    format.push(\"\" + date.getUTCSeconds());\n    // ensure 2 digits are used for each format entry\n    for(var i = 0; i < format.length; ++i){\n        if (format[i].length < 2) {\n            rval += \"0\";\n        }\n        rval += format[i];\n    }\n    rval += \"Z\";\n    return rval;\n};\n/**\n * Converts a javascript integer to a DER-encoded byte buffer to be used\n * as the value for an INTEGER type.\n *\n * @param x the integer.\n *\n * @return the byte buffer.\n */ asn1.integerToDer = function(x) {\n    var rval = forge.util.createBuffer();\n    if (x >= -0x80 && x < 0x80) {\n        return rval.putSignedInt(x, 8);\n    }\n    if (x >= -0x8000 && x < 0x8000) {\n        return rval.putSignedInt(x, 16);\n    }\n    if (x >= -0x800000 && x < 0x800000) {\n        return rval.putSignedInt(x, 24);\n    }\n    if (x >= -0x80000000 && x < 0x80000000) {\n        return rval.putSignedInt(x, 32);\n    }\n    var error = new Error(\"Integer too large; max is 32-bits.\");\n    error.integer = x;\n    throw error;\n};\n/**\n * Converts a DER-encoded byte buffer to a javascript integer. This is\n * typically used to decode the value of an INTEGER type.\n *\n * @param bytes the byte buffer.\n *\n * @return the integer.\n */ asn1.derToInteger = function(bytes) {\n    // wrap in buffer if needed\n    if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n    }\n    var n = bytes.length() * 8;\n    if (n > 32) {\n        throw new Error(\"Integer too large; max is 32-bits.\");\n    }\n    return bytes.getSignedInt(n);\n};\n/**\n * Validates that the given ASN.1 object is at least a super set of the\n * given ASN.1 structure. Only tag classes and types are checked. An\n * optional map may also be provided to capture ASN.1 values while the\n * structure is checked.\n *\n * To capture an ASN.1 value, set an object in the validator's 'capture'\n * parameter to the key to use in the capture map. To capture the full\n * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including\n * the leading unused bits counter byte, specify 'captureBitStringContents'.\n * To capture BIT STRING bytes, without the leading unused bits counter byte,\n * specify 'captureBitStringValue'.\n *\n * Objects in the validator may set a field 'optional' to true to indicate\n * that it isn't necessary to pass validation.\n *\n * @param obj the ASN.1 object to validate.\n * @param v the ASN.1 structure validator.\n * @param capture an optional map to capture values in.\n * @param errors an optional array for storing validation errors.\n *\n * @return true on success, false on failure.\n */ asn1.validate = function(obj, v, capture, errors) {\n    var rval = false;\n    // ensure tag class and type are the same if specified\n    if ((obj.tagClass === v.tagClass || typeof v.tagClass === \"undefined\") && (obj.type === v.type || typeof v.type === \"undefined\")) {\n        // ensure constructed flag is the same if specified\n        if (obj.constructed === v.constructed || typeof v.constructed === \"undefined\") {\n            rval = true;\n            // handle sub values\n            if (v.value && forge.util.isArray(v.value)) {\n                var j = 0;\n                for(var i = 0; rval && i < v.value.length; ++i){\n                    rval = v.value[i].optional || false;\n                    if (obj.value[j]) {\n                        rval = asn1.validate(obj.value[j], v.value[i], capture, errors);\n                        if (rval) {\n                            ++j;\n                        } else if (v.value[i].optional) {\n                            rval = true;\n                        }\n                    }\n                    if (!rval && errors) {\n                        errors.push(\"[\" + v.name + \"] \" + 'Tag class \"' + v.tagClass + '\", type \"' + v.type + '\" expected value length \"' + v.value.length + '\", got \"' + obj.value.length + '\"');\n                    }\n                }\n            }\n            if (rval && capture) {\n                if (v.capture) {\n                    capture[v.capture] = obj.value;\n                }\n                if (v.captureAsn1) {\n                    capture[v.captureAsn1] = obj;\n                }\n                if (v.captureBitStringContents && \"bitStringContents\" in obj) {\n                    capture[v.captureBitStringContents] = obj.bitStringContents;\n                }\n                if (v.captureBitStringValue && \"bitStringContents\" in obj) {\n                    var value;\n                    if (obj.bitStringContents.length < 2) {\n                        capture[v.captureBitStringValue] = \"\";\n                    } else {\n                        // FIXME: support unused bits with data shifting\n                        var unused = obj.bitStringContents.charCodeAt(0);\n                        if (unused !== 0) {\n                            throw new Error(\"captureBitStringValue only supported for zero unused bits\");\n                        }\n                        capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);\n                    }\n                }\n            }\n        } else if (errors) {\n            errors.push(\"[\" + v.name + \"] \" + 'Expected constructed \"' + v.constructed + '\", got \"' + obj.constructed + '\"');\n        }\n    } else if (errors) {\n        if (obj.tagClass !== v.tagClass) {\n            errors.push(\"[\" + v.name + \"] \" + 'Expected tag class \"' + v.tagClass + '\", got \"' + obj.tagClass + '\"');\n        }\n        if (obj.type !== v.type) {\n            errors.push(\"[\" + v.name + \"] \" + 'Expected type \"' + v.type + '\", got \"' + obj.type + '\"');\n        }\n    }\n    return rval;\n};\n// regex for testing for non-latin characters\nvar _nonLatinRegex = /[^\\\\u0000-\\\\u00ff]/;\n/**\n * Pretty prints an ASN.1 object to a string.\n *\n * @param obj the object to write out.\n * @param level the level in the tree.\n * @param indentation the indentation to use.\n *\n * @return the string.\n */ asn1.prettyPrint = function(obj, level, indentation) {\n    var rval = \"\";\n    // set default level and indentation\n    level = level || 0;\n    indentation = indentation || 2;\n    // start new line for deep levels\n    if (level > 0) {\n        rval += \"\\n\";\n    }\n    // create indent\n    var indent = \"\";\n    for(var i = 0; i < level * indentation; ++i){\n        indent += \" \";\n    }\n    // print class:type\n    rval += indent + \"Tag: \";\n    switch(obj.tagClass){\n        case asn1.Class.UNIVERSAL:\n            rval += \"Universal:\";\n            break;\n        case asn1.Class.APPLICATION:\n            rval += \"Application:\";\n            break;\n        case asn1.Class.CONTEXT_SPECIFIC:\n            rval += \"Context-Specific:\";\n            break;\n        case asn1.Class.PRIVATE:\n            rval += \"Private:\";\n            break;\n    }\n    if (obj.tagClass === asn1.Class.UNIVERSAL) {\n        rval += obj.type;\n        // known types\n        switch(obj.type){\n            case asn1.Type.NONE:\n                rval += \" (None)\";\n                break;\n            case asn1.Type.BOOLEAN:\n                rval += \" (Boolean)\";\n                break;\n            case asn1.Type.INTEGER:\n                rval += \" (Integer)\";\n                break;\n            case asn1.Type.BITSTRING:\n                rval += \" (Bit string)\";\n                break;\n            case asn1.Type.OCTETSTRING:\n                rval += \" (Octet string)\";\n                break;\n            case asn1.Type.NULL:\n                rval += \" (Null)\";\n                break;\n            case asn1.Type.OID:\n                rval += \" (Object Identifier)\";\n                break;\n            case asn1.Type.ODESC:\n                rval += \" (Object Descriptor)\";\n                break;\n            case asn1.Type.EXTERNAL:\n                rval += \" (External or Instance of)\";\n                break;\n            case asn1.Type.REAL:\n                rval += \" (Real)\";\n                break;\n            case asn1.Type.ENUMERATED:\n                rval += \" (Enumerated)\";\n                break;\n            case asn1.Type.EMBEDDED:\n                rval += \" (Embedded PDV)\";\n                break;\n            case asn1.Type.UTF8:\n                rval += \" (UTF8)\";\n                break;\n            case asn1.Type.ROID:\n                rval += \" (Relative Object Identifier)\";\n                break;\n            case asn1.Type.SEQUENCE:\n                rval += \" (Sequence)\";\n                break;\n            case asn1.Type.SET:\n                rval += \" (Set)\";\n                break;\n            case asn1.Type.PRINTABLESTRING:\n                rval += \" (Printable String)\";\n                break;\n            case asn1.Type.IA5String:\n                rval += \" (IA5String (ASCII))\";\n                break;\n            case asn1.Type.UTCTIME:\n                rval += \" (UTC time)\";\n                break;\n            case asn1.Type.GENERALIZEDTIME:\n                rval += \" (Generalized time)\";\n                break;\n            case asn1.Type.BMPSTRING:\n                rval += \" (BMP String)\";\n                break;\n        }\n    } else {\n        rval += obj.type;\n    }\n    rval += \"\\n\";\n    rval += indent + \"Constructed: \" + obj.constructed + \"\\n\";\n    if (obj.composed) {\n        var subvalues = 0;\n        var sub = \"\";\n        for(var i = 0; i < obj.value.length; ++i){\n            if (obj.value[i] !== undefined) {\n                subvalues += 1;\n                sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);\n                if (i + 1 < obj.value.length) {\n                    sub += \",\";\n                }\n            }\n        }\n        rval += indent + \"Sub values: \" + subvalues + sub;\n    } else {\n        rval += indent + \"Value: \";\n        if (obj.type === asn1.Type.OID) {\n            var oid = asn1.derToOid(obj.value);\n            rval += oid;\n            if (forge.pki && forge.pki.oids) {\n                if (oid in forge.pki.oids) {\n                    rval += \" (\" + forge.pki.oids[oid] + \") \";\n                }\n            }\n        }\n        if (obj.type === asn1.Type.INTEGER) {\n            try {\n                rval += asn1.derToInteger(obj.value);\n            } catch (ex) {\n                rval += \"0x\" + forge.util.bytesToHex(obj.value);\n            }\n        } else if (obj.type === asn1.Type.BITSTRING) {\n            // TODO: shift bits as needed to display without padding\n            if (obj.value.length > 1) {\n                // remove unused bits field\n                rval += \"0x\" + forge.util.bytesToHex(obj.value.slice(1));\n            } else {\n                rval += \"(none)\";\n            }\n            // show unused bit count\n            if (obj.value.length > 0) {\n                var unused = obj.value.charCodeAt(0);\n                if (unused == 1) {\n                    rval += \" (1 unused bit shown)\";\n                } else if (unused > 1) {\n                    rval += \" (\" + unused + \" unused bits shown)\";\n                }\n            }\n        } else if (obj.type === asn1.Type.OCTETSTRING) {\n            if (!_nonLatinRegex.test(obj.value)) {\n                rval += \"(\" + obj.value + \") \";\n            }\n            rval += \"0x\" + forge.util.bytesToHex(obj.value);\n        } else if (obj.type === asn1.Type.UTF8) {\n            try {\n                rval += forge.util.decodeUtf8(obj.value);\n            } catch (e) {\n                if (e.message === \"URI malformed\") {\n                    rval += \"0x\" + forge.util.bytesToHex(obj.value) + \" (malformed UTF8)\";\n                } else {\n                    throw e;\n                }\n            }\n        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {\n            rval += obj.value;\n        } else if (_nonLatinRegex.test(obj.value)) {\n            rval += \"0x\" + forge.util.bytesToHex(obj.value);\n        } else if (obj.value.length === 0) {\n            rval += \"[null]\";\n        } else {\n            rval += obj.value;\n        }\n    }\n    return rval;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzSUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixhQUFhLEdBQ2IsSUFBSUMsT0FBT0MsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxJQUFJLEdBQUdGLE1BQU1FLElBQUksSUFBSSxDQUFDO0FBRXhEOztDQUVDLEdBQ0RBLEtBQUtHLEtBQUssR0FBRztJQUNYQyxXQUFrQjtJQUNsQkMsYUFBa0I7SUFDbEJDLGtCQUFrQjtJQUNsQkMsU0FBa0I7QUFDcEI7QUFFQTs7O0NBR0MsR0FDRFAsS0FBS1EsSUFBSSxHQUFHO0lBQ1ZDLE1BQWtCO0lBQ2xCQyxTQUFrQjtJQUNsQkMsU0FBa0I7SUFDbEJDLFdBQWtCO0lBQ2xCQyxhQUFrQjtJQUNsQkMsTUFBa0I7SUFDbEJDLEtBQWtCO0lBQ2xCQyxPQUFrQjtJQUNsQkMsVUFBa0I7SUFDbEJDLE1BQWtCO0lBQ2xCQyxZQUFpQjtJQUNqQkMsVUFBaUI7SUFDakJDLE1BQWlCO0lBQ2pCQyxNQUFpQjtJQUNqQkMsVUFBaUI7SUFDakJDLEtBQWlCO0lBQ2pCQyxpQkFBaUI7SUFDakJDLFdBQWlCO0lBQ2pCQyxTQUFpQjtJQUNqQkMsaUJBQWlCO0lBQ2pCQyxXQUFpQjtBQUNuQjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEN0IsS0FBSzhCLE1BQU0sR0FBRyxTQUFTQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxLQUFLLEVBQUVDLE9BQU87SUFDaEU7Ozs7c0NBSW9DLEdBRXBDLDBC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R1MsSUFBSVgsSUFBSSxLQUFLaEMsS0FBS1EsSUFBSSxDQUFDYSxJQUFJLEVBQUU7WUFDckMsSUFBSTtnQkFDRndILFFBQVEvSSxNQUFNc0MsSUFBSSxDQUFDK0ksVUFBVSxDQUFDeEksSUFBSVQsS0FBSztZQUN6QyxFQUFFLE9BQU1rSixHQUFHO2dCQUNULElBQUdBLEVBQUVDLE9BQU8sS0FBSyxpQkFBaUI7b0JBQ2hDeEMsUUFDRSxPQUFPL0ksTUFBTXNDLElBQUksQ0FBQzZJLFVBQVUsQ0FBQ3RJLElBQUlULEtBQUssSUFBSTtnQkFDOUMsT0FBTztvQkFDTCxNQUFNa0o7Z0JBQ1I7WUFDRjtRQUNGLE9BQU8sSUFBR3pJLElBQUlYLElBQUksS0FBS2hDLEtBQUtRLElBQUksQ0FBQ2lCLGVBQWUsSUFDOUNrQixJQUFJWCxJQUFJLEtBQUtoQyxLQUFLUSxJQUFJLENBQUNvSyxTQUFTLEVBQUU7WUFDbEMvQixRQUFRbEcsSUFBSVQsS0FBSztRQUNuQixPQUFPLElBQUdxSSxlQUFlVyxJQUFJLENBQUN2SSxJQUFJVCxLQUFLLEdBQUc7WUFDeEMyRyxRQUFRLE9BQU8vSSxNQUFNc0MsSUFBSSxDQUFDNkksVUFBVSxDQUFDdEksSUFBSVQsS0FBSztRQUNoRCxPQUFPLElBQUdTLElBQUlULEtBQUssQ0FBQ00sTUFBTSxLQUFLLEdBQUc7WUFDaENxRyxRQUFRO1FBQ1YsT0FBTztZQUNMQSxRQUFRbEcsSUFBSVQsS0FBSztRQUNuQjtJQUNGO0lBRUEsT0FBTzJHO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hc24xLmpzPzhhMWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9vaWRzJyk7XG5cbi8qIEFTTi4xIEFQSSAqL1xudmFyIGFzbjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmFzbjEgPSBmb3JnZS5hc24xIHx8IHt9O1xuXG4vKipcbiAqIEFTTi4xIGNsYXNzZXMuXG4gKi9cbmFzbjEuQ2xhc3MgPSB7XG4gIFVOSVZFUlNBTDogICAgICAgIDB4MDAsXG4gIEFQUExJQ0FUSU9OOiAgICAgIDB4NDAsXG4gIENPTlRFWFRfU1BFQ0lGSUM6IDB4ODAsXG4gIFBSSVZBVEU6ICAgICAgICAgIDB4QzBcbn07XG5cbi8qKlxuICogQVNOLjEgdHlwZXMuIE5vdCBhbGwgdHlwZXMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uLCBvbmx5XG4gKiB0aG9zZSBuZWNlc3NhcnkgdG8gaW1wbGVtZW50IGEgc2ltcGxlIFBLSSBhcmUgaW1wbGVtZW50ZWQuXG4gKi9cbmFzbjEuVHlwZSA9IHtcbiAgTk9ORTogICAgICAgICAgICAgMCxcbiAgQk9PTEVBTjogICAgICAgICAgMSxcbiAgSU5URUdFUjogICAgICAgICAgMixcbiAgQklUU1RSSU5HOiAgICAgICAgMyxcbiAgT0NURVRTVFJJTkc6ICAgICAgNCxcbiAgTlVMTDogICAgICAgICAgICAgNSxcbiAgT0lEOiAgICAgICAgICAgICAgNixcbiAgT0RFU0M6ICAgICAgICAgICAgNyxcbiAgRVhURVJOQUw6ICAgICAgICAgOCxcbiAgUkVBTDogICAgICAgICAgICAgOSxcbiAgRU5VTUVSQVRFRDogICAgICAxMCxcbiAgRU1CRURERUQ6ICAgICAgICAxMSxcbiAgVVRGODogICAgICAgICAgICAxMixcbiAgUk9JRDogICAgICAgICAgICAxMyxcbiAgU0VRVUVOQ0U6ICAgICAgICAxNixcbiAgU0VUOiAgICAgICAgICAgICAxNyxcbiAgUFJJTlRBQkxFU1RSSU5HOiAxOSxcbiAgSUE1U1RSSU5HOiAgICAgICAyMixcbiAgVVRDVElNRTogICAgICAgICAyMyxcbiAgR0VORVJBTElaRURUSU1FOiAyNCxcbiAgQk1QU1RSSU5HOiAgICAgICAzMFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFzbjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0YWdDbGFzcyB0aGUgdGFnIGNsYXNzIGZvciB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHR5cGUgdGhlIGRhdGEgdHlwZSAodGFnIG51bWJlcikgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gY29uc3RydWN0ZWQgdHJ1ZSBpZiB0aGUgYXNuMSBvYmplY3QgaXMgaW4gY29uc3RydWN0ZWQgZm9ybS5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgZm9yIHRoZSBvYmplY3QsIGlmIGl0IGlzIG5vdCBjb25zdHJ1Y3RlZC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2JpdFN0cmluZ0NvbnRlbnRzXSB0aGUgcGxhaW4gQklUIFNUUklORyBjb250ZW50IGluY2x1ZGluZyBwYWRkaW5nXG4gKiAgICAgICAgICAgIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuY3JlYXRlID0gZnVuY3Rpb24odGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvKiBBbiBhc24xIG9iamVjdCBoYXMgYSB0YWdDbGFzcywgYSB0eXBlLCBhIGNvbnN0cnVjdGVkIGZsYWcsIGFuZCBhXG4gICAgdmFsdWUuIFRoZSB2YWx1ZSdzIHR5cGUgZGVwZW5kcyBvbiB0aGUgY29uc3RydWN0ZWQgZmxhZy4gSWZcbiAgICBjb25zdHJ1Y3RlZCwgaXQgd2lsbCBjb250YWluIGEgbGlzdCBvZiBvdGhlciBhc24xIG9iamVjdHMuIElmIG5vdCxcbiAgICBpdCB3aWxsIGNvbnRhaW4gdGhlIEFTTi4xIHZhbHVlIGFzIGFuIGFycmF5IG9mIGJ5dGVzIGZvcm1hdHRlZFxuICAgIGFjY29yZGluZyB0byB0aGUgQVNOLjEgZGF0YSB0eXBlLiAqL1xuXG4gIC8vIHJlbW92ZSB1bmRlZmluZWQgdmFsdWVzXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZih2YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRtcC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB0bXA7XG4gIH1cblxuICB2YXIgb2JqID0ge1xuICAgIHRhZ0NsYXNzOiB0YWdDbGFzcyxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBjb25zdHJ1Y3RlZCxcbiAgICBjb21wb3NlZDogY29uc3RydWN0ZWQgfHwgZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgb2JqLmJpdFN0cmluZ0NvbnRlbnRzID0gb3B0aW9ucy5iaXRTdHJpbmdDb250ZW50cztcbiAgICAvLyBUT0RPOiBhZGQgcmVhZG9ubHkgZmxhZyB0byBhdm9pZCB0aGlzIG92ZXJoZWFkXG4gICAgLy8gc2F2ZSBjb3B5IHRvIGRldGVjdCBjaGFuZ2VzXG4gICAgb2JqLm9yaWdpbmFsID0gYXNuMS5jb3B5KG9iaik7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ29waWVzIGFuIGFzbjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIFtvcHRpb25zXSBjb3B5IG9wdGlvbnM6XG4gKiAgICAgICAgICBbZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzXSB0cnVlIHRvIG5vdCBjb3B5IGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0aGUgYSBjb3B5IG9mIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jb3B5ID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gIHZhciBjb3B5O1xuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShvYmopKSB7XG4gICAgY29weSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvcHkucHVzaChhc24xLmNvcHkob2JqW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgaWYodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGNvcHkgPSB7XG4gICAgdGFnQ2xhc3M6IG9iai50YWdDbGFzcyxcbiAgICB0eXBlOiBvYmoudHlwZSxcbiAgICBjb25zdHJ1Y3RlZDogb2JqLmNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBvYmouY29tcG9zZWQsXG4gICAgdmFsdWU6IGFzbjEuY29weShvYmoudmFsdWUsIG9wdGlvbnMpXG4gIH07XG4gIGlmKG9wdGlvbnMgJiYgIW9wdGlvbnMuZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgLy8gVE9ETzogY29weSBieXRlIGJ1ZmZlciBpZiBpdCdzIGEgYnVmZmVyIG5vdCBhIHN0cmluZ1xuICAgIGNvcHkuYml0U3RyaW5nQ29udGVudHMgPSBvYmouYml0U3RyaW5nQ29udGVudHM7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIGFzbjEgb2JqZWN0cyBmb3IgZXF1YWxpdHkuXG4gKlxuICogTm90ZSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJ1biBpbiBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSBvYmoxIHRoZSBmaXJzdCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBvYmoyIHRoZSBzZWNvbmQgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvbXBhcmUgb3B0aW9uczpcbiAqICAgICAgICAgIFtpbmNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gY29tcGFyZSBiaXRTdHJpbmdDb250ZW50c1xuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYXNuMSBvYmplY3RzIGFyZSBlcXVhbC5cbiAqL1xuYXNuMS5lcXVhbHMgPSBmdW5jdGlvbihvYmoxLCBvYmoyLCBvcHRpb25zKSB7XG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShvYmoxKSkge1xuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkob2JqMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZighYXNuMS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmoxICE9PSB0eXBlb2Ygb2JqMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmoxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICB9XG5cbiAgdmFyIGVxdWFsID0gb2JqMS50YWdDbGFzcyA9PT0gb2JqMi50YWdDbGFzcyAmJlxuICAgIG9iajEudHlwZSA9PT0gb2JqMi50eXBlICYmXG4gICAgb2JqMS5jb25zdHJ1Y3RlZCA9PT0gb2JqMi5jb25zdHJ1Y3RlZCAmJlxuICAgIG9iajEuY29tcG9zZWQgPT09IG9iajIuY29tcG9zZWQgJiZcbiAgICBhc24xLmVxdWFscyhvYmoxLnZhbHVlLCBvYmoyLnZhbHVlKTtcbiAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVCaXRTdHJpbmdDb250ZW50cykge1xuICAgIGVxdWFsID0gZXF1YWwgJiYgKG9iajEuYml0U3RyaW5nQ29udGVudHMgPT09IG9iajIuYml0U3RyaW5nQ29udGVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGVxdWFsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsZW5ndGggb2YgYSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZS5cbiAqXG4gKiBJbiBjYXNlIHRoZSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBCRVItZW5jb2RlZCBBU04uMSBieXRlIGJ1ZmZlciwgc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3RcbiAqICAgICAgICAgIGxlbmd0aCBieXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICovXG5hc24xLmdldEJlclZhbHVlTGVuZ3RoID0gZnVuY3Rpb24oYikge1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIHJlbGF0ZWQgREVSL0JFUiBmdW5jdGlvbnMgdG8gYSBkZXIuanNcbiAgLy8gZmlsZTsgYmV0dGVyIGFic3RyYWN0IEFTTi4xIGF3YXkgZnJvbSBkZXIvYmVyLlxuICB2YXIgYjIgPSBiLmdldEJ5dGUoKTtcbiAgaWYoYjIgPT09IDB4ODApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2VlIGlmIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgb3IgXCJsb25nIGZvcm1cIiAoYml0IDggc2V0KVxuICB2YXIgbGVuZ3RoO1xuICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDB4ODA7XG4gIGlmKCFsb25nRm9ybSkge1xuICAgIC8vIGxlbmd0aCBpcyBqdXN0IHRoZSBmaXJzdCBieXRlXG4gICAgbGVuZ3RoID0gYjI7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBpbiBiaXRzIDcgdGhyb3VnaCAxXG4gICAgLy8gYW5kIGVhY2ggbGVuZ3RoIGJ5dGUgaXMgaW4gYmlnLWVuZGlhbiBiYXNlLTI1NlxuICAgIGxlbmd0aCA9IGIuZ2V0SW50KChiMiAmIDB4N0YpIDw8IDMpO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBieXRlIGJ1ZmZlciBoYXMgZW5vdWdoIGJ5dGVzLiBUaHJvd3MgYW4gRXJyb3IgaWYgbm90LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSByZW1haW5pbmcgdGhlIGJ5dGVzIHJlbWFpbmluZyBpbiB0aGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIG11c3QgaGF2ZS5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIG4pIHtcbiAgaWYobiA+IHJlbWFpbmluZykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVG9vIGZldyBieXRlcyB0byBwYXJzZSBERVIuJyk7XG4gICAgZXJyb3IuYXZhaWxhYmxlID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgZXJyb3IucmVtYWluaW5nID0gcmVtYWluaW5nO1xuICAgIGVycm9yLnJlcXVlc3RlZCA9IG47XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsZW5ndGggb2YgYSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZS5cbiAqXG4gKiBJbiBjYXNlIHRoZSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSByZW1haW5pbmcgdGhlIGJ5dGVzIHJlbWFpbmluZyBpbiB0aGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICovXG52YXIgX2dldFZhbHVlTGVuZ3RoID0gZnVuY3Rpb24oYnl0ZXMsIHJlbWFpbmluZykge1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIHJlbGF0ZWQgREVSL0JFUiBmdW5jdGlvbnMgdG8gYSBkZXIuanNcbiAgLy8gZmlsZTsgYmV0dGVyIGFic3RyYWN0IEFTTi4xIGF3YXkgZnJvbSBkZXIvYmVyLlxuICAvLyBmcm9tRGVyIGFscmVhZHkgY2hlY2tlZCB0aGF0IHRoaXMgYnl0ZSBleGlzdHNcbiAgdmFyIGIyID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICByZW1haW5pbmctLTtcbiAgaWYoYjIgPT09IDB4ODApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2VlIGlmIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgb3IgXCJsb25nIGZvcm1cIiAoYml0IDggc2V0KVxuICB2YXIgbGVuZ3RoO1xuICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDB4ODA7XG4gIGlmKCFsb25nRm9ybSkge1xuICAgIC8vIGxlbmd0aCBpcyBqdXN0IHRoZSBmaXJzdCBieXRlXG4gICAgbGVuZ3RoID0gYjI7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBpbiBiaXRzIDcgdGhyb3VnaCAxXG4gICAgLy8gYW5kIGVhY2ggbGVuZ3RoIGJ5dGUgaXMgaW4gYmlnLWVuZGlhbiBiYXNlLTI1NlxuICAgIHZhciBsb25nRm9ybUJ5dGVzID0gYjIgJiAweDdGO1xuICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCBsb25nRm9ybUJ5dGVzKTtcbiAgICBsZW5ndGggPSBieXRlcy5nZXRJbnQobG9uZ0Zvcm1CeXRlcyA8PCAzKTtcbiAgfVxuICAvLyBGSVhNRTogdGhpcyB3aWxsIG9ubHkgaGFwcGVuIGZvciAzMiBiaXQgZ2V0SW50IHdpdGggaGlnaCBiaXQgc2V0XG4gIGlmKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZ2F0aXZlIGxlbmd0aDogJyArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGFuIGFzbjEgb2JqZWN0IGZyb20gYSBieXRlIGJ1ZmZlciBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSBbc3RyaWN0XSB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICBhbGxvdyB0cnVuY2F0ZWQgdmFsdWVzIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb2JqZWN0IHdpdGggb3B0aW9ucyBvciBib29sZWFuIHN0cmljdCBmbGFnXG4gKiAgICAgICAgICBbc3RyaWN0XSB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgICAgW3BhcnNlQWxsQnl0ZXNdIHRydWUgdG8gZW5zdXJlIGFsbCBieXRlcyBhcmUgcGFyc2VkXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgW2RlY29kZUJpdFN0cmluZ3NdIHRydWUgdG8gYXR0ZW1wdCB0byBkZWNvZGUgdGhlIGNvbnRlbnQgb2ZcbiAqICAgICAgICAgICAgQklUIFNUUklOR3MgKG5vdCBPQ1RFVCBTVFJJTkdzKSB1c2luZyBzdHJpY3QgbW9kZS4gTm90ZSB0aGF0XG4gKiAgICAgICAgICAgIHdpdGhvdXQgc2NoZW1hIHN1cHBvcnQgdG8gdW5kZXJzdGFuZCB0aGUgZGF0YSBjb250ZXh0IHRoaXMgY2FuXG4gKiAgICAgICAgICAgIGVycm9uZW91c2x5IGRlY29kZSB2YWx1ZXMgdGhhdCBoYXBwZW4gdG8gYmUgdmFsaWQgQVNOLjEuIFRoaXNcbiAqICAgICAgICAgICAgZmxhZyB3aWxsIGJlIGRlcHJlY2F0ZWQgb3IgcmVtb3ZlZCBhcyBzb29uIGFzIHNjaGVtYSBzdXBwb3J0IGlzXG4gKiAgICAgICAgICAgIGF2YWlsYWJsZS4gKGRlZmF1bHQ6IHRydWUpXG4gKlxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGZvciB2YXJpb3VzIG1hbGZvcm1lZCBpbnB1dCBjb25kaXRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5mcm9tRGVyID0gZnVuY3Rpb24oYnl0ZXMsIG9wdGlvbnMpIHtcbiAgaWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIHBhcnNlQWxsQnl0ZXM6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIHBhcnNlQWxsQnl0ZXM6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZighKCdzdHJpY3QnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5zdHJpY3QgPSB0cnVlO1xuICB9XG4gIGlmKCEoJ3BhcnNlQWxsQnl0ZXMnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5wYXJzZUFsbEJ5dGVzID0gdHJ1ZTtcbiAgfVxuICBpZighKCdkZWNvZGVCaXRTdHJpbmdzJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuZGVjb2RlQml0U3RyaW5ncyA9IHRydWU7XG4gIH1cblxuICAvLyB3cmFwIGluIGJ1ZmZlciBpZiBuZWVkZWRcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICB9XG5cbiAgdmFyIGJ5dGVDb3VudCA9IGJ5dGVzLmxlbmd0aCgpO1xuICB2YXIgdmFsdWUgPSBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xuICBpZihvcHRpb25zLnBhcnNlQWxsQnl0ZXMgJiYgYnl0ZXMubGVuZ3RoKCkgIT09IDApIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1VucGFyc2VkIERFUiBieXRlcyByZW1haW4gYWZ0ZXIgQVNOLjEgcGFyc2luZy4nKTtcbiAgICBlcnJvci5ieXRlQ291bnQgPSBieXRlQ291bnQ7XG4gICAgZXJyb3IucmVtYWluaW5nID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbXBvc2VkID0gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBzdWJPcHRpb25zKTtcbiAgICAgICAgdmFyIHVzZWQgPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICByZW1haW5pbmcgLT0gdXNlZDtcbiAgICAgICAgaWYodHlwZSA9PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAgICAgdXNlZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgYWxsIGRlY29kZWQgYW5kIHRoZSBjbGFzcyBpbmRpY2F0ZXMgVU5JVkVSU0FMIG9yXG4gICAgICAgIC8vIENPTlRFWFRfU1BFQ0lGSUMgdGhlbiBhc3N1bWUgd2UndmUgZ290IGFuIGVuY2Fwc3VsYXRlZCBBU04uMSBvYmplY3RcbiAgICAgICAgdmFyIHRjID0gY29tcG9zZWQudGFnQ2xhc3M7XG4gICAgICAgIGlmKHVzZWQgPT09IGxlbmd0aCAmJlxuICAgICAgICAgICh0YyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgfHwgdGMgPT09IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQykpIHtcbiAgICAgICAgICB2YWx1ZSA9IFtjb21wb3NlZF07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVzdG9yZSByZWFkIHBvc2l0aW9uXG4gICAgICBieXRlcy5yZWFkID0gc2F2ZWRSZWFkO1xuICAgICAgcmVtYWluaW5nID0gc2F2ZWRSZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGFzbjEgbm90IGNvbnN0cnVjdGVkIG9yIGNvbXBvc2VkLCBnZXQgcmF3IHZhbHVlXG4gICAgLy8gVE9ETzogZG8gREVSIHRvIE9JRCBjb252ZXJzaW9uIGFuZCB2aWNlLXZlcnNhIGluIC50b0Rlcj9cblxuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1jb25zdHJ1Y3RlZCBBU04uMSBvYmplY3Qgb2YgaW5kZWZpbml0ZSBsZW5ndGguJyk7XG4gICAgICB9XG4gICAgICAvLyBiZSBsZW5pZW50IGFuZCB1c2UgcmVtYWluaW5nIHN0YXRlIGJ5dGVzXG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuXG4gICAgaWYodHlwZSA9PT0gYXNuMS5UeXBlLkJNUFNUUklORykge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICAgIGZvcig7IGxlbmd0aCA+IDA7IGxlbmd0aCAtPSAyKSB7XG4gICAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAyKTtcbiAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlcy5nZXRJbnQxNigpKTtcbiAgICAgICAgcmVtYWluaW5nIC09IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gYnl0ZXMuZ2V0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgIHJlbWFpbmluZyAtPSBsZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyBudWxsIDoge1xuICAgIGJpdFN0cmluZ0NvbnRlbnRzOiBiaXRTdHJpbmdDb250ZW50c1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbmQgcmV0dXJuIGFzbjEgb2JqZWN0XG4gIHJldHVybiBhc24xLmNyZWF0ZSh0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBhc24xT3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGFzbjEgb2JqZWN0IHRvIGEgYnVmZmVyIG9mIGJ5dGVzIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGFzbjEgdGhlIGFzbjEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgYnVmZmVyIG9mIGJ5dGVzLlxuICovXG5hc24xLnRvRGVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gYnVpbGQgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGIxID0gb2JqLnRhZ0NsYXNzIHwgb2JqLnR5cGU7XG5cbiAgLy8gZm9yIHN0b3JpbmcgdGhlIEFTTi4xIHZhbHVlXG4gIHZhciB2YWx1ZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlIGFuZCBkYXRhIG5vdCBjaGFuZ2VkXG4gIHZhciB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGZhbHNlO1xuICBpZignYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gdHJ1ZTtcbiAgICBpZihvYmoub3JpZ2luYWwpIHtcbiAgICAgIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gYXNuMS5lcXVhbHMob2JqLCBvYmoub3JpZ2luYWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHVzZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgdmFsdWUucHV0Qnl0ZXMob2JqLmJpdFN0cmluZ0NvbnRlbnRzKTtcbiAgfSBlbHNlIGlmKG9iai5jb21wb3NlZCkge1xuICAgIC8vIGlmIGNvbXBvc2VkLCB1c2UgZWFjaCBjaGlsZCBhc24xIG9iamVjdCdzIERFUiBieXRlcyBhcyB2YWx1ZVxuICAgIC8vIHR1cm4gb24gNnRoIGJpdCAoMHgyMCA9IDMyKSB0byBpbmRpY2F0ZSBhc24xIGlzIGNvbnN0cnVjdGVkXG4gICAgLy8gZnJvbSBvdGhlciBhc24xIG9iamVjdHNcbiAgICBpZihvYmouY29uc3RydWN0ZWQpIHtcbiAgICAgIGIxIHw9IDB4MjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR5cGUgaXMgYSBiaXQgc3RyaW5nLCBhZGQgdW51c2VkIGJpdHMgb2YgMHgwMFxuICAgICAgdmFsdWUucHV0Qnl0ZSgweDAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGlsZCBERVIgYnl0ZXMgdG9nZXRoZXJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZihvYmoudmFsdWVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZS5wdXRCdWZmZXIoYXNuMS50b0RlcihvYmoudmFsdWVbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGFzbjEudmFsdWUgZGlyZWN0bHlcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLkJNUFNUUklORykge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZS5wdXRJbnQxNihvYmoudmFsdWUuY2hhckNvZGVBdChpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuc3VyZSBpbnRlZ2VyIGlzIG1pbmltYWxseS1lbmNvZGVkXG4gICAgICAvLyBUT0RPOiBzaG91bGQgYWxsIGxlYWRpbmcgYnl0ZXMgYmUgc3RyaXBwZWQgdnMganVzdCBvbmU/XG4gICAgICAvLyAuLiBleCAnMDAgMDAgMDEnID0+ICcwMSc/XG4gICAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIgJiZcbiAgICAgICAgb2JqLnZhbHVlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgLy8gbGVhZGluZyAweDAwIGZvciBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICAgICgob2JqLnZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDAgJiZcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgICAgIC8vIGxlYWRpbmcgMHhGRiBmb3IgbmVnYXRpdmUgaW50ZWdlclxuICAgICAgICAob2JqLnZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDB4ODApKSkge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLnB1dEJ5dGVzKG9iai52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRhZyBieXRlXG4gIGJ5dGVzLnB1dEJ5dGUoYjEpO1xuXG4gIC8vIHVzZSBcInNob3J0IGZvcm1cIiBlbmNvZGluZ1xuICBpZih2YWx1ZS5sZW5ndGgoKSA8PSAxMjcpIHtcbiAgICAvLyBvbmUgYnl0ZSBkZXNjcmliZXMgdGhlIGxlbmd0aFxuICAgIC8vIGJpdCA4ID0gMCBhbmQgYml0cyA3LTEgPSBsZW5ndGhcbiAgICBieXRlcy5wdXRCeXRlKHZhbHVlLmxlbmd0aCgpICYgMHg3Rik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIFwibG9uZyBmb3JtXCIgZW5jb2RpbmdcbiAgICAvLyAyIHRvIDEyNyBieXRlcyBkZXNjcmliZSB0aGUgbGVuZ3RoXG4gICAgLy8gZmlyc3QgYnl0ZTogYml0IDggPSAxIGFuZCBiaXRzIDctMSA9ICMgb2YgYWRkaXRpb25hbCBieXRlc1xuICAgIC8vIG90aGVyIGJ5dGVzOiBsZW5ndGggaW4gYmFzZSAyNTYsIGJpZy1lbmRpYW5cbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoKCk7XG4gICAgdmFyIGxlbkJ5dGVzID0gJyc7XG4gICAgZG8ge1xuICAgICAgbGVuQnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4gJiAweEZGKTtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gODtcbiAgICB9IHdoaWxlKGxlbiA+IDApO1xuXG4gICAgLy8gc2V0IGZpcnN0IGJ5dGUgdG8gIyBieXRlcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggYW5kIHR1cm4gb25cbiAgICAvLyBiaXQgOCB0byBpbmRpY2F0ZSBsb25nLWZvcm0gbGVuZ3RoIGlzIHVzZWRcbiAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmxlbmd0aCB8IDB4ODApO1xuXG4gICAgLy8gY29uY2F0ZW5hdGUgbGVuZ3RoIGJ5dGVzIGluIHJldmVyc2Ugc2luY2UgdGhleSB3ZXJlIGdlbmVyYXRlZFxuICAgIC8vIGxpdHRsZSBlbmRpYW4gYW5kIHdlIG5lZWQgYmlnIGVuZGlhblxuICAgIGZvcih2YXIgaSA9IGxlbkJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbmNhdGVuYXRlIHZhbHVlIGJ5dGVzXG4gIGJ5dGVzLnB1dEJ1ZmZlcih2YWx1ZSk7XG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIHRvIGEgYnl0ZSBidWZmZXIuIFRoZSBieXRlIGJ1ZmZlclxuICogY29udGFpbnMgb25seSB0aGUgREVSLWVuY29kZWQgdmFsdWUsIG5vdCBhbnkgdGFnIG9yIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBPSUQgZG90LXNlcGFyYXRlZCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEub2lkVG9EZXIgPSBmdW5jdGlvbihvaWQpIHtcbiAgLy8gc3BsaXQgT0lEIGludG8gaW5kaXZpZHVhbCB2YWx1ZXNcbiAgdmFyIHZhbHVlcyA9IG9pZC5zcGxpdCgnLicpO1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgYnl0ZXMucHV0Qnl0ZSg0MCAqIHBhcnNlSW50KHZhbHVlc1swXSwgMTApICsgcGFyc2VJbnQodmFsdWVzWzFdLCAxMCkpO1xuICAvLyBvdGhlciBieXRlcyBhcmUgZWFjaCB2YWx1ZSBpbiBiYXNlIDEyOCB3aXRoIDh0aCBiaXQgc2V0IGV4Y2VwdCBmb3JcbiAgLy8gdGhlIGxhc3QgYnl0ZSBmb3IgZWFjaCB2YWx1ZVxuICB2YXIgbGFzdCwgdmFsdWVCeXRlcywgdmFsdWUsIGI7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBwcm9kdWNlIHZhbHVlIGJ5dGVzIGluIHJldmVyc2UgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGhvdyBtYW55XG4gICAgLy8gYnl0ZXMgaXQgd2lsbCB0YWtlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgIGxhc3QgPSB0cnVlO1xuICAgIHZhbHVlQnl0ZXMgPSBbXTtcbiAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlc1tpXSwgMTApO1xuICAgIGRvIHtcbiAgICAgIGIgPSB2YWx1ZSAmIDB4N0Y7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgLy8gaWYgdmFsdWUgaXMgbm90IGxhc3QsIHRoZW4gdHVybiBvbiA4dGggYml0XG4gICAgICBpZighbGFzdCkge1xuICAgICAgICBiIHw9IDB4ODA7XG4gICAgICB9XG4gICAgICB2YWx1ZUJ5dGVzLnB1c2goYik7XG4gICAgICBsYXN0ID0gZmFsc2U7XG4gICAgfSB3aGlsZSh2YWx1ZSA+IDApO1xuXG4gICAgLy8gYWRkIHZhbHVlIGJ5dGVzIGluIHJldmVyc2UgKG5lZWRzIHRvIGJlIGluIGJpZyBlbmRpYW4pXG4gICAgZm9yKHZhciBuID0gdmFsdWVCeXRlcy5sZW5ndGggLSAxOyBuID49IDA7IC0tbikge1xuICAgICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZUJ5dGVzW25dKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYW4gT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLiBUaGVcbiAqIGJ5dGUgYnVmZmVyIHNob3VsZCBjb250YWluIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvclxuICogbGVuZ3RoIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICovXG5hc24xLmRlclRvT2lkID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdmFyIG9pZDtcblxuICAvLyB3cmFwIGluIGJ1ZmZlciBpZiBuZWVkZWRcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICB9XG5cbiAgLy8gZmlyc3QgYnl0ZSBpcyA0MCAqIHZhbHVlMSArIHZhbHVlMlxuICB2YXIgYiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgb2lkID0gTWF0aC5mbG9vcihiIC8gNDApICsgJy4nICsgKGIgJSA0MCk7XG5cbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIHZhbHVlID0gMDtcbiAgd2hpbGUoYnl0ZXMubGVuZ3RoKCkgPiAwKSB7XG4gICAgYiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgICB2YWx1ZSA9IHZhbHVlIDw8IDc7XG4gICAgLy8gbm90IHRoZSBsYXN0IGJ5dGUgZm9yIHRoZSB2YWx1ZVxuICAgIGlmKGIgJiAweDgwKSB7XG4gICAgICB2YWx1ZSArPSBiICYgMHg3RjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGFzdCBieXRlXG4gICAgICBvaWQgKz0gJy4nICsgKHZhbHVlICsgYik7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9pZDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVVENUaW1lIHZhbHVlIHRvIGEgZGF0ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gUGFyc2luZyB0aGF0IHN0cnVjdHVyZSBoYXNuJ3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXG4gKlxuICogQHBhcmFtIHV0YyB0aGUgVVRDVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEudXRjVGltZVRvRGF0ZSA9IGZ1bmN0aW9uKHV0Yykge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWU1NRERoaG1tWlxuICAgIFlZTU1ERGhobW0raGgnbW0nXG4gICAgWVlNTUREaGhtbS1oaCdtbSdcbiAgICBZWU1NRERoaG1tc3NaXG4gICAgWVlNTUREaGhtbXNzK2hoJ21tJ1xuICAgIFlZTU1ERGhobW1zcy1oaCdtbSdcblxuICAgIFdoZXJlOlxuXG4gICAgWVkgaXMgdGhlIGxlYXN0IHNpZ25pZmljYW50IHR3byBkaWdpdHMgb2YgdGhlIHllYXJcbiAgICBNTSBpcyB0aGUgbW9udGggKDAxIHRvIDEyKVxuICAgIEREIGlzIHRoZSBkYXkgKDAxIHRvIDMxKVxuICAgIGhoIGlzIHRoZSBob3VyICgwMCB0byAyMylcbiAgICBtbSBhcmUgdGhlIG1pbnV0ZXMgKDAwIHRvIDU5KVxuICAgIHNzIGFyZSB0aGUgc2Vjb25kcyAoMDAgdG8gNTkpXG4gICAgWiBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIEdNVCwgKyBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzXG4gICAgbGF0ZXIgdGhhbiBHTVQsIGFuZCAtIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgZWFybGllciB0aGFuIEdNVFxuICAgIGhoJyBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG9mZnNldCBmcm9tIEdNVCBpbiBob3Vyc1xuICAgIG1tJyBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG9mZnNldCBmcm9tIEdNVCBpbiBtaW51dGVzICovXG4gIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAvLyBpZiBZWSA+PSA1MCB1c2UgMTl4eCwgaWYgWVkgPCA1MCB1c2UgMjB4eFxuICB2YXIgeWVhciA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMCwgMiksIDEwKTtcbiAgeWVhciA9ICh5ZWFyID49IDUwKSA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG4gIHZhciBNTSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMiwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludCh1dGMuc3Vic3RyKDQsIDIpLCAxMCk7XG4gIHZhciBoaCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoNiwgMiksIDEwKTtcbiAgdmFyIG1tID0gcGFyc2VJbnQodXRjLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgc3MgPSAwO1xuXG4gIC8vIG5vdCBqdXN0IFlZTU1ERGhobW1aXG4gIGlmKHV0Yy5sZW5ndGggPiAxMSkge1xuICAgIC8vIGdldCBjaGFyYWN0ZXIgYWZ0ZXIgbWludXRlc1xuICAgIHZhciBjID0gdXRjLmNoYXJBdCgxMCk7XG4gICAgdmFyIGVuZCA9IDEwO1xuXG4gICAgLy8gc2VlIGlmIHNlY29uZHMgYXJlIHByZXNlbnRcbiAgICBpZihjICE9PSAnKycgJiYgYyAhPT0gJy0nKSB7XG4gICAgICAvLyBnZXQgc2Vjb25kc1xuICAgICAgc3MgPSBwYXJzZUludCh1dGMuc3Vic3RyKDEwLCAyKSwgMTApO1xuICAgICAgZW5kICs9IDI7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIGRhdGVcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBNTSwgREQpO1xuICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIDApO1xuXG4gIGlmKGVuZCkge1xuICAgIC8vIGdldCArLy0gYWZ0ZXIgZW5kIG9mIHRpbWVcbiAgICBjID0gdXRjLmNoYXJBdChlbmQpO1xuICAgIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAgIC8vIGdldCBob3VycyttaW51dGVzIG9mZnNldFxuICAgICAgdmFyIGhob2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyA0LCAyKSwgMTApO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAgdmFyIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICAgIG9mZnNldCAqPSA2MDAwMDtcblxuICAgICAgLy8gYXBwbHkgb2Zmc2V0XG4gICAgICBpZihjID09PSAnKycpIHtcbiAgICAgICAgZGF0ZS5zZXRUaW1lKCtkYXRlIC0gb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgR2VuZXJhbGl6ZWRUaW1lIHZhbHVlIHRvIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZ2VudGltZSB0aGUgR2VuZXJhbGl6ZWRUaW1lIHZhbHVlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZGF0ZS5cbiAqL1xuYXNuMS5nZW5lcmFsaXplZFRpbWVUb0RhdGUgPSBmdW5jdGlvbihnZW50aW1lKSB7XG4gIC8qIFRoZSBmb2xsb3dpbmcgZm9ybWF0cyBjYW4gYmUgdXNlZDpcblxuICAgIFlZWVlNTURESEhNTVNTXG4gICAgWVlZWU1NRERISE1NU1MuZmZmXG4gICAgWVlZWU1NRERISE1NU1NaXG4gICAgWVlZWU1NRERISE1NU1MuZmZmWlxuICAgIFlZWVlNTURESEhNTVNTK2hoJ21tJ1xuICAgIFlZWVlNTURESEhNTVNTLmZmZitoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy1oaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZWVkgaXMgdGhlIHllYXJcbiAgICBNTSBpcyB0aGUgbW9udGggKDAxIHRvIDEyKVxuICAgIEREIGlzIHRoZSBkYXkgKDAxIHRvIDMxKVxuICAgIGhoIGlzIHRoZSBob3VyICgwMCB0byAyMylcbiAgICBtbSBhcmUgdGhlIG1pbnV0ZXMgKDAwIHRvIDU5KVxuICAgIHNzIGFyZSB0aGUgc2Vjb25kcyAoMDAgdG8gNTkpXG4gICAgLmZmZiBpcyB0aGUgc2Vjb25kIGZyYWN0aW9uLCBhY2N1cmF0ZSB0byB0aHJlZSBkZWNpbWFsIHBsYWNlc1xuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgdmFyIFlZWVkgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigwLCA0KSwgMTApO1xuICB2YXIgTU0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig0LCAyKSwgMTApIC0gMTsgLy8gdXNlIDAtMTEgZm9yIG1vbnRoXG4gIHZhciBERCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBoaCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDgsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDEwLCAyKSwgMTApO1xuICB2YXIgc3MgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMiwgMiksIDEwKTtcbiAgdmFyIGZmZiA9IDA7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgaXNVVEMgPSBmYWxzZTtcblxuICBpZihnZW50aW1lLmNoYXJBdChnZW50aW1lLmxlbmd0aCAtIDEpID09PSAnWicpIHtcbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICB2YXIgZW5kID0gZ2VudGltZS5sZW5ndGggLSA1LCBjID0gZ2VudGltZS5jaGFyQXQoZW5kKTtcbiAgaWYoYyA9PT0gJysnIHx8IGMgPT09ICctJykge1xuICAgIC8vIGdldCBob3VycyttaW51dGVzIG9mZnNldFxuICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDEsIDIpLCAxMCk7XG4gICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgb2Zmc2V0ID0gaGhvZmZzZXQgKiA2MCArIG1tb2Zmc2V0O1xuICAgIG9mZnNldCAqPSA2MDAwMDtcblxuICAgIC8vIGFwcGx5IG9mZnNldFxuICAgIGlmKGMgPT09ICcrJykge1xuICAgICAgb2Zmc2V0ICo9IC0xO1xuICAgIH1cblxuICAgIGlzVVRDID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzZWNvbmQgZnJhY3Rpb25cbiAgaWYoZ2VudGltZS5jaGFyQXQoMTQpID09PSAnLicpIHtcbiAgICBmZmYgPSBwYXJzZUZsb2F0KGdlbnRpbWUuc3Vic3RyKDE0KSwgMTApICogMTAwMDtcbiAgfVxuXG4gIGlmKGlzVVRDKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoaGgsIG1tLCBzcywgZmZmKTtcblxuICAgIC8vIGFwcGx5IG9mZnNldFxuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgIGRhdGUuc2V0SG91cnMoaGgsIG1tLCBzcywgZmZmKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBVVENUaW1lIHZhbHVlLlxuICpcbiAqIE5vdGU6IEdlbmVyYWxpemVkVGltZSBoYXMgNCBkaWdpdHMgZm9yIHRoZSB5ZWFyIGFuZCBpcyB1c2VkIGZvciBYLjUwOVxuICogZGF0ZXMgcGFzdCAyMDQ5LiBDb252ZXJ0aW5nIHRvIGEgR2VuZXJhbGl6ZWRUaW1lIGhhc24ndCBiZWVuXG4gKiBpbXBsZW1lbnRlZCB5ZXQuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVVENUaW1lIHZhbHVlLlxuICovXG5hc24xLmRhdGVUb1V0Y1RpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlOyBjdXJyZW50bHkgYXNzdW1lcyBwcm9wZXIgZm9ybWF0XG4gIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBjcmVhdGUgZm9ybWF0IFlZTU1ERGhobW1zc1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgoJycgKyBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpLnN1YnN0cigyKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGF0ZSB0byBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSBhcyBhIHN0cmluZy5cbiAqL1xuYXNuMS5kYXRlVG9HZW5lcmFsaXplZFRpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlOyBjdXJyZW50bHkgYXNzdW1lcyBwcm9wZXIgZm9ybWF0XG4gIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBjcmVhdGUgZm9ybWF0IFlZWVlNTURESEhNTVNTWlxuICB2YXIgZm9ybWF0ID0gW107XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgZm9ybWF0LnB1c2goJycgKyAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0hvdXJzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDTWludXRlcygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ1NlY29uZHMoKSk7XG5cbiAgLy8gZW5zdXJlIDIgZGlnaXRzIGFyZSB1c2VkIGZvciBlYWNoIGZvcm1hdCBlbnRyeVxuICBmb3IodmFyIGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYoZm9ybWF0W2ldLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJ2YWwgKz0gJzAnO1xuICAgIH1cbiAgICBydmFsICs9IGZvcm1hdFtpXTtcbiAgfVxuICBydmFsICs9ICdaJztcblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBqYXZhc2NyaXB0IGludGVnZXIgdG8gYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBiZSB1c2VkXG4gKiBhcyB0aGUgdmFsdWUgZm9yIGFuIElOVEVHRVIgdHlwZS5cbiAqXG4gKiBAcGFyYW0geCB0aGUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlIGJ1ZmZlci5cbiAqL1xuYXNuMS5pbnRlZ2VyVG9EZXIgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgaWYoeCA+PSAtMHg4MCAmJiB4IDwgMHg4MCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCA4KTtcbiAgfVxuICBpZih4ID49IC0weDgwMDAgJiYgeCA8IDB4ODAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAxNik7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAgJiYgeCA8IDB4ODAwMDAwKSB7XG4gICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDI0KTtcbiAgfVxuICBpZih4ID49IC0weDgwMDAwMDAwICYmIHggPCAweDgwMDAwMDAwKSB7XG4gICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDMyKTtcbiAgfVxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy4nKTtcbiAgZXJyb3IuaW50ZWdlciA9IHg7XG4gIHRocm93IGVycm9yO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGEgamF2YXNjcmlwdCBpbnRlZ2VyLiBUaGlzIGlzXG4gKiB0eXBpY2FsbHkgdXNlZCB0byBkZWNvZGUgdGhlIHZhbHVlIG9mIGFuIElOVEVHRVIgdHlwZS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbmFzbjEuZGVyVG9JbnRlZ2VyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHZhciBuID0gYnl0ZXMubGVuZ3RoKCkgKiA4O1xuICBpZihuID4gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy4nKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuZ2V0U2lnbmVkSW50KG4pO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZ2l2ZW4gQVNOLjEgb2JqZWN0IGlzIGF0IGxlYXN0IGEgc3VwZXIgc2V0IG9mIHRoZVxuICogZ2l2ZW4gQVNOLjEgc3RydWN0dXJlLiBPbmx5IHRhZyBjbGFzc2VzIGFuZCB0eXBlcyBhcmUgY2hlY2tlZC4gQW5cbiAqIG9wdGlvbmFsIG1hcCBtYXkgYWxzbyBiZSBwcm92aWRlZCB0byBjYXB0dXJlIEFTTi4xIHZhbHVlcyB3aGlsZSB0aGVcbiAqIHN0cnVjdHVyZSBpcyBjaGVja2VkLlxuICpcbiAqIFRvIGNhcHR1cmUgYW4gQVNOLjEgdmFsdWUsIHNldCBhbiBvYmplY3QgaW4gdGhlIHZhbGlkYXRvcidzICdjYXB0dXJlJ1xuICogcGFyYW1ldGVyIHRvIHRoZSBrZXkgdG8gdXNlIGluIHRoZSBjYXB0dXJlIG1hcC4gVG8gY2FwdHVyZSB0aGUgZnVsbFxuICogQVNOLjEgb2JqZWN0LCBzcGVjaWZ5ICdjYXB0dXJlQXNuMScuIFRvIGNhcHR1cmUgQklUIFNUUklORyBieXRlcywgaW5jbHVkaW5nXG4gKiB0aGUgbGVhZGluZyB1bnVzZWQgYml0cyBjb3VudGVyIGJ5dGUsIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdDb250ZW50cycuXG4gKiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIHdpdGhvdXQgdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLFxuICogc3BlY2lmeSAnY2FwdHVyZUJpdFN0cmluZ1ZhbHVlJy5cbiAqXG4gKiBPYmplY3RzIGluIHRoZSB2YWxpZGF0b3IgbWF5IHNldCBhIGZpZWxkICdvcHRpb25hbCcgdG8gdHJ1ZSB0byBpbmRpY2F0ZVxuICogdGhhdCBpdCBpc24ndCBuZWNlc3NhcnkgdG8gcGFzcyB2YWxpZGF0aW9uLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSB2IHRoZSBBU04uMSBzdHJ1Y3R1cmUgdmFsaWRhdG9yLlxuICogQHBhcmFtIGNhcHR1cmUgYW4gb3B0aW9uYWwgbWFwIHRvIGNhcHR1cmUgdmFsdWVzIGluLlxuICogQHBhcmFtIGVycm9ycyBhbiBvcHRpb25hbCBhcnJheSBmb3Igc3RvcmluZyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAqL1xuYXNuMS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9iaiwgdiwgY2FwdHVyZSwgZXJyb3JzKSB7XG4gIHZhciBydmFsID0gZmFsc2U7XG5cbiAgLy8gZW5zdXJlIHRhZyBjbGFzcyBhbmQgdHlwZSBhcmUgdGhlIHNhbWUgaWYgc3BlY2lmaWVkXG4gIGlmKChvYmoudGFnQ2xhc3MgPT09IHYudGFnQ2xhc3MgfHwgdHlwZW9mKHYudGFnQ2xhc3MpID09PSAndW5kZWZpbmVkJykgJiZcbiAgICAob2JqLnR5cGUgPT09IHYudHlwZSB8fCB0eXBlb2Yodi50eXBlKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgLy8gZW5zdXJlIGNvbnN0cnVjdGVkIGZsYWcgaXMgdGhlIHNhbWUgaWYgc3BlY2lmaWVkXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkID09PSB2LmNvbnN0cnVjdGVkIHx8XG4gICAgICB0eXBlb2Yodi5jb25zdHJ1Y3RlZCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBydmFsID0gdHJ1ZTtcblxuICAgICAgLy8gaGFuZGxlIHN1YiB2YWx1ZXNcbiAgICAgIGlmKHYudmFsdWUgJiYgZm9yZ2UudXRpbC5pc0FycmF5KHYudmFsdWUpKSB7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgcnZhbCAmJiBpIDwgdi52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJ2YWwgPSB2LnZhbHVlW2ldLm9wdGlvbmFsIHx8IGZhbHNlO1xuICAgICAgICAgIGlmKG9iai52YWx1ZVtqXSkge1xuICAgICAgICAgICAgcnZhbCA9IGFzbjEudmFsaWRhdGUob2JqLnZhbHVlW2pdLCB2LnZhbHVlW2ldLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgICAgICAgaWYocnZhbCkge1xuICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9IGVsc2UgaWYodi52YWx1ZVtpXS5vcHRpb25hbCkge1xuICAgICAgICAgICAgICBydmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIXJ2YWwgJiYgZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICAgICAgICdUYWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgdHlwZSBcIicgK1xuICAgICAgICAgICAgICB2LnR5cGUgKyAnXCIgZXhwZWN0ZWQgdmFsdWUgbGVuZ3RoIFwiJyArXG4gICAgICAgICAgICAgIHYudmFsdWUubGVuZ3RoICsgJ1wiLCBnb3QgXCInICtcbiAgICAgICAgICAgICAgb2JqLnZhbHVlLmxlbmd0aCArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsICYmIGNhcHR1cmUpIHtcbiAgICAgICAgaWYodi5jYXB0dXJlKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVdID0gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUFzbjEpIHtcbiAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUFzbjFdID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ0NvbnRlbnRzICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50c10gPSBvYmouYml0U3RyaW5nQ29udGVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYodi5jYXB0dXJlQml0U3RyaW5nVmFsdWUgJiYgJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgaWYob2JqLmJpdFN0cmluZ0NvbnRlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nVmFsdWVdID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IHVudXNlZCBiaXRzIHdpdGggZGF0YSBzaGlmdGluZ1xuICAgICAgICAgICAgdmFyIHVudXNlZCA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYodW51c2VkICE9PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnY2FwdHVyZUJpdFN0cmluZ1ZhbHVlIG9ubHkgc3VwcG9ydGVkIGZvciB6ZXJvIHVudXNlZCBiaXRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCBjb25zdHJ1Y3RlZCBcIicgKyB2LmNvbnN0cnVjdGVkICsgJ1wiLCBnb3QgXCInICtcbiAgICAgICAgb2JqLmNvbnN0cnVjdGVkICsgJ1wiJyk7XG4gICAgfVxuICB9IGVsc2UgaWYoZXJyb3JzKSB7XG4gICAgaWYob2JqLnRhZ0NsYXNzICE9PSB2LnRhZ0NsYXNzKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCB0YWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai50YWdDbGFzcyArICdcIicpO1xuICAgIH1cbiAgICBpZihvYmoudHlwZSAhPT0gdi50eXBlKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCB0eXBlIFwiJyArIHYudHlwZSArICdcIiwgZ290IFwiJyArIG9iai50eXBlICsgJ1wiJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLy8gcmVnZXggZm9yIHRlc3RpbmcgZm9yIG5vbi1sYXRpbiBjaGFyYWN0ZXJzXG52YXIgX25vbkxhdGluUmVnZXggPSAvW15cXFxcdTAwMDAtXFxcXHUwMGZmXS87XG5cbi8qKlxuICogUHJldHR5IHByaW50cyBhbiBBU04uMSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHRvIHdyaXRlIG91dC5cbiAqIEBwYXJhbSBsZXZlbCB0aGUgbGV2ZWwgaW4gdGhlIHRyZWUuXG4gKiBAcGFyYW0gaW5kZW50YXRpb24gdGhlIGluZGVudGF0aW9uIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcuXG4gKi9cbmFzbjEucHJldHR5UHJpbnQgPSBmdW5jdGlvbihvYmosIGxldmVsLCBpbmRlbnRhdGlvbikge1xuICB2YXIgcnZhbCA9ICcnO1xuXG4gIC8vIHNldCBkZWZhdWx0IGxldmVsIGFuZCBpbmRlbnRhdGlvblxuICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gIGluZGVudGF0aW9uID0gaW5kZW50YXRpb24gfHwgMjtcblxuICAvLyBzdGFydCBuZXcgbGluZSBmb3IgZGVlcCBsZXZlbHNcbiAgaWYobGV2ZWwgPiAwKSB7XG4gICAgcnZhbCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbmRlbnRcbiAgdmFyIGluZGVudCA9ICcnO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGV2ZWwgKiBpbmRlbnRhdGlvbjsgKytpKSB7XG4gICAgaW5kZW50ICs9ICcgJztcbiAgfVxuXG4gIC8vIHByaW50IGNsYXNzOnR5cGVcbiAgcnZhbCArPSBpbmRlbnQgKyAnVGFnOiAnO1xuICBzd2l0Y2gob2JqLnRhZ0NsYXNzKSB7XG4gIGNhc2UgYXNuMS5DbGFzcy5VTklWRVJTQUw6XG4gICAgcnZhbCArPSAnVW5pdmVyc2FsOic7XG4gICAgYnJlYWs7XG4gIGNhc2UgYXNuMS5DbGFzcy5BUFBMSUNBVElPTjpcbiAgICBydmFsICs9ICdBcHBsaWNhdGlvbjonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQzpcbiAgICBydmFsICs9ICdDb250ZXh0LVNwZWNpZmljOic7XG4gICAgYnJlYWs7XG4gIGNhc2UgYXNuMS5DbGFzcy5QUklWQVRFOlxuICAgIHJ2YWwgKz0gJ1ByaXZhdGU6JztcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmKG9iai50YWdDbGFzcyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwpIHtcbiAgICBydmFsICs9IG9iai50eXBlO1xuXG4gICAgLy8ga25vd24gdHlwZXNcbiAgICBzd2l0Y2gob2JqLnR5cGUpIHtcbiAgICBjYXNlIGFzbjEuVHlwZS5OT05FOlxuICAgICAgcnZhbCArPSAnIChOb25lKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CT09MRUFOOlxuICAgICAgcnZhbCArPSAnIChCb29sZWFuKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5JTlRFR0VSOlxuICAgICAgcnZhbCArPSAnIChJbnRlZ2VyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CSVRTVFJJTkc6XG4gICAgICBydmFsICs9ICcgKEJpdCBzdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9DVEVUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChPY3RldCBzdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk5VTEw6XG4gICAgICBydmFsICs9ICcgKE51bGwpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9ERVNDOlxuICAgICAgcnZhbCArPSAnIChPYmplY3QgRGVzY3JpcHRvciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRVhURVJOQUw6XG4gICAgICBydmFsICs9ICcgKEV4dGVybmFsIG9yIEluc3RhbmNlIG9mKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5SRUFMOlxuICAgICAgcnZhbCArPSAnIChSZWFsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5FTlVNRVJBVEVEOlxuICAgICAgcnZhbCArPSAnIChFbnVtZXJhdGVkKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5FTUJFRERFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW1iZWRkZWQgUERWKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5VVEY4OlxuICAgICAgcnZhbCArPSAnIChVVEY4KSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5ST0lEOlxuICAgICAgcnZhbCArPSAnIChSZWxhdGl2ZSBPYmplY3QgSWRlbnRpZmllciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VRVUVOQ0U6XG4gICAgICBydmFsICs9ICcgKFNlcXVlbmNlKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5TRVQ6XG4gICAgICBydmFsICs9ICcgKFNldCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChQcmludGFibGUgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5JQTVTdHJpbmc6XG4gICAgICBydmFsICs9ICcgKElBNVN0cmluZyAoQVNDSUkpKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5VVENUSU1FOlxuICAgICAgcnZhbCArPSAnIChVVEMgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FOlxuICAgICAgcnZhbCArPSAnIChHZW5lcmFsaXplZCB0aW1lKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CTVBTVFJJTkc6XG4gICAgICBydmFsICs9ICcgKEJNUCBTdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IG9iai50eXBlO1xuICB9XG5cbiAgcnZhbCArPSAnXFxuJztcbiAgcnZhbCArPSBpbmRlbnQgKyAnQ29uc3RydWN0ZWQ6ICcgKyBvYmouY29uc3RydWN0ZWQgKyAnXFxuJztcblxuICBpZihvYmouY29tcG9zZWQpIHtcbiAgICB2YXIgc3VidmFsdWVzID0gMDtcbiAgICB2YXIgc3ViID0gJyc7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VidmFsdWVzICs9IDE7XG4gICAgICAgIHN1YiArPSBhc24xLnByZXR0eVByaW50KG9iai52YWx1ZVtpXSwgbGV2ZWwgKyAxLCBpbmRlbnRhdGlvbik7XG4gICAgICAgIGlmKChpICsgMSkgPCBvYmoudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgc3ViICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBydmFsICs9IGluZGVudCArICdTdWIgdmFsdWVzOiAnICsgc3VidmFsdWVzICsgc3ViO1xuICB9IGVsc2Uge1xuICAgIHJ2YWwgKz0gaW5kZW50ICsgJ1ZhbHVlOiAnO1xuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuT0lEKSB7XG4gICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChvYmoudmFsdWUpO1xuICAgICAgcnZhbCArPSBvaWQ7XG4gICAgICBpZihmb3JnZS5wa2kgJiYgZm9yZ2UucGtpLm9pZHMpIHtcbiAgICAgICAgaWYob2lkIGluIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgnICsgZm9yZ2UucGtpLm9pZHNbb2lkXSArICcpICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydmFsICs9IGFzbjEuZGVyVG9JbnRlZ2VyKG9iai52YWx1ZSk7XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgLy8gVE9ETzogc2hpZnQgYml0cyBhcyBuZWVkZWQgdG8gZGlzcGxheSB3aXRob3V0IHBhZGRpbmdcbiAgICAgIGlmKG9iai52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSB1bnVzZWQgYml0cyBmaWVsZFxuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgKz0gJyhub25lKSc7XG4gICAgICB9XG4gICAgICAvLyBzaG93IHVudXNlZCBiaXQgY291bnRcbiAgICAgIGlmKG9iai52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB1bnVzZWQgPSBvYmoudmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYodW51c2VkID09IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKDEgdW51c2VkIGJpdCBzaG93biknO1xuICAgICAgICB9IGVsc2UgaWYodW51c2VkID4gMSkge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIHVudXNlZCArICcgdW51c2VkIGJpdHMgc2hvd24pJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgICBpZighX25vbkxhdGluUmVnZXgudGVzdChvYmoudmFsdWUpKSB7XG4gICAgICAgIHJ2YWwgKz0gJygnICsgb2JqLnZhbHVlICsgJykgJztcbiAgICAgIH1cbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ2YWwgKz0gZm9yZ2UudXRpbC5kZWNvZGVVdGY4KG9iai52YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgaWYoZS5tZXNzYWdlID09PSAnVVJJIG1hbGZvcm1lZCcpIHtcbiAgICAgICAgICBydmFsICs9XG4gICAgICAgICAgICAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZSkgKyAnIChtYWxmb3JtZWQgVVRGOCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHxcbiAgICAgIG9iai50eXBlID09PSBhc24xLlR5cGUuSUE1U3RyaW5nKSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9IGVsc2UgaWYoX25vbkxhdGluUmVnZXgudGVzdChvYmoudmFsdWUpKSB7XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcnZhbCArPSAnW251bGxdJztcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCArPSBvYmoudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsImFzbjEiLCJtb2R1bGUiLCJleHBvcnRzIiwiQ2xhc3MiLCJVTklWRVJTQUwiLCJBUFBMSUNBVElPTiIsIkNPTlRFWFRfU1BFQ0lGSUMiLCJQUklWQVRFIiwiVHlwZSIsIk5PTkUiLCJCT09MRUFOIiwiSU5URUdFUiIsIkJJVFNUUklORyIsIk9DVEVUU1RSSU5HIiwiTlVMTCIsIk9JRCIsIk9ERVNDIiwiRVhURVJOQUwiLCJSRUFMIiwiRU5VTUVSQVRFRCIsIkVNQkVEREVEIiwiVVRGOCIsIlJPSUQiLCJTRVFVRU5DRSIsIlNFVCIsIlBSSU5UQUJMRVNUUklORyIsIklBNVNUUklORyIsIlVUQ1RJTUUiLCJHRU5FUkFMSVpFRFRJTUUiLCJCTVBTVFJJTkciLCJjcmVhdGUiLCJ0YWdDbGFzcyIsInR5cGUiLCJjb25zdHJ1Y3RlZCIsInZhbHVlIiwib3B0aW9ucyIsInV0aWwiLCJpc0FycmF5IiwidG1wIiwiaSIsImxlbmd0aCIsInVuZGVmaW5lZCIsInB1c2giLCJvYmoiLCJjb21wb3NlZCIsImJpdFN0cmluZ0NvbnRlbnRzIiwib3JpZ2luYWwiLCJjb3B5IiwiZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzIiwiZXF1YWxzIiwib2JqMSIsIm9iajIiLCJlcXVhbCIsImluY2x1ZGVCaXRTdHJpbmdDb250ZW50cyIsImdldEJlclZhbHVlTGVuZ3RoIiwiYiIsImIyIiwiZ2V0Qnl0ZSIsImxvbmdGb3JtIiwiZ2V0SW50IiwiX2NoZWNrQnVmZmVyTGVuZ3RoIiwiYnl0ZXMiLCJyZW1haW5pbmciLCJuIiwiZXJyb3IiLCJFcnJvciIsImF2YWlsYWJsZSIsInJlcXVlc3RlZCIsIl9nZXRWYWx1ZUxlbmd0aCIsImxvbmdGb3JtQnl0ZXMiLCJmcm9tRGVyIiwic3RyaWN0IiwicGFyc2VBbGxCeXRlcyIsImRlY29kZUJpdFN0cmluZ3MiLCJjcmVhdGVCdWZmZXIiLCJieXRlQ291bnQiLCJfZnJvbURlciIsImRlcHRoIiwic3RhcnQiLCJiMSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImdldEJ5dGVzIiwic2F2ZWRSZWFkIiwicmVhZCIsInNhdmVkUmVtYWluaW5nIiwidW51c2VkIiwic3ViT3B0aW9ucyIsInVzZWQiLCJ0YyIsImV4IiwiZ2V0SW50MTYiLCJhc24xT3B0aW9ucyIsInRvRGVyIiwidXNlQml0U3RyaW5nQ29udGVudHMiLCJwdXRCeXRlcyIsInB1dEJ5dGUiLCJwdXRCdWZmZXIiLCJwdXRJbnQxNiIsImNoYXJDb2RlQXQiLCJzdWJzdHIiLCJsZW4iLCJsZW5CeXRlcyIsIm9pZFRvRGVyIiwib2lkIiwidmFsdWVzIiwic3BsaXQiLCJwYXJzZUludCIsImxhc3QiLCJ2YWx1ZUJ5dGVzIiwiZGVyVG9PaWQiLCJNYXRoIiwiZmxvb3IiLCJ1dGNUaW1lVG9EYXRlIiwidXRjIiwiZGF0ZSIsIkRhdGUiLCJ5ZWFyIiwiTU0iLCJERCIsImhoIiwibW0iLCJzcyIsImMiLCJjaGFyQXQiLCJlbmQiLCJzZXRVVENGdWxsWWVhciIsInNldFVUQ0hvdXJzIiwiaGhvZmZzZXQiLCJtbW9mZnNldCIsIm9mZnNldCIsInNldFRpbWUiLCJnZW5lcmFsaXplZFRpbWVUb0RhdGUiLCJnZW50aW1lIiwiWVlZWSIsImZmZiIsImlzVVRDIiwicGFyc2VGbG9hdCIsInNldEZ1bGxZZWFyIiwic2V0SG91cnMiLCJkYXRlVG9VdGNUaW1lIiwicnZhbCIsImZvcm1hdCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImRhdGVUb0dlbmVyYWxpemVkVGltZSIsImludGVnZXJUb0RlciIsIngiLCJwdXRTaWduZWRJbnQiLCJpbnRlZ2VyIiwiZGVyVG9JbnRlZ2VyIiwiZ2V0U2lnbmVkSW50IiwidmFsaWRhdGUiLCJ2IiwiY2FwdHVyZSIsImVycm9ycyIsImoiLCJvcHRpb25hbCIsIm5hbWUiLCJjYXB0dXJlQXNuMSIsImNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyIsImNhcHR1cmVCaXRTdHJpbmdWYWx1ZSIsInNsaWNlIiwiX25vbkxhdGluUmVnZXgiLCJwcmV0dHlQcmludCIsImxldmVsIiwiaW5kZW50YXRpb24iLCJpbmRlbnQiLCJJQTVTdHJpbmciLCJzdWJ2YWx1ZXMiLCJzdWIiLCJwa2kiLCJvaWRzIiwiYnl0ZXNUb0hleCIsInRlc3QiLCJkZWNvZGVVdGY4IiwiZSIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/asn1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/baseN.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/baseN.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n * Base-N/Base-X encoding/decoding functions.\n *\n * Original implementation from base-x:\n * https://github.com/cryptocoinjs/base-x\n *\n * Which is MIT licensed:\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */ \nvar api = {};\nmodule.exports = api;\n// baseN alphabet indexes\nvar _reverseAlphabets = {};\n/**\n * BaseN-encodes a Uint8Array using the given alphabet.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the baseN-encoded output string.\n */ api.encode = function(input, alphabet, maxline) {\n    if (typeof alphabet !== \"string\") {\n        throw new TypeError('\"alphabet\" must be a string.');\n    }\n    if (maxline !== undefined && typeof maxline !== \"number\") {\n        throw new TypeError('\"maxline\" must be a number.');\n    }\n    var output = \"\";\n    if (!(input instanceof Uint8Array)) {\n        // assume forge byte buffer\n        output = _encodeWithByteBuffer(input, alphabet);\n    } else {\n        var i = 0;\n        var base = alphabet.length;\n        var first = alphabet.charAt(0);\n        var digits = [\n            0\n        ];\n        for(i = 0; i < input.length; ++i){\n            for(var j = 0, carry = input[i]; j < digits.length; ++j){\n                carry += digits[j] << 8;\n                digits[j] = carry % base;\n                carry = carry / base | 0;\n            }\n            while(carry > 0){\n                digits.push(carry % base);\n                carry = carry / base | 0;\n            }\n        }\n        // deal with leading zeros\n        for(i = 0; input[i] === 0 && i < input.length - 1; ++i){\n            output += first;\n        }\n        // convert digits to a string\n        for(i = digits.length - 1; i >= 0; --i){\n            output += alphabet[digits[i]];\n        }\n    }\n    if (maxline) {\n        var regex = new RegExp(\".{1,\" + maxline + \"}\", \"g\");\n        output = output.match(regex).join(\"\\r\\n\");\n    }\n    return output;\n};\n/**\n * Decodes a baseN-encoded (using the given alphabet) string to a\n * Uint8Array.\n *\n * @param input the baseN-encoded input string.\n *\n * @return the Uint8Array.\n */ api.decode = function(input, alphabet) {\n    if (typeof input !== \"string\") {\n        throw new TypeError('\"input\" must be a string.');\n    }\n    if (typeof alphabet !== \"string\") {\n        throw new TypeError('\"alphabet\" must be a string.');\n    }\n    var table = _reverseAlphabets[alphabet];\n    if (!table) {\n        // compute reverse alphabet\n        table = _reverseAlphabets[alphabet] = [];\n        for(var i = 0; i < alphabet.length; ++i){\n            table[alphabet.charCodeAt(i)] = i;\n        }\n    }\n    // remove whitespace characters\n    input = input.replace(/\\s/g, \"\");\n    var base = alphabet.length;\n    var first = alphabet.charAt(0);\n    var bytes = [\n        0\n    ];\n    for(var i = 0; i < input.length; i++){\n        var value = table[input.charCodeAt(i)];\n        if (value === undefined) {\n            return;\n        }\n        for(var j = 0, carry = value; j < bytes.length; ++j){\n            carry += bytes[j] * base;\n            bytes[j] = carry & 0xff;\n            carry >>= 8;\n        }\n        while(carry > 0){\n            bytes.push(carry & 0xff);\n            carry >>= 8;\n        }\n    }\n    // deal with leading zeros\n    for(var k = 0; input[k] === first && k < input.length - 1; ++k){\n        bytes.push(0);\n    }\n    if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(bytes.reverse());\n    }\n    return new Uint8Array(bytes.reverse());\n};\nfunction _encodeWithByteBuffer(input, alphabet) {\n    var i = 0;\n    var base = alphabet.length;\n    var first = alphabet.charAt(0);\n    var digits = [\n        0\n    ];\n    for(i = 0; i < input.length(); ++i){\n        for(var j = 0, carry = input.at(i); j < digits.length; ++j){\n            carry += digits[j] << 8;\n            digits[j] = carry % base;\n            carry = carry / base | 0;\n        }\n        while(carry > 0){\n            digits.push(carry % base);\n            carry = carry / base | 0;\n        }\n    }\n    var output = \"\";\n    // deal with leading zeros\n    for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i){\n        output += first;\n    }\n    // convert digits to a string\n    for(i = digits.length - 1; i >= 0; --i){\n        output += alphabet[digits[i]];\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYmFzZU4uanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDO0FBQ0QsSUFBSUEsTUFBTSxDQUFDO0FBQ1hDLE9BQU9DLE9BQU8sR0FBR0Y7QUFFakIseUJBQXlCO0FBQ3pCLElBQUlHLG9CQUFvQixDQUFDO0FBRXpCOzs7Ozs7OztDQVFDLEdBQ0RILElBQUlJLE1BQU0sR0FBRyxTQUFTQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsT0FBTztJQUM1QyxJQUFHLE9BQU9ELGFBQWEsVUFBVTtRQUMvQixNQUFNLElBQUlFLFVBQVU7SUFDdEI7SUFDQSxJQUFHRCxZQUFZRSxhQUFhLE9BQU9GLFlBQVksVUFBVTtRQUN2RCxNQUFNLElBQUlDLFVBQVU7SUFDdEI7SUFFQSxJQUFJRSxTQUFTO0lBRWIsSUFBRyxDQUFFTCxDQUFBQSxpQkFBaUJNLFVBQVMsR0FBSTtRQUNqQywyQkFBMkI7UUFDM0JELFNBQVNFLHNCQUFzQlAsT0FBT0M7SUFDeEMsT0FBTztRQUNMLElBQUlPLElBQUk7UUFDUixJQUFJQyxPQUFPUixTQUFTUyxNQUFNO1FBQzFCLElBQUlDLFFBQVFWLFNBQVNXLE1BQU0sQ0FBQztRQUM1QixJQUFJQyxTQUFTO1lBQUM7U0FBRTtRQUNoQixJQUFJTCxJQUFJLEdBQUdBLElBQUlSLE1BQU1VLE1BQU0sRUFBRSxFQUFFRixFQUFHO1lBQ2hDLElBQUksSUFBSU0sSUFBSSxHQUFHQyxRQUFRZixLQUFLLENBQUNRLEVBQUUsRUFBRU0sSUFBSUQsT0FBT0gsTUFBTSxFQUFFLEVBQUVJLEVBQUc7Z0JBQ3ZEQyxTQUFTRixNQUFNLENBQUNDLEVBQUUsSUFBSTtnQkFDdEJELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHQyxRQUFRTjtnQkFDcEJNLFFBQVEsUUFBU04sT0FBUTtZQUMzQjtZQUVBLE1BQU1NLFFBQVEsRUFBRztnQkFDZkYsT0FBT0csSUFBSSxDQUFDRCxRQUFR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QUksR0FBR0MsUUFBUWYsTUFBTStCLEVBQUUsQ0FBQ3ZCLElBQUlNLElBQUlELE9BQU9ILE1BQU0sRUFBRSxFQUFFSSxFQUFHO1lBQzFEQyxTQUFTRixNQUFNLENBQUNDLEVBQUUsSUFBSTtZQUN0QkQsTUFBTSxDQUFDQyxFQUFFLEdBQUdDLFFBQVFOO1lBQ3BCTSxRQUFRLFFBQVNOLE9BQVE7UUFDM0I7UUFFQSxNQUFNTSxRQUFRLEVBQUc7WUFDZkYsT0FBT0csSUFBSSxDQUFDRCxRQUFRTjtZQUNwQk0sUUFBUSxRQUFTTixPQUFRO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJSixTQUFTO0lBRWIsMEJBQTBCO0lBQzFCLElBQUlHLElBQUksR0FBR1IsTUFBTStCLEVBQUUsQ0FBQ3ZCLE9BQU8sS0FBS0EsSUFBSVIsTUFBTVUsTUFBTSxLQUFLLEdBQUcsRUFBRUYsRUFBRztRQUMzREgsVUFBVU07SUFDWjtJQUNBLDZCQUE2QjtJQUM3QixJQUFJSCxJQUFJSyxPQUFPSCxNQUFNLEdBQUcsR0FBR0YsS0FBSyxHQUFHLEVBQUVBLEVBQUc7UUFDdENILFVBQVVKLFFBQVEsQ0FBQ1ksTUFBTSxDQUFDTCxFQUFFLENBQUM7SUFDL0I7SUFFQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYmFzZU4uanM/Nzc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UtTi9CYXNlLVggZW5jb2RpbmcvZGVjb2RpbmcgZnVuY3Rpb25zLlxuICpcbiAqIE9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGZyb20gYmFzZS14OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iYXNlLXhcbiAqXG4gKiBXaGljaCBpcyBNSVQgbGljZW5zZWQ6XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG52YXIgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLy8gYmFzZU4gYWxwaGFiZXQgaW5kZXhlc1xudmFyIF9yZXZlcnNlQWxwaGFiZXRzID0ge307XG5cbi8qKlxuICogQmFzZU4tZW5jb2RlcyBhIFVpbnQ4QXJyYXkgdXNpbmcgdGhlIGdpdmVuIGFscGhhYmV0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW5jb2RlZCBjaGFyYWN0ZXJzIHBlciBsaW5lIHRvIHVzZSxcbiAqICAgICAgICAgIGRlZmF1bHRzIHRvIG5vbmUuXG4gKlxuICogQHJldHVybiB0aGUgYmFzZU4tZW5jb2RlZCBvdXRwdXQgc3RyaW5nLlxuICovXG5hcGkuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0LCBtYXhsaW5lKSB7XG4gIGlmKHR5cGVvZiBhbHBoYWJldCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFscGhhYmV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZihtYXhsaW5lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG1heGxpbmUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJtYXhsaW5lXCIgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICBpZighKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAvLyBhc3N1bWUgZm9yZ2UgYnl0ZSBidWZmZXJcbiAgICBvdXRwdXQgPSBfZW5jb2RlV2l0aEJ5dGVCdWZmZXIoaW5wdXQsIGFscGhhYmV0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gYWxwaGFiZXQuY2hhckF0KDApO1xuICAgIHZhciBkaWdpdHMgPSBbMF07XG4gICAgZm9yKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvcih2YXIgaiA9IDAsIGNhcnJ5ID0gaW5wdXRbaV07IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIGJhc2UpO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgIGZvcihpID0gMDsgaW5wdXRbaV0gPT09IDAgJiYgaSA8IGlucHV0Lmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgb3V0cHV0ICs9IGZpcnN0O1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgIGZvcihpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBvdXRwdXQgKz0gYWxwaGFiZXRbZGlnaXRzW2ldXTtcbiAgICB9XG4gIH1cblxuICBpZihtYXhsaW5lKSB7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnLnsxLCcgKyBtYXhsaW5lICsgJ30nLCAnZycpO1xuICAgIG91dHB1dCA9IG91dHB1dC5tYXRjaChyZWdleCkuam9pbignXFxyXFxuJyk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZU4tZW5jb2RlZCAodXNpbmcgdGhlIGdpdmVuIGFscGhhYmV0KSBzdHJpbmcgdG8gYVxuICogVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2VOLWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkuXG4gKi9cbmFwaS5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgYWxwaGFiZXQpIHtcbiAgaWYodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiaW5wdXRcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG4gIGlmKHR5cGVvZiBhbHBoYWJldCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFscGhhYmV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIHZhciB0YWJsZSA9IF9yZXZlcnNlQWxwaGFiZXRzW2FscGhhYmV0XTtcbiAgaWYoIXRhYmxlKSB7XG4gICAgLy8gY29tcHV0ZSByZXZlcnNlIGFscGhhYmV0XG4gICAgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF0gPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRhYmxlW2FscGhhYmV0LmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgdmFyIGZpcnN0ID0gYWxwaGFiZXQuY2hhckF0KDApO1xuICB2YXIgYnl0ZXMgPSBbMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IHRhYmxlW2lucHV0LmNoYXJDb2RlQXQoaSldO1xuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IHZhbHVlOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNhcnJ5ICs9IGJ5dGVzW2pdICogYmFzZTtcbiAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuXG4gICAgd2hpbGUoY2FycnkgPiAwKSB7XG4gICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZik7XG4gICAgICBjYXJyeSA+Pj0gODtcbiAgICB9XG4gIH1cblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IodmFyIGsgPSAwOyBpbnB1dFtrXSA9PT0gZmlyc3QgJiYgayA8IGlucHV0Lmxlbmd0aCAtIDE7ICsraykge1xuICAgIGJ5dGVzLnB1c2goMCk7XG4gIH1cblxuICBpZih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcy5yZXZlcnNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSk7XG59O1xuXG5mdW5jdGlvbiBfZW5jb2RlV2l0aEJ5dGVCdWZmZXIoaW5wdXQsIGFscGhhYmV0KSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGRpZ2l0cyA9IFswXTtcbiAgZm9yKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoKCk7ICsraSkge1xuICAgIGZvcih2YXIgaiA9IDAsIGNhcnJ5ID0gaW5wdXQuYXQoaSk7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBiYXNlO1xuICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgfVxuXG4gICAgd2hpbGUoY2FycnkgPiAwKSB7XG4gICAgICBkaWdpdHMucHVzaChjYXJyeSAlIGJhc2UpO1xuICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuXG4gIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gIGZvcihpID0gMDsgaW5wdXQuYXQoaSkgPT09IDAgJiYgaSA8IGlucHV0Lmxlbmd0aCgpIC0gMTsgKytpKSB7XG4gICAgb3V0cHV0ICs9IGZpcnN0O1xuICB9XG4gIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gIGZvcihpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuIl0sIm5hbWVzIjpbImFwaSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfcmV2ZXJzZUFscGhhYmV0cyIsImVuY29kZSIsImlucHV0IiwiYWxwaGFiZXQiLCJtYXhsaW5lIiwiVHlwZUVycm9yIiwidW5kZWZpbmVkIiwib3V0cHV0IiwiVWludDhBcnJheSIsIl9lbmNvZGVXaXRoQnl0ZUJ1ZmZlciIsImkiLCJiYXNlIiwibGVuZ3RoIiwiZmlyc3QiLCJjaGFyQXQiLCJkaWdpdHMiLCJqIiwiY2FycnkiLCJwdXNoIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImpvaW4iLCJkZWNvZGUiLCJ0YWJsZSIsImNoYXJDb2RlQXQiLCJyZXBsYWNlIiwiYnl0ZXMiLCJ2YWx1ZSIsImsiLCJCdWZmZXIiLCJmcm9tIiwicmV2ZXJzZSIsImF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/baseN.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/cipher.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Cipher base API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nmodule.exports = forge.cipher = forge.cipher || {};\n// registered algorithms\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n/**\n * Creates a cipher object that can be used to encrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */ forge.cipher.createCipher = function(algorithm, key) {\n    var api = algorithm;\n    if (typeof api === \"string\") {\n        api = forge.cipher.getAlgorithm(api);\n        if (api) {\n            api = api();\n        }\n    }\n    if (!api) {\n        throw new Error(\"Unsupported algorithm: \" + algorithm);\n    }\n    // assume block cipher\n    return new forge.cipher.BlockCipher({\n        algorithm: api,\n        key: key,\n        decrypt: false\n    });\n};\n/**\n * Creates a decipher object that can be used to decrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */ forge.cipher.createDecipher = function(algorithm, key) {\n    var api = algorithm;\n    if (typeof api === \"string\") {\n        api = forge.cipher.getAlgorithm(api);\n        if (api) {\n            api = api();\n        }\n    }\n    if (!api) {\n        throw new Error(\"Unsupported algorithm: \" + algorithm);\n    }\n    // assume block cipher\n    return new forge.cipher.BlockCipher({\n        algorithm: api,\n        key: key,\n        decrypt: true\n    });\n};\n/**\n * Registers an algorithm by name. If the name was already registered, the\n * algorithm API object will be overwritten.\n *\n * @param name the name of the algorithm.\n * @param algorithm the algorithm API object.\n */ forge.cipher.registerAlgorithm = function(name, algorithm) {\n    name = name.toUpperCase();\n    forge.cipher.algorithms[name] = algorithm;\n};\n/**\n * Gets a registered algorithm by name.\n *\n * @param name the name of the algorithm.\n *\n * @return the algorithm, if found, null if not.\n */ forge.cipher.getAlgorithm = function(name) {\n    name = name.toUpperCase();\n    if (name in forge.cipher.algorithms) {\n        return forge.cipher.algorithms[name];\n    }\n    return null;\n};\nvar BlockCipher = forge.cipher.BlockCipher = function(options) {\n    this.algorithm = options.algorithm;\n    this.mode = this.algorithm.mode;\n    this.blockSize = this.mode.blockSize;\n    this._finish = false;\n    this._input = null;\n    this.output = null;\n    this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n    this._decrypt = options.decrypt;\n    this.algorithm.initialize(options);\n};\n/**\n * Starts or restarts the encryption or decryption process, whichever\n * was previously configured.\n *\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\n * 32-bit integers, then it must be 4 integers long.\n *\n * Note: an IV is not required or used in ECB mode.\n *\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\n * by NIST SP-800-38D but another length may be given.\n *\n * @param options the options to use:\n *          iv the initialization vector to use as a binary-encoded string of\n *            bytes, null to reuse the last ciphered block from a previous\n *            update() (this \"residue\" method is for legacy support only).\n *          additionalData additional authentication data as a binary-encoded\n *            string of bytes, for 'GCM' mode, (default: none).\n *          tagLength desired length of authentication tag, in bits, for\n *            'GCM' mode (0-128, default: 128).\n *          tag the authentication tag to check if decrypting, as a\n *             binary-encoded string of bytes.\n *          output the output the buffer to write to, null to create one.\n */ BlockCipher.prototype.start = function(options) {\n    options = options || {};\n    var opts = {};\n    for(var key in options){\n        opts[key] = options[key];\n    }\n    opts.decrypt = this._decrypt;\n    this._finish = false;\n    this._input = forge.util.createBuffer();\n    this.output = options.output || forge.util.createBuffer();\n    this.mode.start(opts);\n};\n/**\n * Updates the next block according to the cipher mode.\n *\n * @param input the buffer to read from.\n */ BlockCipher.prototype.update = function(input) {\n    if (input) {\n        // input given, so empty it into the input buffer\n        this._input.putBuffer(input);\n    }\n    // do cipher operation until it needs more input and not finished\n    while(!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish){}\n    // free consumed memory from input buffer\n    this._input.compact();\n};\n/**\n * Finishes encrypting or decrypting.\n *\n * @param pad a padding function to use in CBC mode, null for default,\n *          signature(blockSize, buffer, decrypt).\n *\n * @return true if successful, false on error.\n */ BlockCipher.prototype.finish = function(pad) {\n    // backwards-compatibility w/deprecated padding API\n    // Note: will overwrite padding functions even after another start() call\n    if (pad && (this.mode.name === \"ECB\" || this.mode.name === \"CBC\")) {\n        this.mode.pad = function(input) {\n            return pad(this.blockSize, input, false);\n        };\n        this.mode.unpad = function(output) {\n            return pad(this.blockSize, output, true);\n        };\n    }\n    // build options for padding and afterFinish functions\n    var options = {};\n    options.decrypt = this._decrypt;\n    // get # of bytes that won't fill a block\n    options.overflow = this._input.length() % this.blockSize;\n    if (!this._decrypt && this.mode.pad) {\n        if (!this.mode.pad(this._input, options)) {\n            return false;\n        }\n    }\n    // do final update\n    this._finish = true;\n    this.update();\n    if (this._decrypt && this.mode.unpad) {\n        if (!this.mode.unpad(this.output, options)) {\n            return false;\n        }\n    }\n    if (this.mode.afterFinish) {\n        if (!this.mode.afterFinish(this.output, options)) {\n            return false;\n        }\n    }\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLE1BQU0sR0FBR0osTUFBTUksTUFBTSxJQUFJLENBQUM7QUFFakQsd0JBQXdCO0FBQ3hCSixNQUFNSSxNQUFNLENBQUNDLFVBQVUsR0FBR0wsTUFBTUksTUFBTSxDQUFDQyxVQUFVLElBQUksQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7O0NBWUMsR0FDREwsTUFBTUksTUFBTSxDQUFDRSxZQUFZLEdBQUcsU0FBU0MsU0FBUyxFQUFFQyxHQUFHO0lBQ2pELElBQUlDLE1BQU1GO0lBQ1YsSUFBRyxPQUFPRSxRQUFRLFVBQVU7UUFDMUJBLE1BQU1ULE1BQU1JLE1BQU0sQ0FBQ00sWUFBWSxDQUFDRDtRQUNoQyxJQUFHQSxLQUFLO1lBQ05BLE1BQU1BO1FBQ1I7SUFDRjtJQUNBLElBQUcsQ0FBQ0EsS0FBSztRQUNQLE1BQU0sSUFBSUUsTUFBTSw0QkFBNEJKO0lBQzlDO0lBRUEsc0JBQXNCO0lBQ3RCLE9BQU8sSUFBSVAsTUFBTUksTUFBTSxDQUFDUSxXQUFXLENBQUM7UUFDbENMLFdBQVdFO1FBQ1hELEtBQUtBO1FBQ0xLLFNBQVM7SUFDWDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0RiLE1BQU1JLE1BQU0sQ0FBQ1UsY0FBYyxHQUFHLFNBQVNQLFNBQVMsRUFBRUMsR0FBRztJQUNuRCxJQUFJQyxNQUFNRjtJQUNWLElBQUcsT0FBT0UsUUFBUSxVQUFVO1FBQzFCQSxNQUFNVCxNQUFNSSxNQUFNLENBQUNNLFlBQVksQ0FBQ0Q7UUFDaEMsSUFBR0EsS0FBSztZQUNOQSxNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxJQUFHLENBQUNBLEtBQUs7UUFDUCxNQUFNLElBQUlFLE1BQU0sNEJBQTRCSjtJQUM5QztJ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O1FBQ3hCLElBQUcsQ0FBQyxJQUFJLENBQUN4QixJQUFJLENBQUN3QixXQUFXLENBQUMsSUFBSSxDQUFDcEIsTUFBTSxFQUFFTCxVQUFVO1lBQy9DLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyLmpzPzgyMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaXBoZXIgYmFzZSBBUEkuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5jaXBoZXIgPSBmb3JnZS5jaXBoZXIgfHwge307XG5cbi8vIHJlZ2lzdGVyZWQgYWxnb3JpdGhtc1xuZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXMgPSBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyB8fCB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2lwaGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW5cbiAqIGFsZ29yaXRobSBhbmQga2V5LiBUaGUgYWxnb3JpdGhtIG1heSBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyB2YWx1ZSBmb3IgYVxuICogcHJldmlvdXNseSByZWdpc3RlcmVkIGFsZ29yaXRobSBvciBpdCBtYXkgYmUgZ2l2ZW4gYXMgYSBjaXBoZXIgYWxnb3JpdGhtXG4gKiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UsIGVpdGhlciBhIHN0cmluZyBvciBhbiBhbGdvcml0aG0gQVBJXG4gKiAgICAgICAgICBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhXG4gKiAgICAgICAgICBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIgPSBmdW5jdGlvbihhbGdvcml0aG0sIGtleSkge1xuICB2YXIgYXBpID0gYWxnb3JpdGhtO1xuICBpZih0eXBlb2YgYXBpID09PSAnc3RyaW5nJykge1xuICAgIGFwaSA9IGZvcmdlLmNpcGhlci5nZXRBbGdvcml0aG0oYXBpKTtcbiAgICBpZihhcGkpIHtcbiAgICAgIGFwaSA9IGFwaSgpO1xuICAgIH1cbiAgfVxuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBhbGdvcml0aG0pO1xuICB9XG5cbiAgLy8gYXNzdW1lIGJsb2NrIGNpcGhlclxuICByZXR1cm4gbmV3IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlcih7XG4gICAgYWxnb3JpdGhtOiBhcGksXG4gICAga2V5OiBrZXksXG4gICAgZGVjcnlwdDogZmFsc2VcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWNpcGhlciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuXG4gKiBhbGdvcml0aG0gYW5kIGtleS4gVGhlIGFsZ29yaXRobSBtYXkgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcgdmFsdWUgZm9yIGFcbiAqIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBhbGdvcml0aG0gb3IgaXQgbWF5IGJlIGdpdmVuIGFzIGEgY2lwaGVyIGFsZ29yaXRobVxuICogQVBJIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlLCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYWxnb3JpdGhtIEFQSVxuICogICAgICAgICAgb2JqZWN0LlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYVxuICogICAgICAgICAgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIgPSBmdW5jdGlvbihhbGdvcml0aG0sIGtleSkge1xuICB2YXIgYXBpID0gYWxnb3JpdGhtO1xuICBpZih0eXBlb2YgYXBpID09PSAnc3RyaW5nJykge1xuICAgIGFwaSA9IGZvcmdlLmNpcGhlci5nZXRBbGdvcml0aG0oYXBpKTtcbiAgICBpZihhcGkpIHtcbiAgICAgIGFwaSA9IGFwaSgpO1xuICAgIH1cbiAgfVxuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBhbGdvcml0aG0pO1xuICB9XG5cbiAgLy8gYXNzdW1lIGJsb2NrIGNpcGhlclxuICByZXR1cm4gbmV3IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlcih7XG4gICAgYWxnb3JpdGhtOiBhcGksXG4gICAga2V5OiBrZXksXG4gICAgZGVjcnlwdDogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGFsZ29yaXRobSBieSBuYW1lLiBJZiB0aGUgbmFtZSB3YXMgYWxyZWFkeSByZWdpc3RlcmVkLCB0aGVcbiAqIGFsZ29yaXRobSBBUEkgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSBBUEkgb2JqZWN0LlxuICovXG5mb3JnZS5jaXBoZXIucmVnaXN0ZXJBbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBhbGdvcml0aG0pIHtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXNbbmFtZV0gPSBhbGdvcml0aG07XG59O1xuXG4vKipcbiAqIEdldHMgYSByZWdpc3RlcmVkIGFsZ29yaXRobSBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKlxuICogQHJldHVybiB0aGUgYWxnb3JpdGhtLCBpZiBmb3VuZCwgbnVsbCBpZiBub3QuXG4gKi9cbmZvcmdlLmNpcGhlci5nZXRBbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gIGlmKG5hbWUgaW4gZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXMpIHtcbiAgICByZXR1cm4gZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgQmxvY2tDaXBoZXIgPSBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gIHRoaXMubW9kZSA9IHRoaXMuYWxnb3JpdGhtLm1vZGU7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5tb2RlLmJsb2NrU2l6ZTtcbiAgdGhpcy5fZmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgdGhpcy5vdXRwdXQgPSBudWxsO1xuICB0aGlzLl9vcCA9IG9wdGlvbnMuZGVjcnlwdCA/IHRoaXMubW9kZS5kZWNyeXB0IDogdGhpcy5tb2RlLmVuY3J5cHQ7XG4gIHRoaXMuX2RlY3J5cHQgPSBvcHRpb25zLmRlY3J5cHQ7XG4gIHRoaXMuYWxnb3JpdGhtLmluaXRpYWxpemUob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBvciByZXN0YXJ0cyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MsIHdoaWNoZXZlclxuICogd2FzIHByZXZpb3VzbHkgY29uZmlndXJlZC5cbiAqXG4gKiBGb3Igbm9uLUdDTSBtb2RlLCB0aGUgSVYgbWF5IGJlIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheVxuICogb2YgYnl0ZXMsIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCBpbnRlZ2Vycy4gSWYgdGhlIElWIGlzIGluXG4gKiBieXRlcywgdGhlbiBpdCBtdXN0IGJlIE5iICgxNikgYnl0ZXMgaW4gbGVuZ3RoLiBJZiB0aGUgSVYgaXMgZ2l2ZW4gaW4gYXNcbiAqIDMyLWJpdCBpbnRlZ2VycywgdGhlbiBpdCBtdXN0IGJlIDQgaW50ZWdlcnMgbG9uZy5cbiAqXG4gKiBOb3RlOiBhbiBJViBpcyBub3QgcmVxdWlyZWQgb3IgdXNlZCBpbiBFQ0IgbW9kZS5cbiAqXG4gKiBGb3IgR0NNLW1vZGUsIHRoZSBJViBtdXN0IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yXG4gKiBhIGJ5dGUgYnVmZmVyLiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHNob3VsZCBiZSAxMiAoOTYgYml0cykgYXMgcmVjb21tZW5kZWRcbiAqIGJ5IE5JU1QgU1AtODAwLTM4RCBidXQgYW5vdGhlciBsZW5ndGggbWF5IGJlIGdpdmVuLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mXG4gKiAgICAgICAgICAgIGJ5dGVzLCBudWxsIHRvIHJldXNlIHRoZSBsYXN0IGNpcGhlcmVkIGJsb2NrIGZyb20gYSBwcmV2aW91c1xuICogICAgICAgICAgICB1cGRhdGUoKSAodGhpcyBcInJlc2lkdWVcIiBtZXRob2QgaXMgZm9yIGxlZ2FjeSBzdXBwb3J0IG9ubHkpLlxuICogICAgICAgICAgYWRkaXRpb25hbERhdGEgYWRkaXRpb25hbCBhdXRoZW50aWNhdGlvbiBkYXRhIGFzIGEgYmluYXJ5LWVuY29kZWRcbiAqICAgICAgICAgICAgc3RyaW5nIG9mIGJ5dGVzLCBmb3IgJ0dDTScgbW9kZSwgKGRlZmF1bHQ6IG5vbmUpLlxuICogICAgICAgICAgdGFnTGVuZ3RoIGRlc2lyZWQgbGVuZ3RoIG9mIGF1dGhlbnRpY2F0aW9uIHRhZywgaW4gYml0cywgZm9yXG4gKiAgICAgICAgICAgICdHQ00nIG1vZGUgKDAtMTI4LCBkZWZhdWx0OiAxMjgpLlxuICogICAgICAgICAgdGFnIHRoZSBhdXRoZW50aWNhdGlvbiB0YWcgdG8gY2hlY2sgaWYgZGVjcnlwdGluZywgYXMgYVxuICogICAgICAgICAgICAgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgb3B0cyA9IHt9O1xuICBmb3IodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIG9wdHMuZGVjcnlwdCA9IHRoaXMuX2RlY3J5cHQ7XG4gIHRoaXMuX2ZpbmlzaCA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMub3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQgfHwgZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5tb2RlLnN0YXJ0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBuZXh0IGJsb2NrIGFjY29yZGluZyB0byB0aGUgY2lwaGVyIG1vZGUuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBidWZmZXIgdG8gcmVhZCBmcm9tLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYoaW5wdXQpIHtcbiAgICAvLyBpbnB1dCBnaXZlbiwgc28gZW1wdHkgaXQgaW50byB0aGUgaW5wdXQgYnVmZmVyXG4gICAgdGhpcy5faW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgfVxuXG4gIC8vIGRvIGNpcGhlciBvcGVyYXRpb24gdW50aWwgaXQgbmVlZHMgbW9yZSBpbnB1dCBhbmQgbm90IGZpbmlzaGVkXG4gIHdoaWxlKCF0aGlzLl9vcC5jYWxsKHRoaXMubW9kZSwgdGhpcy5faW5wdXQsIHRoaXMub3V0cHV0LCB0aGlzLl9maW5pc2gpICYmXG4gICAgIXRoaXMuX2ZpbmlzaCkge31cblxuICAvLyBmcmVlIGNvbnN1bWVkIG1lbW9yeSBmcm9tIGlucHV0IGJ1ZmZlclxuICB0aGlzLl9pbnB1dC5jb21wYWN0KCk7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIGVuY3J5cHRpbmcgb3IgZGVjcnlwdGluZy5cbiAqXG4gKiBAcGFyYW0gcGFkIGEgcGFkZGluZyBmdW5jdGlvbiB0byB1c2UgaW4gQ0JDIG1vZGUsIG51bGwgZm9yIGRlZmF1bHQsXG4gKiAgICAgICAgICBzaWduYXR1cmUoYmxvY2tTaXplLCBidWZmZXIsIGRlY3J5cHQpLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBzdWNjZXNzZnVsLCBmYWxzZSBvbiBlcnJvci5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKHBhZCkge1xuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3L2RlcHJlY2F0ZWQgcGFkZGluZyBBUElcbiAgLy8gTm90ZTogd2lsbCBvdmVyd3JpdGUgcGFkZGluZyBmdW5jdGlvbnMgZXZlbiBhZnRlciBhbm90aGVyIHN0YXJ0KCkgY2FsbFxuICBpZihwYWQgJiYgKHRoaXMubW9kZS5uYW1lID09PSAnRUNCJyB8fCB0aGlzLm1vZGUubmFtZSA9PT0gJ0NCQycpKSB7XG4gICAgdGhpcy5tb2RlLnBhZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gcGFkKHRoaXMuYmxvY2tTaXplLCBpbnB1dCwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5tb2RlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICByZXR1cm4gcGFkKHRoaXMuYmxvY2tTaXplLCBvdXRwdXQsIHRydWUpO1xuICAgIH07XG4gIH1cblxuICAvLyBidWlsZCBvcHRpb25zIGZvciBwYWRkaW5nIGFuZCBhZnRlckZpbmlzaCBmdW5jdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgb3B0aW9ucy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcblxuICAvLyBnZXQgIyBvZiBieXRlcyB0aGF0IHdvbid0IGZpbGwgYSBibG9ja1xuICBvcHRpb25zLm92ZXJmbG93ID0gdGhpcy5faW5wdXQubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcblxuICBpZighdGhpcy5fZGVjcnlwdCAmJiB0aGlzLm1vZGUucGFkKSB7XG4gICAgaWYoIXRoaXMubW9kZS5wYWQodGhpcy5faW5wdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8gZmluYWwgdXBkYXRlXG4gIHRoaXMuX2ZpbmlzaCA9IHRydWU7XG4gIHRoaXMudXBkYXRlKCk7XG5cbiAgaWYodGhpcy5fZGVjcnlwdCAmJiB0aGlzLm1vZGUudW5wYWQpIHtcbiAgICBpZighdGhpcy5tb2RlLnVucGFkKHRoaXMub3V0cHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKHRoaXMubW9kZS5hZnRlckZpbmlzaCkge1xuICAgIGlmKCF0aGlzLm1vZGUuYWZ0ZXJGaW5pc2godGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaXBoZXIiLCJhbGdvcml0aG1zIiwiY3JlYXRlQ2lwaGVyIiwiYWxnb3JpdGhtIiwia2V5IiwiYXBpIiwiZ2V0QWxnb3JpdGhtIiwiRXJyb3IiLCJCbG9ja0NpcGhlciIsImRlY3J5cHQiLCJjcmVhdGVEZWNpcGhlciIsInJlZ2lzdGVyQWxnb3JpdGhtIiwibmFtZSIsInRvVXBwZXJDYXNlIiwib3B0aW9ucyIsIm1vZGUiLCJibG9ja1NpemUiLCJfZmluaXNoIiwiX2lucHV0Iiwib3V0cHV0IiwiX29wIiwiZW5jcnlwdCIsIl9kZWNyeXB0IiwiaW5pdGlhbGl6ZSIsInByb3RvdHlwZSIsInN0YXJ0Iiwib3B0cyIsInV0aWwiLCJjcmVhdGVCdWZmZXIiLCJ1cGRhdGUiLCJpbnB1dCIsInB1dEJ1ZmZlciIsImNhbGwiLCJjb21wYWN0IiwiZmluaXNoIiwicGFkIiwidW5wYWQiLCJvdmVyZmxvdyIsImxlbmd0aCIsImFmdGVyRmluaXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/cipher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/cipherModes.js":
/*!****************************************************!*\
  !*** ./node_modules/node-forge/lib/cipherModes.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nforge.cipher = forge.cipher || {};\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/ modes.ecb = function(options) {\n    options = options || {};\n    this.name = \"ECB\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = new Array(this._ints);\n    this._outBlock = new Array(this._ints);\n};\nmodes.ecb.prototype.start = function(options) {};\nmodes.ecb.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = input.getInt32();\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // write output\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i]);\n    }\n};\nmodes.ecb.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = input.getInt32();\n    }\n    // decrypt block\n    this.cipher.decrypt(this._inBlock, this._outBlock);\n    // write output\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i]);\n    }\n};\nmodes.ecb.prototype.pad = function(input, options) {\n    // add PKCS#7 padding to block (each pad byte is the\n    // value of the number of pad bytes)\n    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n    input.fillWithByte(padding, padding);\n    return true;\n};\nmodes.ecb.prototype.unpad = function(output, options) {\n    // check for error: input data not a multiple of blockSize\n    if (options.overflow > 0) {\n        return false;\n    }\n    // ensure padding byte count is valid\n    var len = output.length();\n    var count = output.at(len - 1);\n    if (count > this.blockSize << 2) {\n        return false;\n    }\n    // trim off padding bytes\n    output.truncate(count);\n    return true;\n};\n/** Cipher-block Chaining (CBC) **/ modes.cbc = function(options) {\n    options = options || {};\n    this.name = \"CBC\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = new Array(this._ints);\n    this._outBlock = new Array(this._ints);\n};\nmodes.cbc.prototype.start = function(options) {\n    // Note: legacy support for using IV residue (has security flaws)\n    // if IV is null, reuse block from previous processing\n    if (options.iv === null) {\n        // must have a previous block\n        if (!this._prev) {\n            throw new Error(\"Invalid IV parameter.\");\n        }\n        this._iv = this._prev.slice(0);\n    } else if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    } else {\n        // save IV as \"previous\" block\n        this._iv = transformIV(options.iv, this.blockSize);\n        this._prev = this._iv.slice(0);\n    }\n};\nmodes.cbc.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    // CBC XOR's IV (or previous block) with plaintext\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = this._prev[i] ^ input.getInt32();\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // write output, save previous block\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i]);\n    }\n    this._prev = this._outBlock;\n};\nmodes.cbc.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = input.getInt32();\n    }\n    // decrypt block\n    this.cipher.decrypt(this._inBlock, this._outBlock);\n    // write output, save previous ciphered block\n    // CBC XOR's IV (or previous block) with ciphertext\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._prev[i] ^ this._outBlock[i]);\n    }\n    this._prev = this._inBlock.slice(0);\n};\nmodes.cbc.prototype.pad = function(input, options) {\n    // add PKCS#7 padding to block (each pad byte is the\n    // value of the number of pad bytes)\n    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n    input.fillWithByte(padding, padding);\n    return true;\n};\nmodes.cbc.prototype.unpad = function(output, options) {\n    // check for error: input data not a multiple of blockSize\n    if (options.overflow > 0) {\n        return false;\n    }\n    // ensure padding byte count is valid\n    var len = output.length();\n    var count = output.at(len - 1);\n    if (count > this.blockSize << 2) {\n        return false;\n    }\n    // trim off padding bytes\n    output.truncate(count);\n    return true;\n};\n/** Cipher feedback (CFB) **/ modes.cfb = function(options) {\n    options = options || {};\n    this.name = \"CFB\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = null;\n    this._outBlock = new Array(this._ints);\n    this._partialBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n};\nmodes.cfb.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // use IV as first input\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._inBlock = this._iv.slice(0);\n    this._partialBytes = 0;\n};\nmodes.cfb.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output, write input as output\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n            output.putInt32(this._inBlock[i]);\n        }\n        return;\n    }\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n    }\n    // XOR input with output, write input as partial output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i){\n        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n        this._partialOutput.putInt32(this._partialBlock[i]);\n    }\n    if (partialBytes > 0) {\n        // block still incomplete, restore input buffer\n        input.read -= this.blockSize;\n    } else {\n        // block complete, update input block\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = this._partialBlock[i];\n        }\n    }\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n        this._partialBytes = partialBytes;\n        return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n};\nmodes.cfb.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block (CFB always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output, write input as output\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = input.getInt32();\n            output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n        }\n        return;\n    }\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n    }\n    // XOR input with output, write input as partial output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i){\n        this._partialBlock[i] = input.getInt32();\n        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n    }\n    if (partialBytes > 0) {\n        // block still incomplete, restore input buffer\n        input.read -= this.blockSize;\n    } else {\n        // block complete, update input block\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = this._partialBlock[i];\n        }\n    }\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n        this._partialBytes = partialBytes;\n        return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n};\n/** Output feedback (OFB) **/ modes.ofb = function(options) {\n    options = options || {};\n    this.name = \"OFB\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = null;\n    this._outBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n};\nmodes.ofb.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // use IV as first input\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._inBlock = this._iv.slice(0);\n    this._partialBytes = 0;\n};\nmodes.ofb.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (input.length() === 0) {\n        return true;\n    }\n    // encrypt block (OFB always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output and update next input\n        for(var i = 0; i < this._ints; ++i){\n            output.putInt32(input.getInt32() ^ this._outBlock[i]);\n            this._inBlock[i] = this._outBlock[i];\n        }\n        return;\n    }\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n    }\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i){\n        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n    if (partialBytes > 0) {\n        // block still incomplete, restore input buffer\n        input.read -= this.blockSize;\n    } else {\n        // block complete, update input block\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = this._outBlock[i];\n        }\n    }\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n        this._partialBytes = partialBytes;\n        return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n};\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n/** Counter (CTR) **/ modes.ctr = function(options) {\n    options = options || {};\n    this.name = \"CTR\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = null;\n    this._outBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n};\nmodes.ctr.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // use IV as first input\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._inBlock = this._iv.slice(0);\n    this._partialBytes = 0;\n};\nmodes.ctr.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block (CTR always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output\n        for(var i = 0; i < this._ints; ++i){\n            output.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n    } else {\n        // handle partial block\n        var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n        if (partialBytes > 0) {\n            partialBytes = this.blockSize - partialBytes;\n        }\n        // XOR input with output\n        this._partialOutput.clear();\n        for(var i = 0; i < this._ints; ++i){\n            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n        if (partialBytes > 0) {\n            // block still incomplete, restore input buffer\n            input.read -= this.blockSize;\n        }\n        // skip any previous partial bytes\n        if (this._partialBytes > 0) {\n            this._partialOutput.getBytes(this._partialBytes);\n        }\n        if (partialBytes > 0 && !finish) {\n            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n            this._partialBytes = partialBytes;\n            return true;\n        }\n        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n        this._partialBytes = 0;\n    }\n    // block complete, increment counter (input block)\n    inc32(this._inBlock);\n};\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n/** Galois/Counter Mode (GCM) **/ modes.gcm = function(options) {\n    options = options || {};\n    this.name = \"GCM\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = new Array(this._ints);\n    this._outBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n    // R is actually this value concatenated with 120 more zero bits, but\n    // we only XOR against R so the other zeros have no effect -- we just\n    // apply this value to the first integer in a block\n    this._R = 0xE1000000;\n};\nmodes.gcm.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // ensure IV is a byte buffer\n    var iv = forge.util.createBuffer(options.iv);\n    // no ciphered data processed yet\n    this._cipherLength = 0;\n    // default additional data is none\n    var additionalData;\n    if (\"additionalData\" in options) {\n        additionalData = forge.util.createBuffer(options.additionalData);\n    } else {\n        additionalData = forge.util.createBuffer();\n    }\n    // default tag length is 128 bits\n    if (\"tagLength\" in options) {\n        this._tagLength = options.tagLength;\n    } else {\n        this._tagLength = 128;\n    }\n    // if tag is given, ensure tag matches tag length\n    this._tag = null;\n    if (options.decrypt) {\n        // save tag to check later\n        this._tag = forge.util.createBuffer(options.tag).getBytes();\n        if (this._tag.length !== this._tagLength / 8) {\n            throw new Error(\"Authentication tag does not match tag length.\");\n        }\n    }\n    // create tmp storage for hash calculation\n    this._hashBlock = new Array(this._ints);\n    // no tag generated yet\n    this.tag = null;\n    // generate hash subkey\n    // (apply block cipher to \"zero\" block)\n    this._hashSubkey = new Array(this._ints);\n    this.cipher.encrypt([\n        0,\n        0,\n        0,\n        0\n    ], this._hashSubkey);\n    // generate table M\n    // use 4-bit tables (32 component decomposition of a 16 byte value)\n    // 8-bit tables take more space and are known to have security\n    // vulnerabilities (in native implementations)\n    this.componentBits = 4;\n    this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n    // Note: support IV length different from 96 bits? (only supporting\n    // 96 bits is recommended by NIST SP-800-38D)\n    // generate J_0\n    var ivLength = iv.length();\n    if (ivLength === 12) {\n        // 96-bit IV\n        this._j0 = [\n            iv.getInt32(),\n            iv.getInt32(),\n            iv.getInt32(),\n            1\n        ];\n    } else {\n        // IV is NOT 96-bits\n        this._j0 = [\n            0,\n            0,\n            0,\n            0\n        ];\n        while(iv.length() > 0){\n            this._j0 = this.ghash(this._hashSubkey, this._j0, [\n                iv.getInt32(),\n                iv.getInt32(),\n                iv.getInt32(),\n                iv.getInt32()\n            ]);\n        }\n        this._j0 = this.ghash(this._hashSubkey, this._j0, [\n            0,\n            0\n        ].concat(from64To32(ivLength * 8)));\n    }\n    // generate ICB (initial counter block)\n    this._inBlock = this._j0.slice(0);\n    inc32(this._inBlock);\n    this._partialBytes = 0;\n    // consume authentication data\n    additionalData = forge.util.createBuffer(additionalData);\n    // save additional data length as a BE 64-bit number\n    this._aDataLength = from64To32(additionalData.length() * 8);\n    // pad additional data to 128 bit (16 byte) block size\n    var overflow = additionalData.length() % this.blockSize;\n    if (overflow) {\n        additionalData.fillWithByte(0, this.blockSize - overflow);\n    }\n    this._s = [\n        0,\n        0,\n        0,\n        0\n    ];\n    while(additionalData.length() > 0){\n        this._s = this.ghash(this._hashSubkey, this._s, [\n            additionalData.getInt32(),\n            additionalData.getInt32(),\n            additionalData.getInt32(),\n            additionalData.getInt32()\n        ]);\n    }\n};\nmodes.gcm.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output\n        for(var i = 0; i < this._ints; ++i){\n            output.putInt32(this._outBlock[i] ^= input.getInt32());\n        }\n        this._cipherLength += this.blockSize;\n    } else {\n        // handle partial block\n        var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n        if (partialBytes > 0) {\n            partialBytes = this.blockSize - partialBytes;\n        }\n        // XOR input with output\n        this._partialOutput.clear();\n        for(var i = 0; i < this._ints; ++i){\n            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n        if (partialBytes <= 0 || finish) {\n            // handle overflow prior to hashing\n            if (finish) {\n                // get block overflow\n                var overflow = inputLength % this.blockSize;\n                this._cipherLength += overflow;\n                // truncate for hash function\n                this._partialOutput.truncate(this.blockSize - overflow);\n            } else {\n                this._cipherLength += this.blockSize;\n            }\n            // get output block for hashing\n            for(var i = 0; i < this._ints; ++i){\n                this._outBlock[i] = this._partialOutput.getInt32();\n            }\n            this._partialOutput.read -= this.blockSize;\n        }\n        // skip any previous partial bytes\n        if (this._partialBytes > 0) {\n            this._partialOutput.getBytes(this._partialBytes);\n        }\n        if (partialBytes > 0 && !finish) {\n            // block still incomplete, restore input buffer, get partial output,\n            // and return early\n            input.read -= this.blockSize;\n            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n            this._partialBytes = partialBytes;\n            return true;\n        }\n        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n        this._partialBytes = 0;\n    }\n    // update hash block S\n    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n    // increment counter (input block)\n    inc32(this._inBlock);\n};\nmodes.gcm.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    var inputLength = input.length();\n    if (inputLength < this.blockSize && !(finish && inputLength > 0)) {\n        return true;\n    }\n    // encrypt block (GCM always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // increment counter (input block)\n    inc32(this._inBlock);\n    // update hash block S\n    this._hashBlock[0] = input.getInt32();\n    this._hashBlock[1] = input.getInt32();\n    this._hashBlock[2] = input.getInt32();\n    this._hashBlock[3] = input.getInt32();\n    this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n    // XOR hash input with output\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n    }\n    // increment cipher data length\n    if (inputLength < this.blockSize) {\n        this._cipherLength += inputLength % this.blockSize;\n    } else {\n        this._cipherLength += this.blockSize;\n    }\n};\nmodes.gcm.prototype.afterFinish = function(output, options) {\n    var rval = true;\n    // handle overflow\n    if (options.decrypt && options.overflow) {\n        output.truncate(this.blockSize - options.overflow);\n    }\n    // handle authentication tag\n    this.tag = forge.util.createBuffer();\n    // concatenate additional data length with cipher length\n    var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n    // include lengths in hash\n    this._s = this.ghash(this._hashSubkey, this._s, lengths);\n    // do GCTR(J_0, S)\n    var tag = [];\n    this.cipher.encrypt(this._j0, tag);\n    for(var i = 0; i < this._ints; ++i){\n        this.tag.putInt32(this._s[i] ^ tag[i]);\n    }\n    // trim tag to length\n    this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n    // check authentication tag\n    if (options.decrypt && this.tag.bytes() !== this._tag) {\n        rval = false;\n    }\n    return rval;\n};\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */ modes.gcm.prototype.multiply = function(x, y) {\n    var z_i = [\n        0,\n        0,\n        0,\n        0\n    ];\n    var v_i = y.slice(0);\n    // calculate Z_128 (block has 128 bits)\n    for(var i = 0; i < 128; ++i){\n        // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n        // else Z_{i+1} = Z_i ^ V_i\n        // get x_i by finding 32-bit int position, then left shift 1 by remainder\n        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;\n        if (x_i) {\n            z_i[0] ^= v_i[0];\n            z_i[1] ^= v_i[1];\n            z_i[2] ^= v_i[2];\n            z_i[3] ^= v_i[3];\n        }\n        // if LSB(V_i) is 1, V_i = V_i >> 1\n        // else V_i = (V_i >> 1) ^ R\n        this.pow(v_i, v_i);\n    }\n    return z_i;\n};\nmodes.gcm.prototype.pow = function(x, out) {\n    // if LSB(x) is 1, x = x >>> 1\n    // else x = (x >>> 1) ^ R\n    var lsb = x[3] & 1;\n    // always do x >>> 1:\n    // starting with the rightmost integer, shift each integer to the right\n    // one bit, pulling in the bit from the integer to the left as its top\n    // most bit (do this for the last 3 integers)\n    for(var i = 3; i > 0; --i){\n        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;\n    }\n    // shift the first integer normally\n    out[0] = x[0] >>> 1;\n    // if lsb was not set, then polynomial had a degree of 127 and doesn't\n    // need to divided; otherwise, XOR with R to find the remainder; we only\n    // need to XOR the first integer since R technically ends w/120 zero bits\n    if (lsb) {\n        out[0] ^= this._R;\n    }\n};\nmodes.gcm.prototype.tableMultiply = function(x) {\n    // assumes 4-bit tables are used\n    var z = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for(var i = 0; i < 32; ++i){\n        var idx = i / 8 | 0;\n        var x_i = x[idx] >>> (7 - i % 8) * 4 & 0xF;\n        var ah = this._m[i][x_i];\n        z[0] ^= ah[0];\n        z[1] ^= ah[1];\n        z[2] ^= ah[2];\n        z[3] ^= ah[3];\n    }\n    return z;\n};\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */ modes.gcm.prototype.ghash = function(h, y, x) {\n    y[0] ^= x[0];\n    y[1] ^= x[1];\n    y[2] ^= x[2];\n    y[3] ^= x[3];\n    return this.tableMultiply(y);\n//return this.multiply(y, h);\n};\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */ modes.gcm.prototype.generateHashTable = function(h, bits) {\n    // TODO: There are further optimizations that would use only the\n    // first table M_0 (or some variant) along with a remainder table;\n    // this can be explored in the future\n    var multiplier = 8 / bits;\n    var perInt = 4 * multiplier;\n    var size = 16 * multiplier;\n    var m = new Array(size);\n    for(var i = 0; i < size; ++i){\n        var tmp = [\n            0,\n            0,\n            0,\n            0\n        ];\n        var idx = i / perInt | 0;\n        var shft = (perInt - 1 - i % perInt) * bits;\n        tmp[idx] = 1 << bits - 1 << shft;\n        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n    }\n    return m;\n};\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */ modes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n    // compute the table quickly by minimizing the number of\n    // POW operations -- they only need to be performed for powers of 2,\n    // all other entries can be composed from those powers using XOR\n    var size = 1 << bits;\n    var half = size >>> 1;\n    var m = new Array(size);\n    m[half] = mid.slice(0);\n    var i = half >>> 1;\n    while(i > 0){\n        // raise m0[2 * i] and store in m0[i]\n        this.pow(m[2 * i], m[i] = []);\n        i >>= 1;\n    }\n    i = 2;\n    while(i < half){\n        for(var j = 1; j < i; ++j){\n            var m_i = m[i];\n            var m_j = m[j];\n            m[i + j] = [\n                m_i[0] ^ m_j[0],\n                m_i[1] ^ m_j[1],\n                m_i[2] ^ m_j[2],\n                m_i[3] ^ m_j[3]\n            ];\n        }\n        i *= 2;\n    }\n    m[0] = [\n        0,\n        0,\n        0,\n        0\n    ];\n    /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */ for(i = half + 1; i < size; ++i){\n        var c = m[i ^ half];\n        m[i] = [\n            mid[0] ^ c[0],\n            mid[1] ^ c[1],\n            mid[2] ^ c[2],\n            mid[3] ^ c[3]\n        ];\n    }\n    return m;\n};\n/** Utility functions */ function transformIV(iv, blockSize) {\n    if (typeof iv === \"string\") {\n        // convert iv string into byte buffer\n        iv = forge.util.createBuffer(iv);\n    }\n    if (forge.util.isArray(iv) && iv.length > 4) {\n        // convert iv byte array into byte buffer\n        var tmp = iv;\n        iv = forge.util.createBuffer();\n        for(var i = 0; i < tmp.length; ++i){\n            iv.putByte(tmp[i]);\n        }\n    }\n    if (iv.length() < blockSize) {\n        throw new Error(\"Invalid IV length; got \" + iv.length() + \" bytes and expected \" + blockSize + \" bytes.\");\n    }\n    if (!forge.util.isArray(iv)) {\n        // convert iv byte buffer into 32-bit integer array\n        var ints = [];\n        var blocks = blockSize / 4;\n        for(var i = 0; i < blocks; ++i){\n            ints.push(iv.getInt32());\n        }\n        iv = ints;\n    }\n    return iv;\n}\nfunction inc32(block) {\n    // increment last 32 bits of block only\n    block[block.length - 1] = block[block.length - 1] + 1 & 0xFFFFFFFF;\n}\nfunction from64To32(num) {\n    // convert 64-bit number to two BE Int32s\n    return [\n        num / 0x100000000 | 0,\n        num & 0xFFFFFFFF\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyTW9kZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBRVJELE1BQU1FLE1BQU0sR0FBR0YsTUFBTUUsTUFBTSxJQUFJLENBQUM7QUFFaEMseUJBQXlCO0FBQ3pCLElBQUlDLFFBQVFDLE9BQU9DLE9BQU8sR0FBR0wsTUFBTUUsTUFBTSxDQUFDQyxLQUFLLEdBQUdILE1BQU1FLE1BQU0sQ0FBQ0MsS0FBSyxJQUFJLENBQUM7QUFFekUsaUVBQWlFLEdBRWpFQSxNQUFNRyxHQUFHLEdBQUcsU0FBU0MsT0FBTztJQUMxQkEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDTixNQUFNLEdBQUdLLFFBQVFMLE1BQU07SUFDNUIsSUFBSSxDQUFDTyxTQUFTLEdBQUdGLFFBQVFFLFNBQVMsSUFBSTtJQUN0QyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLENBQUNELFNBQVMsR0FBRztJQUM5QixJQUFJLENBQUNFLFFBQVEsR0FBRyxJQUFJQyxNQUFNLElBQUksQ0FBQ0YsS0FBSztJQUNwQyxJQUFJLENBQUNHLFNBQVMsR0FBRyxJQUFJRCxNQUFNLElBQUksQ0FBQ0YsS0FBSztBQUN2QztBQUVBUCxNQUFNRyxHQUFHLENBQUNRLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHLFNBQVNSLE9BQU8sR0FBRztBQUUvQ0osTUFBTUcsR0FBRyxDQUFDUSxTQUFTLENBQUNFLE9BQU8sR0FBRyxTQUFTQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtJQUMxRCw4QkFBOEI7SUFDOUIsSUFBR0YsTUFBTUcsTUFBTSxLQUFLLElBQUksQ0FBQ1gsU0FBUyxJQUFJLENBQUVVLENBQUFBLFVBQVVGLE1BQU1HLE1BQU0sS0FBSyxJQUFJO1FBQ3JFLE9BQU87SUFDVDtJQUVB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QUVBLElBQUduQyxNQUFNNEMsSUFBSSxDQUFDZ0UsT0FBTyxDQUFDekUsT0FBT0EsR0FBR2YsTUFBTSxHQUFHLEdBQUc7UUFDMUMseUNBQXlDO1FBQ3pDLElBQUkrRSxNQUFNaEU7UUFDVkEsS0FBS25DLE1BQU00QyxJQUFJLENBQUNDLFlBQVk7UUFDNUIsSUFBSSxJQUFJeEIsSUFBSSxHQUFHQSxJQUFJOEUsSUFBSS9FLE1BQU0sRUFBRSxFQUFFQyxFQUFHO1lBQ2xDYyxHQUFHMEUsT0FBTyxDQUFDVixHQUFHLENBQUM5RSxFQUFFO1FBQ25CO0lBQ0Y7SUFFQSxJQUFHYyxHQUFHZixNQUFNLEtBQUtYLFdBQVc7UUFDMUIsTUFBTSxJQUFJNEIsTUFDUiw0QkFBNEJGLEdBQUdmLE1BQU0sS0FDckMseUJBQXlCWCxZQUFZO0lBQ3pDO0lBRUEsSUFBRyxDQUFDVCxNQUFNNEMsSUFBSSxDQUFDZ0UsT0FBTyxDQUFDekUsS0FBSztRQUMxQixtREFBbUQ7UUFDbkQsSUFBSTJFLE9BQU8sRUFBRTtRQUNiLElBQUlDLFNBQVN0RyxZQUFZO1FBQ3pCLElBQUksSUFBSVksSUFBSSxHQUFHQSxJQUFJMEYsUUFBUSxFQUFFMUYsRUFBRztZQUM5QnlGLEtBQUtFLElBQUksQ0FBQzdFLEdBQUdiLFFBQVE7UUFDdkI7UUFDQWEsS0FBSzJFO0lBQ1A7SUFFQSxPQUFPM0U7QUFDVDtBQUVBLFNBQVNvQixNQUFNMEQsS0FBSztJQUNsQix1Q0FBdUM7SUFDdkNBLEtBQUssQ0FBQ0EsTUFBTTdGLE1BQU0sR0FBRyxFQUFFLEdBQUcsS0FBTSxDQUFDNkYsTUFBTTdGLE1BQU0sR0FBRyxFQUFFLEdBQUcsSUFBSztBQUM1RDtBQUVBLFNBQVNxRCxXQUFXeUMsR0FBRztJQUNyQix5Q0FBeUM7SUFDekMsT0FBTztRQUFFQSxNQUFNLGNBQWU7UUFBR0EsTUFBTTtLQUFXO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyTW9kZXMuanM/MDkwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICAgIHRoaXMuX3ByZXYgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgfVxufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIC8vIENCQyBYT1IncyBJViAob3IgcHJldmlvdXMgYmxvY2spIHdpdGggcGxhaW50ZXh0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcHJldltpXSBeIGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuICB0aGlzLl9wcmV2ID0gdGhpcy5fb3V0QmxvY2s7XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZGVjcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5kZWNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXQsIHNhdmUgcHJldmlvdXMgY2lwaGVyZWQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBjaXBoZXJ0ZXh0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fcHJldltpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuICB0aGlzLl9wcmV2ID0gdGhpcy5faW5CbG9jay5zbGljZSgwKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gYWRkIFBLQ1MjNyBwYWRkaW5nIHRvIGJsb2NrIChlYWNoIHBhZCBieXRlIGlzIHRoZVxuICAvLyB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHBhZCBieXRlcylcbiAgdmFyIHBhZGRpbmcgPSAoaW5wdXQubGVuZ3RoKCkgPT09IHRoaXMuYmxvY2tTaXplID9cbiAgICB0aGlzLmJsb2NrU2l6ZSA6ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0Lmxlbmd0aCgpKSk7XG4gIGlucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvcjogaW5wdXQgZGF0YSBub3QgYSBtdWx0aXBsZSBvZiBibG9ja1NpemVcbiAgaWYob3B0aW9ucy5vdmVyZmxvdyA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gIHZhciBsZW4gPSBvdXRwdXQubGVuZ3RoKCk7XG4gIHZhciBjb3VudCA9IG91dHB1dC5hdChsZW4gLSAxKTtcbiAgaWYoY291bnQgPiAodGhpcy5ibG9ja1NpemUgPDwgMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0cmltIG9mZiBwYWRkaW5nIGJ5dGVzXG4gIG91dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqIENpcGhlciBmZWVkYmFjayAoQ0ZCKSAqKi9cblxubW9kZXMuY2ZiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0NGQic7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBudWxsO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmNmYi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gdXNlIElWIGFzIGZpcnN0IGlucHV0XG4gIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9pbkJsb2NrID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jZmIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwYXJ0aWFsIGJsb2NrXG4gIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICB9XG5cbiAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBwYXJ0aWFsIG91dHB1dFxuICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxCbG9ja1tpXTtcbiAgICB9XG4gIH1cblxuICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jZmIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9jayAoQ0ZCIGFsd2F5cyB1c2VzIGVuY3J5cHRpb24gbW9kZSlcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9pbkJsb2NrW2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKHRoaXMuX3BhcnRpYWxCbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxuLyoqIE91dHB1dCBmZWVkYmFjayAoT0ZCKSAqKi9cblxubW9kZXMub2ZiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ09GQic7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBudWxsO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5vZmIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9XG4gIC8vIHVzZSBJViBhcyBmaXJzdCBpbnB1dFxuICB0aGlzLl9pdiA9IHRyYW5zZm9ybUlWKG9wdGlvbnMuaXYsIHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmN0ci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrIChDVFIgYWx3YXlzIHVzZXMgZW5jcnlwdGlvbiBtb2RlKVxuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gIH1cblxuICAvLyBibG9jayBjb21wbGV0ZSwgaW5jcmVtZW50IGNvdW50ZXIgKGlucHV0IGJsb2NrKVxuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbn07XG5cbm1vZGVzLmN0ci5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLmN0ci5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIEdhbG9pcy9Db3VudGVyIE1vZGUgKEdDTSkgKiovXG5cbm1vZGVzLmdjbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdHQ00nO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gUiBpcyBhY3R1YWxseSB0aGlzIHZhbHVlIGNvbmNhdGVuYXRlZCB3aXRoIDEyMCBtb3JlIHplcm8gYml0cywgYnV0XG4gIC8vIHdlIG9ubHkgWE9SIGFnYWluc3QgUiBzbyB0aGUgb3RoZXIgemVyb3MgaGF2ZSBubyBlZmZlY3QgLS0gd2UganVzdFxuICAvLyBhcHBseSB0aGlzIHZhbHVlIHRvIHRoZSBmaXJzdCBpbnRlZ2VyIGluIGEgYmxvY2tcbiAgdGhpcy5fUiA9IDB4RTEwMDAwMDA7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9XG4gIC8vIGVuc3VyZSBJViBpcyBhIGJ5dGUgYnVmZmVyXG4gIHZhciBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMuaXYpO1xuXG4gIC8vIG5vIGNpcGhlcmVkIGRhdGEgcHJvY2Vzc2VkIHlldFxuICB0aGlzLl9jaXBoZXJMZW5ndGggPSAwO1xuXG4gIC8vIGRlZmF1bHQgYWRkaXRpb25hbCBkYXRhIGlzIG5vbmVcbiAgdmFyIGFkZGl0aW9uYWxEYXRhO1xuICBpZignYWRkaXRpb25hbERhdGEnIGluIG9wdGlvbnMpIHtcbiAgICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMuYWRkaXRpb25hbERhdGEpO1xuICB9IGVsc2Uge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdGFnIGxlbmd0aCBpcyAxMjggYml0c1xuICBpZigndGFnTGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fdGFnTGVuZ3RoID0gb3B0aW9ucy50YWdMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdGFnTGVuZ3RoID0gMTI4O1xuICB9XG5cbiAgLy8gaWYgdGFnIGlzIGdpdmVuLCBlbnN1cmUgdGFnIG1hdGNoZXMgdGFnIGxlbmd0aFxuICB0aGlzLl90YWcgPSBudWxsO1xuICBpZihvcHRpb25zLmRlY3J5cHQpIHtcbiAgICAvLyBzYXZlIHRhZyB0byBjaGVjayBsYXRlclxuICAgIHRoaXMuX3RhZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMudGFnKS5nZXRCeXRlcygpO1xuICAgIGlmKHRoaXMuX3RhZy5sZW5ndGggIT09ICh0aGlzLl90YWdMZW5ndGggLyA4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiB0YWcgZG9lcyBub3QgbWF0Y2ggdGFnIGxlbmd0aC4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgdG1wIHN0b3JhZ2UgZm9yIGhhc2ggY2FsY3VsYXRpb25cbiAgdGhpcy5faGFzaEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuXG4gIC8vIG5vIHRhZyBnZW5lcmF0ZWQgeWV0XG4gIHRoaXMudGFnID0gbnVsbDtcblxuICAvLyBnZW5lcmF0ZSBoYXNoIHN1YmtleVxuICAvLyAoYXBwbHkgYmxvY2sgY2lwaGVyIHRvIFwiemVyb1wiIGJsb2NrKVxuICB0aGlzLl9oYXNoU3Via2V5ID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KFswLCAwLCAwLCAwXSwgdGhpcy5faGFzaFN1YmtleSk7XG5cbiAgLy8gZ2VuZXJhdGUgdGFibGUgTVxuICAvLyB1c2UgNC1iaXQgdGFibGVzICgzMiBjb21wb25lbnQgZGVjb21wb3NpdGlvbiBvZiBhIDE2IGJ5dGUgdmFsdWUpXG4gIC8vIDgtYml0IHRhYmxlcyB0YWtlIG1vcmUgc3BhY2UgYW5kIGFyZSBrbm93biB0byBoYXZlIHNlY3VyaXR5XG4gIC8vIHZ1bG5lcmFiaWxpdGllcyAoaW4gbmF0aXZlIGltcGxlbWVudGF0aW9ucylcbiAgdGhpcy5jb21wb25lbnRCaXRzID0gNDtcbiAgdGhpcy5fbSA9IHRoaXMuZ2VuZXJhdGVIYXNoVGFibGUodGhpcy5faGFzaFN1YmtleSwgdGhpcy5jb21wb25lbnRCaXRzKTtcblxuICAvLyBOb3RlOiBzdXBwb3J0IElWIGxlbmd0aCBkaWZmZXJlbnQgZnJvbSA5NiBiaXRzPyAob25seSBzdXBwb3J0aW5nXG4gIC8vIDk2IGJpdHMgaXMgcmVjb21tZW5kZWQgYnkgTklTVCBTUC04MDAtMzhEKVxuICAvLyBnZW5lcmF0ZSBKXzBcbiAgdmFyIGl2TGVuZ3RoID0gaXYubGVuZ3RoKCk7XG4gIGlmKGl2TGVuZ3RoID09PSAxMikge1xuICAgIC8vIDk2LWJpdCBJVlxuICAgIHRoaXMuX2owID0gW2l2LmdldEludDMyKCksIGl2LmdldEludDMyKCksIGl2LmdldEludDMyKCksIDFdO1xuICB9IGVsc2Uge1xuICAgIC8vIElWIGlzIE5PVCA5Ni1iaXRzXG4gICAgdGhpcy5fajAgPSBbMCwgMCwgMCwgMF07XG4gICAgd2hpbGUoaXYubGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLl9qMCA9IHRoaXMuZ2hhc2goXG4gICAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLFxuICAgICAgICBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKV0pO1xuICAgIH1cbiAgICB0aGlzLl9qMCA9IHRoaXMuZ2hhc2goXG4gICAgICB0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9qMCwgWzAsIDBdLmNvbmNhdChmcm9tNjRUbzMyKGl2TGVuZ3RoICogOCkpKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIElDQiAoaW5pdGlhbCBjb3VudGVyIGJsb2NrKVxuICB0aGlzLl9pbkJsb2NrID0gdGhpcy5fajAuc2xpY2UoMCk7XG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuXG4gIC8vIGNvbnN1bWUgYXV0aGVudGljYXRpb24gZGF0YVxuICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGFkZGl0aW9uYWxEYXRhKTtcbiAgLy8gc2F2ZSBhZGRpdGlvbmFsIGRhdGEgbGVuZ3RoIGFzIGEgQkUgNjQtYml0IG51bWJlclxuICB0aGlzLl9hRGF0YUxlbmd0aCA9IGZyb202NFRvMzIoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgKiA4KTtcbiAgLy8gcGFkIGFkZGl0aW9uYWwgZGF0YSB0byAxMjggYml0ICgxNiBieXRlKSBibG9jayBzaXplXG4gIHZhciBvdmVyZmxvdyA9IGFkZGl0aW9uYWxEYXRhLmxlbmd0aCgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKG92ZXJmbG93KSB7XG4gICAgYWRkaXRpb25hbERhdGEuZmlsbFdpdGhCeXRlKDAsIHRoaXMuYmxvY2tTaXplIC0gb3ZlcmZsb3cpO1xuICB9XG4gIHRoaXMuX3MgPSBbMCwgMCwgMCwgMF07XG4gIHdoaWxlKGFkZGl0aW9uYWxEYXRhLmxlbmd0aCgpID4gMCkge1xuICAgIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIFtcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKClcbiAgICBdKTtcbiAgfVxufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldIF49IGlucHV0LmdldEludDMyKCkpO1xuICAgIH1cbiAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0aWFsQnl0ZXMgPD0gMCB8fCBmaW5pc2gpIHtcbiAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBwcmlvciB0byBoYXNoaW5nXG4gICAgICBpZihmaW5pc2gpIHtcbiAgICAgICAgLy8gZ2V0IGJsb2NrIG92ZXJmbG93XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgLy8gdHJ1bmNhdGUgZm9yIGhhc2ggZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IG91dHB1dCBibG9jayBmb3IgaGFzaGluZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXIsIGdldCBwYXJ0aWFsIG91dHB1dCxcbiAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0TGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKEdDTSBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMl0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9oYXNoQmxvY2spO1xuXG4gIC8vIFhPUiBoYXNoIGlucHV0IHdpdGggb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXiB0aGlzLl9oYXNoQmxvY2tbaV0pO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IGNpcGhlciBkYXRhIGxlbmd0aFxuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmFmdGVyRmluaXNoID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIHZhciBydmFsID0gdHJ1ZTtcblxuICAvLyBoYW5kbGUgb3ZlcmZsb3dcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIG9wdGlvbnMub3ZlcmZsb3cpIHtcbiAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgdGhpcy50YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGNvbmNhdGVuYXRlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggd2l0aCBjaXBoZXIgbGVuZ3RoXG4gIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuXG4gIC8vIGluY2x1ZGUgbGVuZ3RocyBpbiBoYXNoXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIGxlbmd0aHMpO1xuXG4gIC8vIGRvIEdDVFIoSl8wLCBTKVxuICB2YXIgdGFnID0gW107XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsIHRhZyk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW2ldIF4gdGFnW2ldKTtcbiAgfVxuXG4gIC8vIHRyaW0gdGFnIHRvIGxlbmd0aFxuICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG5cbiAgLy8gY2hlY2sgYXV0aGVudGljYXRpb24gdGFnXG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiB0aGlzLnRhZy5ieXRlcygpICE9PSB0aGlzLl90YWcpIHtcbiAgICBydmFsID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU2VlIE5JU1QgU1AtODAwLTM4RCA2LjMgKEFsZ29yaXRobSAxKS4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBHYWxvaXNcbiAqIGZpZWxkIG11bHRpcGxpY2F0aW9uLiBUaGUgZmllbGQsIEdGKDJeMTI4KSwgaXMgZGVmaW5lZCBieSB0aGUgcG9seW5vbWlhbDpcbiAqXG4gKiB4XjEyOCArIHheNyArIHheMiArIHggKyAxXG4gKlxuICogV2hpY2ggaXMgcmVwcmVzZW50ZWQgaW4gbGl0dGxlLWVuZGlhbiBiaW5hcnkgZm9ybSBhczogMTExMDAwMDEgKDB4ZTEpLiBXaGVuXG4gKiB0aGUgdmFsdWUgb2YgYSBjb2VmZmljaWVudCBpcyAxLCBhIGJpdCBpcyBzZXQuIFRoZSB2YWx1ZSBSLCBpcyB0aGVcbiAqIGNvbmNhdGVuYXRpb24gb2YgdGhpcyB2YWx1ZSBhbmQgMTIwIHplcm8gYml0cywgeWllbGRpbmcgYSAxMjgtYml0IHZhbHVlXG4gKiB3aGljaCBtYXRjaGVzIHRoZSBibG9jayBzaXplLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtdWx0aXBseSB0d28gZWxlbWVudHMgKHZlY3RvcnMgb2YgYnl0ZXMpLCBYIGFuZCBZLCBpblxuICogdGhlIGZpZWxkIEdGKDJeMTI4KS4gVGhlIHJlc3VsdCBpcyBpbml0aWFsaXplZCB0byB6ZXJvLiBGb3IgZWFjaCBiaXQgb2ZcbiAqIFggKG91dCBvZiAxMjgpLCB4X2ksIGlmIHhfaSBpcyBzZXQsIHRoZW4gdGhlIHJlc3VsdCBpcyBtdWx0aXBsaWVkIChYT1InZClcbiAqIGJ5IHRoZSBjdXJyZW50IHZhbHVlIG9mIFkuIEZvciBlYWNoIGJpdCwgdGhlIHZhbHVlIG9mIFkgd2lsbCBiZSByYWlzZWQgYnlcbiAqIGEgcG93ZXIgb2YgeCAobXVsdGlwbGllZCBieSB0aGUgcG9seW5vbWlhbCB4KS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAqIHNoaWZ0aW5nIFkgb25jZSB0byB0aGUgcmlnaHQuIElmIHRoZSBjdXJyZW50IHZhbHVlIG9mIFksIHByaW9yIHRvIGJlaW5nXG4gKiBtdWx0aXBsaWVkIGJ5IHgsIGhhcyAwIGFzIGl0cyBMU0IsIHRoZW4gaXQgaXMgYSAxMjd0aCBkZWdyZWUgcG9seW5vbWlhbC5cbiAqIE90aGVyd2lzZSwgd2UgbXVzdCBkaXZpZGUgYnkgUiBhZnRlciBzaGlmdGluZyB0byBmaW5kIHRoZSByZW1haW5kZXIuXG4gKlxuICogQHBhcmFtIHggdGhlIGZpcnN0IGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0geSB0aGUgc2Vjb25kIGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBmaXJzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBibG9jayByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICB2YXIgdl9pID0geS5zbGljZSgwKTtcblxuICAvLyBjYWxjdWxhdGUgWl8xMjggKGJsb2NrIGhhcyAxMjggYml0cylcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgLy8gaWYgeF9pIGlzIDAsIFpfe2krMX0gPSBaX2kgKHVuY2hhbmdlZClcbiAgICAvLyBlbHNlIFpfe2krMX0gPSBaX2kgXiBWX2lcbiAgICAvLyBnZXQgeF9pIGJ5IGZpbmRpbmcgMzItYml0IGludCBwb3NpdGlvbiwgdGhlbiBsZWZ0IHNoaWZ0IDEgYnkgcmVtYWluZGVyXG4gICAgdmFyIHhfaSA9IHhbKGkgLyAzMikgfCAwXSAmICgxIDw8ICgzMSAtIGkgJSAzMikpO1xuICAgIGlmKHhfaSkge1xuICAgICAgel9pWzBdIF49IHZfaVswXTtcbiAgICAgIHpfaVsxXSBePSB2X2lbMV07XG4gICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgel9pWzNdIF49IHZfaVszXTtcbiAgICB9XG5cbiAgICAvLyBpZiBMU0IoVl9pKSBpcyAxLCBWX2kgPSBWX2kgPj4gMVxuICAgIC8vIGVsc2UgVl9pID0gKFZfaSA+PiAxKSBeIFJcbiAgICB0aGlzLnBvdyh2X2ksIHZfaSk7XG4gIH1cblxuICByZXR1cm4gel9pO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbih4LCBvdXQpIHtcbiAgLy8gaWYgTFNCKHgpIGlzIDEsIHggPSB4ID4+PiAxXG4gIC8vIGVsc2UgeCA9ICh4ID4+PiAxKSBeIFJcbiAgdmFyIGxzYiA9IHhbM10gJiAxO1xuXG4gIC8vIGFsd2F5cyBkbyB4ID4+PiAxOlxuICAvLyBzdGFydGluZyB3aXRoIHRoZSByaWdodG1vc3QgaW50ZWdlciwgc2hpZnQgZWFjaCBpbnRlZ2VyIHRvIHRoZSByaWdodFxuICAvLyBvbmUgYml0LCBwdWxsaW5nIGluIHRoZSBiaXQgZnJvbSB0aGUgaW50ZWdlciB0byB0aGUgbGVmdCBhcyBpdHMgdG9wXG4gIC8vIG1vc3QgYml0IChkbyB0aGlzIGZvciB0aGUgbGFzdCAzIGludGVnZXJzKVxuICBmb3IodmFyIGkgPSAzOyBpID4gMDsgLS1pKSB7XG4gICAgb3V0W2ldID0gKHhbaV0gPj4+IDEpIHwgKCh4W2kgLSAxXSAmIDEpIDw8IDMxKTtcbiAgfVxuICAvLyBzaGlmdCB0aGUgZmlyc3QgaW50ZWdlciBub3JtYWxseVxuICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuXG4gIC8vIGlmIGxzYiB3YXMgbm90IHNldCwgdGhlbiBwb2x5bm9taWFsIGhhZCBhIGRlZ3JlZSBvZiAxMjcgYW5kIGRvZXNuJ3RcbiAgLy8gbmVlZCB0byBkaXZpZGVkOyBvdGhlcndpc2UsIFhPUiB3aXRoIFIgdG8gZmluZCB0aGUgcmVtYWluZGVyOyB3ZSBvbmx5XG4gIC8vIG5lZWQgdG8gWE9SIHRoZSBmaXJzdCBpbnRlZ2VyIHNpbmNlIFIgdGVjaG5pY2FsbHkgZW5kcyB3LzEyMCB6ZXJvIGJpdHNcbiAgaWYobHNiKSB7XG4gICAgb3V0WzBdIF49IHRoaXMuX1I7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gYXNzdW1lcyA0LWJpdCB0YWJsZXMgYXJlIHVzZWRcbiAgdmFyIHogPSBbMCwgMCwgMCwgMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChpIC8gOCkgfCAwO1xuICAgIHZhciB4X2kgPSAoeFtpZHhdID4+PiAoKDcgLSAoaSAlIDgpKSAqIDQpKSAmIDB4RjtcbiAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgelswXSBePSBhaFswXTtcbiAgICB6WzFdIF49IGFoWzFdO1xuICAgIHpbMl0gXj0gYWhbMl07XG4gICAgelszXSBePSBhaFszXTtcbiAgfVxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQSBjb250aW51aW5nIHZlcnNpb24gb2YgdGhlIEdIQVNIIGFsZ29yaXRobSB0aGF0IG9wZXJhdGVzIG9uIGEgc2luZ2xlXG4gKiBibG9jay4gVGhlIGhhc2ggYmxvY2ssIGxhc3QgaGFzaCB2YWx1ZSAoWW0pIGFuZCB0aGUgbmV3IGJsb2NrIHRvIGhhc2hcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBibG9jay5cbiAqIEBwYXJhbSB5IHRoZSBwcmV2aW91cyB2YWx1ZSBmb3IgWW0sIHVzZSBbMCwgMCwgMCwgMF0gZm9yIGEgbmV3IGhhc2guXG4gKiBAcGFyYW0geCB0aGUgYmxvY2sgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoYXNoZWQgdmFsdWUgKFltKS5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uKGgsIHksIHgpIHtcbiAgeVswXSBePSB4WzBdO1xuICB5WzFdIF49IHhbMV07XG4gIHlbMl0gXj0geFsyXTtcbiAgeVszXSBePSB4WzNdO1xuICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAvL3JldHVybiB0aGlzLm11bHRpcGx5KHksIGgpO1xufTtcblxuLyoqXG4gKiBQcmVjb21wdXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleS4gVGhpc1xuICogbWVjaGFuaXNtIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgc3BlZWQgaW5jcmVhc2Ugb3ZlciBtdWx0aXBsaWNhdGlvblxuICogcGVyZm9ybWVkIHdpdGhvdXQgYSB0YWJsZS4gVGhlIHRhYmxlLWJhc2VkIG11bHRpcGxpY2F0aW9uIHRoaXMgdGFibGUgaXNcbiAqIGZvciBzb2x2ZXMgWCAqIEggYnkgbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnQgb2YgWCBieSBIIGFuZCB0aGVuXG4gKiBjb21wb3NpbmcgdGhlIHJlc3VsdHMgdG9nZXRoZXIgdXNpbmcgWE9SLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGFibGVzIHdpdGggZGlmZmVyZW50IGJpdCBzaXplc1xuICogZm9yIHRoZSBjb21wb25lbnRzLCBob3dldmVyLCB0aGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlcmUgYXJlXG4gKiAzMiBjb21wb25lbnRzIG9mIFggKHdoaWNoIGlzIGEgMTYgYnl0ZSB2ZWN0b3IpLCB0aGVyZWZvcmUgZWFjaCBjb21wb25lbnRcbiAqIHRha2VzIDQtYml0cyAoc28gdGhlIHRhYmxlIGlzIGNvbnN0cnVjdGVkIHdpdGggYml0cz00KS5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBzdWJrZXkuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlSGFzaFRhYmxlID0gZnVuY3Rpb24oaCwgYml0cykge1xuICAvLyBUT0RPOiBUaGVyZSBhcmUgZnVydGhlciBvcHRpbWl6YXRpb25zIHRoYXQgd291bGQgdXNlIG9ubHkgdGhlXG4gIC8vIGZpcnN0IHRhYmxlIE1fMCAob3Igc29tZSB2YXJpYW50KSBhbG9uZyB3aXRoIGEgcmVtYWluZGVyIHRhYmxlO1xuICAvLyB0aGlzIGNhbiBiZSBleHBsb3JlZCBpbiB0aGUgZnV0dXJlXG4gIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gIHZhciBwZXJJbnQgPSA0ICogbXVsdGlwbGllcjtcbiAgdmFyIHNpemUgPSAxNiAqIG11bHRpcGxpZXI7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaWR4ID0gKGkgLyBwZXJJbnQpIHwgMDtcbiAgICB2YXIgc2hmdCA9ICgocGVySW50IC0gMSAtIChpICUgcGVySW50KSkgKiBiaXRzKTtcbiAgICB0bXBbaWR4XSA9ICgxIDw8IChiaXRzIC0gMSkpIDw8IHNoZnQ7XG4gICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5IGZvciBvbmVcbiAqIHBhcnRpY3VsYXIgY29tcG9uZW50IChvdXQgb2YgYWxsIHBvc3NpYmxlIGNvbXBvbmVudCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBtaWQgdGhlIHByZS1tdWx0aXBsaWVkIHZhbHVlIGZvciB0aGUgbWlkZGxlIGtleSBvZiB0aGUgdGFibGUuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlID0gZnVuY3Rpb24obWlkLCBiaXRzKSB7XG4gIC8vIGNvbXB1dGUgdGhlIHRhYmxlIHF1aWNrbHkgYnkgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mXG4gIC8vIFBPVyBvcGVyYXRpb25zIC0tIHRoZXkgb25seSBuZWVkIHRvIGJlIHBlcmZvcm1lZCBmb3IgcG93ZXJzIG9mIDIsXG4gIC8vIGFsbCBvdGhlciBlbnRyaWVzIGNhbiBiZSBjb21wb3NlZCBmcm9tIHRob3NlIHBvd2VycyB1c2luZyBYT1JcbiAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gIHZhciBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gIHZhciBpID0gaGFsZiA+Pj4gMTtcbiAgd2hpbGUoaSA+IDApIHtcbiAgICAvLyByYWlzZSBtMFsyICogaV0gYW5kIHN0b3JlIGluIG0wW2ldXG4gICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgaSA+Pj0gMTtcbiAgfVxuICBpID0gMjtcbiAgd2hpbGUoaSA8IGhhbGYpIHtcbiAgICBmb3IodmFyIGogPSAxOyBqIDwgaTsgKytqKSB7XG4gICAgICB2YXIgbV9pID0gbVtpXTtcbiAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgbVtpICsgal0gPSBbXG4gICAgICAgIG1faVswXSBeIG1falswXSxcbiAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICBtX2lbMl0gXiBtX2pbMl0sXG4gICAgICAgIG1faVszXSBeIG1falszXVxuICAgICAgXTtcbiAgICB9XG4gICAgaSAqPSAyO1xuICB9XG4gIG1bMF0gPSBbMCwgMCwgMCwgMF07XG4gIC8qIE5vdGU6IFdlIGNvdWxkIGF2b2lkIHN0b3JpbmcgdGhlc2UgYnkgZG9pbmcgY29tcG9zaXRpb24gZHVyaW5nIG11bHRpcGx5XG4gIGNhbGN1bGF0ZSB0b3AgaGFsZiB1c2luZyBjb21wb3NpdGlvbiBieSBzcGVlZCBpcyBwcmVmZXJyZWQuICovXG4gIGZvcihpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgYyA9IG1baSBeIGhhbGZdO1xuICAgIG1baV0gPSBbbWlkWzBdIF4gY1swXSwgbWlkWzFdIF4gY1sxXSwgbWlkWzJdIF4gY1syXSwgbWlkWzNdIF4gY1szXV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYsIGJsb2NrU2l6ZSkge1xuICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY29udmVydCBpdiBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoaXYpO1xuICB9XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGl2KSAmJiBpdi5sZW5ndGggPiA0KSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICB2YXIgdG1wID0gaXY7XG4gICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgIGl2LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZihpdi5sZW5ndGgoKSA8IGJsb2NrU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIElWIGxlbmd0aDsgZ290ICcgKyBpdi5sZW5ndGgoKSArXG4gICAgICAnIGJ5dGVzIGFuZCBleHBlY3RlZCAnICsgYmxvY2tTaXplICsgJyBieXRlcy4nKTtcbiAgfVxuXG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoaXYpKSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gICAgdmFyIGludHMgPSBbXTtcbiAgICB2YXIgYmxvY2tzID0gYmxvY2tTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyArK2kpIHtcbiAgICAgIGludHMucHVzaChpdi5nZXRJbnQzMigpKTtcbiAgICB9XG4gICAgaXYgPSBpbnRzO1xuICB9XG5cbiAgcmV0dXJuIGl2O1xufVxuXG5mdW5jdGlvbiBpbmMzMihibG9jaykge1xuICAvLyBpbmNyZW1lbnQgbGFzdCAzMiBiaXRzIG9mIGJsb2NrIG9ubHlcbiAgYmxvY2tbYmxvY2subGVuZ3RoIC0gMV0gPSAoYmxvY2tbYmxvY2subGVuZ3RoIC0gMV0gKyAxKSAmIDB4RkZGRkZGRkY7XG59XG5cbmZ1bmN0aW9uIGZyb202NFRvMzIobnVtKSB7XG4gIC8vIGNvbnZlcnQgNjQtYml0IG51bWJlciB0byB0d28gQkUgSW50MzJzXG4gIHJldHVybiBbKG51bSAvIDB4MTAwMDAwMDAwKSB8IDAsIG51bSAmIDB4RkZGRkZGRkZdO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsImNpcGhlciIsIm1vZGVzIiwibW9kdWxlIiwiZXhwb3J0cyIsImVjYiIsIm9wdGlvbnMiLCJuYW1lIiwiYmxvY2tTaXplIiwiX2ludHMiLCJfaW5CbG9jayIsIkFycmF5IiwiX291dEJsb2NrIiwicHJvdG90eXBlIiwic3RhcnQiLCJlbmNyeXB0IiwiaW5wdXQiLCJvdXRwdXQiLCJmaW5pc2giLCJsZW5ndGgiLCJpIiwiZ2V0SW50MzIiLCJwdXRJbnQzMiIsImRlY3J5cHQiLCJwYWQiLCJwYWRkaW5nIiwiZmlsbFdpdGhCeXRlIiwidW5wYWQiLCJvdmVyZmxvdyIsImxlbiIsImNvdW50IiwiYXQiLCJ0cnVuY2F0ZSIsImNiYyIsIml2IiwiX3ByZXYiLCJFcnJvciIsIl9pdiIsInNsaWNlIiwidHJhbnNmb3JtSVYiLCJjZmIiLCJfcGFydGlhbEJsb2NrIiwiX3BhcnRpYWxPdXRwdXQiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiX3BhcnRpYWxCeXRlcyIsImlucHV0TGVuZ3RoIiwicGFydGlhbEJ5dGVzIiwiY2xlYXIiLCJyZWFkIiwiZ2V0Qnl0ZXMiLCJwdXRCeXRlcyIsIm9mYiIsImN0ciIsImluYzMyIiwiZ2NtIiwiX1IiLCJfY2lwaGVyTGVuZ3RoIiwiYWRkaXRpb25hbERhdGEiLCJfdGFnTGVuZ3RoIiwidGFnTGVuZ3RoIiwiX3RhZyIsInRhZyIsIl9oYXNoQmxvY2siLCJfaGFzaFN1YmtleSIsImNvbXBvbmVudEJpdHMiLCJfbSIsImdlbmVyYXRlSGFzaFRhYmxlIiwiaXZMZW5ndGgiLCJfajAiLCJnaGFzaCIsImNvbmNhdCIsImZyb202NFRvMzIiLCJfYURhdGFMZW5ndGgiLCJfcyIsImFmdGVyRmluaXNoIiwicnZhbCIsImxlbmd0aHMiLCJieXRlcyIsIm11bHRpcGx5IiwieCIsInkiLCJ6X2kiLCJ2X2kiLCJ4X2kiLCJwb3ciLCJvdXQiLCJsc2IiLCJ0YWJsZU11bHRpcGx5IiwieiIsImlkeCIsImFoIiwiaCIsImJpdHMiLCJtdWx0aXBsaWVyIiwicGVySW50Iiwic2l6ZSIsIm0iLCJ0bXAiLCJzaGZ0IiwiZ2VuZXJhdGVTdWJIYXNoVGFibGUiLCJtaWQiLCJoYWxmIiwiaiIsIm1faSIsIm1faiIsImMiLCJpc0FycmF5IiwicHV0Qnl0ZSIsImludHMiLCJibG9ja3MiLCJwdXNoIiwiYmxvY2siLCJudW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/cipherModes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/des.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/des.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * DES (Data Encryption Standard) implementation.\n *\n * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.\n * It is based on the BSD-licensed implementation by Paul Tero:\n *\n * Paul Tero, July 2001\n * http://www.tero.co.uk/des/\n *\n * Optimised for performance with large blocks by\n * Michael Hayworth, November 2001\n * http://www.netdealing.com\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2012-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./cipher */ \"(ssr)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! ./cipherModes */ \"(ssr)/./node_modules/node-forge/lib/cipherModes.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n/* DES API */ module.exports = forge.des = forge.des || {};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('DES-<mode>', key);\n * cipher.start({iv: iv});\n *\n * Creates an DES cipher object to encrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as binary-encoded strings of bytes or\n * byte buffers.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC' if IV is\n *          given, 'ECB' if null).\n *\n * @return the cipher.\n */ forge.des.startEncrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: false,\n        mode: mode || (iv === null ? \"ECB\" : \"CBC\")\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('DES-<mode>', key);\n *\n * Creates an DES cipher object to encrypt data using the given symmetric key.\n *\n * The key may be given as a binary-encoded string of bytes or a byte buffer.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.des.createEncryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: false,\n        mode: mode\n    });\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\n * decipher.start({iv: iv});\n *\n * Creates an DES cipher object to decrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as binary-encoded strings of bytes or\n * byte buffers.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC' if IV is\n *          given, 'ECB' if null).\n *\n * @return the cipher.\n */ forge.des.startDecrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: true,\n        mode: mode || (iv === null ? \"ECB\" : \"CBC\")\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\n *\n * Creates an DES cipher object to decrypt data using the given symmetric key.\n *\n * The key may be given as a binary-encoded string of bytes or a byte buffer.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.des.createDecryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: true,\n        mode: mode\n    });\n};\n/**\n * Creates a new DES cipher algorithm object.\n *\n * @param name the name of the algorithm.\n * @param mode the mode factory function.\n *\n * @return the DES algorithm object.\n */ forge.des.Algorithm = function(name, mode) {\n    var self = this;\n    self.name = name;\n    self.mode = new mode({\n        blockSize: 8,\n        cipher: {\n            encrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._keys, inBlock, outBlock, false);\n            },\n            decrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._keys, inBlock, outBlock, true);\n            }\n        }\n    });\n    self._init = false;\n};\n/**\n * Initializes this DES algorithm by expanding its key.\n *\n * @param options the options to use.\n *          key the key to use with this algorithm.\n *          decrypt true if the algorithm should be initialized for decryption,\n *            false for encryption.\n */ forge.des.Algorithm.prototype.initialize = function(options) {\n    if (this._init) {\n        return;\n    }\n    var key = forge.util.createBuffer(options.key);\n    if (this.name.indexOf(\"3DES\") === 0) {\n        if (key.length() !== 24) {\n            throw new Error(\"Invalid Triple-DES key size: \" + key.length() * 8);\n        }\n    }\n    // do key expansion to 16 or 48 subkeys (single or triple DES)\n    this._keys = _createKeys(key);\n    this._init = true;\n};\n/** Register DES algorithms **/ registerAlgorithm(\"DES-ECB\", forge.cipher.modes.ecb);\nregisterAlgorithm(\"DES-CBC\", forge.cipher.modes.cbc);\nregisterAlgorithm(\"DES-CFB\", forge.cipher.modes.cfb);\nregisterAlgorithm(\"DES-OFB\", forge.cipher.modes.ofb);\nregisterAlgorithm(\"DES-CTR\", forge.cipher.modes.ctr);\nregisterAlgorithm(\"3DES-ECB\", forge.cipher.modes.ecb);\nregisterAlgorithm(\"3DES-CBC\", forge.cipher.modes.cbc);\nregisterAlgorithm(\"3DES-CFB\", forge.cipher.modes.cfb);\nregisterAlgorithm(\"3DES-OFB\", forge.cipher.modes.ofb);\nregisterAlgorithm(\"3DES-CTR\", forge.cipher.modes.ctr);\nfunction registerAlgorithm(name, mode) {\n    var factory = function() {\n        return new forge.des.Algorithm(name, mode);\n    };\n    forge.cipher.registerAlgorithm(name, factory);\n}\n/** DES implementation **/ var spfunction1 = [\n    0x1010400,\n    0,\n    0x10000,\n    0x1010404,\n    0x1010004,\n    0x10404,\n    0x4,\n    0x10000,\n    0x400,\n    0x1010400,\n    0x1010404,\n    0x400,\n    0x1000404,\n    0x1010004,\n    0x1000000,\n    0x4,\n    0x404,\n    0x1000400,\n    0x1000400,\n    0x10400,\n    0x10400,\n    0x1010000,\n    0x1010000,\n    0x1000404,\n    0x10004,\n    0x1000004,\n    0x1000004,\n    0x10004,\n    0,\n    0x404,\n    0x10404,\n    0x1000000,\n    0x10000,\n    0x1010404,\n    0x4,\n    0x1010000,\n    0x1010400,\n    0x1000000,\n    0x1000000,\n    0x400,\n    0x1010004,\n    0x10000,\n    0x10400,\n    0x1000004,\n    0x400,\n    0x4,\n    0x1000404,\n    0x10404,\n    0x1010404,\n    0x10004,\n    0x1010000,\n    0x1000404,\n    0x1000004,\n    0x404,\n    0x10404,\n    0x1010400,\n    0x404,\n    0x1000400,\n    0x1000400,\n    0,\n    0x10004,\n    0x10400,\n    0,\n    0x1010004\n];\nvar spfunction2 = [\n    -0x7fef7fe0,\n    -0x7fff8000,\n    0x8000,\n    0x108020,\n    0x100000,\n    0x20,\n    -0x7fefffe0,\n    -0x7fff7fe0,\n    -0x7fffffe0,\n    -0x7fef7fe0,\n    -0x7fef8000,\n    -0x80000000,\n    -0x7fff8000,\n    0x100000,\n    0x20,\n    -0x7fefffe0,\n    0x108000,\n    0x100020,\n    -0x7fff7fe0,\n    0,\n    -0x80000000,\n    0x8000,\n    0x108020,\n    -0x7ff00000,\n    0x100020,\n    -0x7fffffe0,\n    0,\n    0x108000,\n    0x8020,\n    -0x7fef8000,\n    -0x7ff00000,\n    0x8020,\n    0,\n    0x108020,\n    -0x7fefffe0,\n    0x100000,\n    -0x7fff7fe0,\n    -0x7ff00000,\n    -0x7fef8000,\n    0x8000,\n    -0x7ff00000,\n    -0x7fff8000,\n    0x20,\n    -0x7fef7fe0,\n    0x108020,\n    0x20,\n    0x8000,\n    -0x80000000,\n    0x8020,\n    -0x7fef8000,\n    0x100000,\n    -0x7fffffe0,\n    0x100020,\n    -0x7fff7fe0,\n    -0x7fffffe0,\n    0x100020,\n    0x108000,\n    0,\n    -0x7fff8000,\n    0x8020,\n    -0x80000000,\n    -0x7fefffe0,\n    -0x7fef7fe0,\n    0x108000\n];\nvar spfunction3 = [\n    0x208,\n    0x8020200,\n    0,\n    0x8020008,\n    0x8000200,\n    0,\n    0x20208,\n    0x8000200,\n    0x20008,\n    0x8000008,\n    0x8000008,\n    0x20000,\n    0x8020208,\n    0x20008,\n    0x8020000,\n    0x208,\n    0x8000000,\n    0x8,\n    0x8020200,\n    0x200,\n    0x20200,\n    0x8020000,\n    0x8020008,\n    0x20208,\n    0x8000208,\n    0x20200,\n    0x20000,\n    0x8000208,\n    0x8,\n    0x8020208,\n    0x200,\n    0x8000000,\n    0x8020200,\n    0x8000000,\n    0x20008,\n    0x208,\n    0x20000,\n    0x8020200,\n    0x8000200,\n    0,\n    0x200,\n    0x20008,\n    0x8020208,\n    0x8000200,\n    0x8000008,\n    0x200,\n    0,\n    0x8020008,\n    0x8000208,\n    0x20000,\n    0x8000000,\n    0x8020208,\n    0x8,\n    0x20208,\n    0x20200,\n    0x8000008,\n    0x8020000,\n    0x8000208,\n    0x208,\n    0x8020000,\n    0x20208,\n    0x8,\n    0x8020008,\n    0x20200\n];\nvar spfunction4 = [\n    0x802001,\n    0x2081,\n    0x2081,\n    0x80,\n    0x802080,\n    0x800081,\n    0x800001,\n    0x2001,\n    0,\n    0x802000,\n    0x802000,\n    0x802081,\n    0x81,\n    0,\n    0x800080,\n    0x800001,\n    0x1,\n    0x2000,\n    0x800000,\n    0x802001,\n    0x80,\n    0x800000,\n    0x2001,\n    0x2080,\n    0x800081,\n    0x1,\n    0x2080,\n    0x800080,\n    0x2000,\n    0x802080,\n    0x802081,\n    0x81,\n    0x800080,\n    0x800001,\n    0x802000,\n    0x802081,\n    0x81,\n    0,\n    0,\n    0x802000,\n    0x2080,\n    0x800080,\n    0x800081,\n    0x1,\n    0x802001,\n    0x2081,\n    0x2081,\n    0x80,\n    0x802081,\n    0x81,\n    0x1,\n    0x2000,\n    0x800001,\n    0x2001,\n    0x802080,\n    0x800081,\n    0x2001,\n    0x2080,\n    0x800000,\n    0x802001,\n    0x80,\n    0x800000,\n    0x2000,\n    0x802080\n];\nvar spfunction5 = [\n    0x100,\n    0x2080100,\n    0x2080000,\n    0x42000100,\n    0x80000,\n    0x100,\n    0x40000000,\n    0x2080000,\n    0x40080100,\n    0x80000,\n    0x2000100,\n    0x40080100,\n    0x42000100,\n    0x42080000,\n    0x80100,\n    0x40000000,\n    0x2000000,\n    0x40080000,\n    0x40080000,\n    0,\n    0x40000100,\n    0x42080100,\n    0x42080100,\n    0x2000100,\n    0x42080000,\n    0x40000100,\n    0,\n    0x42000000,\n    0x2080100,\n    0x2000000,\n    0x42000000,\n    0x80100,\n    0x80000,\n    0x42000100,\n    0x100,\n    0x2000000,\n    0x40000000,\n    0x2080000,\n    0x42000100,\n    0x40080100,\n    0x2000100,\n    0x40000000,\n    0x42080000,\n    0x2080100,\n    0x40080100,\n    0x100,\n    0x2000000,\n    0x42080000,\n    0x42080100,\n    0x80100,\n    0x42000000,\n    0x42080100,\n    0x2080000,\n    0,\n    0x40080000,\n    0x42000000,\n    0x80100,\n    0x2000100,\n    0x40000100,\n    0x80000,\n    0,\n    0x40080000,\n    0x2080100,\n    0x40000100\n];\nvar spfunction6 = [\n    0x20000010,\n    0x20400000,\n    0x4000,\n    0x20404010,\n    0x20400000,\n    0x10,\n    0x20404010,\n    0x400000,\n    0x20004000,\n    0x404010,\n    0x400000,\n    0x20000010,\n    0x400010,\n    0x20004000,\n    0x20000000,\n    0x4010,\n    0,\n    0x400010,\n    0x20004010,\n    0x4000,\n    0x404000,\n    0x20004010,\n    0x10,\n    0x20400010,\n    0x20400010,\n    0,\n    0x404010,\n    0x20404000,\n    0x4010,\n    0x404000,\n    0x20404000,\n    0x20000000,\n    0x20004000,\n    0x10,\n    0x20400010,\n    0x404000,\n    0x20404010,\n    0x400000,\n    0x4010,\n    0x20000010,\n    0x400000,\n    0x20004000,\n    0x20000000,\n    0x4010,\n    0x20000010,\n    0x20404010,\n    0x404000,\n    0x20400000,\n    0x404010,\n    0x20404000,\n    0,\n    0x20400010,\n    0x10,\n    0x4000,\n    0x20400000,\n    0x404010,\n    0x4000,\n    0x400010,\n    0x20004010,\n    0,\n    0x20404000,\n    0x20000000,\n    0x400010,\n    0x20004010\n];\nvar spfunction7 = [\n    0x200000,\n    0x4200002,\n    0x4000802,\n    0,\n    0x800,\n    0x4000802,\n    0x200802,\n    0x4200800,\n    0x4200802,\n    0x200000,\n    0,\n    0x4000002,\n    0x2,\n    0x4000000,\n    0x4200002,\n    0x802,\n    0x4000800,\n    0x200802,\n    0x200002,\n    0x4000800,\n    0x4000002,\n    0x4200000,\n    0x4200800,\n    0x200002,\n    0x4200000,\n    0x800,\n    0x802,\n    0x4200802,\n    0x200800,\n    0x2,\n    0x4000000,\n    0x200800,\n    0x4000000,\n    0x200800,\n    0x200000,\n    0x4000802,\n    0x4000802,\n    0x4200002,\n    0x4200002,\n    0x2,\n    0x200002,\n    0x4000000,\n    0x4000800,\n    0x200000,\n    0x4200800,\n    0x802,\n    0x200802,\n    0x4200800,\n    0x802,\n    0x4000002,\n    0x4200802,\n    0x4200000,\n    0x200800,\n    0,\n    0x2,\n    0x4200802,\n    0,\n    0x200802,\n    0x4200000,\n    0x800,\n    0x4000002,\n    0x4000800,\n    0x800,\n    0x200002\n];\nvar spfunction8 = [\n    0x10001040,\n    0x1000,\n    0x40000,\n    0x10041040,\n    0x10000000,\n    0x10001040,\n    0x40,\n    0x10000000,\n    0x40040,\n    0x10040000,\n    0x10041040,\n    0x41000,\n    0x10041000,\n    0x41040,\n    0x1000,\n    0x40,\n    0x10040000,\n    0x10000040,\n    0x10001000,\n    0x1040,\n    0x41000,\n    0x40040,\n    0x10040040,\n    0x10041000,\n    0x1040,\n    0,\n    0,\n    0x10040040,\n    0x10000040,\n    0x10001000,\n    0x41040,\n    0x40000,\n    0x41040,\n    0x40000,\n    0x10041000,\n    0x1000,\n    0x40,\n    0x10040040,\n    0x1000,\n    0x41040,\n    0x10001000,\n    0x40,\n    0x10000040,\n    0x10040000,\n    0x10040040,\n    0x10000000,\n    0x40000,\n    0x10001040,\n    0,\n    0x10041040,\n    0x40040,\n    0x10000040,\n    0x10040000,\n    0x10001000,\n    0x10001040,\n    0,\n    0x10041040,\n    0x41000,\n    0x41000,\n    0x1040,\n    0x1040,\n    0x40040,\n    0x10000000,\n    0x10041000\n];\n/**\n * Create necessary sub keys.\n *\n * @param key the 64-bit or 192-bit key.\n *\n * @return the expanded keys.\n */ function _createKeys(key) {\n    var pc2bytes0 = [\n        0,\n        0x4,\n        0x20000000,\n        0x20000004,\n        0x10000,\n        0x10004,\n        0x20010000,\n        0x20010004,\n        0x200,\n        0x204,\n        0x20000200,\n        0x20000204,\n        0x10200,\n        0x10204,\n        0x20010200,\n        0x20010204\n    ], pc2bytes1 = [\n        0,\n        0x1,\n        0x100000,\n        0x100001,\n        0x4000000,\n        0x4000001,\n        0x4100000,\n        0x4100001,\n        0x100,\n        0x101,\n        0x100100,\n        0x100101,\n        0x4000100,\n        0x4000101,\n        0x4100100,\n        0x4100101\n    ], pc2bytes2 = [\n        0,\n        0x8,\n        0x800,\n        0x808,\n        0x1000000,\n        0x1000008,\n        0x1000800,\n        0x1000808,\n        0,\n        0x8,\n        0x800,\n        0x808,\n        0x1000000,\n        0x1000008,\n        0x1000800,\n        0x1000808\n    ], pc2bytes3 = [\n        0,\n        0x200000,\n        0x8000000,\n        0x8200000,\n        0x2000,\n        0x202000,\n        0x8002000,\n        0x8202000,\n        0x20000,\n        0x220000,\n        0x8020000,\n        0x8220000,\n        0x22000,\n        0x222000,\n        0x8022000,\n        0x8222000\n    ], pc2bytes4 = [\n        0,\n        0x40000,\n        0x10,\n        0x40010,\n        0,\n        0x40000,\n        0x10,\n        0x40010,\n        0x1000,\n        0x41000,\n        0x1010,\n        0x41010,\n        0x1000,\n        0x41000,\n        0x1010,\n        0x41010\n    ], pc2bytes5 = [\n        0,\n        0x400,\n        0x20,\n        0x420,\n        0,\n        0x400,\n        0x20,\n        0x420,\n        0x2000000,\n        0x2000400,\n        0x2000020,\n        0x2000420,\n        0x2000000,\n        0x2000400,\n        0x2000020,\n        0x2000420\n    ], pc2bytes6 = [\n        0,\n        0x10000000,\n        0x80000,\n        0x10080000,\n        0x2,\n        0x10000002,\n        0x80002,\n        0x10080002,\n        0,\n        0x10000000,\n        0x80000,\n        0x10080000,\n        0x2,\n        0x10000002,\n        0x80002,\n        0x10080002\n    ], pc2bytes7 = [\n        0,\n        0x10000,\n        0x800,\n        0x10800,\n        0x20000000,\n        0x20010000,\n        0x20000800,\n        0x20010800,\n        0x20000,\n        0x30000,\n        0x20800,\n        0x30800,\n        0x20020000,\n        0x20030000,\n        0x20020800,\n        0x20030800\n    ], pc2bytes8 = [\n        0,\n        0x40000,\n        0,\n        0x40000,\n        0x2,\n        0x40002,\n        0x2,\n        0x40002,\n        0x2000000,\n        0x2040000,\n        0x2000000,\n        0x2040000,\n        0x2000002,\n        0x2040002,\n        0x2000002,\n        0x2040002\n    ], pc2bytes9 = [\n        0,\n        0x10000000,\n        0x8,\n        0x10000008,\n        0,\n        0x10000000,\n        0x8,\n        0x10000008,\n        0x400,\n        0x10000400,\n        0x408,\n        0x10000408,\n        0x400,\n        0x10000400,\n        0x408,\n        0x10000408\n    ], pc2bytes10 = [\n        0,\n        0x20,\n        0,\n        0x20,\n        0x100000,\n        0x100020,\n        0x100000,\n        0x100020,\n        0x2000,\n        0x2020,\n        0x2000,\n        0x2020,\n        0x102000,\n        0x102020,\n        0x102000,\n        0x102020\n    ], pc2bytes11 = [\n        0,\n        0x1000000,\n        0x200,\n        0x1000200,\n        0x200000,\n        0x1200000,\n        0x200200,\n        0x1200200,\n        0x4000000,\n        0x5000000,\n        0x4000200,\n        0x5000200,\n        0x4200000,\n        0x5200000,\n        0x4200200,\n        0x5200200\n    ], pc2bytes12 = [\n        0,\n        0x1000,\n        0x8000000,\n        0x8001000,\n        0x80000,\n        0x81000,\n        0x8080000,\n        0x8081000,\n        0x10,\n        0x1010,\n        0x8000010,\n        0x8001010,\n        0x80010,\n        0x81010,\n        0x8080010,\n        0x8081010\n    ], pc2bytes13 = [\n        0,\n        0x4,\n        0x100,\n        0x104,\n        0,\n        0x4,\n        0x100,\n        0x104,\n        0x1,\n        0x5,\n        0x101,\n        0x105,\n        0x1,\n        0x5,\n        0x101,\n        0x105\n    ];\n    // how many iterations (1 for des, 3 for triple des)\n    // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys\n    var iterations = key.length() > 8 ? 3 : 1;\n    // stores the return keys\n    var keys = [];\n    // now define the left shifts which need to be done\n    var shifts = [\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0\n    ];\n    var n = 0, tmp;\n    for(var j = 0; j < iterations; j++){\n        var left = key.getInt32();\n        var right = key.getInt32();\n        tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n        right ^= tmp;\n        left ^= tmp << 4;\n        tmp = (right >>> -16 ^ left) & 0x0000ffff;\n        left ^= tmp;\n        right ^= tmp << -16;\n        tmp = (left >>> 2 ^ right) & 0x33333333;\n        right ^= tmp;\n        left ^= tmp << 2;\n        tmp = (right >>> -16 ^ left) & 0x0000ffff;\n        left ^= tmp;\n        right ^= tmp << -16;\n        tmp = (left >>> 1 ^ right) & 0x55555555;\n        right ^= tmp;\n        left ^= tmp << 1;\n        tmp = (right >>> 8 ^ left) & 0x00ff00ff;\n        left ^= tmp;\n        right ^= tmp << 8;\n        tmp = (left >>> 1 ^ right) & 0x55555555;\n        right ^= tmp;\n        left ^= tmp << 1;\n        // right needs to be shifted and OR'd with last four bits of left\n        tmp = left << 8 | right >>> 20 & 0x000000f0;\n        // left needs to be put upside down\n        left = right << 24 | right << 8 & 0xff0000 | right >>> 8 & 0xff00 | right >>> 24 & 0xf0;\n        right = tmp;\n        // now go through and perform these shifts on the left and right keys\n        for(var i = 0; i < shifts.length; ++i){\n            //shift the keys either one or two bits to the left\n            if (shifts[i]) {\n                left = left << 2 | left >>> 26;\n                right = right << 2 | right >>> 26;\n            } else {\n                left = left << 1 | left >>> 27;\n                right = right << 1 | right >>> 27;\n            }\n            left &= -0xf;\n            right &= -0xf;\n            // now apply PC-2, in such a way that E is easier when encrypting or\n            // decrypting this conversion will look like PC-2 except only the last 6\n            // bits of each byte are used rather than 48 consecutive bits and the\n            // order of lines will be according to how the S selection functions will\n            // be applied: S2, S4, S6, S8, S1, S3, S5, S7\n            var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 0xf] | pc2bytes2[left >>> 20 & 0xf] | pc2bytes3[left >>> 16 & 0xf] | pc2bytes4[left >>> 12 & 0xf] | pc2bytes5[left >>> 8 & 0xf] | pc2bytes6[left >>> 4 & 0xf];\n            var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 0xf] | pc2bytes9[right >>> 20 & 0xf] | pc2bytes10[right >>> 16 & 0xf] | pc2bytes11[right >>> 12 & 0xf] | pc2bytes12[right >>> 8 & 0xf] | pc2bytes13[right >>> 4 & 0xf];\n            tmp = (righttmp >>> 16 ^ lefttmp) & 0x0000ffff;\n            keys[n++] = lefttmp ^ tmp;\n            keys[n++] = righttmp ^ tmp << 16;\n        }\n    }\n    return keys;\n}\n/**\n * Updates a single block (1 byte) using DES. The update will either\n * encrypt or decrypt the block.\n *\n * @param keys the expanded keys.\n * @param input the input block (an array of 32-bit words).\n * @param output the updated output block.\n * @param decrypt true to decrypt the block, false to encrypt it.\n */ function _updateBlock(keys, input, output, decrypt) {\n    // set up loops for single or triple DES\n    var iterations = keys.length === 32 ? 3 : 9;\n    var looping;\n    if (iterations === 3) {\n        looping = decrypt ? [\n            30,\n            -2,\n            -2\n        ] : [\n            0,\n            32,\n            2\n        ];\n    } else {\n        looping = decrypt ? [\n            94,\n            62,\n            -2,\n            32,\n            64,\n            2,\n            30,\n            -2,\n            -2\n        ] : [\n            0,\n            32,\n            2,\n            62,\n            30,\n            -2,\n            64,\n            96,\n            2\n        ];\n    }\n    var tmp;\n    var left = input[0];\n    var right = input[1];\n    // first each 64 bit chunk of the message must be permuted according to IP\n    tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n    right ^= tmp;\n    left ^= tmp << 4;\n    tmp = (left >>> 16 ^ right) & 0x0000ffff;\n    right ^= tmp;\n    left ^= tmp << 16;\n    tmp = (right >>> 2 ^ left) & 0x33333333;\n    left ^= tmp;\n    right ^= tmp << 2;\n    tmp = (right >>> 8 ^ left) & 0x00ff00ff;\n    left ^= tmp;\n    right ^= tmp << 8;\n    tmp = (left >>> 1 ^ right) & 0x55555555;\n    right ^= tmp;\n    left ^= tmp << 1;\n    // rotate left 1 bit\n    left = left << 1 | left >>> 31;\n    right = right << 1 | right >>> 31;\n    for(var j = 0; j < iterations; j += 3){\n        var endloop = looping[j + 1];\n        var loopinc = looping[j + 2];\n        // now go through and perform the encryption or decryption\n        for(var i = looping[j]; i != endloop; i += loopinc){\n            var right1 = right ^ keys[i];\n            var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];\n            // passing these bytes through the S selection functions\n            tmp = left;\n            left = right;\n            right = tmp ^ (spfunction2[right1 >>> 24 & 0x3f] | spfunction4[right1 >>> 16 & 0x3f] | spfunction6[right1 >>> 8 & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[right2 >>> 24 & 0x3f] | spfunction3[right2 >>> 16 & 0x3f] | spfunction5[right2 >>> 8 & 0x3f] | spfunction7[right2 & 0x3f]);\n        }\n        // unreverse left and right\n        tmp = left;\n        left = right;\n        right = tmp;\n    }\n    // rotate right 1 bit\n    left = left >>> 1 | left << 31;\n    right = right >>> 1 | right << 31;\n    // now perform IP-1, which is IP in the opposite direction\n    tmp = (left >>> 1 ^ right) & 0x55555555;\n    right ^= tmp;\n    left ^= tmp << 1;\n    tmp = (right >>> 8 ^ left) & 0x00ff00ff;\n    left ^= tmp;\n    right ^= tmp << 8;\n    tmp = (right >>> 2 ^ left) & 0x33333333;\n    left ^= tmp;\n    right ^= tmp << 2;\n    tmp = (left >>> 16 ^ right) & 0x0000ffff;\n    right ^= tmp;\n    left ^= tmp << 16;\n    tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n    right ^= tmp;\n    left ^= tmp << 4;\n    output[0] = left;\n    output[1] = right;\n}\n/**\n * Deprecated. Instead, use:\n *\n * forge.cipher.createCipher('DES-<mode>', key);\n * forge.cipher.createDecipher('DES-<mode>', key);\n *\n * Creates a deprecated DES cipher object. This object's mode will default to\n * CBC (cipher-block-chaining).\n *\n * The key may be given as a binary-encoded string of bytes or a byte buffer.\n *\n * @param options the options to use.\n *          key the symmetric key to use (64 or 192 bits).\n *          output the buffer to write to.\n *          decrypt true for decryption, false for encryption.\n *          mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ function _createCipher(options) {\n    options = options || {};\n    var mode = (options.mode || \"CBC\").toUpperCase();\n    var algorithm = \"DES-\" + mode;\n    var cipher;\n    if (options.decrypt) {\n        cipher = forge.cipher.createDecipher(algorithm, options.key);\n    } else {\n        cipher = forge.cipher.createCipher(algorithm, options.key);\n    }\n    // backwards compatible start API\n    var start = cipher.start;\n    cipher.start = function(iv, options) {\n        // backwards compatibility: support second arg as output buffer\n        var output = null;\n        if (options instanceof forge.util.ByteBuffer) {\n            output = options;\n            options = {};\n        }\n        options = options || {};\n        options.output = output;\n        options.iv = iv;\n        start.call(cipher, options);\n    };\n    return cipher;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixXQUFXLEdBQ1hDLE9BQU9DLE9BQU8sR0FBR0gsTUFBTUksR0FBRyxHQUFHSixNQUFNSSxHQUFHLElBQUksQ0FBQztBQUUzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNESixNQUFNSSxHQUFHLENBQUNDLGVBQWUsR0FBRyxTQUFTQyxHQUFHLEVBQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQ3hELElBQUlDLFNBQVNDLGNBQWM7UUFDekJMLEtBQUtBO1FBQ0xFLFFBQVFBO1FBQ1JJLFNBQVM7UUFDVEgsTUFBTUEsUUFBU0YsQ0FBQUEsT0FBTyxPQUFPLFFBQVEsS0FBSTtJQUMzQztJQUNBRyxPQUFPRyxLQUFLLENBQUNOO0lBQ2IsT0FBT0c7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRFYsTUFBTUksR0FBRyxDQUFDVSxzQkFBc0IsR0FBRyxTQUFTUixHQUFHLEVBQUVHLElBQUk7SUFDbkQsT0FBT0UsY0FBYztRQUNuQkwsS0FBS0E7UUFDTEUsUUFBUTtRQUNSSSxTQUFTO1FBQ1RILE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0RULE1BQU1JLEdBQUcsQ0FBQ1csZUFBZSxHQUFHLFNBQVNULEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7SUFDeEQsSUFBSUMsU0FBU0MsY0FBYztRQUN6QkwsS0FBS0E7UUFDTEUsUUFBUUE7UUFDUkksU0FBUztRQUNUSCxNQUFNQSxRQUFTRixDQUFBQSxPQUFPLE9BQU8sUUFBUSxLQUFJO0lBQzNDO0lBQ0FH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QVU7SUFBVTtJQUFVO0lBQUk7SUFBTTtJQUFVO0lBQVU7SUFBUTtJQUFRO0lBQVU7SUFBVTtJQUFVO0lBQVE7SUFBVTtJQUFVO0lBQVE7SUFBRTtJQUFNO0lBQVE7SUFBVTtJQUFRO0lBQVU7SUFBSTtJQUFVO0lBQVU7SUFBVTtJQUFVO0lBQU07SUFBVTtJQUFRO0lBQVE7SUFBVTtJQUFNO0lBQUk7SUFBVTtJQUFRO0lBQVU7SUFBUTtJQUFVO0lBQVU7SUFBVTtJQUFNO0lBQVE7SUFBVTtJQUFNO0lBQVU7SUFBVTtJQUFFO0lBQVE7SUFBUTtJQUFFO0NBQVU7QUFDM2hCLElBQUlDLGNBQWM7SUFBQyxDQUFDO0lBQVcsQ0FBQztJQUFXO0lBQU87SUFBUztJQUFTO0lBQUssQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVcsQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVcsQ0FBQztJQUFXO0lBQVM7SUFBSyxDQUFDO0lBQVc7SUFBUztJQUFTLENBQUM7SUFBVztJQUFFLENBQUM7SUFBVztJQUFPO0lBQVMsQ0FBQztJQUFXO0lBQVMsQ0FBQztJQUFXO0lBQUU7SUFBUztJQUFPLENBQUM7SUFBVyxDQUFDO0lBQVc7SUFBTztJQUFFO0lBQVMsQ0FBQztJQUFXO0lBQVMsQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVc7SUFBTyxDQUFDO0lBQVcsQ0FBQztJQUFXO0lBQUssQ0FBQztJQUFXO0lBQVM7SUFBSztJQUFPLENBQUM7SUFBVztJQUFPLENBQUM7SUFBVztJQUFTLENBQUM7SUFBVztJQUFTLENBQUM7SUFBVyxDQUFDO0lBQVc7SUFBUztJQUFTO0lBQUUsQ0FBQztJQUFXO0lBQU8sQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVc7Q0FBUztBQUN2bkIsSUFBSUMsY0FBYztJQUFDO0lBQU07SUFBVTtJQUFFO0lBQVU7SUFBVTtJQUFFO0lBQVE7SUFBVTtJQUFRO0lBQVU7SUFBVTtJQUFRO0lBQVU7SUFBUTtJQUFVO0lBQU07SUFBVTtJQUFJO0lBQVU7SUFBTTtJQUFRO0lBQVU7SUFBVTtJQUFRO0lBQVU7SUFBUTtJQUFRO0lBQVU7SUFBSTtJQUFVO0lBQU07SUFBVTtJQUFVO0lBQVU7SUFBUTtJQUFNO0lBQVE7SUFBVTtJQUFVO0lBQUU7SUFBTTtJQUFRO0lBQVU7SUFBVTtJQUFVO0lBQU07SUFBRTtJQUFVO0lBQVU7SUFBUTtJQUFVO0lBQVU7SUFBSTtJQUFRO0lBQVE7SUFBVTtJQUFVO0lBQVU7SUFBTTtJQUFVO0lBQVE7SUFBSTtJQUFVO0NBQVE7QUFDM2hCLElBQUlDLGNBQWM7SUFBQztJQUFTO0lBQU87SUFBTztJQUFLO0lBQVM7SUFBUztJQUFTO0lBQU87SUFBRTtJQUFTO0lBQVM7SUFBUztJQUFLO0lBQUU7SUFBUztJQUFTO0lBQUk7SUFBTztJQUFTO0lBQVM7SUFBSztJQUFTO0lBQU87SUFBTztJQUFTO0lBQUk7SUFBTztJQUFTO0lBQU87SUFBUztJQUFTO0lBQUs7SUFBUztJQUFTO0lBQVM7SUFBUztJQUFLO0lBQUU7SUFBRTtJQUFTO0lBQU87SUFBUztJQUFTO0lBQUk7SUFBUztJQUFPO0lBQU87SUFBSztJQUFTO0lBQUs7SUFBSTtJQUFPO0lBQVM7SUFBTztJQUFTO0lBQVM7SUFBTztJQUFPO0lBQVM7SUFBUztJQUFLO0lBQVM7SUFBTztDQUFTO0FBQ25lLElBQUlDLGNBQWM7SUFBQztJQUFNO0lBQVU7SUFBVTtJQUFXO0lBQVE7SUFBTTtJQUFXO0lBQVU7SUFBVztJQUFRO0lBQVU7SUFBVztJQUFXO0lBQVc7SUFBUTtJQUFXO0lBQVU7SUFBVztJQUFXO0lBQUU7SUFBVztJQUFXO0lBQVc7SUFBVTtJQUFXO0lBQVc7SUFBRTtJQUFXO0lBQVU7SUFBVTtJQUFXO0lBQVE7SUFBUTtJQUFXO0lBQU07SUFBVTtJQUFXO0lBQVU7SUFBVztJQUFXO0lBQVU7SUFBVztJQUFXO0lBQVU7SUFBVztJQUFNO0lBQVU7SUFBVztJQUFXO0lBQVE7SUFBVztJQUFXO0lBQVU7SUFBRTtJQUFXO0lBQVc7SUFBUTtJQUFVO0lBQVc7SUFBUTtJQUFFO0lBQVc7SUFBVTtDQUFXO0FBQ25uQixJQUFJQyxjQUFjO0lBQUM7SUFBVztJQUFXO0lBQU87SUFBVztJQUFXO0lBQUs7SUFBVztJQUFTO0lBQVc7SUFBUztJQUFTO0lBQVc7SUFBUztJQUFXO0lBQVc7SUFBTztJQUFFO0lBQVM7SUFBVztJQUFPO0lBQVM7SUFBVztJQUFLO0lBQVc7SUFBVztJQUFFO0lBQVM7SUFBVztJQUFPO0lBQVM7SUFBVztJQUFXO0lBQVc7SUFBSztJQUFXO0lBQVM7SUFBVztJQUFTO0lBQU87SUFBVztJQUFTO0lBQVc7SUFBVztJQUFPO0lBQVc7SUFBVztJQUFTO0lBQVc7SUFBUztJQUFXO0lBQUU7SUFBVztJQUFLO0lBQU87SUFBVztJQUFTO0lBQU87SUFBUztJQUFXO0lBQUU7SUFBVztJQUFXO0lBQVM7Q0FBVztBQUN2bEIsSUFBSUMsY0FBYztJQUFDO0lBQVM7SUFBVTtJQUFVO0lBQUU7SUFBTTtJQUFVO0lBQVM7SUFBVTtJQUFVO0lBQVM7SUFBRTtJQUFVO0lBQUk7SUFBVTtJQUFVO0lBQU07SUFBVTtJQUFTO0lBQVM7SUFBVTtJQUFVO0lBQVU7SUFBVTtJQUFTO0lBQVU7SUFBTTtJQUFNO0lBQVU7SUFBUztJQUFJO0lBQVU7SUFBUztJQUFVO0lBQVM7SUFBUztJQUFVO0lBQVU7SUFBVTtJQUFVO0lBQUk7SUFBUztJQUFVO0lBQVU7SUFBUztJQUFVO0lBQU07SUFBUztJQUFVO0lBQU07SUFBVTtJQUFVO0lBQVU7SUFBUztJQUFFO0lBQUk7SUFBVTtJQUFFO0lBQVM7SUFBVTtJQUFNO0lBQVU7SUFBVTtJQUFNO0NBQVM7QUFDM2lCLElBQUlDLGNBQWM7SUFBQztJQUFXO0lBQU87SUFBUTtJQUFXO0lBQVc7SUFBVztJQUFLO0lBQVc7SUFBUTtJQUFXO0lBQVc7SUFBUTtJQUFXO0lBQVE7SUFBTztJQUFLO0lBQVc7SUFBVztJQUFXO0lBQU87SUFBUTtJQUFRO0lBQVc7SUFBVztJQUFPO0lBQUU7SUFBRTtJQUFXO0lBQVc7SUFBVztJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVc7SUFBTztJQUFLO0lBQVc7SUFBTztJQUFRO0lB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QSxNQUFNLENBQUMsU0FBVSxJQUFLSSxLQUFJLElBQUs7SUFDL0JBLFNBQVNKO0lBQ1RFLFFBQVNGLE9BQU87SUFFaEI5RCxNQUFNLENBQUMsRUFBRSxHQUFHZ0U7SUFDWmhFLE1BQU0sQ0FBQyxFQUFFLEdBQUdrRTtBQUNkO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVMvRCxjQUFja0IsT0FBTztJQUM1QkEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUlwQixPQUFPLENBQUNvQixRQUFRcEIsSUFBSSxJQUFJLEtBQUksRUFBRzJFLFdBQVc7SUFDOUMsSUFBSUMsWUFBWSxTQUFTNUU7SUFFekIsSUFBSUM7SUFDSixJQUFHbUIsUUFBUWpCLE9BQU8sRUFBRTtRQUNsQkYsU0FBU1YsTUFBTVUsTUFBTSxDQUFDNEUsY0FBYyxDQUFDRCxXQUFXeEQsUUFBUXZCLEdBQUc7SUFDN0QsT0FBTztRQUNMSSxTQUFTVixNQUFNVSxNQUFNLENBQUM2RSxZQUFZLENBQUNGLFdBQVd4RCxRQUFRdkIsR0FBRztJQUMzRDtJQUVBLGlDQUFpQztJQUNqQyxJQUFJTyxRQUFRSCxPQUFPRyxLQUFLO0lBQ3hCSCxPQUFPRyxLQUFLLEdBQUcsU0FBU04sRUFBRSxFQUFFc0IsT0FBTztRQUNqQywrREFBK0Q7UUFDL0QsSUFBSXJCLFNBQVM7UUFDYixJQUFHcUIsbUJBQW1CN0IsTUFBTThCLElBQUksQ0FBQzBELFVBQVUsRUFBRTtZQUMzQ2hGLFNBQVNxQjtZQUNUQSxVQUFVLENBQUM7UUFDYjtRQUNBQSxVQUFVQSxXQUFXLENBQUM7UUFDdEJBLFFBQVFyQixNQUFNLEdBQUdBO1FBQ2pCcUIsUUFBUXRCLEVBQUUsR0FBR0E7UUFDYk0sTUFBTTRFLElBQUksQ0FBQy9FLFFBQVFtQjtJQUNyQjtJQUVBLE9BQU9uQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZGVzLmpzPzUzN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBERVMgKERhdGEgRW5jcnlwdGlvbiBTdGFuZGFyZCkgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0cyBERVMgYXMgd2VsbCBhcyAzREVTLUVERSBpbiBFQ0IgYW5kIENCQyBtb2RlLlxuICogSXQgaXMgYmFzZWQgb24gdGhlIEJTRC1saWNlbnNlZCBpbXBsZW1lbnRhdGlvbiBieSBQYXVsIFRlcm86XG4gKlxuICogUGF1bCBUZXJvLCBKdWx5IDIwMDFcbiAqIGh0dHA6Ly93d3cudGVyby5jby51ay9kZXMvXG4gKlxuICogT3B0aW1pc2VkIGZvciBwZXJmb3JtYW5jZSB3aXRoIGxhcmdlIGJsb2NrcyBieVxuICogTWljaGFlbCBIYXl3b3J0aCwgTm92ZW1iZXIgMjAwMVxuICogaHR0cDovL3d3dy5uZXRkZWFsaW5nLmNvbVxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEVcbiAqIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICogT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVFxuICogTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWVxuICogT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICogU1VDSCBEQU1BR0UuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2NpcGhlcicpO1xucmVxdWlyZSgnLi9jaXBoZXJNb2RlcycpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qIERFUyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuZGVzID0gZm9yZ2UuZGVzIHx8IHt9O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKiBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gREVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGJpbmFyeS1lbmNvZGVkIHN0cmluZ3Mgb2YgYnl0ZXMgb3JcbiAqIGJ5dGUgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJyBpZiBJViBpc1xuICogICAgICAgICAgZ2l2ZW4sICdFQ0InIGlmIG51bGwpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlICg2NCBvciAxOTIgYml0cykuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZGVjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gREVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGJpbmFyeS1lbmNvZGVkIHN0cmluZ3Mgb2YgYnl0ZXMgb3JcbiAqIGJ5dGUgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJyBpZiBJViBpc1xuICogICAgICAgICAgZ2l2ZW4sICdFQ0InIGlmIG51bGwpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlIHx8IChpdiA9PT0gbnVsbCA/ICdFQ0InIDogJ0NCQycpXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlICg2NCBvciAxOTIgYml0cykuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBERVMgY2lwaGVyIGFsZ29yaXRobSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgREVTIGFsZ29yaXRobSBvYmplY3QuXG4gKi9cbmZvcmdlLmRlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5uYW1lID0gbmFtZTtcbiAgc2VsZi5tb2RlID0gbmV3IG1vZGUoe1xuICAgIGJsb2NrU2l6ZTogOCxcbiAgICBjaXBoZXI6IHtcbiAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZi5fa2V5cywgaW5CbG9jaywgb3V0QmxvY2ssIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBkZWNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZWxmLl9pbml0ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoaXMgREVTIGFsZ29yaXRobSBieSBleHBhbmRpbmcgaXRzIGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBrZXkgdGhlIGtleSB0byB1c2Ugd2l0aCB0aGlzIGFsZ29yaXRobS5cbiAqICAgICAgICAgIGRlY3J5cHQgdHJ1ZSBpZiB0aGUgYWxnb3JpdGhtIHNob3VsZCBiZSBpbml0aWFsaXplZCBmb3IgZGVjcnlwdGlvbixcbiAqICAgICAgICAgICAgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKi9cbmZvcmdlLmRlcy5BbGdvcml0aG0ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKHRoaXMuX2luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5rZXkpO1xuICBpZih0aGlzLm5hbWUuaW5kZXhPZignM0RFUycpID09PSAwKSB7XG4gICAgaWYoa2V5Lmxlbmd0aCgpICE9PSAyNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFRyaXBsZS1ERVMga2V5IHNpemU6ICcgKyBrZXkubGVuZ3RoKCkgKiA4KTtcbiAgICB9XG4gIH1cblxuICAvLyBkbyBrZXkgZXhwYW5zaW9uIHRvIDE2IG9yIDQ4IHN1YmtleXMgKHNpbmdsZSBvciB0cmlwbGUgREVTKVxuICB0aGlzLl9rZXlzID0gX2NyZWF0ZUtleXMoa2V5KTtcbiAgdGhpcy5faW5pdCA9IHRydWU7XG59O1xuXG4vKiogUmVnaXN0ZXIgREVTIGFsZ29yaXRobXMgKiovXG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xuXG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1FQ0InLCBmb3JnZS5jaXBoZXIubW9kZXMuZWNiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1PRkInLCBmb3JnZS5jaXBoZXIubW9kZXMub2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xuXG5mdW5jdGlvbiByZWdpc3RlckFsZ29yaXRobShuYW1lLCBtb2RlKSB7XG4gIHZhciBmYWN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBmb3JnZS5kZXMuQWxnb3JpdGhtKG5hbWUsIG1vZGUpO1xuICB9O1xuICBmb3JnZS5jaXBoZXIucmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgZmFjdG9yeSk7XG59XG5cbi8qKiBERVMgaW1wbGVtZW50YXRpb24gKiovXG5cbnZhciBzcGZ1bmN0aW9uMSA9IFsweDEwMTA0MDAsMCwweDEwMDAwLDB4MTAxMDQwNCwweDEwMTAwMDQsMHgxMDQwNCwweDQsMHgxMDAwMCwweDQwMCwweDEwMTA0MDAsMHgxMDEwNDA0LDB4NDAwLDB4MTAwMDQwNCwweDEwMTAwMDQsMHgxMDAwMDAwLDB4NCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDB4MTA0MDAsMHgxMDQwMCwweDEwMTAwMDAsMHgxMDEwMDAwLDB4MTAwMDQwNCwweDEwMDA0LDB4MTAwMDAwNCwweDEwMDAwMDQsMHgxMDAwNCwwLDB4NDA0LDB4MTA0MDQsMHgxMDAwMDAwLDB4MTAwMDAsMHgxMDEwNDA0LDB4NCwweDEwMTAwMDAsMHgxMDEwNDAwLDB4MTAwMDAwMCwweDEwMDAwMDAsMHg0MDAsMHgxMDEwMDA0LDB4MTAwMDAsMHgxMDQwMCwweDEwMDAwMDQsMHg0MDAsMHg0LDB4MTAwMDQwNCwweDEwNDA0LDB4MTAxMDQwNCwweDEwMDA0LDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwMDA0LDB4NDA0LDB4MTA0MDQsMHgxMDEwNDAwLDB4NDA0LDB4MTAwMDQwMCwweDEwMDA0MDAsMCwweDEwMDA0LDB4MTA0MDAsMCwweDEwMTAwMDRdO1xudmFyIHNwZnVuY3Rpb24yID0gWy0weDdmZWY3ZmUwLC0weDdmZmY4MDAwLDB4ODAwMCwweDEwODAyMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLC0weDdmZmY3ZmUwLC0weDdmZmZmZmUwLC0weDdmZWY3ZmUwLC0weDdmZWY4MDAwLC0weDgwMDAwMDAwLC0weDdmZmY4MDAwLDB4MTAwMDAwLDB4MjAsLTB4N2ZlZmZmZTAsMHgxMDgwMDAsMHgxMDAwMjAsLTB4N2ZmZjdmZTAsMCwtMHg4MDAwMDAwMCwweDgwMDAsMHgxMDgwMjAsLTB4N2ZmMDAwMDAsMHgxMDAwMjAsLTB4N2ZmZmZmZTAsMCwweDEwODAwMCwweDgwMjAsLTB4N2ZlZjgwMDAsLTB4N2ZmMDAwMDAsMHg4MDIwLDAsMHgxMDgwMjAsLTB4N2ZlZmZmZTAsMHgxMDAwMDAsLTB4N2ZmZjdmZTAsLTB4N2ZmMDAwMDAsLTB4N2ZlZjgwMDAsMHg4MDAwLC0weDdmZjAwMDAwLC0weDdmZmY4MDAwLDB4MjAsLTB4N2ZlZjdmZTAsMHgxMDgwMjAsMHgyMCwweDgwMDAsLTB4ODAwMDAwMDAsMHg4MDIwLC0weDdmZWY4MDAwLDB4MTAwMDAwLC0weDdmZmZmZmUwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLC0weDdmZmZmZmUwLDB4MTAwMDIwLDB4MTA4MDAwLDAsLTB4N2ZmZjgwMDAsMHg4MDIwLC0weDgwMDAwMDAwLC0weDdmZWZmZmUwLC0weDdmZWY3ZmUwLDB4MTA4MDAwXTtcbnZhciBzcGZ1bmN0aW9uMyA9IFsweDIwOCwweDgwMjAyMDAsMCwweDgwMjAwMDgsMHg4MDAwMjAwLDAsMHgyMDIwOCwweDgwMDAyMDAsMHgyMDAwOCwweDgwMDAwMDgsMHg4MDAwMDA4LDB4MjAwMDAsMHg4MDIwMjA4LDB4MjAwMDgsMHg4MDIwMDAwLDB4MjA4LDB4ODAwMDAwMCwweDgsMHg4MDIwMjAwLDB4MjAwLDB4MjAyMDAsMHg4MDIwMDAwLDB4ODAyMDAwOCwweDIwMjA4LDB4ODAwMDIwOCwweDIwMjAwLDB4MjAwMDAsMHg4MDAwMjA4LDB4OCwweDgwMjAyMDgsMHgyMDAsMHg4MDAwMDAwLDB4ODAyMDIwMCwweDgwMDAwMDAsMHgyMDAwOCwweDIwOCwweDIwMDAwLDB4ODAyMDIwMCwweDgwMDAyMDAsMCwweDIwMCwweDIwMDA4LDB4ODAyMDIwOCwweDgwMDAyMDAsMHg4MDAwMDA4LDB4MjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwOCwweDIwMDAwLDB4ODAwMDAwMCwweDgwMjAyMDgsMHg4LDB4MjAyMDgsMHgyMDIwMCwweDgwMDAwMDgsMHg4MDIwMDAwLDB4ODAwMDIwOCwweDIwOCwweDgwMjAwMDAsMHgyMDIwOCwweDgsMHg4MDIwMDA4LDB4MjAyMDBdO1xudmFyIHNwZnVuY3Rpb240ID0gWzB4ODAyMDAxLDB4MjA4MSwweDIwODEsMHg4MCwweDgwMjA4MCwweDgwMDA4MSwweDgwMDAwMSwweDIwMDEsMCwweDgwMjAwMCwweDgwMjAwMCwweDgwMjA4MSwweDgxLDAsMHg4MDAwODAsMHg4MDAwMDEsMHgxLDB4MjAwMCwweDgwMDAwMCwweDgwMjAwMSwweDgwLDB4ODAwMDAwLDB4MjAwMSwweDIwODAsMHg4MDAwODEsMHgxLDB4MjA4MCwweDgwMDA4MCwweDIwMDAsMHg4MDIwODAsMHg4MDIwODEsMHg4MSwweDgwMDA4MCwweDgwMDAwMSwweDgwMjAwMCwweDgwMjA4MSwweDgxLDAsMCwweDgwMjAwMCwweDIwODAsMHg4MDAwODAsMHg4MDAwODEsMHgxLDB4ODAyMDAxLDB4MjA4MSwweDIwODEsMHg4MCwweDgwMjA4MSwweDgxLDB4MSwweDIwMDAsMHg4MDAwMDEsMHgyMDAxLDB4ODAyMDgwLDB4ODAwMDgxLDB4MjAwMSwweDIwODAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDAsMHg4MDIwODBdO1xudmFyIHNwZnVuY3Rpb241ID0gWzB4MTAwLDB4MjA4MDEwMCwweDIwODAwMDAsMHg0MjAwMDEwMCwweDgwMDAwLDB4MTAwLDB4NDAwMDAwMDAsMHgyMDgwMDAwLDB4NDAwODAxMDAsMHg4MDAwMCwweDIwMDAxMDAsMHg0MDA4MDEwMCwweDQyMDAwMTAwLDB4NDIwODAwMDAsMHg4MDEwMCwweDQwMDAwMDAwLDB4MjAwMDAwMCwweDQwMDgwMDAwLDB4NDAwODAwMDAsMCwweDQwMDAwMTAwLDB4NDIwODAxMDAsMHg0MjA4MDEwMCwweDIwMDAxMDAsMHg0MjA4MDAwMCwweDQwMDAwMTAwLDAsMHg0MjAwMDAwMCwweDIwODAxMDAsMHgyMDAwMDAwLDB4NDIwMDAwMDAsMHg4MDEwMCwweDgwMDAwLDB4NDIwMDAxMDAsMHgxMDAsMHgyMDAwMDAwLDB4NDAwMDAwMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg0MDA4MDEwMCwweDIwMDAxMDAsMHg0MDAwMDAwMCwweDQyMDgwMDAwLDB4MjA4MDEwMCwweDQwMDgwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQyMDgwMDAwLDB4NDIwODAxMDAsMHg4MDEwMCwweDQyMDAwMDAwLDB4NDIwODAxMDAsMHgyMDgwMDAwLDAsMHg0MDA4MDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAxMDAsMHg4MDAwMCwwLDB4NDAwODAwMDAsMHgyMDgwMTAwLDB4NDAwMDAxMDBdO1xudmFyIHNwZnVuY3Rpb242ID0gWzB4MjAwMDAwMTAsMHgyMDQwMDAwMCwweDQwMDAsMHgyMDQwNDAxMCwweDIwNDAwMDAwLDB4MTAsMHgyMDQwNDAxMCwweDQwMDAwMCwweDIwMDA0MDAwLDB4NDA0MDEwLDB4NDAwMDAwLDB4MjAwMDAwMTAsMHg0MDAwMTAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwwLDB4NDAwMDEwLDB4MjAwMDQwMTAsMHg0MDAwLDB4NDA0MDAwLDB4MjAwMDQwMTAsMHgxMCwweDIwNDAwMDEwLDB4MjA0MDAwMTAsMCwweDQwNDAxMCwweDIwNDA0MDAwLDB4NDAxMCwweDQwNDAwMCwweDIwNDA0MDAwLDB4MjAwMDAwMDAsMHgyMDAwNDAwMCwweDEwLDB4MjA0MDAwMTAsMHg0MDQwMDAsMHgyMDQwNDAxMCwweDQwMDAwMCwweDQwMTAsMHgyMDAwMDAxMCwweDQwMDAwMCwweDIwMDA0MDAwLDB4MjAwMDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHgyMDQwNDAxMCwweDQwNDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4MjA0MDQwMDAsMCwweDIwNDAwMDEwLDB4MTAsMHg0MDAwLDB4MjA0MDAwMDAsMHg0MDQwMTAsMHg0MDAwLDB4NDAwMDEwLDB4MjAwMDQwMTAsMCwweDIwNDA0MDAwLDB4MjAwMDAwMDAsMHg0MDAwMTAsMHgyMDAwNDAxMF07XG52YXIgc3BmdW5jdGlvbjcgPSBbMHgyMDAwMDAsMHg0MjAwMDAyLDB4NDAwMDgwMiwwLDB4ODAwLDB4NDAwMDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg0MjAwODAyLDB4MjAwMDAwLDAsMHg0MDAwMDAyLDB4MiwweDQwMDAwMDAsMHg0MjAwMDAyLDB4ODAyLDB4NDAwMDgwMCwweDIwMDgwMiwweDIwMDAwMiwweDQwMDA4MDAsMHg0MDAwMDAyLDB4NDIwMDAwMCwweDQyMDA4MDAsMHgyMDAwMDIsMHg0MjAwMDAwLDB4ODAwLDB4ODAyLDB4NDIwMDgwMiwweDIwMDgwMCwweDIsMHg0MDAwMDAwLDB4MjAwODAwLDB4NDAwMDAwMCwweDIwMDgwMCwweDIwMDAwMCwweDQwMDA4MDIsMHg0MDAwODAyLDB4NDIwMDAwMiwweDQyMDAwMDIsMHgyLDB4MjAwMDAyLDB4NDAwMDAwMCwweDQwMDA4MDAsMHgyMDAwMDAsMHg0MjAwODAwLDB4ODAyLDB4MjAwODAyLDB4NDIwMDgwMCwweDgwMiwweDQwMDAwMDIsMHg0MjAwODAyLDB4NDIwMDAwMCwweDIwMDgwMCwwLDB4MiwweDQyMDA4MDIsMCwweDIwMDgwMiwweDQyMDAwMDAsMHg4MDAsMHg0MDAwMDAyLDB4NDAwMDgwMCwweDgwMCwweDIwMDAwMl07XG52YXIgc3BmdW5jdGlvbjggPSBbMHgxMDAwMTA0MCwweDEwMDAsMHg0MDAwMCwweDEwMDQxMDQwLDB4MTAwMDAwMDAsMHgxMDAwMTA0MCwweDQwLDB4MTAwMDAwMDAsMHg0MDA0MCwweDEwMDQwMDAwLDB4MTAwNDEwNDAsMHg0MTAwMCwweDEwMDQxMDAwLDB4NDEwNDAsMHgxMDAwLDB4NDAsMHgxMDA0MDAwMCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHgxMDQwLDB4NDEwMDAsMHg0MDA0MCwweDEwMDQwMDQwLDB4MTAwNDEwMDAsMHgxMDQwLDAsMCwweDEwMDQwMDQwLDB4MTAwMDAwNDAsMHgxMDAwMTAwMCwweDQxMDQwLDB4NDAwMDAsMHg0MTA0MCwweDQwMDAwLDB4MTAwNDEwMDAsMHgxMDAwLDB4NDAsMHgxMDA0MDA0MCwweDEwMDAsMHg0MTA0MCwweDEwMDAxMDAwLDB4NDAsMHgxMDAwMDA0MCwweDEwMDQwMDAwLDB4MTAwNDAwNDAsMHgxMDAwMDAwMCwweDQwMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDAwNDAsMHgxMDAwMDA0MCwweDEwMDQwMDAwLDB4MTAwMDEwMDAsMHgxMDAwMTA0MCwwLDB4MTAwNDEwNDAsMHg0MTAwMCwweDQxMDAwLDB4MTA0MCwweDEwNDAsMHg0MDA0MCwweDEwMDAwMDAwLDB4MTAwNDEwMDBdO1xuXG4vKipcbiAqIENyZWF0ZSBuZWNlc3Nhcnkgc3ViIGtleXMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgNjQtYml0IG9yIDE5Mi1iaXQga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIGtleXMuXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVLZXlzKGtleSkge1xuICB2YXIgcGMyYnl0ZXMwICA9IFswLDB4NCwweDIwMDAwMDAwLDB4MjAwMDAwMDQsMHgxMDAwMCwweDEwMDA0LDB4MjAwMTAwMDAsMHgyMDAxMDAwNCwweDIwMCwweDIwNCwweDIwMDAwMjAwLDB4MjAwMDAyMDQsMHgxMDIwMCwweDEwMjA0LDB4MjAwMTAyMDAsMHgyMDAxMDIwNF0sXG4gICAgICBwYzJieXRlczEgID0gWzAsMHgxLDB4MTAwMDAwLDB4MTAwMDAxLDB4NDAwMDAwMCwweDQwMDAwMDEsMHg0MTAwMDAwLDB4NDEwMDAwMSwweDEwMCwweDEwMSwweDEwMDEwMCwweDEwMDEwMSwweDQwMDAxMDAsMHg0MDAwMTAxLDB4NDEwMDEwMCwweDQxMDAxMDFdLFxuICAgICAgcGMyYnl0ZXMyICA9IFswLDB4OCwweDgwMCwweDgwOCwweDEwMDAwMDAsMHgxMDAwMDA4LDB4MTAwMDgwMCwweDEwMDA4MDgsMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4XSxcbiAgICAgIHBjMmJ5dGVzMyAgPSBbMCwweDIwMDAwMCwweDgwMDAwMDAsMHg4MjAwMDAwLDB4MjAwMCwweDIwMjAwMCwweDgwMDIwMDAsMHg4MjAyMDAwLDB4MjAwMDAsMHgyMjAwMDAsMHg4MDIwMDAwLDB4ODIyMDAwMCwweDIyMDAwLDB4MjIyMDAwLDB4ODAyMjAwMCwweDgyMjIwMDBdLFxuICAgICAgcGMyYnl0ZXM0ICA9IFswLDB4NDAwMDAsMHgxMCwweDQwMDEwLDAsMHg0MDAwMCwweDEwLDB4NDAwMTAsMHgxMDAwLDB4NDEwMDAsMHgxMDEwLDB4NDEwMTAsMHgxMDAwLDB4NDEwMDAsMHgxMDEwLDB4NDEwMTBdLFxuICAgICAgcGMyYnl0ZXM1ICA9IFswLDB4NDAwLDB4MjAsMHg0MjAsMCwweDQwMCwweDIwLDB4NDIwLDB4MjAwMDAwMCwweDIwMDA0MDAsMHgyMDAwMDIwLDB4MjAwMDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjBdLFxuICAgICAgcGMyYnl0ZXM2ICA9IFswLDB4MTAwMDAwMDAsMHg4MDAwMCwweDEwMDgwMDAwLDB4MiwweDEwMDAwMDAyLDB4ODAwMDIsMHgxMDA4MDAwMiwwLDB4MTAwMDAwMDAsMHg4MDAwMCwweDEwMDgwMDAwLDB4MiwweDEwMDAwMDAyLDB4ODAwMDIsMHgxMDA4MDAwMl0sXG4gICAgICBwYzJieXRlczcgID0gWzAsMHgxMDAwMCwweDgwMCwweDEwODAwLDB4MjAwMDAwMDAsMHgyMDAxMDAwMCwweDIwMDAwODAwLDB4MjAwMTA4MDAsMHgyMDAwMCwweDMwMDAwLDB4MjA4MDAsMHgzMDgwMCwweDIwMDIwMDAwLDB4MjAwMzAwMDAsMHgyMDAyMDgwMCwweDIwMDMwODAwXSxcbiAgICAgIHBjMmJ5dGVzOCAgPSBbMCwweDQwMDAwLDAsMHg0MDAwMCwweDIsMHg0MDAwMiwweDIsMHg0MDAwMiwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMCwweDIwNDAwMDAsMHgyMDAwMDAyLDB4MjA0MDAwMiwweDIwMDAwMDIsMHgyMDQwMDAyXSxcbiAgICAgIHBjMmJ5dGVzOSAgPSBbMCwweDEwMDAwMDAwLDB4OCwweDEwMDAwMDA4LDAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwweDQwMCwweDEwMDAwNDAwLDB4NDA4LDB4MTAwMDA0MDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4XSxcbiAgICAgIHBjMmJ5dGVzMTAgPSBbMCwweDIwLDAsMHgyMCwweDEwMDAwMCwweDEwMDAyMCwweDEwMDAwMCwweDEwMDAyMCwweDIwMDAsMHgyMDIwLDB4MjAwMCwweDIwMjAsMHgxMDIwMDAsMHgxMDIwMjAsMHgxMDIwMDAsMHgxMDIwMjBdLFxuICAgICAgcGMyYnl0ZXMxMSA9IFswLDB4MTAwMDAwMCwweDIwMCwweDEwMDAyMDAsMHgyMDAwMDAsMHgxMjAwMDAwLDB4MjAwMjAwLDB4MTIwMDIwMCwweDQwMDAwMDAsMHg1MDAwMDAwLDB4NDAwMDIwMCwweDUwMDAyMDAsMHg0MjAwMDAwLDB4NTIwMDAwMCwweDQyMDAyMDAsMHg1MjAwMjAwXSxcbiAgICAgIHBjMmJ5dGVzMTIgPSBbMCwweDEwMDAsMHg4MDAwMDAwLDB4ODAwMTAwMCwweDgwMDAwLDB4ODEwMDAsMHg4MDgwMDAwLDB4ODA4MTAwMCwweDEwLDB4MTAxMCwweDgwMDAwMTAsMHg4MDAxMDEwLDB4ODAwMTAsMHg4MTAxMCwweDgwODAwMTAsMHg4MDgxMDEwXSxcbiAgICAgIHBjMmJ5dGVzMTMgPSBbMCwweDQsMHgxMDAsMHgxMDQsMCwweDQsMHgxMDAsMHgxMDQsMHgxLDB4NSwweDEwMSwweDEwNSwweDEsMHg1LDB4MTAxLDB4MTA1XTtcblxuICAvLyBob3cgbWFueSBpdGVyYXRpb25zICgxIGZvciBkZXMsIDMgZm9yIHRyaXBsZSBkZXMpXG4gIC8vIGNoYW5nZWQgYnkgUGF1bCAxNi82LzIwMDcgdG8gdXNlIFRyaXBsZSBERVMgZm9yIDkrIGJ5dGUga2V5c1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleS5sZW5ndGgoKSA+IDggPyAzIDogMTtcblxuICAvLyBzdG9yZXMgdGhlIHJldHVybiBrZXlzXG4gIHZhciBrZXlzID0gW107XG5cbiAgLy8gbm93IGRlZmluZSB0aGUgbGVmdCBzaGlmdHMgd2hpY2ggbmVlZCB0byBiZSBkb25lXG4gIHZhciBzaGlmdHMgPSBbMCwgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMF07XG5cbiAgdmFyIG4gPSAwLCB0bXA7XG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICB2YXIgbGVmdCA9IGtleS5nZXRJbnQzMigpO1xuICAgIHZhciByaWdodCA9IGtleS5nZXRJbnQzMigpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCA0KTtcblxuICAgIHRtcCA9ICgocmlnaHQgPj4+IC0xNikgXiBsZWZ0KSAmIDB4MDAwMGZmZmY7XG4gICAgbGVmdCBePSB0bXA7XG4gICAgcmlnaHQgXj0gKHRtcCA8PCAtMTYpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAyKSBeIHJpZ2h0KSAmIDB4MzMzMzMzMzM7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAyKTtcblxuICAgIHRtcCA9ICgocmlnaHQgPj4+IC0xNikgXiBsZWZ0KSAmIDB4MDAwMGZmZmY7XG4gICAgbGVmdCBePSB0bXA7XG4gICAgcmlnaHQgXj0gKHRtcCA8PCAtMTYpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIHRtcCA9ICgocmlnaHQgPj4+IDgpIF4gbGVmdCkgJiAweDAwZmYwMGZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgICByaWdodCBePSB0bXA7XG4gICAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gICAgLy8gcmlnaHQgbmVlZHMgdG8gYmUgc2hpZnRlZCBhbmQgT1InZCB3aXRoIGxhc3QgZm91ciBiaXRzIG9mIGxlZnRcbiAgICB0bXAgPSAobGVmdCA8PCA4KSB8ICgocmlnaHQgPj4+IDIwKSAmIDB4MDAwMDAwZjApO1xuXG4gICAgLy8gbGVmdCBuZWVkcyB0byBiZSBwdXQgdXBzaWRlIGRvd25cbiAgICBsZWZ0ID0gKChyaWdodCA8PCAyNCkgfCAoKHJpZ2h0IDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICgocmlnaHQgPj4+IDgpICYgMHhmZjAwKSB8ICgocmlnaHQgPj4+IDI0KSAmIDB4ZjApKTtcbiAgICByaWdodCA9IHRtcDtcblxuICAgIC8vIG5vdyBnbyB0aHJvdWdoIGFuZCBwZXJmb3JtIHRoZXNlIHNoaWZ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQga2V5c1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaGlmdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vc2hpZnQgdGhlIGtleXMgZWl0aGVyIG9uZSBvciB0d28gYml0cyB0byB0aGUgbGVmdFxuICAgICAgaWYoc2hpZnRzW2ldKSB7XG4gICAgICAgIGxlZnQgPSAobGVmdCA8PCAyKSB8IChsZWZ0ID4+PiAyNik7XG4gICAgICAgIHJpZ2h0ID0gKHJpZ2h0IDw8IDIpIHwgKHJpZ2h0ID4+PiAyNik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMjcpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAxKSB8IChyaWdodCA+Pj4gMjcpO1xuICAgICAgfVxuICAgICAgbGVmdCAmPSAtMHhmO1xuICAgICAgcmlnaHQgJj0gLTB4ZjtcblxuICAgICAgLy8gbm93IGFwcGx5IFBDLTIsIGluIHN1Y2ggYSB3YXkgdGhhdCBFIGlzIGVhc2llciB3aGVuIGVuY3J5cHRpbmcgb3JcbiAgICAgIC8vIGRlY3J5cHRpbmcgdGhpcyBjb252ZXJzaW9uIHdpbGwgbG9vayBsaWtlIFBDLTIgZXhjZXB0IG9ubHkgdGhlIGxhc3QgNlxuICAgICAgLy8gYml0cyBvZiBlYWNoIGJ5dGUgYXJlIHVzZWQgcmF0aGVyIHRoYW4gNDggY29uc2VjdXRpdmUgYml0cyBhbmQgdGhlXG4gICAgICAvLyBvcmRlciBvZiBsaW5lcyB3aWxsIGJlIGFjY29yZGluZyB0byBob3cgdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9ucyB3aWxsXG4gICAgICAvLyBiZSBhcHBsaWVkOiBTMiwgUzQsIFM2LCBTOCwgUzEsIFMzLCBTNSwgUzdcbiAgICAgIHZhciBsZWZ0dG1wID0gKFxuICAgICAgICBwYzJieXRlczBbbGVmdCA+Pj4gMjhdIHwgcGMyYnl0ZXMxWyhsZWZ0ID4+PiAyNCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXMyWyhsZWZ0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMzWyhsZWZ0ID4+PiAxNikgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM0WyhsZWZ0ID4+PiAxMikgJiAweGZdIHwgcGMyYnl0ZXM1WyhsZWZ0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczZbKGxlZnQgPj4+IDQpICYgMHhmXSk7XG4gICAgICB2YXIgcmlnaHR0bXAgPSAoXG4gICAgICAgIHBjMmJ5dGVzN1tyaWdodCA+Pj4gMjhdIHwgcGMyYnl0ZXM4WyhyaWdodCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzOVsocmlnaHQgPj4+IDIwKSAmIDB4Zl0gfCBwYzJieXRlczEwWyhyaWdodCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMTFbKHJpZ2h0ID4+PiAxMikgJiAweGZdIHwgcGMyYnl0ZXMxMlsocmlnaHQgPj4+IDgpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMTNbKHJpZ2h0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdG1wID0gKChyaWdodHRtcCA+Pj4gMTYpIF4gbGVmdHRtcCkgJiAweDAwMDBmZmZmO1xuICAgICAga2V5c1tuKytdID0gbGVmdHRtcCBeIHRtcDtcbiAgICAgIGtleXNbbisrXSA9IHJpZ2h0dG1wIF4gKHRtcCA8PCAxNik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNpbmdsZSBibG9jayAoMSBieXRlKSB1c2luZyBERVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIGtleXMgdGhlIGV4cGFuZGVkIGtleXMuXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGlucHV0IGJsb2NrIChhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMpLlxuICogQHBhcmFtIG91dHB1dCB0aGUgdXBkYXRlZCBvdXRwdXQgYmxvY2suXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIGRlY3J5cHQgdGhlIGJsb2NrLCBmYWxzZSB0byBlbmNyeXB0IGl0LlxuICovXG5mdW5jdGlvbiBfdXBkYXRlQmxvY2soa2V5cywgaW5wdXQsIG91dHB1dCwgZGVjcnlwdCkge1xuICAvLyBzZXQgdXAgbG9vcHMgZm9yIHNpbmdsZSBvciB0cmlwbGUgREVTXG4gIHZhciBpdGVyYXRpb25zID0ga2V5cy5sZW5ndGggPT09IDMyID8gMyA6IDk7XG4gIHZhciBsb29waW5nO1xuICBpZihpdGVyYXRpb25zID09PSAzKSB7XG4gICAgbG9vcGluZyA9IGRlY3J5cHQgPyBbMzAsIC0yLCAtMl0gOiBbMCwgMzIsIDJdO1xuICB9IGVsc2Uge1xuICAgIGxvb3BpbmcgPSAoZGVjcnlwdCA/XG4gICAgICBbOTQsIDYyLCAtMiwgMzIsIDY0LCAyLCAzMCwgLTIsIC0yXSA6XG4gICAgICBbMCwgMzIsIDIsIDYyLCAzMCwgLTIsIDY0LCA5NiwgMl0pO1xuICB9XG5cbiAgdmFyIHRtcDtcblxuICB2YXIgbGVmdCA9IGlucHV0WzBdO1xuICB2YXIgcmlnaHQgPSBpbnB1dFsxXTtcblxuICAvLyBmaXJzdCBlYWNoIDY0IGJpdCBjaHVuayBvZiB0aGUgbWVzc2FnZSBtdXN0IGJlIHBlcm11dGVkIGFjY29yZGluZyB0byBJUFxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxNikgXiByaWdodCkgJiAweDAwMDBmZmZmO1xuICByaWdodCBePSB0bXA7XG4gIGxlZnQgXj0gKHRtcCA8PCAxNik7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gMikgXiBsZWZ0KSAmIDB4MzMzMzMzMzM7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDIpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDgpIF4gbGVmdCkgJiAweDAwZmYwMGZmO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCA4KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgLy8gcm90YXRlIGxlZnQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA8PCAxKSB8IChsZWZ0ID4+PiAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDMxKSk7XG5cbiAgZm9yKHZhciBqID0gMDsgaiA8IGl0ZXJhdGlvbnM7IGogKz0gMykge1xuICAgIHZhciBlbmRsb29wID0gbG9vcGluZ1tqICsgMV07XG4gICAgdmFyIGxvb3BpbmMgPSBsb29waW5nW2ogKyAyXTtcblxuICAgIC8vIG5vdyBnbyB0aHJvdWdoIGFuZCBwZXJmb3JtIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb25cbiAgICBmb3IodmFyIGkgPSBsb29waW5nW2pdOyBpICE9IGVuZGxvb3A7IGkgKz0gbG9vcGluYykge1xuICAgICAgdmFyIHJpZ2h0MSA9IHJpZ2h0IF4ga2V5c1tpXTtcbiAgICAgIHZhciByaWdodDIgPSAoKHJpZ2h0ID4+PiA0KSB8IChyaWdodCA8PCAyOCkpIF4ga2V5c1tpICsgMV07XG5cbiAgICAgIC8vIHBhc3NpbmcgdGhlc2UgYnl0ZXMgdGhyb3VnaCB0aGUgUyBzZWxlY3Rpb24gZnVuY3Rpb25zXG4gICAgICB0bXAgPSBsZWZ0O1xuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgcmlnaHQgPSB0bXAgXiAoXG4gICAgICAgIHNwZnVuY3Rpb24yWyhyaWdodDEgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjRbKHJpZ2h0MSA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNlsocmlnaHQxID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb244W3JpZ2h0MSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjFbKHJpZ2h0MiA+Pj4gMjQpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uM1socmlnaHQyID4+PiAxNikgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb241WyhyaWdodDIgPj4+ICA4KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjdbcmlnaHQyICYgMHgzZl0pO1xuICAgIH1cbiAgICAvLyB1bnJldmVyc2UgbGVmdCBhbmQgcmlnaHRcbiAgICB0bXAgPSBsZWZ0O1xuICAgIGxlZnQgPSByaWdodDtcbiAgICByaWdodCA9IHRtcDtcbiAgfVxuXG4gIC8vIHJvdGF0ZSByaWdodCAxIGJpdFxuICBsZWZ0ID0gKChsZWZ0ID4+PiAxKSB8IChsZWZ0IDw8IDMxKSk7XG4gIHJpZ2h0ID0gKChyaWdodCA+Pj4gMSkgfCAocmlnaHQgPDwgMzEpKTtcblxuICAvLyBub3cgcGVyZm9ybSBJUC0xLCB3aGljaCBpcyBJUCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICByaWdodCBePSB0bXA7XG4gIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gMikgXiBsZWZ0KSAmIDB4MzMzMzMzMzM7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDIpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICByaWdodCBePSB0bXA7XG4gIGxlZnQgXj0gKHRtcCA8PCA0KTtcblxuICBvdXRwdXRbMF0gPSBsZWZ0O1xuICBvdXRwdXRbMV0gPSByaWdodDtcbn1cblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKiBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYSBkZXByZWNhdGVkIERFUyBjaXBoZXIgb2JqZWN0LiBUaGlzIG9iamVjdCdzIG1vZGUgd2lsbCBkZWZhdWx0IHRvXG4gKiBDQkMgKGNpcGhlci1ibG9jay1jaGFpbmluZykuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlICg2NCBvciAxOTIgYml0cykuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0by5cbiAqICAgICAgICAgIGRlY3J5cHQgdHJ1ZSBmb3IgZGVjcnlwdGlvbiwgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKiAgICAgICAgICBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVDaXBoZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1vZGUgPSAob3B0aW9ucy5tb2RlIHx8ICdDQkMnKS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgYWxnb3JpdGhtID0gJ0RFUy0nICsgbW9kZTtcblxuICB2YXIgY2lwaGVyO1xuICBpZihvcHRpb25zLmRlY3J5cHQpIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH0gZWxzZSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfVxuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHN0YXJ0IEFQSVxuICB2YXIgc3RhcnQgPSBjaXBoZXIuc3RhcnQ7XG4gIGNpcGhlci5zdGFydCA9IGZ1bmN0aW9uKGl2LCBvcHRpb25zKSB7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHN1cHBvcnQgc2Vjb25kIGFyZyBhcyBvdXRwdXQgYnVmZmVyXG4gICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgaWYob3B0aW9ucyBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcikge1xuICAgICAgb3V0cHV0ID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgb3B0aW9ucy5pdiA9IGl2O1xuICAgIHN0YXJ0LmNhbGwoY2lwaGVyLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZXMiLCJzdGFydEVuY3J5cHRpbmciLCJrZXkiLCJpdiIsIm91dHB1dCIsIm1vZGUiLCJjaXBoZXIiLCJfY3JlYXRlQ2lwaGVyIiwiZGVjcnlwdCIsInN0YXJ0IiwiY3JlYXRlRW5jcnlwdGlvbkNpcGhlciIsInN0YXJ0RGVjcnlwdGluZyIsImNyZWF0ZURlY3J5cHRpb25DaXBoZXIiLCJBbGdvcml0aG0iLCJuYW1lIiwic2VsZiIsImJsb2NrU2l6ZSIsImVuY3J5cHQiLCJpbkJsb2NrIiwib3V0QmxvY2siLCJfdXBkYXRlQmxvY2siLCJfa2V5cyIsIl9pbml0IiwicHJvdG90eXBlIiwiaW5pdGlhbGl6ZSIsIm9wdGlvbnMiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiaW5kZXhPZiIsImxlbmd0aCIsIkVycm9yIiwiX2NyZWF0ZUtleXMiLCJyZWdpc3RlckFsZ29yaXRobSIsIm1vZGVzIiwiZWNiIiwiY2JjIiwiY2ZiIiwib2ZiIiwiY3RyIiwiZmFjdG9yeSIsInNwZnVuY3Rpb24xIiwic3BmdW5jdGlvbjIiLCJzcGZ1bmN0aW9uMyIsInNwZnVuY3Rpb240Iiwic3BmdW5jdGlvbjUiLCJzcGZ1bmN0aW9uNiIsInNwZnVuY3Rpb243Iiwic3BmdW5jdGlvbjgiLCJwYzJieXRlczAiLCJwYzJieXRlczEiLCJwYzJieXRlczIiLCJwYzJieXRlczMiLCJwYzJieXRlczQiLCJwYzJieXRlczUiLCJwYzJieXRlczYiLCJwYzJieXRlczciLCJwYzJieXRlczgiLCJwYzJieXRlczkiLCJwYzJieXRlczEwIiwicGMyYnl0ZXMxMSIsInBjMmJ5dGVzMTIiLCJwYzJieXRlczEzIiwiaXRlcmF0aW9ucyIsImtleXMiLCJzaGlmdHMiLCJuIiwidG1wIiwiaiIsImxlZnQiLCJnZXRJbnQzMiIsInJpZ2h0IiwiaSIsImxlZnR0bXAiLCJyaWdodHRtcCIsImlucHV0IiwibG9vcGluZyIsImVuZGxvb3AiLCJsb29waW5jIiwicmlnaHQxIiwicmlnaHQyIiwidG9VcHBlckNhc2UiLCJhbGdvcml0aG0iLCJjcmVhdGVEZWNpcGhlciIsImNyZWF0ZUNpcGhlciIsIkJ5dGVCdWZmZXIiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/des.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/forge.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/forge.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n * Node.js module for Forge.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2016 Digital Bazaar, Inc.\n */ \nmodule.exports = {\n    // default options\n    options: {\n        usePureJavaScript: false\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZm9yZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0RBLE9BQU9DLE9BQU8sR0FBRztJQUNmLGtCQUFrQjtJQUNsQkMsU0FBUztRQUNQQyxtQkFBbUI7SUFDckI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2ZvcmdlLmpzPzA0MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9uczoge1xuICAgIHVzZVB1cmVKYXZhU2NyaXB0OiBmYWxzZVxuICB9XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJvcHRpb25zIiwidXNlUHVyZUphdmFTY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/forge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/hmac.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/hmac.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Hash-based Message Authentication Code implementation. Requires a message\n * digest object that can be obtained, for example, from forge.md.sha1 or\n * forge.md.md5.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(ssr)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n/* HMAC API */ var hmac = module.exports = forge.hmac = forge.hmac || {};\n/**\n * Creates an HMAC object that uses the given message digest object.\n *\n * @return an HMAC object.\n */ hmac.create = function() {\n    // the hmac key to use\n    var _key = null;\n    // the message digest to use\n    var _md = null;\n    // the inner padding\n    var _ipadding = null;\n    // the outer padding\n    var _opadding = null;\n    // hmac context\n    var ctx = {};\n    /**\n   * Starts or restarts the HMAC with the given key and message digest.\n   *\n   * @param md the message digest to use, null to reuse the previous one,\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\n   * @param key the key to use as a string, array of bytes, byte buffer,\n   *           or null to reuse the previous key.\n   */ ctx.start = function(md, key) {\n        if (md !== null) {\n            if (typeof md === \"string\") {\n                // create builtin message digest\n                md = md.toLowerCase();\n                if (md in forge.md.algorithms) {\n                    _md = forge.md.algorithms[md].create();\n                } else {\n                    throw new Error('Unknown hash algorithm \"' + md + '\"');\n                }\n            } else {\n                // store message digest\n                _md = md;\n            }\n        }\n        if (key === null) {\n            // reuse previous key\n            key = _key;\n        } else {\n            if (typeof key === \"string\") {\n                // convert string into byte buffer\n                key = forge.util.createBuffer(key);\n            } else if (forge.util.isArray(key)) {\n                // convert byte array into byte buffer\n                var tmp = key;\n                key = forge.util.createBuffer();\n                for(var i = 0; i < tmp.length; ++i){\n                    key.putByte(tmp[i]);\n                }\n            }\n            // if key is longer than blocksize, hash it\n            var keylen = key.length();\n            if (keylen > _md.blockLength) {\n                _md.start();\n                _md.update(key.bytes());\n                key = _md.digest();\n            }\n            // mix key into inner and outer padding\n            // ipadding = [0x36 * blocksize] ^ key\n            // opadding = [0x5C * blocksize] ^ key\n            _ipadding = forge.util.createBuffer();\n            _opadding = forge.util.createBuffer();\n            keylen = key.length();\n            for(var i = 0; i < keylen; ++i){\n                var tmp = key.at(i);\n                _ipadding.putByte(0x36 ^ tmp);\n                _opadding.putByte(0x5C ^ tmp);\n            }\n            // if key is shorter than blocksize, add additional padding\n            if (keylen < _md.blockLength) {\n                var tmp = _md.blockLength - keylen;\n                for(var i = 0; i < tmp; ++i){\n                    _ipadding.putByte(0x36);\n                    _opadding.putByte(0x5C);\n                }\n            }\n            _key = key;\n            _ipadding = _ipadding.bytes();\n            _opadding = _opadding.bytes();\n        }\n        // digest is done like so: hash(opadding | hash(ipadding | message))\n        // prepare to do inner hash\n        // hash(ipadding | message)\n        _md.start();\n        _md.update(_ipadding);\n    };\n    /**\n   * Updates the HMAC with the given message bytes.\n   *\n   * @param bytes the bytes to update with.\n   */ ctx.update = function(bytes) {\n        _md.update(bytes);\n    };\n    /**\n   * Produces the Message Authentication Code (MAC).\n   *\n   * @return a byte buffer containing the digest value.\n   */ ctx.getMac = function() {\n        // digest is done like so: hash(opadding | hash(ipadding | message))\n        // here we do the outer hashing\n        var inner = _md.digest().bytes();\n        _md.start();\n        _md.update(_opadding);\n        _md.update(inner);\n        return _md.digest();\n    };\n    // alias for getMac\n    ctx.digest = ctx.getMac;\n    return ctx;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLFlBQVksR0FDWixJQUFJQyxPQUFPQyxPQUFPQyxPQUFPLEdBQUdKLE1BQU1FLElBQUksR0FBR0YsTUFBTUUsSUFBSSxJQUFJLENBQUM7QUFFeEQ7Ozs7Q0FJQyxHQUNEQSxLQUFLRyxNQUFNLEdBQUc7SUFDWixzQkFBc0I7SUFDdEIsSUFBSUMsT0FBTztJQUVYLDRCQUE0QjtJQUM1QixJQUFJQyxNQUFNO0lBRVYsb0JBQW9CO0lBQ3BCLElBQUlDLFlBQVk7SUFFaEIsb0JBQW9CO0lBQ3BCLElBQUlDLFlBQVk7SUFFaEIsZUFBZTtJQUNmLElBQUlDLE1BQU0sQ0FBQztJQUVYOzs7Ozs7O0dBT0MsR0FDREEsSUFBSUMsS0FBSyxHQUFHLFNBQVNDLEVBQUUsRUFBRUMsR0FBRztRQUMxQixJQUFHRCxPQUFPLE1BQU07WUFDZCxJQUFHLE9BQU9BLE9BQU8sVUFBVTtnQkFDekIsZ0NBQWdDO2dCQUNoQ0EsS0FBS0EsR0FBR0UsV0FBVztnQkFDbkIsSUFBR0YsTUFBTVosTUFBTVksRUFBRSxDQUFDRyxVQUFVLEVBQUU7b0JBQzVCUixNQUFNUCxNQUFNWSxFQUFFLENBQUNHLFVBQVUsQ0FBQ0gsR0FBRyxDQUFDUCxNQUFNO2dCQUN0QyxPQUFPO29CQUNMLE1BQU0sSUFBSVcsTUFBTSw2QkFBNkJKLEtBQUs7Z0JBQ3BEO1lBQ0YsT0FBTztnQkFDTCx1QkFBdUI7Z0JBQ3ZCTCxNQUFNSztZQUNSO1FBQ0Y7UUFFQSxJQUFHQyxRQUFRLE1BQU07WUFDZixxQkFBcUI7WUFDckJBLE1BQU1QO1FBQ1IsT0FBTztZQUNMLElBQUcsT0FBT08sUUFBUSxVQUFVO2dCQUMxQixrQ0FBa0M7Z0JBQ2xDQSxNQUFNYixNQUFNaUIsSUFBSSxDQUFDQyxZQUFZLENBQUNMO1lBQ2hDLE9BQU8sSUFBR2IsTUFBTWlCLElBQUksQ0FBQ0UsT0FBTyxDQUFDTixNQUFNO2dCQUNqQyxzQ0FBc0M7Z0JBQ3RDLElBQUlPLE1BQU1QO2dCQUNWQSxNQUFNYixNQUFNaUIsSUFBSSxDQUFDQyxZQUFZO2dCQUM3QixJQUFJLElBQUlHLElBQUksR0FBR0EsSUFBSUQsSUFBSUUsTUFBTSxFQUFFLEVBQUVELEVBQUc7b0JBQ2xDUixJQUFJVSxPQUFPLENBQUNILEdBQUcsQ0FBQ0MsRUFBRTtnQkFDcEI7WUFDRjtZQUVBLDJDQUEyQztZQUMzQyxJQUFJRyxTQUFTWCxJQUFJUyxNQUFNO1lBQ3ZCLElBQUdFLFNBQVNqQixJQUFJa0IsV0FBVyxFQUFFO2dCQUMzQmxCLElBQUlJLEtBQUs7Z0JBQ1RKLElBQUltQixNQUFNLENBQUNiLElBQUljLEtBQUs7Z0JBQ3BCZCxNQUFNTixJQUFJcUIsTUFBTTtZQUNsQjtZQUVBLHVDQUF1QztZQUN2QyxzQ0FBc0M7WUFDdEMsc0NBQXNDO1lBQ3RDcEIsWUFBWVIsTUFBTWlCLElBQUksQ0FBQ0MsWUFBWTtZQUNuQ1QsWUFBWVQsTUFBTWlCLElBQUksQ0FBQ0MsWUFBWTtZQUNuQ00sU0FBU1gsSUFBSVMsTUFBTTtZQUNuQixJQUFJLElBQUlELElBQUksR0FBR0EsSUFBSUcsUUFBUSxFQUFFSCxFQUFHO2dCQUM5QixJQUFJRCxNQUFNUCxJQUFJZ0IsRUFBRSxDQUFDUjtnQkFDakJiLFVBQVVlLE9BQU8sQ0FBQyxPQUFPSDtnQkFDekJYLFVBQVVjLE9BQU8sQ0FBQyxPQUFPSDtZQUMzQjtZQUVBLDJEQUEyRDtZQUMzRCxJQUFHSSxTQUFTakIsSUFBSWtCLFdBQVcsRUFBRTtnQkFDM0IsSUFBSUwsTUFBTWIsSUFBSWtCLFdBQVcsR0FBR0Q7Z0JBQzVCLElBQUksSUFBSUgsSUFBSSxHQUFHQSxJQUFJRCxLQUFLLEVBQUVDLEVBQUc7b0JBQzNCYixVQUFVZSxPQUFPLENBQUM7b0JBQ2xCZCxVQUFVYyxPQUFPLENBQUM7Z0JBQ3BCO1lBQ0Y7WUFDQWpCLE9BQU9PO1lBQ1BMLFlBQVlBLFVBQVVtQixLQUFLO1lBQzNCbEIsWUFBWUEsVUFBVWtCLEtBQUs7UUFDN0I7UUFFQSxvRUFBb0U7UUFFcEUsMkJBQTJCO1FBQzNCLDJCQUEyQjtRQUMzQnBCLElBQUlJLEtBQUs7UUFDVEosSUFBSW1CLE1BQU0sQ0FBQ2xCO0lBQ2I7SUFFQTs7OztHQUlDLEdBQ0RFLElBQUlnQixNQUFNLEdBQUcsU0FBU0MsS0FBSztRQUN6QnBCLElBQUltQixNQUFNLENBQUNDO0lBQ2I7SUFFQTs7OztHQUlDLEdBQ0RqQixJQUFJb0IsTUFBTSxHQUFHO1FBQ1gsb0VBQW9FO1FBQ3BFLCtCQUErQjtRQUMvQixJQUFJQyxRQUFReEIsSUFBSXFCLE1BQU0sR0FBR0QsS0FBSztRQUM5QnBCLElBQUlJLEtBQUs7UUFDVEosSUFBSW1CLE1BQU0sQ0FBQ2pCO1FBQ1hGLElBQUltQixNQUFNLENBQUNLO1FBQ1gsT0FBT3hCLElBQUlxQixNQUFNO0lBQ25CO0lBQ0EsbUJBQW1CO0lBQ25CbEIsSUFBSWtCLE1BQU0sR0FBR2xCLElBQUlvQixNQUFNO0lBRXZCLE9BQU9wQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvaG1hYy5qcz9kOGQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGFzaC1iYXNlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgaW1wbGVtZW50YXRpb24uIFJlcXVpcmVzIGEgbWVzc2FnZVxuICogZGlnZXN0IG9iamVjdCB0aGF0IGNhbiBiZSBvYnRhaW5lZCwgZm9yIGV4YW1wbGUsIGZyb20gZm9yZ2UubWQuc2hhMSBvclxuICogZm9yZ2UubWQubWQ1LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qIEhNQUMgQVBJICovXG52YXIgaG1hYyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuaG1hYyA9IGZvcmdlLmhtYWMgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBITUFDIG9iamVjdCB0aGF0IHVzZXMgdGhlIGdpdmVuIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGFuIEhNQUMgb2JqZWN0LlxuICovXG5obWFjLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyB0aGUgaG1hYyBrZXkgdG8gdXNlXG4gIHZhciBfa2V5ID0gbnVsbDtcblxuICAvLyB0aGUgbWVzc2FnZSBkaWdlc3QgdG8gdXNlXG4gIHZhciBfbWQgPSBudWxsO1xuXG4gIC8vIHRoZSBpbm5lciBwYWRkaW5nXG4gIHZhciBfaXBhZGRpbmcgPSBudWxsO1xuXG4gIC8vIHRoZSBvdXRlciBwYWRkaW5nXG4gIHZhciBfb3BhZGRpbmcgPSBudWxsO1xuXG4gIC8vIGhtYWMgY29udGV4dFxuICB2YXIgY3R4ID0ge307XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBvciByZXN0YXJ0cyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBrZXkgYW5kIG1lc3NhZ2UgZGlnZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgbnVsbCB0byByZXVzZSB0aGUgcHJldmlvdXMgb25lLFxuICAgKiAgICAgICAgICAgYSBzdHJpbmcgdG8gdXNlIGJ1aWx0aW4gJ3NoYTEnLCAnbWQ1JywgJ3NoYTI1NicuXG4gICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UgYXMgYSBzdHJpbmcsIGFycmF5IG9mIGJ5dGVzLCBieXRlIGJ1ZmZlcixcbiAgICogICAgICAgICAgIG9yIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGtleS5cbiAgICovXG4gIGN0eC5zdGFydCA9IGZ1bmN0aW9uKG1kLCBrZXkpIHtcbiAgICBpZihtZCAhPT0gbnVsbCkge1xuICAgICAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjcmVhdGUgYnVpbHRpbiBtZXNzYWdlIGRpZ2VzdFxuICAgICAgICBtZCA9IG1kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmKG1kIGluIGZvcmdlLm1kLmFsZ29yaXRobXMpIHtcbiAgICAgICAgICBfbWQgPSBmb3JnZS5tZC5hbGdvcml0aG1zW21kXS5jcmVhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG0gXCInICsgbWQgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RvcmUgbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgX21kID0gbWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoa2V5ID09PSBudWxsKSB7XG4gICAgICAvLyByZXVzZSBwcmV2aW91cyBrZXlcbiAgICAgIGtleSA9IF9rZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAgICAgIH0gZWxzZSBpZihmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvLyBjb252ZXJ0IGJ5dGUgYXJyYXkgaW50byBieXRlIGJ1ZmZlclxuICAgICAgICB2YXIgdG1wID0ga2V5O1xuICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBrZXkgaXMgbG9uZ2VyIHRoYW4gYmxvY2tzaXplLCBoYXNoIGl0XG4gICAgICB2YXIga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgaWYoa2V5bGVuID4gX21kLmJsb2NrTGVuZ3RoKSB7XG4gICAgICAgIF9tZC5zdGFydCgpO1xuICAgICAgICBfbWQudXBkYXRlKGtleS5ieXRlcygpKTtcbiAgICAgICAga2V5ID0gX21kLmRpZ2VzdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBtaXgga2V5IGludG8gaW5uZXIgYW5kIG91dGVyIHBhZGRpbmdcbiAgICAgIC8vIGlwYWRkaW5nID0gWzB4MzYgKiBibG9ja3NpemVdIF4ga2V5XG4gICAgICAvLyBvcGFkZGluZyA9IFsweDVDICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgX2lwYWRkaW5nID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBrZXlsZW4gPSBrZXkubGVuZ3RoKCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwga2V5bGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHRtcCA9IGtleS5hdChpKTtcbiAgICAgICAgX2lwYWRkaW5nLnB1dEJ5dGUoMHgzNiBeIHRtcCk7XG4gICAgICAgIF9vcGFkZGluZy5wdXRCeXRlKDB4NUMgXiB0bXApO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBrZXkgaXMgc2hvcnRlciB0aGFuIGJsb2Nrc2l6ZSwgYWRkIGFkZGl0aW9uYWwgcGFkZGluZ1xuICAgICAgaWYoa2V5bGVuIDwgX21kLmJsb2NrTGVuZ3RoKSB7XG4gICAgICAgIHZhciB0bXAgPSBfbWQuYmxvY2tMZW5ndGggLSBrZXlsZW47XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXA7ICsraSkge1xuICAgICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYpO1xuICAgICAgICAgIF9vcGFkZGluZy5wdXRCeXRlKDB4NUMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfa2V5ID0ga2V5O1xuICAgICAgX2lwYWRkaW5nID0gX2lwYWRkaW5nLmJ5dGVzKCk7XG4gICAgICBfb3BhZGRpbmcgPSBfb3BhZGRpbmcuYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvLyBkaWdlc3QgaXMgZG9uZSBsaWtlIHNvOiBoYXNoKG9wYWRkaW5nIHwgaGFzaChpcGFkZGluZyB8IG1lc3NhZ2UpKVxuXG4gICAgLy8gcHJlcGFyZSB0byBkbyBpbm5lciBoYXNoXG4gICAgLy8gaGFzaChpcGFkZGluZyB8IG1lc3NhZ2UpXG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfaXBhZGRpbmcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBITUFDIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gdXBkYXRlIHdpdGguXG4gICAqL1xuICBjdHgudXBkYXRlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICBfbWQudXBkYXRlKGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSAoTUFDKS5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIGN0eC5nZXRNYWMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBkaWdlc3QgaXMgZG9uZSBsaWtlIHNvOiBoYXNoKG9wYWRkaW5nIHwgaGFzaChpcGFkZGluZyB8IG1lc3NhZ2UpKVxuICAgIC8vIGhlcmUgd2UgZG8gdGhlIG91dGVyIGhhc2hpbmdcbiAgICB2YXIgaW5uZXIgPSBfbWQuZGlnZXN0KCkuYnl0ZXMoKTtcbiAgICBfbWQuc3RhcnQoKTtcbiAgICBfbWQudXBkYXRlKF9vcGFkZGluZyk7XG4gICAgX21kLnVwZGF0ZShpbm5lcik7XG4gICAgcmV0dXJuIF9tZC5kaWdlc3QoKTtcbiAgfTtcbiAgLy8gYWxpYXMgZm9yIGdldE1hY1xuICBjdHguZGlnZXN0ID0gY3R4LmdldE1hYztcblxuICByZXR1cm4gY3R4O1xufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJobWFjIiwibW9kdWxlIiwiZXhwb3J0cyIsImNyZWF0ZSIsIl9rZXkiLCJfbWQiLCJfaXBhZGRpbmciLCJfb3BhZGRpbmciLCJjdHgiLCJzdGFydCIsIm1kIiwia2V5IiwidG9Mb3dlckNhc2UiLCJhbGdvcml0aG1zIiwiRXJyb3IiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiaXNBcnJheSIsInRtcCIsImkiLCJsZW5ndGgiLCJwdXRCeXRlIiwia2V5bGVuIiwiYmxvY2tMZW5ndGgiLCJ1cGRhdGUiLCJieXRlcyIsImRpZ2VzdCIsImF0IiwiZ2V0TWFjIiwiaW5uZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/jsbn.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/jsbn.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Basic JavaScript BN library - subset useful for RSA encryption.\n/*\nLicensing (LICENSE)\n-------------------\n\nThis software is covered under the following copyright:\n*/ /*\n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */ /*\nAddress all questions regarding this license to:\n\n  Tom Wu\n  tjw@cs.Stanford.EDU\n*/ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\nmodule.exports = forge.jsbn = forge.jsbn || {};\n// Bits per digit\nvar dbits;\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = (canary & 0xffffff) == 0xefcafe;\n// (public) Constructor\nfunction BigInteger(a, b, c) {\n    this.data = [];\n    if (a != null) if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n}\nforge.jsbn.BigInteger = BigInteger;\n// return new, unset BigInteger\nfunction nbi() {\n    return new BigInteger(null);\n}\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i, x, w, j, c, n) {\n    while(--n >= 0){\n        var v = x * this.data[i++] + w.data[j] + c;\n        c = Math.floor(v / 0x4000000);\n        w.data[j++] = v & 0x3ffffff;\n    }\n    return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i, x, w, j, c, n) {\n    var xl = x & 0x7fff, xh = x >> 15;\n    while(--n >= 0){\n        var l = this.data[i] & 0x7fff;\n        var h = this.data[i++] >> 15;\n        var m = xh * l + h * xl;\n        l = xl * l + ((m & 0x7fff) << 15) + w.data[j] + (c & 0x3fffffff);\n        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n        w.data[j++] = l & 0x3fffffff;\n    }\n    return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i, x, w, j, c, n) {\n    var xl = x & 0x3fff, xh = x >> 14;\n    while(--n >= 0){\n        var l = this.data[i] & 0x3fff;\n        var h = this.data[i++] >> 14;\n        var m = xh * l + h * xl;\n        l = xl * l + ((m & 0x3fff) << 14) + w.data[j] + c;\n        c = (l >> 28) + (m >> 14) + xh * h;\n        w.data[j++] = l & 0xfffffff;\n    }\n    return c;\n}\n// node.js (no browser)\nif (typeof navigator === \"undefined\") {\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n} else if (j_lm && navigator.appName == \"Microsoft Internet Explorer\") {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n} else if (j_lm && navigator.appName != \"Netscape\") {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n} else {\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n}\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = (1 << dbits) - 1;\nBigInteger.prototype.DV = 1 << dbits;\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv)BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv;\nfunction int2char(n) {\n    return BI_RM.charAt(n);\n}\nfunction intAt(s, i) {\n    var c = BI_RC[s.charCodeAt(i)];\n    return c == null ? -1 : c;\n}\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n    for(var i = this.t - 1; i >= 0; --i)r.data[i] = this.data[i];\n    r.t = this.t;\n    r.s = this.s;\n}\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n    this.t = 1;\n    this.s = x < 0 ? -1 : 0;\n    if (x > 0) this.data[0] = x;\n    else if (x < -1) this.data[0] = x + this.DV;\n    else this.t = 0;\n}\n// return bigint initialized to value\nfunction nbv(i) {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n}\n// (protected) set from string and radix\nfunction bnpFromString(s, b) {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else {\n        this.fromRadix(s, b);\n        return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length, mi = false, sh = 0;\n    while(--i >= 0){\n        var x = k == 8 ? s[i] & 0xff : intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\") mi = true;\n            continue;\n        }\n        mi = false;\n        if (sh == 0) this.data[this.t++] = x;\n        else if (sh + k > this.DB) {\n            this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n            this.data[this.t++] = x >> this.DB - sh;\n        } else this.data[this.t - 1] |= x << sh;\n        sh += k;\n        if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0) {\n        this.s = -1;\n        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n}\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n    var c = this.s & this.DM;\n    while(this.t > 0 && this.data[this.t - 1] == c)--this.t;\n}\n// (public) return string representation in given radix\nfunction bnToString(b) {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\n    var p = this.DB - i * this.DB % k;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this.data[i] >> p) > 0) {\n            m = true;\n            r = int2char(d);\n        }\n        while(i >= 0){\n            if (p < k) {\n                d = (this.data[i] & (1 << p) - 1) << k - p;\n                d |= this.data[--i] >> (p += this.DB - k);\n            } else {\n                d = this.data[i] >> (p -= k) & km;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if (d > 0) m = true;\n            if (m) r += int2char(d);\n        }\n    }\n    return m ? r : \"0\";\n}\n// (public) -this\nfunction bnNegate() {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n}\n// (public) |this|\nfunction bnAbs() {\n    return this.s < 0 ? this.negate() : this;\n}\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return this.s < 0 ? -r : r;\n    while(--i >= 0)if ((r = this.data[i] - a.data[i]) != 0) return r;\n    return 0;\n}\n// returns bit length of the integer x\nfunction nbits(x) {\n    var r = 1, t;\n    if ((t = x >>> 16) != 0) {\n        x = t;\n        r += 16;\n    }\n    if ((t = x >> 8) != 0) {\n        x = t;\n        r += 8;\n    }\n    if ((t = x >> 4) != 0) {\n        x = t;\n        r += 4;\n    }\n    if ((t = x >> 2) != 0) {\n        x = t;\n        r += 2;\n    }\n    if ((t = x >> 1) != 0) {\n        x = t;\n        r += 1;\n    }\n    return r;\n}\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);\n}\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n, r) {\n    var i;\n    for(i = this.t - 1; i >= 0; --i)r.data[i + n] = this.data[i];\n    for(i = n - 1; i >= 0; --i)r.data[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n}\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n, r) {\n    for(var i = n; i < this.t; ++i)r.data[i - n] = this.data[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n}\n// (protected) r = this << n\nfunction bnpLShiftTo(n, r) {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;\n    for(i = this.t - 1; i >= 0; --i){\n        r.data[i + ds + 1] = this.data[i] >> cbs | c;\n        c = (this.data[i] & bm) << bs;\n    }\n    for(i = ds - 1; i >= 0; --i)r.data[i] = 0;\n    r.data[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n}\n// (protected) r = this >> n\nfunction bnpRShiftTo(n, r) {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t) {\n        r.t = 0;\n        return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r.data[0] = this.data[ds] >> bs;\n    for(var i = ds + 1; i < this.t; ++i){\n        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;\n        r.data[i - ds] = this.data[i] >> bs;\n    }\n    if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n}\n// (protected) r = this - a\nfunction bnpSubTo(a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while(i < m){\n        c += this.data[i] - a.data[i];\n        r.data[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c -= a.s;\n        while(i < this.t){\n            c += this.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while(i < a.t){\n            c -= a.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c -= a.s;\n    }\n    r.s = c < 0 ? -1 : 0;\n    if (c < -1) r.data[i++] = this.DV + c;\n    else if (c > 0) r.data[i++] = c;\n    r.t = i;\n    r.clamp();\n}\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a, r) {\n    var x = this.abs(), y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while(--i >= 0)r.data[i] = 0;\n    for(i = 0; i < y.t; ++i)r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n}\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while(--i >= 0)r.data[i] = 0;\n    for(i = 0; i < x.t - 1; ++i){\n        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);\n        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n            r.data[i + x.t] -= x.DV;\n            r.data[i + x.t + 1] = 1;\n        }\n    }\n    if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n}\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m, q, r) {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t) {\n        if (q != null) q.fromInt(0);\n        if (r != null) this.copyTo(r);\n        return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(), ts = this.s, ms = m.s;\n    var nsh = this.DB - nbits(pm.data[pm.t - 1]); // normalize modulus\n    if (nsh > 0) {\n        pm.lShiftTo(nsh, y);\n        pt.lShiftTo(nsh, r);\n    } else {\n        pm.copyTo(y);\n        pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y.data[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\n    var i = r.t, j = i - ys, t = q == null ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0) {\n        r.data[r.t++] = 1;\n        r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while(y.t < ys)y.data[y.t++] = 0;\n    while(--j >= 0){\n        // Estimate quotient digit\n        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);\n        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n            y.dlShiftTo(j, t);\n            r.subTo(t, r);\n            while(r.data[i] < --qd)r.subTo(t, r);\n        }\n    }\n    if (q != null) {\n        r.drShiftTo(ys, q);\n        if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n}\n// (public) this mod a\nfunction bnMod(a) {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n}\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) {\n    this.m = m;\n}\nfunction cConvert(x) {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n}\nfunction cRevert(x) {\n    return x;\n}\nfunction cReduce(x) {\n    x.divRemTo(this.m, null, x);\n}\nfunction cMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n}\nfunction cSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n}\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n    if (this.t < 1) return 0;\n    var x = this.data[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4\n    y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8\n    y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return y > 0 ? this.DV - y : -y;\n}\n// Montgomery reduction\nfunction Montgomery(m) {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << m.DB - 15) - 1;\n    this.mt2 = 2 * m.t;\n}\n// xR mod m\nfunction montConvert(x) {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n}\n// x/R mod m\nfunction montRevert(x) {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n}\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n    while(x.t <= this.mt2)x.data[x.t++] = 0;\n    for(var i = 0; i < this.m.t; ++i){\n        // faster way of calculating u0 = x.data[i]*mp mod DV\n        var j = x.data[i] & 0x7fff;\n        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i + this.m.t;\n        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n        // propagate carry\n        while(x.data[j] >= x.DV){\n            x.data[j] -= x.DV;\n            x.data[++j]++;\n        }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n}\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n}\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n}\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n// (protected) true iff this is even\nfunction bnpIsEven() {\n    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;\n}\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e, z) {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\n    g.copyTo(r);\n    while(--i >= 0){\n        z.sqrTo(r, r2);\n        if ((e & 1 << i) > 0) z.mulTo(r2, g, r);\n        else {\n            var t = r;\n            r = r2;\n            r2 = t;\n        }\n    }\n    return z.revert(r);\n}\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e, m) {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n}\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// jsbn2 lib\n//Copyright (c) 2005-2009  Tom Wu\n//All Rights Reserved.\n//See \"LICENSE\" for details (See jsbn.js for LICENSE).\n//Extended JavaScript BN functions, required for RSA private ops.\n//Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n//(public)\nfunction bnClone() {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n}\n//(public) return value as integer\nfunction bnIntValue() {\n    if (this.s < 0) {\n        if (this.t == 1) return this.data[0] - this.DV;\n        else if (this.t == 0) return -1;\n    } else if (this.t == 1) return this.data[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];\n}\n//(public) return value as byte\nfunction bnByteValue() {\n    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;\n}\n//(public) return value as short (assumes DB>=16)\nfunction bnShortValue() {\n    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;\n}\n//(protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n}\n//(public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;\n    else return 1;\n}\n//(protected) convert to radix string\nfunction bnpToRadix(b) {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n    this.divRemTo(d, y, z);\n    while(y.signum() > 0){\n        r = (a + z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n}\n//(protected) convert from radix string\nfunction bnpFromRadix(s, b) {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;\n    for(var i = 0; i < s.length; ++i){\n        var x = intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n            continue;\n        }\n        w = b * w + x;\n        if (++j >= cs) {\n            this.dMultiply(d);\n            this.dAddOffset(w, 0);\n            j = 0;\n            w = 0;\n        }\n    }\n    if (j > 0) {\n        this.dMultiply(Math.pow(b, j));\n        this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n}\n//(protected) alternate constructor\nfunction bnpFromNumber(a, b, c) {\n    if (\"number\" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if (a < 2) this.fromInt(1);\n        else {\n            this.fromNumber(a, c);\n            if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n            if (this.isEven()) this.dAddOffset(1, 0); // force odd\n            while(!this.isProbablePrime(b)){\n                this.dAddOffset(2, 0);\n                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n            }\n        }\n    } else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a & 7;\n        x.length = (a >> 3) + 1;\n        b.nextBytes(x);\n        if (t > 0) x[0] &= (1 << t) - 1;\n        else x[0] = 0;\n        this.fromString(x, 256);\n    }\n}\n//(public) convert to bigendian byte array\nfunction bnToByteArray() {\n    var i = this.t, r = new Array();\n    r[0] = this.s;\n    var p = this.DB - i * this.DB % 8, d, k = 0;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;\n        while(i >= 0){\n            if (p < 8) {\n                d = (this.data[i] & (1 << p) - 1) << 8 - p;\n                d |= this.data[--i] >> (p += this.DB - 8);\n            } else {\n                d = this.data[i] >> (p -= 8) & 0xff;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if ((d & 0x80) != 0) d |= -256;\n            if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;\n            if (k > 0 || d != this.s) r[k++] = d;\n        }\n    }\n    return r;\n}\nfunction bnEquals(a) {\n    return this.compareTo(a) == 0;\n}\nfunction bnMin(a) {\n    return this.compareTo(a) < 0 ? this : a;\n}\nfunction bnMax(a) {\n    return this.compareTo(a) > 0 ? this : a;\n}\n//(protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a, op, r) {\n    var i, f, m = Math.min(a.t, this.t);\n    for(i = 0; i < m; ++i)r.data[i] = op(this.data[i], a.data[i]);\n    if (a.t < this.t) {\n        f = a.s & this.DM;\n        for(i = m; i < this.t; ++i)r.data[i] = op(this.data[i], f);\n        r.t = this.t;\n    } else {\n        f = this.s & this.DM;\n        for(i = m; i < a.t; ++i)r.data[i] = op(f, a.data[i]);\n        r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n}\n//(public) this & a\nfunction op_and(x, y) {\n    return x & y;\n}\nfunction bnAnd(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n}\n//(public) this | a\nfunction op_or(x, y) {\n    return x | y;\n}\nfunction bnOr(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n}\n//(public) this ^ a\nfunction op_xor(x, y) {\n    return x ^ y;\n}\nfunction bnXor(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n}\n//(public) this & ~a\nfunction op_andnot(x, y) {\n    return x & ~y;\n}\nfunction bnAndNot(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n}\n//(public) ~this\nfunction bnNot() {\n    var r = nbi();\n    for(var i = 0; i < this.t; ++i)r.data[i] = this.DM & ~this.data[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n}\n//(public) this << n\nfunction bnShiftLeft(n) {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n}\n//(public) this >> n\nfunction bnShiftRight(n) {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n}\n//return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0) {\n        x >>= 16;\n        r += 16;\n    }\n    if ((x & 0xff) == 0) {\n        x >>= 8;\n        r += 8;\n    }\n    if ((x & 0xf) == 0) {\n        x >>= 4;\n        r += 4;\n    }\n    if ((x & 3) == 0) {\n        x >>= 2;\n        r += 2;\n    }\n    if ((x & 1) == 0) ++r;\n    return r;\n}\n//(public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n    for(var i = 0; i < this.t; ++i)if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n}\n//return number of 1 bits in x\nfunction cbit(x) {\n    var r = 0;\n    while(x != 0){\n        x &= x - 1;\n        ++r;\n    }\n    return r;\n}\n//(public) return number of set bits\nfunction bnBitCount() {\n    var r = 0, x = this.s & this.DM;\n    for(var i = 0; i < this.t; ++i)r += cbit(this.data[i] ^ x);\n    return r;\n}\n//(public) true iff nth bit is set\nfunction bnTestBit(n) {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return this.s != 0;\n    return (this.data[j] & 1 << n % this.DB) != 0;\n}\n//(protected) this op (1<<n)\nfunction bnpChangeBit(n, op) {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n}\n//(public) this | (1<<n)\nfunction bnSetBit(n) {\n    return this.changeBit(n, op_or);\n}\n//(public) this & ~(1<<n)\nfunction bnClearBit(n) {\n    return this.changeBit(n, op_andnot);\n}\n//(public) this ^ (1<<n)\nfunction bnFlipBit(n) {\n    return this.changeBit(n, op_xor);\n}\n//(protected) r = this + a\nfunction bnpAddTo(a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while(i < m){\n        c += this.data[i] + a.data[i];\n        r.data[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c += a.s;\n        while(i < this.t){\n            c += this.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while(i < a.t){\n            c += a.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += a.s;\n    }\n    r.s = c < 0 ? -1 : 0;\n    if (c > 0) r.data[i++] = c;\n    else if (c < -1) r.data[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n}\n//(public) this + a\nfunction bnAdd(a) {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n}\n//(public) this - a\nfunction bnSubtract(a) {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n}\n//(public) this * a\nfunction bnMultiply(a) {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n}\n//(public) this / a\nfunction bnDivide(a) {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n}\n//(public) this % a\nfunction bnRemainder(a) {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n}\n//(public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n    var q = nbi(), r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n}\n//(protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n    this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n}\n//(protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n, w) {\n    if (n == 0) return;\n    while(this.t <= w)this.data[this.t++] = 0;\n    this.data[w] += n;\n    while(this.data[w] >= this.DV){\n        this.data[w] -= this.DV;\n        if (++w >= this.t) this.data[this.t++] = 0;\n        ++this.data[w];\n    }\n}\n//A \"null\" reducer\nfunction NullExp() {}\nfunction nNop(x) {\n    return x;\n}\nfunction nMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n}\nfunction nSqrTo(x, r) {\n    x.squareTo(r);\n}\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n//(public) this^e\nfunction bnPow(e) {\n    return this.exp(e, new NullExp());\n}\n//(protected) r = lower n words of \"this * a\", a.t <= n\n//\"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a, n, r) {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while(i > 0)r.data[--i] = 0;\n    var j;\n    for(j = r.t - this.t; i < j; ++i)r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);\n    for(j = Math.min(a.t, n); i < j; ++i)this.am(0, a.data[i], r, i, 0, n - i);\n    r.clamp();\n}\n//(protected) r = \"this * a\" without lower n words, n > 0\n//\"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a, n, r) {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while(--i >= 0)r.data[i] = 0;\n    for(i = Math.max(n - this.t, 0); i < a.t; ++i)r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n}\n//Barrett modular reduction\nfunction Barrett(m) {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n}\nfunction barrettConvert(x) {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else {\n        var r = nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n    }\n}\nfunction barrettRevert(x) {\n    return x;\n}\n//x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1) {\n        x.t = this.m.t + 1;\n        x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while(x.compareTo(this.r2) < 0)x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while(x.compareTo(this.m) >= 0)x.subTo(this.m, x);\n}\n//r = x^2 mod m; x != r\nfunction barrettSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n}\n//r = x*y mod m; x,y != r\nfunction barrettMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n}\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n//(public) this^e % m (HAC 14.85)\nfunction bnModPow(e, m) {\n    var i = e.bitLength(), k, r = nbv(1), z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8) z = new Classic(m);\n    else if (m.isEven()) z = new Barrett(m);\n    else z = new Montgomery(m);\n    // precomputation\n    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1], g2);\n        while(n <= km){\n            g[n] = nbi();\n            z.mulTo(g2, g[n - 2], g[n]);\n            n += 2;\n        }\n    }\n    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n    i = nbits(e.data[j]) - 1;\n    while(j >= 0){\n        if (i >= k1) w = e.data[j] >> i - k1 & km;\n        else {\n            w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;\n            if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;\n        }\n        n = k;\n        while((w & 1) == 0){\n            w >>= 1;\n            --n;\n        }\n        if ((i -= n) < 0) {\n            i += this.DB;\n            --j;\n        }\n        if (is1) {\n            g[w].copyTo(r);\n            is1 = false;\n        } else {\n            while(n > 1){\n                z.sqrTo(r, r2);\n                z.sqrTo(r2, r);\n                n -= 2;\n            }\n            if (n > 0) z.sqrTo(r, r2);\n            else {\n                t = r;\n                r = r2;\n                r2 = t;\n            }\n            z.mulTo(r2, g[w], r);\n        }\n        while(j >= 0 && (e.data[j] & 1 << i) == 0){\n            z.sqrTo(r, r2);\n            t = r;\n            r = r2;\n            r2 = t;\n            if (--i < 0) {\n                i = this.DB - 1;\n                --j;\n            }\n        }\n    }\n    return z.revert(r);\n}\n//(public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n    var x = this.s < 0 ? this.negate() : this.clone();\n    var y = a.s < 0 ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0) {\n        var t = x;\n        x = y;\n        y = t;\n    }\n    var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0) {\n        x.rShiftTo(g, x);\n        y.rShiftTo(g, y);\n    }\n    while(x.signum() > 0){\n        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n        if (x.compareTo(y) >= 0) {\n            x.subTo(y, x);\n            x.rShiftTo(1, x);\n        } else {\n            y.subTo(x, y);\n            y.rShiftTo(1, y);\n        }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n}\n//(protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n    if (n <= 0) return 0;\n    var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;\n    if (this.t > 0) if (d == 0) r = this.data[0] % n;\n    else for(var i = this.t - 1; i >= 0; --i)r = (d * r + this.data[i]) % n;\n    return r;\n}\n//(public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n    var ac = m.isEven();\n    if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(), v = this.clone();\n    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n    while(u.signum() != 0){\n        while(u.isEven()){\n            u.rShiftTo(1, u);\n            if (ac) {\n                if (!a.isEven() || !b.isEven()) {\n                    a.addTo(this, a);\n                    b.subTo(m, b);\n                }\n                a.rShiftTo(1, a);\n            } else if (!b.isEven()) b.subTo(m, b);\n            b.rShiftTo(1, b);\n        }\n        while(v.isEven()){\n            v.rShiftTo(1, v);\n            if (ac) {\n                if (!c.isEven() || !d.isEven()) {\n                    c.addTo(this, c);\n                    d.subTo(m, d);\n                }\n                c.rShiftTo(1, c);\n            } else if (!d.isEven()) d.subTo(m, d);\n            d.rShiftTo(1, d);\n        }\n        if (u.compareTo(v) >= 0) {\n            u.subTo(v, u);\n            if (ac) a.subTo(c, a);\n            b.subTo(d, b);\n        } else {\n            v.subTo(u, v);\n            if (ac) c.subTo(a, c);\n            d.subTo(b, d);\n        }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n}\nvar lowprimes = [\n    2,\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n    59,\n    61,\n    67,\n    71,\n    73,\n    79,\n    83,\n    89,\n    97,\n    101,\n    103,\n    107,\n    109,\n    113,\n    127,\n    131,\n    137,\n    139,\n    149,\n    151,\n    157,\n    163,\n    167,\n    173,\n    179,\n    181,\n    191,\n    193,\n    197,\n    199,\n    211,\n    223,\n    227,\n    229,\n    233,\n    239,\n    241,\n    251,\n    257,\n    263,\n    269,\n    271,\n    277,\n    281,\n    283,\n    293,\n    307,\n    311,\n    313,\n    317,\n    331,\n    337,\n    347,\n    349,\n    353,\n    359,\n    367,\n    373,\n    379,\n    383,\n    389,\n    397,\n    401,\n    409,\n    419,\n    421,\n    431,\n    433,\n    439,\n    443,\n    449,\n    457,\n    461,\n    463,\n    467,\n    479,\n    487,\n    491,\n    499,\n    503,\n    509\n];\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n//(public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n    var i, x = this.abs();\n    if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {\n        for(i = 0; i < lowprimes.length; ++i)if (x.data[0] == lowprimes[i]) return true;\n        return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while(i < lowprimes.length){\n        var m = lowprimes[i], j = i + 1;\n        while(j < lowprimes.length && m < lplim)m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j)if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n}\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    var prng = bnGetPrng();\n    var a;\n    for(var i = 0; i < t; ++i){\n        // select witness 'a' at random from between 1 and n1\n        do {\n            a = new BigInteger(this.bitLength(), prng);\n        }while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\n        var y = a.modPow(r, this);\n        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n            var j = 1;\n            while(j++ < k && y.compareTo(n1) != 0){\n                y = y.modPowInt(2, this);\n                if (y.compareTo(BigInteger.ONE) == 0) return false;\n            }\n            if (y.compareTo(n1) != 0) return false;\n        }\n    }\n    return true;\n}\n// get pseudo random number generator\nfunction bnGetPrng() {\n    // create prng with api that matches BigInteger secure random\n    return {\n        // x is an array to fill with bytes\n        nextBytes: function(x) {\n            for(var i = 0; i < x.length; ++i){\n                x[i] = Math.floor(Math.random() * 0x0100);\n            }\n        }\n    };\n}\n//protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n//public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime; //BigInteger interfaces not implemented in jsbn:\n //BigInteger(int signum, byte[] magnitude)\n //double doubleValue()\n //float floatValue()\n //int hashCode()\n //long longValue()\n //static BigInteger valueOf(long val)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvanNibi5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUU3QixrRUFBa0U7QUFFbEU7Ozs7O0FBS0EsR0FDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDRDs7Ozs7QUFLQTtBQUNBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLElBQUksR0FBR0osTUFBTUksSUFBSSxJQUFJLENBQUM7QUFFN0MsaUJBQWlCO0FBQ2pCLElBQUlDO0FBRUosNkJBQTZCO0FBQzdCLElBQUlDLFNBQVM7QUFDYixJQUFJQyxPQUFRLENBQUNELFNBQU8sUUFBTyxLQUFJO0FBRS9CLHVCQUF1QjtBQUN2QixTQUFTRSxXQUFXQyxDQUFDLEVBQUNDLENBQUMsRUFBQ0MsQ0FBQztJQUN2QixJQUFJLENBQUNDLElBQUksR0FBRyxFQUFFO0lBQ2QsSUFBR0gsS0FBSyxNQUNOLElBQUcsWUFBWSxPQUFPQSxHQUFHLElBQUksQ0FBQ0ksVUFBVSxDQUFDSixHQUFFQyxHQUFFQztTQUN4QyxJQUFHRCxLQUFLLFFBQVEsWUFBWSxPQUFPRCxHQUFHLElBQUksQ0FBQ0ssVUFBVSxDQUFDTCxHQUFFO1NBQ3hELElBQUksQ0FBQ0ssVUFBVSxDQUFDTCxHQUFFQztBQUMzQjtBQUNBVixNQUFNSSxJQUFJLENBQUNJLFVBQVUsR0FBR0E7QUFFeEIsK0JBQStCO0FBQy9CLFNBQVNPO0lBQVEsT0FBTyxJQUFJUCxXQUFXO0FBQU87QUFFOUMsb0RBQW9EO0FBQ3BELDJDQUEyQztBQUMzQyw4Q0FBOEM7QUFDOUMsb0VBQW9FO0FBRXBFLDBEQUEwRDtBQUMxRCxzQ0FBc0M7QUFDdEMsb0RBQW9EO0FBQ3BELFNBQVNRLElBQUlDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQ1QsQ0FBQyxFQUFDVSxD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R2pDO0FBQ2xDN08sV0FBV3lCLFNBQVMsQ0FBQ1EsR0FBRyxHQUFHc0w7QUFDM0J2TixXQUFXeUIsU0FBUyxDQUFDc1AsR0FBRyxHQUFHdEM7QUFDM0J6TyxXQUFXeUIsU0FBUyxDQUFDbUosZUFBZSxHQUFHd0UsbUJBRXZDLGdEQUFnRDtDQUVoRCwwQ0FBMEM7Q0FDMUMsc0JBQXNCO0NBQ3RCLG9CQUFvQjtDQUNwQixnQkFBZ0I7Q0FDaEIsa0JBQWtCO0NBQ2xCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2pzYm4uanM/NmRmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbi8qXG5MaWNlbnNpbmcgKExJQ0VOU0UpXG4tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblRoaXMgc29mdHdhcmUgaXMgY292ZXJlZCB1bmRlciB0aGUgZm9sbG93aW5nIGNvcHlyaWdodDpcbiovXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUy1JU1wiIEFORCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUywgSU1QTElFRCBPUiBPVEhFUldJU0UsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04sIEFOWVxuICogV0FSUkFOVFkgT0YgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuICpcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRPTSBXVSBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBJTkNJREVOVEFMLFxuICogSU5ESVJFQ1QgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9GIEFOWSBLSU5ELCBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSXG4gKiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIE9SIE5PVCBBRFZJU0VEIE9GXG4gKiBUSEUgUE9TU0lCSUxJVFkgT0YgREFNQUdFLCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIEFSSVNJTkcgT1VUXG4gKiBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBhcHBsaWVzOlxuICpcbiAqIEFsbCByZWRpc3RyaWJ1dGlvbnMgbXVzdCByZXRhaW4gYW4gaW50YWN0IGNvcHkgb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlXG4gKiBhbmQgZGlzY2xhaW1lci5cbiAqL1xuLypcbkFkZHJlc3MgYWxsIHF1ZXN0aW9ucyByZWdhcmRpbmcgdGhpcyBsaWNlbnNlIHRvOlxuXG4gIFRvbSBXdVxuICB0andAY3MuU3RhbmZvcmQuRURVXG4qL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmpzYm4gPSBmb3JnZS5qc2JuIHx8IHt9O1xuXG4vLyBCaXRzIHBlciBkaWdpdFxudmFyIGRiaXRzO1xuXG4vLyBKYXZhU2NyaXB0IGVuZ2luZSBhbmFseXNpc1xudmFyIGNhbmFyeSA9IDB4ZGVhZGJlZWZjYWZlO1xudmFyIGpfbG0gPSAoKGNhbmFyeSYweGZmZmZmZik9PTB4ZWZjYWZlKTtcblxuLy8gKHB1YmxpYykgQ29uc3RydWN0b3JcbmZ1bmN0aW9uIEJpZ0ludGVnZXIoYSxiLGMpIHtcbiAgdGhpcy5kYXRhID0gW107XG4gIGlmKGEgIT0gbnVsbClcbiAgICBpZihcIm51bWJlclwiID09IHR5cGVvZiBhKSB0aGlzLmZyb21OdW1iZXIoYSxiLGMpO1xuICAgIGVsc2UgaWYoYiA9PSBudWxsICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGEpIHRoaXMuZnJvbVN0cmluZyhhLDI1Nik7XG4gICAgZWxzZSB0aGlzLmZyb21TdHJpbmcoYSxiKTtcbn1cbmZvcmdlLmpzYm4uQmlnSW50ZWdlciA9IEJpZ0ludGVnZXI7XG5cbi8vIHJldHVybiBuZXcsIHVuc2V0IEJpZ0ludGVnZXJcbmZ1bmN0aW9uIG5iaSgpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpOyB9XG5cbi8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2Fycmllcyxcbi8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cbi8vIGMgPCAzKmR2YWx1ZSwgeCA8IDIqZHZhbHVlLCB0aGlzX2kgPCBkdmFsdWVcbi8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG5cbi8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbi8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4vLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG5mdW5jdGlvbiBhbTEoaSx4LHcsaixjLG4pIHtcbiAgd2hpbGUoLS1uID49IDApIHtcbiAgICB2YXIgdiA9IHgqdGhpcy5kYXRhW2krK10rdy5kYXRhW2pdK2M7XG4gICAgYyA9IE1hdGguZmxvb3Iodi8weDQwMDAwMDApO1xuICAgIHcuZGF0YVtqKytdID0gdiYweDNmZmZmZmY7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG4vLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbi8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXG4vLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG5mdW5jdGlvbiBhbTIoaSx4LHcsaixjLG4pIHtcbiAgdmFyIHhsID0geCYweDdmZmYsIHhoID0geD4+MTU7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW2krK10+PjE1O1xuICAgIHZhciBtID0geGgqbCtoKnhsO1xuICAgIGwgPSB4bCpsKygobSYweDdmZmYpPDwxNSkrdy5kYXRhW2pdKyhjJjB4M2ZmZmZmZmYpO1xuICAgIGMgPSAobD4+PjMwKSsobT4+PjE1KSt4aCpoKyhjPj4+MzApO1xuICAgIHcuZGF0YVtqKytdID0gbCYweDNmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gQWx0ZXJuYXRlbHksIHNldCBtYXggZGlnaXQgYml0cyB0byAyOCBzaW5jZSBzb21lXG4vLyBicm93c2VycyBzbG93IGRvd24gd2hlbiBkZWFsaW5nIHdpdGggMzItYml0IG51bWJlcnMuXG5mdW5jdGlvbiBhbTMoaSx4LHcsaixjLG4pIHtcbiAgdmFyIHhsID0geCYweDNmZmYsIHhoID0geD4+MTQ7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbaV0mMHgzZmZmO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW2krK10+PjE0O1xuICAgIHZhciBtID0geGgqbCtoKnhsO1xuICAgIGwgPSB4bCpsKygobSYweDNmZmYpPDwxNCkrdy5kYXRhW2pdK2M7XG4gICAgYyA9IChsPj4yOCkrKG0+PjE0KSt4aCpoO1xuICAgIHcuZGF0YVtqKytdID0gbCYweGZmZmZmZmY7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIG5vZGUuanMgKG5vIGJyb3dzZXIpXG5pZih0eXBlb2YobmF2aWdhdG9yKSA9PT0gJ3VuZGVmaW5lZCcpXG57XG4gICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMztcbiAgIGRiaXRzID0gMjg7XG59IGVsc2UgaWYoal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTI7XG4gIGRiaXRzID0gMzA7XG59IGVsc2UgaWYoal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgIT0gXCJOZXRzY2FwZVwiKSkge1xuICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMTtcbiAgZGJpdHMgPSAyNjtcbn0gZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xuICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMztcbiAgZGJpdHMgPSAyODtcbn1cblxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxPDxkYml0cyktMSk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxPDxkYml0cyk7XG5cbnZhciBCSV9GUCA9IDUyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLEJJX0ZQKTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAtZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMiA9IDIqZGJpdHMtQklfRlA7XG5cbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xudmFyIEJJX1JDID0gbmV3IEFycmF5KCk7XG52YXIgcnIsdnY7XG5yciA9IFwiMFwiLmNoYXJDb2RlQXQoMCk7XG5mb3IodnYgPSAwOyB2diA8PSA5OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcImFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcblxuZnVuY3Rpb24gaW50MmNoYXIobikgeyByZXR1cm4gQklfUk0uY2hhckF0KG4pOyB9XG5mdW5jdGlvbiBpbnRBdChzLGkpIHtcbiAgdmFyIGMgPSBCSV9SQ1tzLmNoYXJDb2RlQXQoaSldO1xuICByZXR1cm4gKGM9PW51bGwpPy0xOmM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNvcHkgdGhpcyB0byByXG5mdW5jdGlvbiBibnBDb3B5VG8ocikge1xuICBmb3IodmFyIGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gdGhpcy50O1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIGludGVnZXIgdmFsdWUgeCwgLURWIDw9IHggPCBEVlxuZnVuY3Rpb24gYm5wRnJvbUludCh4KSB7XG4gIHRoaXMudCA9IDE7XG4gIHRoaXMucyA9ICh4PDApPy0xOjA7XG4gIGlmKHggPiAwKSB0aGlzLmRhdGFbMF0gPSB4O1xuICBlbHNlIGlmKHggPCAtMSkgdGhpcy5kYXRhWzBdID0geCt0aGlzLkRWO1xuICBlbHNlIHRoaXMudCA9IDA7XG59XG5cbi8vIHJldHVybiBiaWdpbnQgaW5pdGlhbGl6ZWQgdG8gdmFsdWVcbmZ1bmN0aW9uIG5idihpKSB7IHZhciByID0gbmJpKCk7IHIuZnJvbUludChpKTsgcmV0dXJuIHI7IH1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gc3RyaW5nIGFuZCByYWRpeFxuZnVuY3Rpb24gYm5wRnJvbVN0cmluZyhzLGIpIHtcbiAgdmFyIGs7XG4gIGlmKGIgPT0gMTYpIGsgPSA0O1xuICBlbHNlIGlmKGIgPT0gOCkgayA9IDM7XG4gIGVsc2UgaWYoYiA9PSAyNTYpIGsgPSA4OyAvLyBieXRlIGFycmF5XG4gIGVsc2UgaWYoYiA9PSAyKSBrID0gMTtcbiAgZWxzZSBpZihiID09IDMyKSBrID0gNTtcbiAgZWxzZSBpZihiID09IDQpIGsgPSAyO1xuICBlbHNlIHsgdGhpcy5mcm9tUmFkaXgocyxiKTsgcmV0dXJuOyB9XG4gIHRoaXMudCA9IDA7XG4gIHRoaXMucyA9IDA7XG4gIHZhciBpID0gcy5sZW5ndGgsIG1pID0gZmFsc2UsIHNoID0gMDtcbiAgd2hpbGUoLS1pID49IDApIHtcbiAgICB2YXIgeCA9IChrPT04KT9zW2ldJjB4ZmY6aW50QXQocyxpKTtcbiAgICBpZih4IDwgMCkge1xuICAgICAgaWYocy5jaGFyQXQoaSkgPT0gXCItXCIpIG1pID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBtaSA9IGZhbHNlO1xuICAgIGlmKHNoID09IDApXG4gICAgICB0aGlzLmRhdGFbdGhpcy50KytdID0geDtcbiAgICBlbHNlIGlmKHNoK2sgPiB0aGlzLkRCKSB7XG4gICAgICB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICh4JigoMTw8KHRoaXMuREItc2gpKS0xKSk8PHNoO1xuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9ICh4Pj4odGhpcy5EQi1zaCkpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSB4PDxzaDtcbiAgICBzaCArPSBrO1xuICAgIGlmKHNoID49IHRoaXMuREIpIHNoIC09IHRoaXMuREI7XG4gIH1cbiAgaWYoayA9PSA4ICYmIChzWzBdJjB4ODApICE9IDApIHtcbiAgICB0aGlzLnMgPSAtMTtcbiAgICBpZihzaCA+IDApIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0gKCgxPDwodGhpcy5EQi1zaCkpLTEpPDxzaDtcbiAgfVxuICB0aGlzLmNsYW1wKCk7XG4gIGlmKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyx0aGlzKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgY2xhbXAgb2ZmIGV4Y2VzcyBoaWdoIHdvcmRzXG5mdW5jdGlvbiBibnBDbGFtcCgpIHtcbiAgdmFyIGMgPSB0aGlzLnMmdGhpcy5ETTtcbiAgd2hpbGUodGhpcy50ID4gMCAmJiB0aGlzLmRhdGFbdGhpcy50LTFdID09IGMpIC0tdGhpcy50O1xufVxuXG4vLyAocHVibGljKSByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIGluIGdpdmVuIHJhZGl4XG5mdW5jdGlvbiBiblRvU3RyaW5nKGIpIHtcbiAgaWYodGhpcy5zIDwgMCkgcmV0dXJuIFwiLVwiK3RoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSByZXR1cm4gdGhpcy50b1JhZGl4KGIpO1xuICB2YXIga20gPSAoMTw8ayktMSwgZCwgbSA9IGZhbHNlLCByID0gXCJcIiwgaSA9IHRoaXMudDtcbiAgdmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJWs7XG4gIGlmKGktLSA+IDApIHtcbiAgICBpZihwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXMuZGF0YVtpXT4+cCkgPiAwKSB7IG0gPSB0cnVlOyByID0gaW50MmNoYXIoZCk7IH1cbiAgICB3aGlsZShpID49IDApIHtcbiAgICAgIGlmKHAgPCBrKSB7XG4gICAgICAgIGQgPSAodGhpcy5kYXRhW2ldJigoMTw8cCktMSkpPDwoay1wKTtcbiAgICAgICAgZCB8PSB0aGlzLmRhdGFbLS1pXT4+KHArPXRoaXMuREItayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXT4+KHAtPWspKSZrbTtcbiAgICAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICAgICB9XG4gICAgICBpZihkID4gMCkgbSA9IHRydWU7XG4gICAgICBpZihtKSByICs9IGludDJjaGFyKGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbT9yOlwiMFwiO1xufVxuXG4vLyAocHVibGljKSAtdGhpc1xuZnVuY3Rpb24gYm5OZWdhdGUoKSB7IHZhciByID0gbmJpKCk7IEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHIpOyByZXR1cm4gcjsgfVxuXG4vLyAocHVibGljKSB8dGhpc3xcbmZ1bmN0aW9uIGJuQWJzKCkgeyByZXR1cm4gKHRoaXMuczwwKT90aGlzLm5lZ2F0ZSgpOnRoaXM7IH1cblxuLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbmZ1bmN0aW9uIGJuQ29tcGFyZVRvKGEpIHtcbiAgdmFyIHIgPSB0aGlzLnMtYS5zO1xuICBpZihyICE9IDApIHJldHVybiByO1xuICB2YXIgaSA9IHRoaXMudDtcbiAgciA9IGktYS50O1xuICBpZihyICE9IDApIHJldHVybiAodGhpcy5zPDApPy1yOnI7XG4gIHdoaWxlKC0taSA+PSAwKSBpZigocj10aGlzLmRhdGFbaV0tYS5kYXRhW2ldKSAhPSAwKSByZXR1cm4gcjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIHJldHVybnMgYml0IGxlbmd0aCBvZiB0aGUgaW50ZWdlciB4XG5mdW5jdGlvbiBuYml0cyh4KSB7XG4gIHZhciByID0gMSwgdDtcbiAgaWYoKHQ9eD4+PjE2KSAhPSAwKSB7IHggPSB0OyByICs9IDE2OyB9XG4gIGlmKCh0PXg+PjgpICE9IDApIHsgeCA9IHQ7IHIgKz0gODsgfVxuICBpZigodD14Pj40KSAhPSAwKSB7IHggPSB0OyByICs9IDQ7IH1cbiAgaWYoKHQ9eD4+MikgIT0gMCkgeyB4ID0gdDsgciArPSAyOyB9XG4gIGlmKCh0PXg+PjEpICE9IDApIHsgeCA9IHQ7IHIgKz0gMTsgfVxuICByZXR1cm4gcjtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYml0cyBpbiBcInRoaXNcIlxuZnVuY3Rpb24gYm5CaXRMZW5ndGgoKSB7XG4gIGlmKHRoaXMudCA8PSAwKSByZXR1cm4gMDtcbiAgcmV0dXJuIHRoaXMuREIqKHRoaXMudC0xKStuYml0cyh0aGlzLmRhdGFbdGhpcy50LTFdXih0aGlzLnMmdGhpcy5ETSkpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuKkRCXG5mdW5jdGlvbiBibnBETFNoaWZ0VG8obixyKSB7XG4gIHZhciBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgci5kYXRhW2krbl0gPSB0aGlzLmRhdGFbaV07XG4gIGZvcihpID0gbi0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci50ID0gdGhpcy50K247XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxuZnVuY3Rpb24gYm5wRFJTaGlmdFRvKG4scikge1xuICBmb3IodmFyIGkgPSBuOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpLW5dID0gdGhpcy5kYXRhW2ldO1xuICByLnQgPSBNYXRoLm1heCh0aGlzLnQtbiwwKTtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuXG5mdW5jdGlvbiBibnBMU2hpZnRUbyhuLHIpIHtcbiAgdmFyIGJzID0gbiV0aGlzLkRCO1xuICB2YXIgY2JzID0gdGhpcy5EQi1icztcbiAgdmFyIGJtID0gKDE8PGNicyktMTtcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpLCBjID0gKHRoaXMuczw8YnMpJnRoaXMuRE0sIGk7XG4gIGZvcihpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgci5kYXRhW2krZHMrMV0gPSAodGhpcy5kYXRhW2ldPj5jYnMpfGM7XG4gICAgYyA9ICh0aGlzLmRhdGFbaV0mYm0pPDxicztcbiAgfVxuICBmb3IoaSA9IGRzLTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSAwO1xuICByLmRhdGFbZHNdID0gYztcbiAgci50ID0gdGhpcy50K2RzKzE7XG4gIHIucyA9IHRoaXMucztcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuXG5mdW5jdGlvbiBibnBSU2hpZnRUbyhuLHIpIHtcbiAgci5zID0gdGhpcy5zO1xuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4vdGhpcy5EQik7XG4gIGlmKGRzID49IHRoaXMudCkgeyByLnQgPSAwOyByZXR1cm47IH1cbiAgdmFyIGJzID0gbiV0aGlzLkRCO1xuICB2YXIgY2JzID0gdGhpcy5EQi1icztcbiAgdmFyIGJtID0gKDE8PGJzKS0xO1xuICByLmRhdGFbMF0gPSB0aGlzLmRhdGFbZHNdPj5icztcbiAgZm9yKHZhciBpID0gZHMrMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgci5kYXRhW2ktZHMtMV0gfD0gKHRoaXMuZGF0YVtpXSZibSk8PGNicztcbiAgICByLmRhdGFbaS1kc10gPSB0aGlzLmRhdGFbaV0+PmJzO1xuICB9XG4gIGlmKGJzID4gMCkgci5kYXRhW3RoaXMudC1kcy0xXSB8PSAodGhpcy5zJmJtKTw8Y2JzO1xuICByLnQgPSB0aGlzLnQtZHM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgLSBhXG5mdW5jdGlvbiBibnBTdWJUbyhhLHIpIHtcbiAgdmFyIGkgPSAwLCBjID0gMCwgbSA9IE1hdGgubWluKGEudCx0aGlzLnQpO1xuICB3aGlsZShpIDwgbSkge1xuICAgIGMgKz0gdGhpcy5kYXRhW2ldLWEuZGF0YVtpXTtcbiAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICBjID4+PSB0aGlzLkRCO1xuICB9XG4gIGlmKGEudCA8IHRoaXMudCkge1xuICAgIGMgLT0gYS5zO1xuICAgIHdoaWxlKGkgPCB0aGlzLnQpIHtcbiAgICAgIGMgKz0gdGhpcy5kYXRhW2ldO1xuICAgICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgICBjID4+PSB0aGlzLkRCO1xuICAgIH1cbiAgICBjICs9IHRoaXMucztcbiAgfSBlbHNlIHtcbiAgICBjICs9IHRoaXMucztcbiAgICB3aGlsZShpIDwgYS50KSB7XG4gICAgICBjIC09IGEuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyAtPSBhLnM7XG4gIH1cbiAgci5zID0gKGM8MCk/LTE6MDtcbiAgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbiAgZWxzZSBpZihjID4gMCkgci5kYXRhW2krK10gPSBjO1xuICByLnQgPSBpO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICogYSwgciAhPSB0aGlzLGEgKEhBQyAxNC4xMilcbi8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5VG8oYSxyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKSwgeSA9IGEuYWJzKCk7XG4gIHZhciBpID0geC50O1xuICByLnQgPSBpK3kudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHkudDsgKytpKSByLmRhdGFbaSt4LnRdID0geC5hbSgwLHkuZGF0YVtpXSxyLGksMCx4LnQpO1xuICByLnMgPSAwO1xuICByLmNsYW1wKCk7XG4gIGlmKHRoaXMucyAhPSBhLnMpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLHIpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcbmZ1bmN0aW9uIGJucFNxdWFyZVRvKHIpIHtcbiAgdmFyIHggPSB0aGlzLmFicygpO1xuICB2YXIgaSA9IHIudCA9IDIqeC50O1xuICB3aGlsZSgtLWkgPj0gMCkgci5kYXRhW2ldID0gMDtcbiAgZm9yKGkgPSAwOyBpIDwgeC50LTE7ICsraSkge1xuICAgIHZhciBjID0geC5hbShpLHguZGF0YVtpXSxyLDIqaSwwLDEpO1xuICAgIGlmKChyLmRhdGFbaSt4LnRdKz14LmFtKGkrMSwyKnguZGF0YVtpXSxyLDIqaSsxLGMseC50LWktMSkpID49IHguRFYpIHtcbiAgICAgIHIuZGF0YVtpK3gudF0gLT0geC5EVjtcbiAgICAgIHIuZGF0YVtpK3gudCsxXSA9IDE7XG4gICAgfVxuICB9XG4gIGlmKHIudCA+IDApIHIuZGF0YVtyLnQtMV0gKz0geC5hbShpLHguZGF0YVtpXSxyLDIqaSwwLDEpO1xuICByLnMgPSAwO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuLy8gciAhPSBxLCB0aGlzICE9IG0uICBxIG9yIHIgbWF5IGJlIG51bGwuXG5mdW5jdGlvbiBibnBEaXZSZW1UbyhtLHEscikge1xuICB2YXIgcG0gPSBtLmFicygpO1xuICBpZihwbS50IDw9IDApIHJldHVybjtcbiAgdmFyIHB0ID0gdGhpcy5hYnMoKTtcbiAgaWYocHQudCA8IHBtLnQpIHtcbiAgICBpZihxICE9IG51bGwpIHEuZnJvbUludCgwKTtcbiAgICBpZihyICE9IG51bGwpIHRoaXMuY29weVRvKHIpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZihyID09IG51bGwpIHIgPSBuYmkoKTtcbiAgdmFyIHkgPSBuYmkoKSwgdHMgPSB0aGlzLnMsIG1zID0gbS5zO1xuICB2YXIgbnNoID0gdGhpcy5EQi1uYml0cyhwbS5kYXRhW3BtLnQtMV0pO1x0Ly8gbm9ybWFsaXplIG1vZHVsdXNcbiAgaWYobnNoID4gMCkgeyBwbS5sU2hpZnRUbyhuc2gseSk7IHB0LmxTaGlmdFRvKG5zaCxyKTsgfSBlbHNlIHsgcG0uY29weVRvKHkpOyBwdC5jb3B5VG8ocik7IH1cbiAgdmFyIHlzID0geS50O1xuICB2YXIgeTAgPSB5LmRhdGFbeXMtMV07XG4gIGlmKHkwID09IDApIHJldHVybjtcbiAgdmFyIHl0ID0geTAqKDE8PHRoaXMuRjEpKygoeXM+MSk/eS5kYXRhW3lzLTJdPj50aGlzLkYyOjApO1xuICB2YXIgZDEgPSB0aGlzLkZWL3l0LCBkMiA9ICgxPDx0aGlzLkYxKS95dCwgZSA9IDE8PHRoaXMuRjI7XG4gIHZhciBpID0gci50LCBqID0gaS15cywgdCA9IChxPT1udWxsKT9uYmkoKTpxO1xuICB5LmRsU2hpZnRUbyhqLHQpO1xuICBpZihyLmNvbXBhcmVUbyh0KSA+PSAwKSB7XG4gICAgci5kYXRhW3IudCsrXSA9IDE7XG4gICAgci5zdWJUbyh0LHIpO1xuICB9XG4gIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cyx0KTtcbiAgdC5zdWJUbyh5LHkpO1x0Ly8gXCJuZWdhdGl2ZVwiIHkgc28gd2UgY2FuIHJlcGxhY2Ugc3ViIHdpdGggYW0gbGF0ZXJcbiAgd2hpbGUoeS50IDwgeXMpIHkuZGF0YVt5LnQrK10gPSAwO1xuICB3aGlsZSgtLWogPj0gMCkge1xuICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgdmFyIHFkID0gKHIuZGF0YVstLWldPT15MCk/dGhpcy5ETTpNYXRoLmZsb29yKHIuZGF0YVtpXSpkMSsoci5kYXRhW2ktMV0rZSkqZDIpO1xuICAgIGlmKChyLmRhdGFbaV0rPXkuYW0oMCxxZCxyLGosMCx5cykpIDwgcWQpIHtcdC8vIFRyeSBpdCBvdXRcbiAgICAgIHkuZGxTaGlmdFRvKGosdCk7XG4gICAgICByLnN1YlRvKHQscik7XG4gICAgICB3aGlsZShyLmRhdGFbaV0gPCAtLXFkKSByLnN1YlRvKHQscik7XG4gICAgfVxuICB9XG4gIGlmKHEgIT0gbnVsbCkge1xuICAgIHIuZHJTaGlmdFRvKHlzLHEpO1xuICAgIGlmKHRzICE9IG1zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSxxKTtcbiAgfVxuICByLnQgPSB5cztcbiAgci5jbGFtcCgpO1xuICBpZihuc2ggPiAwKSByLnJTaGlmdFRvKG5zaCxyKTtcdC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxuICBpZih0cyA8IDApIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzIG1vZCBhXG5mdW5jdGlvbiBibk1vZChhKSB7XG4gIHZhciByID0gbmJpKCk7XG4gIHRoaXMuYWJzKCkuZGl2UmVtVG8oYSxudWxsLHIpO1xuICBpZih0aGlzLnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSBhLnN1YlRvKHIscik7XG4gIHJldHVybiByO1xufVxuXG4vLyBNb2R1bGFyIHJlZHVjdGlvbiB1c2luZyBcImNsYXNzaWNcIiBhbGdvcml0aG1cbmZ1bmN0aW9uIENsYXNzaWMobSkgeyB0aGlzLm0gPSBtOyB9XG5mdW5jdGlvbiBjQ29udmVydCh4KSB7XG4gIGlmKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgZWxzZSByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGNSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuZnVuY3Rpb24gY1JlZHVjZSh4KSB7IHguZGl2UmVtVG8odGhpcy5tLG51bGwseCk7IH1cbmZ1bmN0aW9uIGNNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cbmZ1bmN0aW9uIGNTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGNDb252ZXJ0O1xuQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gY1JldmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJlZHVjZSA9IGNSZWR1Y2U7XG5DbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUbztcbkNsYXNzaWMucHJvdG90eXBlLnNxclRvID0gY1NxclRvO1xuXG4vLyAocHJvdGVjdGVkKSByZXR1cm4gXCItMS90aGlzICUgMl5EQlwiOyB1c2VmdWwgZm9yIE1vbnQuIHJlZHVjdGlvblxuLy8ganVzdGlmaWNhdGlvbjpcbi8vICAgICAgICAgeHkgPT0gMSAobW9kIG0pXG4vLyAgICAgICAgIHh5ID0gIDEra21cbi8vICAgeHkoMi14eSkgPSAoMStrbSkoMS1rbSlcbi8vIHhbeSgyLXh5KV0gPSAxLWteMm1eMlxuLy8geFt5KDIteHkpXSA9PSAxIChtb2QgbV4yKVxuLy8gaWYgeSBpcyAxL3ggbW9kIG0sIHRoZW4geSgyLXh5KSBpcyAxL3ggbW9kIG1eMlxuLy8gc2hvdWxkIHJlZHVjZSB4IGFuZCB5KDIteHkpIGJ5IG1eMiBhdCBlYWNoIHN0ZXAgdG8ga2VlcCBzaXplIGJvdW5kZWQuXG4vLyBKUyBtdWx0aXBseSBcIm92ZXJmbG93c1wiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXG5mdW5jdGlvbiBibnBJbnZEaWdpdCgpIHtcbiAgaWYodGhpcy50IDwgMSkgcmV0dXJuIDA7XG4gIHZhciB4ID0gdGhpcy5kYXRhWzBdO1xuICBpZigoeCYxKSA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIHkgPSB4JjM7XHRcdC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgeSA9ICh5KigyLSh4JjB4ZikqeSkpJjB4ZjtcdC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgeSA9ICh5KigyLSh4JjB4ZmYpKnkpKSYweGZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeOFxuICB5ID0gKHkqKDItKCgoeCYweGZmZmYpKnkpJjB4ZmZmZikpKSYweGZmZmY7XHQvLyB5ID09IDEveCBtb2QgMl4xNlxuICAvLyBsYXN0IHN0ZXAgLSBjYWxjdWxhdGUgaW52ZXJzZSBtb2QgRFYgZGlyZWN0bHk7XG4gIC8vIGFzc3VtZXMgMTYgPCBEQiA8PSAzMiBhbmQgYXNzdW1lcyBhYmlsaXR5IHRvIGhhbmRsZSA0OC1iaXQgaW50c1xuICB5ID0gKHkqKDIteCp5JXRoaXMuRFYpKSV0aGlzLkRWO1x0XHQvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAvLyB3ZSByZWFsbHkgd2FudCB0aGUgbmVnYXRpdmUgaW52ZXJzZSwgYW5kIC1EViA8IHkgPCBEVlxuICByZXR1cm4gKHk+MCk/dGhpcy5EVi15Oi15O1xufVxuXG4vLyBNb250Z29tZXJ5IHJlZHVjdGlvblxuZnVuY3Rpb24gTW9udGdvbWVyeShtKSB7XG4gIHRoaXMubSA9IG07XG4gIHRoaXMubXAgPSBtLmludkRpZ2l0KCk7XG4gIHRoaXMubXBsID0gdGhpcy5tcCYweDdmZmY7XG4gIHRoaXMubXBoID0gdGhpcy5tcD4+MTU7XG4gIHRoaXMudW0gPSAoMTw8KG0uREItMTUpKS0xO1xuICB0aGlzLm10MiA9IDIqbS50O1xufVxuXG4vLyB4UiBtb2QgbVxuZnVuY3Rpb24gbW9udENvbnZlcnQoeCkge1xuICB2YXIgciA9IG5iaSgpO1xuICB4LmFicygpLmRsU2hpZnRUbyh0aGlzLm0udCxyKTtcbiAgci5kaXZSZW1Ubyh0aGlzLm0sbnVsbCxyKTtcbiAgaWYoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgdGhpcy5tLnN1YlRvKHIscik7XG4gIHJldHVybiByO1xufVxuXG4vLyB4L1IgbW9kIG1cbmZ1bmN0aW9uIG1vbnRSZXZlcnQoeCkge1xuICB2YXIgciA9IG5iaSgpO1xuICB4LmNvcHlUbyhyKTtcbiAgdGhpcy5yZWR1Y2Uocik7XG4gIHJldHVybiByO1xufVxuXG4vLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG5mdW5jdGlvbiBtb250UmVkdWNlKHgpIHtcbiAgd2hpbGUoeC50IDw9IHRoaXMubXQyKVx0Ly8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgeC5kYXRhW3gudCsrXSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHguZGF0YVtpXSptcCBtb2QgRFZcbiAgICB2YXIgaiA9IHguZGF0YVtpXSYweDdmZmY7XG4gICAgdmFyIHUwID0gKGoqdGhpcy5tcGwrKCgoaip0aGlzLm1waCsoeC5kYXRhW2ldPj4xNSkqdGhpcy5tcGwpJnRoaXMudW0pPDwxNSkpJnguRE07XG4gICAgLy8gdXNlIGFtIHRvIGNvbWJpbmUgdGhlIG11bHRpcGx5LXNoaWZ0LWFkZCBpbnRvIG9uZSBjYWxsXG4gICAgaiA9IGkrdGhpcy5tLnQ7XG4gICAgeC5kYXRhW2pdICs9IHRoaXMubS5hbSgwLHUwLHgsaSwwLHRoaXMubS50KTtcbiAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICB3aGlsZSh4LmRhdGFbal0gPj0geC5EVikgeyB4LmRhdGFbal0gLT0geC5EVjsgeC5kYXRhWysral0rKzsgfVxuICB9XG4gIHguY2xhbXAoKTtcbiAgeC5kclNoaWZ0VG8odGhpcy5tLnQseCk7XG4gIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG59XG5cbi8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuZnVuY3Rpb24gbW9udFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4vLyByID0gXCJ4eS9SIG1vZCBtXCI7IHgseSAhPSByXG5mdW5jdGlvbiBtb250TXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbk1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcbk1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IG1vbnRSZXZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlO1xuTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbyA9IG1vbnRTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG5mdW5jdGlvbiBibnBJc0V2ZW4oKSB7IHJldHVybiAoKHRoaXMudD4wKT8odGhpcy5kYXRhWzBdJjEpOnRoaXMucykgPT0gMDsgfVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzXmUsIGUgPCAyXjMyLCBkb2luZyBzcXIgYW5kIG11bCB3aXRoIFwiclwiIChIQUMgMTQuNzkpXG5mdW5jdGlvbiBibnBFeHAoZSx6KSB7XG4gIGlmKGUgPiAweGZmZmZmZmZmIHx8IGUgPCAxKSByZXR1cm4gQmlnSW50ZWdlci5PTkU7XG4gIHZhciByID0gbmJpKCksIHIyID0gbmJpKCksIGcgPSB6LmNvbnZlcnQodGhpcyksIGkgPSBuYml0cyhlKS0xO1xuICBnLmNvcHlUbyhyKTtcbiAgd2hpbGUoLS1pID49IDApIHtcbiAgICB6LnNxclRvKHIscjIpO1xuICAgIGlmKChlJigxPDxpKSkgPiAwKSB6Lm11bFRvKHIyLGcscik7XG4gICAgZWxzZSB7IHZhciB0ID0gcjsgciA9IHIyOyByMiA9IHQ7IH1cbiAgfVxuICByZXR1cm4gei5yZXZlcnQocik7XG59XG5cbi8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcbmZ1bmN0aW9uIGJuTW9kUG93SW50KGUsbSkge1xuICB2YXIgejtcbiAgaWYoZSA8IDI1NiB8fCBtLmlzRXZlbigpKSB6ID0gbmV3IENsYXNzaWMobSk7IGVsc2UgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuICByZXR1cm4gdGhpcy5leHAoZSx6KTtcbn1cblxuLy8gcHJvdGVjdGVkXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jb3B5VG8gPSBibnBDb3B5VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gYm5wRnJvbUludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBibnBDbGFtcDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRsU2hpZnRUbyA9IGJucERMU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRyU2hpZnRUbyA9IGJucERSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGJucFJTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc3ViVG8gPSBibnBTdWJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBibnBTcXVhcmVUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gYm5wRGl2UmVtVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnZEaWdpdCA9IGJucEludkRpZ2l0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gYm5wSXNFdmVuO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZXhwID0gYm5wRXhwO1xuXG4vLyBwdWJsaWNcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gYm5Ub1N0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGJuTmVnYXRlO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gYm5BYnM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBibkNvbXBhcmVUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gYm5Nb2Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBibk1vZFBvd0ludDtcblxuLy8gXCJjb25zdGFudHNcIlxuQmlnSW50ZWdlci5aRVJPID0gbmJ2KDApO1xuQmlnSW50ZWdlci5PTkUgPSBuYnYoMSk7XG5cbi8vIGpzYm4yIGxpYlxuXG4vL0NvcHlyaWdodCAoYykgMjAwNS0yMDA5ICBUb20gV3Vcbi8vQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzIChTZWUganNibi5qcyBmb3IgTElDRU5TRSkuXG5cbi8vRXh0ZW5kZWQgSmF2YVNjcmlwdCBCTiBmdW5jdGlvbnMsIHJlcXVpcmVkIGZvciBSU0EgcHJpdmF0ZSBvcHMuXG5cbi8vVmVyc2lvbiAxLjE6IG5ldyBCaWdJbnRlZ2VyKFwiMFwiLCAxMCkgcmV0dXJucyBcInByb3BlclwiIHplcm9cblxuLy8ocHVibGljKVxuZnVuY3Rpb24gYm5DbG9uZSgpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5jb3B5VG8ocik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGludGVnZXJcbmZ1bmN0aW9uIGJuSW50VmFsdWUoKSB7XG5pZih0aGlzLnMgPCAwKSB7XG4gaWYodGhpcy50ID09IDEpIHJldHVybiB0aGlzLmRhdGFbMF0tdGhpcy5EVjtcbiBlbHNlIGlmKHRoaXMudCA9PSAwKSByZXR1cm4gLTE7XG59IGVsc2UgaWYodGhpcy50ID09IDEpIHJldHVybiB0aGlzLmRhdGFbMF07XG5lbHNlIGlmKHRoaXMudCA9PSAwKSByZXR1cm4gMDtcbi8vIGFzc3VtZXMgMTYgPCBEQiA8IDMyXG5yZXR1cm4gKCh0aGlzLmRhdGFbMV0mKCgxPDwoMzItdGhpcy5EQikpLTEpKTw8dGhpcy5EQil8dGhpcy5kYXRhWzBdO1xufVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBieXRlXG5mdW5jdGlvbiBibkJ5dGVWYWx1ZSgpIHsgcmV0dXJuICh0aGlzLnQ9PTApP3RoaXMuczoodGhpcy5kYXRhWzBdPDwyNCk+PjI0OyB9XG5cbi8vKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIHNob3J0IChhc3N1bWVzIERCPj0xNilcbmZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpIHsgcmV0dXJuICh0aGlzLnQ9PTApP3RoaXMuczoodGhpcy5kYXRhWzBdPDwxNik+PjE2OyB9XG5cbi8vKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxuZnVuY3Rpb24gYm5wQ2h1bmtTaXplKHIpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIqdGhpcy5EQi9NYXRoLmxvZyhyKSk7IH1cblxuLy8ocHVibGljKSAwIGlmIHRoaXMgPT0gMCwgMSBpZiB0aGlzID4gMFxuZnVuY3Rpb24gYm5TaWdOdW0oKSB7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gLTE7XG5lbHNlIGlmKHRoaXMudCA8PSAwIHx8ICh0aGlzLnQgPT0gMSAmJiB0aGlzLmRhdGFbMF0gPD0gMCkpIHJldHVybiAwO1xuZWxzZSByZXR1cm4gMTtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuZnVuY3Rpb24gYm5wVG9SYWRpeChiKSB7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbmlmKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHJldHVybiBcIjBcIjtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGEgPSBNYXRoLnBvdyhiLGNzKTtcbnZhciBkID0gbmJ2KGEpLCB5ID0gbmJpKCksIHogPSBuYmkoKSwgciA9IFwiXCI7XG50aGlzLmRpdlJlbVRvKGQseSx6KTtcbndoaWxlKHkuc2lnbnVtKCkgPiAwKSB7XG4gciA9IChhK3ouaW50VmFsdWUoKSkudG9TdHJpbmcoYikuc3Vic3RyKDEpICsgcjtcbiB5LmRpdlJlbVRvKGQseSx6KTtcbn1cbnJldHVybiB6LmludFZhbHVlKCkudG9TdHJpbmcoYikgKyByO1xufVxuXG4vLyhwcm90ZWN0ZWQpIGNvbnZlcnQgZnJvbSByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucEZyb21SYWRpeChzLGIpIHtcbnRoaXMuZnJvbUludCgwKTtcbmlmKGIgPT0gbnVsbCkgYiA9IDEwO1xudmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG52YXIgZCA9IE1hdGgucG93KGIsY3MpLCBtaSA9IGZhbHNlLCBqID0gMCwgdyA9IDA7XG5mb3IodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuIHZhciB4ID0gaW50QXQocyxpKTtcbiBpZih4IDwgMCkge1xuICAgaWYocy5jaGFyQXQoaSkgPT0gXCItXCIgJiYgdGhpcy5zaWdudW0oKSA9PSAwKSBtaSA9IHRydWU7XG4gICBjb250aW51ZTtcbiB9XG4gdyA9IGIqdyt4O1xuIGlmKCsraiA+PSBjcykge1xuICAgdGhpcy5kTXVsdGlwbHkoZCk7XG4gICB0aGlzLmRBZGRPZmZzZXQodywwKTtcbiAgIGogPSAwO1xuICAgdyA9IDA7XG4gfVxufVxuaWYoaiA+IDApIHtcbiB0aGlzLmRNdWx0aXBseShNYXRoLnBvdyhiLGopKTtcbiB0aGlzLmRBZGRPZmZzZXQodywwKTtcbn1cbmlmKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyx0aGlzKTtcbn1cblxuLy8ocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbmZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSxiLGMpIHtcbmlmKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsaW50LFJORylcbiBpZihhIDwgMikgdGhpcy5mcm9tSW50KDEpO1xuIGVsc2Uge1xuICAgdGhpcy5mcm9tTnVtYmVyKGEsYyk7XG4gICBpZighdGhpcy50ZXN0Qml0KGEtMSkpICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLG9wX29yLHRoaXMpO1xuICAgaWYodGhpcy5pc0V2ZW4oKSkgdGhpcy5kQWRkT2Zmc2V0KDEsMCk7IC8vIGZvcmNlIG9kZFxuICAgd2hpbGUoIXRoaXMuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgIHRoaXMuZEFkZE9mZnNldCgyLDApO1xuICAgICBpZih0aGlzLmJpdExlbmd0aCgpID4gYSkgdGhpcy5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSx0aGlzKTtcbiAgIH1cbiB9XG59IGVsc2Uge1xuIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXG4gdmFyIHggPSBuZXcgQXJyYXkoKSwgdCA9IGEmNztcbiB4Lmxlbmd0aCA9IChhPj4zKSsxO1xuIGIubmV4dEJ5dGVzKHgpO1xuIGlmKHQgPiAwKSB4WzBdICY9ICgoMTw8dCktMSk7IGVsc2UgeFswXSA9IDA7XG4gdGhpcy5mcm9tU3RyaW5nKHgsMjU2KTtcbn1cbn1cblxuLy8ocHVibGljKSBjb252ZXJ0IHRvIGJpZ2VuZGlhbiBieXRlIGFycmF5XG5mdW5jdGlvbiBiblRvQnl0ZUFycmF5KCkge1xudmFyIGkgPSB0aGlzLnQsIHIgPSBuZXcgQXJyYXkoKTtcbnJbMF0gPSB0aGlzLnM7XG52YXIgcCA9IHRoaXMuREItKGkqdGhpcy5EQiklOCwgZCwgayA9IDA7XG5pZihpLS0gPiAwKSB7XG4gaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApICE9ICh0aGlzLnMmdGhpcy5ETSk+PnApXG4gICByW2srK10gPSBkfCh0aGlzLnM8PCh0aGlzLkRCLXApKTtcbiB3aGlsZShpID49IDApIHtcbiAgIGlmKHAgPCA4KSB7XG4gICAgIGQgPSAodGhpcy5kYXRhW2ldJigoMTw8cCktMSkpPDwoOC1wKTtcbiAgICAgZCB8PSB0aGlzLmRhdGFbLS1pXT4+KHArPXRoaXMuREItOCk7XG4gICB9IGVsc2Uge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXT4+KHAtPTgpKSYweGZmO1xuICAgICBpZihwIDw9IDApIHsgcCArPSB0aGlzLkRCOyAtLWk7IH1cbiAgIH1cbiAgIGlmKChkJjB4ODApICE9IDApIGQgfD0gLTI1NjtcbiAgIGlmKGsgPT0gMCAmJiAodGhpcy5zJjB4ODApICE9IChkJjB4ODApKSArK2s7XG4gICBpZihrID4gMCB8fCBkICE9IHRoaXMucykgcltrKytdID0gZDtcbiB9XG59XG5yZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYm5FcXVhbHMoYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk9PTApOyB9XG5mdW5jdGlvbiBibk1pbihhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKTwwKT90aGlzOmE7IH1cbmZ1bmN0aW9uIGJuTWF4KGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPjApP3RoaXM6YTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG5mdW5jdGlvbiBibnBCaXR3aXNlVG8oYSxvcCxyKSB7XG52YXIgaSwgZiwgbSA9IE1hdGgubWluKGEudCx0aGlzLnQpO1xuZm9yKGkgPSAwOyBpIDwgbTsgKytpKSByLmRhdGFbaV0gPSBvcCh0aGlzLmRhdGFbaV0sYS5kYXRhW2ldKTtcbmlmKGEudCA8IHRoaXMudCkge1xuIGYgPSBhLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCB0aGlzLnQ7ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGYpO1xuIHIudCA9IHRoaXMudDtcbn0gZWxzZSB7XG4gZiA9IHRoaXMucyZ0aGlzLkRNO1xuIGZvcihpID0gbTsgaSA8IGEudDsgKytpKSByLmRhdGFbaV0gPSBvcChmLGEuZGF0YVtpXSk7XG4gci50ID0gYS50O1xufVxuci5zID0gb3AodGhpcy5zLGEucyk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyAmIGFcbmZ1bmN0aW9uIG9wX2FuZCh4LHkpIHsgcmV0dXJuIHgmeTsgfVxuZnVuY3Rpb24gYm5BbmQoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIHwgYVxuZnVuY3Rpb24gb3Bfb3IoeCx5KSB7IHJldHVybiB4fHk7IH1cbmZ1bmN0aW9uIGJuT3IoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX29yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgXiBhXG5mdW5jdGlvbiBvcF94b3IoeCx5KSB7IHJldHVybiB4Xnk7IH1cbmZ1bmN0aW9uIGJuWG9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF94b3Iscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH5hXG5mdW5jdGlvbiBvcF9hbmRub3QoeCx5KSB7IHJldHVybiB4Jn55OyB9XG5mdW5jdGlvbiBibkFuZE5vdChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfYW5kbm90LHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIH50aGlzXG5mdW5jdGlvbiBibk5vdCgpIHtcbnZhciByID0gbmJpKCk7XG5mb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IHRoaXMuRE0mfnRoaXMuZGF0YVtpXTtcbnIudCA9IHRoaXMudDtcbnIucyA9IH50aGlzLnM7XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJuU2hpZnRMZWZ0KG4pIHtcbnZhciByID0gbmJpKCk7XG5pZihuIDwgMCkgdGhpcy5yU2hpZnRUbygtbixyKTsgZWxzZSB0aGlzLmxTaGlmdFRvKG4scik7XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSB0aGlzID4+IG5cbmZ1bmN0aW9uIGJuU2hpZnRSaWdodChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMubFNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5yU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vcmV0dXJuIGluZGV4IG9mIGxvd2VzdCAxLWJpdCBpbiB4LCB4IDwgMl4zMVxuZnVuY3Rpb24gbGJpdCh4KSB7XG5pZih4ID09IDApIHJldHVybiAtMTtcbnZhciByID0gMDtcbmlmKCh4JjB4ZmZmZikgPT0gMCkgeyB4ID4+PSAxNjsgciArPSAxNjsgfVxuaWYoKHgmMHhmZikgPT0gMCkgeyB4ID4+PSA4OyByICs9IDg7IH1cbmlmKCh4JjB4ZikgPT0gMCkgeyB4ID4+PSA0OyByICs9IDQ7IH1cbmlmKCh4JjMpID09IDApIHsgeCA+Pj0gMjsgciArPSAyOyB9XG5pZigoeCYxKSA9PSAwKSArK3I7XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSByZXR1cm5zIGluZGV4IG9mIGxvd2VzdCAxLWJpdCAob3IgLTEgaWYgbm9uZSlcbmZ1bmN0aW9uIGJuR2V0TG93ZXN0U2V0Qml0KCkge1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKVxuIGlmKHRoaXMuZGF0YVtpXSAhPSAwKSByZXR1cm4gaSp0aGlzLkRCK2xiaXQodGhpcy5kYXRhW2ldKTtcbmlmKHRoaXMucyA8IDApIHJldHVybiB0aGlzLnQqdGhpcy5EQjtcbnJldHVybiAtMTtcbn1cblxuLy9yZXR1cm4gbnVtYmVyIG9mIDEgYml0cyBpbiB4XG5mdW5jdGlvbiBjYml0KHgpIHtcbnZhciByID0gMDtcbndoaWxlKHggIT0gMCkgeyB4ICY9IHgtMTsgKytyOyB9XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG5mdW5jdGlvbiBibkJpdENvdW50KCkge1xudmFyIHIgPSAwLCB4ID0gdGhpcy5zJnRoaXMuRE07XG5mb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHIgKz0gY2JpdCh0aGlzLmRhdGFbaV1eeCk7XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuZnVuY3Rpb24gYm5UZXN0Qml0KG4pIHtcbnZhciBqID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuaWYoaiA+PSB0aGlzLnQpIHJldHVybih0aGlzLnMhPTApO1xucmV0dXJuKCh0aGlzLmRhdGFbal0mKDE8PChuJXRoaXMuREIpKSkhPTApO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgb3AgKDE8PG4pXG5mdW5jdGlvbiBibnBDaGFuZ2VCaXQobixvcCkge1xudmFyIHIgPSBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobik7XG50aGlzLmJpdHdpc2VUbyhyLG9wLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxuZnVuY3Rpb24gYm5TZXRCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9vcik7IH1cblxuLy8ocHVibGljKSB0aGlzICYgfigxPDxuKVxuZnVuY3Rpb24gYm5DbGVhckJpdChuKSB7IHJldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX2FuZG5vdCk7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gKDE8PG4pXG5mdW5jdGlvbiBibkZsaXBCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF94b3IpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IHRoaXMgKyBhXG5mdW5jdGlvbiBibnBBZGRUbyhhLHIpIHtcbnZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbndoaWxlKGkgPCBtKSB7XG4gYyArPSB0aGlzLmRhdGFbaV0rYS5kYXRhW2ldO1xuIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuIGMgPj49IHRoaXMuREI7XG59XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBjICs9IGEucztcbiB3aGlsZShpIDwgdGhpcy50KSB7XG4gICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSB0aGlzLnM7XG59IGVsc2Uge1xuIGMgKz0gdGhpcy5zO1xuIHdoaWxlKGkgPCBhLnQpIHtcbiAgIGMgKz0gYS5kYXRhW2ldO1xuICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICBjID4+PSB0aGlzLkRCO1xuIH1cbiBjICs9IGEucztcbn1cbnIucyA9IChjPDApPy0xOjA7XG5pZihjID4gMCkgci5kYXRhW2krK10gPSBjO1xuZWxzZSBpZihjIDwgLTEpIHIuZGF0YVtpKytdID0gdGhpcy5EVitjO1xuci50ID0gaTtcbnIuY2xhbXAoKTtcbn1cblxuLy8ocHVibGljKSB0aGlzICsgYVxuZnVuY3Rpb24gYm5BZGQoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmFkZFRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAtIGFcbmZ1bmN0aW9uIGJuU3VidHJhY3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLnN1YlRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAqIGFcbmZ1bmN0aW9uIGJuTXVsdGlwbHkoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLm11bHRpcGx5VG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIC8gYVxuZnVuY3Rpb24gYm5EaXZpZGUoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmRpdlJlbVRvKGEscixudWxsKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzICUgYVxuZnVuY3Rpb24gYm5SZW1haW5kZXIoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmRpdlJlbVRvKGEsbnVsbCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSBbdGhpcy9hLHRoaXMlYV1cbmZ1bmN0aW9uIGJuRGl2aWRlQW5kUmVtYWluZGVyKGEpIHtcbnZhciBxID0gbmJpKCksIHIgPSBuYmkoKTtcbnRoaXMuZGl2UmVtVG8oYSxxLHIpO1xucmV0dXJuIG5ldyBBcnJheShxLHIpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG5mdW5jdGlvbiBibnBETXVsdGlwbHkobikge1xudGhpcy5kYXRhW3RoaXMudF0gPSB0aGlzLmFtKDAsbi0xLHRoaXMsMCwwLHRoaXMudCk7XG4rK3RoaXMudDtcbnRoaXMuY2xhbXAoKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXG5mdW5jdGlvbiBibnBEQWRkT2Zmc2V0KG4sdykge1xuaWYobiA9PSAwKSByZXR1cm47XG53aGlsZSh0aGlzLnQgPD0gdykgdGhpcy5kYXRhW3RoaXMudCsrXSA9IDA7XG50aGlzLmRhdGFbd10gKz0gbjtcbndoaWxlKHRoaXMuZGF0YVt3XSA+PSB0aGlzLkRWKSB7XG4gdGhpcy5kYXRhW3ddIC09IHRoaXMuRFY7XG4gaWYoKyt3ID49IHRoaXMudCkgdGhpcy5kYXRhW3RoaXMudCsrXSA9IDA7XG4gKyt0aGlzLmRhdGFbd107XG59XG59XG5cbi8vQSBcIm51bGxcIiByZWR1Y2VyXG5mdW5jdGlvbiBOdWxsRXhwKCkge31cbmZ1bmN0aW9uIG5Ob3AoeCkgeyByZXR1cm4geDsgfVxuZnVuY3Rpb24gbk11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB9XG5mdW5jdGlvbiBuU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IH1cblxuTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IG5Ob3A7XG5OdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG87XG5OdWxsRXhwLnByb3RvdHlwZS5zcXJUbyA9IG5TcXJUbztcblxuLy8ocHVibGljKSB0aGlzXmVcbmZ1bmN0aW9uIGJuUG93KGUpIHsgcmV0dXJuIHRoaXMuZXhwKGUsbmV3IE51bGxFeHAoKSk7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4vL1widGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5TG93ZXJUbyhhLG4scikge1xudmFyIGkgPSBNYXRoLm1pbih0aGlzLnQrYS50LG4pO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuci50ID0gaTtcbndoaWxlKGkgPiAwKSByLmRhdGFbLS1pXSA9IDA7XG52YXIgajtcbmZvcihqID0gci50LXRoaXMudDsgaSA8IGo7ICsraSkgci5kYXRhW2krdGhpcy50XSA9IHRoaXMuYW0oMCxhLmRhdGFbaV0scixpLDAsdGhpcy50KTtcbmZvcihqID0gTWF0aC5taW4oYS50LG4pOyBpIDwgajsgKytpKSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLG4taSk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgciA9IFwidGhpcyAqIGFcIiB3aXRob3V0IGxvd2VyIG4gd29yZHMsIG4gPiAwXG4vL1widGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLG4scikge1xuLS1uO1xudmFyIGkgPSByLnQgPSB0aGlzLnQrYS50LW47XG5yLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG53aGlsZSgtLWkgPj0gMCkgci5kYXRhW2ldID0gMDtcbmZvcihpID0gTWF0aC5tYXgobi10aGlzLnQsMCk7IGkgPCBhLnQ7ICsraSlcbiByLmRhdGFbdGhpcy50K2ktbl0gPSB0aGlzLmFtKG4taSxhLmRhdGFbaV0sciwwLDAsdGhpcy50K2ktbik7XG5yLmNsYW1wKCk7XG5yLmRyU2hpZnRUbygxLHIpO1xufVxuXG4vL0JhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbmZ1bmN0aW9uIEJhcnJldHQobSkge1xuLy8gc2V0dXAgQmFycmV0dFxudGhpcy5yMiA9IG5iaSgpO1xudGhpcy5xMyA9IG5iaSgpO1xuQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIqbS50LHRoaXMucjIpO1xudGhpcy5tdSA9IHRoaXMucjIuZGl2aWRlKG0pO1xudGhpcy5tID0gbTtcbn1cblxuZnVuY3Rpb24gYmFycmV0dENvbnZlcnQoeCkge1xuaWYoeC5zIDwgMCB8fCB4LnQgPiAyKnRoaXMubS50KSByZXR1cm4geC5tb2QodGhpcy5tKTtcbmVsc2UgaWYoeC5jb21wYXJlVG8odGhpcy5tKSA8IDApIHJldHVybiB4O1xuZWxzZSB7IHZhciByID0gbmJpKCk7IHguY29weVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgcmV0dXJuIHI7IH1cbn1cblxuZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KSB7IHJldHVybiB4OyB9XG5cbi8veCA9IHggbW9kIG0gKEhBQyAxNC40MilcbmZ1bmN0aW9uIGJhcnJldHRSZWR1Y2UoeCkge1xueC5kclNoaWZ0VG8odGhpcy5tLnQtMSx0aGlzLnIyKTtcbmlmKHgudCA+IHRoaXMubS50KzEpIHsgeC50ID0gdGhpcy5tLnQrMTsgeC5jbGFtcCgpOyB9XG50aGlzLm11Lm11bHRpcGx5VXBwZXJUbyh0aGlzLnIyLHRoaXMubS50KzEsdGhpcy5xMyk7XG50aGlzLm0ubXVsdGlwbHlMb3dlclRvKHRoaXMucTMsdGhpcy5tLnQrMSx0aGlzLnIyKTtcbndoaWxlKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkgeC5kQWRkT2Zmc2V0KDEsdGhpcy5tLnQrMSk7XG54LnN1YlRvKHRoaXMucjIseCk7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vL3IgPSB4XjIgbW9kIG07IHggIT0gclxuZnVuY3Rpb24gYmFycmV0dFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4vL3IgPSB4KnkgbW9kIG07IHgseSAhPSByXG5mdW5jdGlvbiBiYXJyZXR0TXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBiYXJyZXR0Q29udmVydDtcbkJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBiYXJyZXR0TXVsVG87XG5CYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUbztcblxuLy8ocHVibGljKSB0aGlzXmUgJSBtIChIQUMgMTQuODUpXG5mdW5jdGlvbiBibk1vZFBvdyhlLG0pIHtcbnZhciBpID0gZS5iaXRMZW5ndGgoKSwgaywgciA9IG5idigxKSwgejtcbmlmKGkgPD0gMCkgcmV0dXJuIHI7XG5lbHNlIGlmKGkgPCAxOCkgayA9IDE7XG5lbHNlIGlmKGkgPCA0OCkgayA9IDM7XG5lbHNlIGlmKGkgPCAxNDQpIGsgPSA0O1xuZWxzZSBpZihpIDwgNzY4KSBrID0gNTtcbmVsc2UgayA9IDY7XG5pZihpIDwgOClcbiB6ID0gbmV3IENsYXNzaWMobSk7XG5lbHNlIGlmKG0uaXNFdmVuKCkpXG4geiA9IG5ldyBCYXJyZXR0KG0pO1xuZWxzZVxuIHogPSBuZXcgTW9udGdvbWVyeShtKTtcblxuLy8gcHJlY29tcHV0YXRpb25cbnZhciBnID0gbmV3IEFycmF5KCksIG4gPSAzLCBrMSA9IGstMSwga20gPSAoMTw8ayktMTtcbmdbMV0gPSB6LmNvbnZlcnQodGhpcyk7XG5pZihrID4gMSkge1xuIHZhciBnMiA9IG5iaSgpO1xuIHouc3FyVG8oZ1sxXSxnMik7XG4gd2hpbGUobiA8PSBrbSkge1xuICAgZ1tuXSA9IG5iaSgpO1xuICAgei5tdWxUbyhnMixnW24tMl0sZ1tuXSk7XG4gICBuICs9IDI7XG4gfVxufVxuXG52YXIgaiA9IGUudC0xLCB3LCBpczEgPSB0cnVlLCByMiA9IG5iaSgpLCB0O1xuaSA9IG5iaXRzKGUuZGF0YVtqXSktMTtcbndoaWxlKGogPj0gMCkge1xuIGlmKGkgPj0gazEpIHcgPSAoZS5kYXRhW2pdPj4oaS1rMSkpJmttO1xuIGVsc2Uge1xuICAgdyA9IChlLmRhdGFbal0mKCgxPDwoaSsxKSktMSkpPDwoazEtaSk7XG4gICBpZihqID4gMCkgdyB8PSBlLmRhdGFbai0xXT4+KHRoaXMuREIraS1rMSk7XG4gfVxuXG4gbiA9IGs7XG4gd2hpbGUoKHcmMSkgPT0gMCkgeyB3ID4+PSAxOyAtLW47IH1cbiBpZigoaSAtPSBuKSA8IDApIHsgaSArPSB0aGlzLkRCOyAtLWo7IH1cbiBpZihpczEpIHsgIC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcbiAgIGdbd10uY29weVRvKHIpO1xuICAgaXMxID0gZmFsc2U7XG4gfSBlbHNlIHtcbiAgIHdoaWxlKG4gPiAxKSB7IHouc3FyVG8ocixyMik7IHouc3FyVG8ocjIscik7IG4gLT0gMjsgfVxuICAgaWYobiA+IDApIHouc3FyVG8ocixyMik7IGVsc2UgeyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7IH1cbiAgIHoubXVsVG8ocjIsZ1t3XSxyKTtcbiB9XG5cbiB3aGlsZShqID49IDAgJiYgKGUuZGF0YVtqXSYoMTw8aSkpID09IDApIHtcbiAgIHouc3FyVG8ocixyMik7IHQgPSByOyByID0gcjI7IHIyID0gdDtcbiAgIGlmKC0taSA8IDApIHsgaSA9IHRoaXMuREItMTsgLS1qOyB9XG4gfVxufVxucmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyhwdWJsaWMpIGdjZCh0aGlzLGEpIChIQUMgMTQuNTQpXG5mdW5jdGlvbiBibkdDRChhKSB7XG52YXIgeCA9ICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzLmNsb25lKCk7XG52YXIgeSA9IChhLnM8MCk/YS5uZWdhdGUoKTphLmNsb25lKCk7XG5pZih4LmNvbXBhcmVUbyh5KSA8IDApIHsgdmFyIHQgPSB4OyB4ID0geTsgeSA9IHQ7IH1cbnZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKSwgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG5pZihnIDwgMCkgcmV0dXJuIHg7XG5pZihpIDwgZykgZyA9IGk7XG5pZihnID4gMCkge1xuIHguclNoaWZ0VG8oZyx4KTtcbiB5LnJTaGlmdFRvKGcseSk7XG59XG53aGlsZSh4LnNpZ251bSgpID4gMCkge1xuIGlmKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB4LnJTaGlmdFRvKGkseCk7XG4gaWYoKGkgPSB5LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHkuclNoaWZ0VG8oaSx5KTtcbiBpZih4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICB4LnN1YlRvKHkseCk7XG4gICB4LnJTaGlmdFRvKDEseCk7XG4gfSBlbHNlIHtcbiAgIHkuc3ViVG8oeCx5KTtcbiAgIHkuclNoaWZ0VG8oMSx5KTtcbiB9XG59XG5pZihnID4gMCkgeS5sU2hpZnRUbyhnLHkpO1xucmV0dXJuIHk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XG5mdW5jdGlvbiBibnBNb2RJbnQobikge1xuaWYobiA8PSAwKSByZXR1cm4gMDtcbnZhciBkID0gdGhpcy5EViVuLCByID0gKHRoaXMuczwwKT9uLTE6MDtcbmlmKHRoaXMudCA+IDApXG4gaWYoZCA9PSAwKSByID0gdGhpcy5kYXRhWzBdJW47XG4gZWxzZSBmb3IodmFyIGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIgPSAoZCpyK3RoaXMuZGF0YVtpXSklbjtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIDEvdGhpcyAlIG0gKEhBQyAxNC42MSlcbmZ1bmN0aW9uIGJuTW9kSW52ZXJzZShtKSB7XG52YXIgYWMgPSBtLmlzRXZlbigpO1xuaWYoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbnZhciB1ID0gbS5jbG9uZSgpLCB2ID0gdGhpcy5jbG9uZSgpO1xudmFyIGEgPSBuYnYoMSksIGIgPSBuYnYoMCksIGMgPSBuYnYoMCksIGQgPSBuYnYoMSk7XG53aGlsZSh1LnNpZ251bSgpICE9IDApIHtcbiB3aGlsZSh1LmlzRXZlbigpKSB7XG4gICB1LnJTaGlmdFRvKDEsdSk7XG4gICBpZihhYykge1xuICAgICBpZighYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkgeyBhLmFkZFRvKHRoaXMsYSk7IGIuc3ViVG8obSxiKTsgfVxuICAgICBhLnJTaGlmdFRvKDEsYSk7XG4gICB9IGVsc2UgaWYoIWIuaXNFdmVuKCkpIGIuc3ViVG8obSxiKTtcbiAgIGIuclNoaWZ0VG8oMSxiKTtcbiB9XG4gd2hpbGUodi5pc0V2ZW4oKSkge1xuICAgdi5yU2hpZnRUbygxLHYpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWMuaXNFdmVuKCkgfHwgIWQuaXNFdmVuKCkpIHsgYy5hZGRUbyh0aGlzLGMpOyBkLnN1YlRvKG0sZCk7IH1cbiAgICAgYy5yU2hpZnRUbygxLGMpO1xuICAgfSBlbHNlIGlmKCFkLmlzRXZlbigpKSBkLnN1YlRvKG0sZCk7XG4gICBkLnJTaGlmdFRvKDEsZCk7XG4gfVxuIGlmKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgIHUuc3ViVG8odix1KTtcbiAgIGlmKGFjKSBhLnN1YlRvKGMsYSk7XG4gICBiLnN1YlRvKGQsYik7XG4gfSBlbHNlIHtcbiAgIHYuc3ViVG8odSx2KTtcbiAgIGlmKGFjKSBjLnN1YlRvKGEsYyk7XG4gICBkLnN1YlRvKGIsZCk7XG4gfVxufVxuaWYodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG5pZihkLmNvbXBhcmVUbyhtKSA+PSAwKSByZXR1cm4gZC5zdWJ0cmFjdChtKTtcbmlmKGQuc2lnbnVtKCkgPCAwKSBkLmFkZFRvKG0sZCk7IGVsc2UgcmV0dXJuIGQ7XG5pZihkLnNpZ251bSgpIDwgMCkgcmV0dXJuIGQuYWRkKG0pOyBlbHNlIHJldHVybiBkO1xufVxuXG52YXIgbG93cHJpbWVzID0gWzIsMyw1LDcsMTEsMTMsMTcsMTksMjMsMjksMzEsMzcsNDEsNDMsNDcsNTMsNTksNjEsNjcsNzEsNzMsNzksODMsODksOTcsMTAxLDEwMywxMDcsMTA5LDExMywxMjcsMTMxLDEzNywxMzksMTQ5LDE1MSwxNTcsMTYzLDE2NywxNzMsMTc5LDE4MSwxOTEsMTkzLDE5NywxOTksMjExLDIyMywyMjcsMjI5LDIzMywyMzksMjQxLDI1MSwyNTcsMjYzLDI2OSwyNzEsMjc3LDI4MSwyODMsMjkzLDMwNywzMTEsMzEzLDMxNywzMzEsMzM3LDM0NywzNDksMzUzLDM1OSwzNjcsMzczLDM3OSwzODMsMzg5LDM5Nyw0MDEsNDA5LDQxOSw0MjEsNDMxLDQzMyw0MzksNDQzLDQ0OSw0NTcsNDYxLDQ2Myw0NjcsNDc5LDQ4Nyw0OTEsNDk5LDUwMyw1MDldO1xudmFyIGxwbGltID0gKDE8PDI2KS9sb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aC0xXTtcblxuLy8ocHVibGljKSB0ZXN0IHByaW1hbGl0eSB3aXRoIGNlcnRhaW50eSA+PSAxLS41XnRcbmZ1bmN0aW9uIGJuSXNQcm9iYWJsZVByaW1lKHQpIHtcbnZhciBpLCB4ID0gdGhpcy5hYnMoKTtcbmlmKHgudCA9PSAxICYmIHguZGF0YVswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aC0xXSkge1xuIGZvcihpID0gMDsgaSA8IGxvd3ByaW1lcy5sZW5ndGg7ICsraSlcbiAgIGlmKHguZGF0YVswXSA9PSBsb3dwcmltZXNbaV0pIHJldHVybiB0cnVlO1xuIHJldHVybiBmYWxzZTtcbn1cbmlmKHguaXNFdmVuKCkpIHJldHVybiBmYWxzZTtcbmkgPSAxO1xud2hpbGUoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiB2YXIgbSA9IGxvd3ByaW1lc1tpXSwgaiA9IGkrMTtcbiB3aGlsZShqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIG0gKj0gbG93cHJpbWVzW2orK107XG4gbSA9IHgubW9kSW50KG0pO1xuIHdoaWxlKGkgPCBqKSBpZihtJWxvd3ByaW1lc1tpKytdID09IDApIHJldHVybiBmYWxzZTtcbn1cbnJldHVybiB4Lm1pbGxlclJhYmluKHQpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRydWUgaWYgcHJvYmFibHkgcHJpbWUgKEhBQyA0LjI0LCBNaWxsZXItUmFiaW4pXG5mdW5jdGlvbiBibnBNaWxsZXJSYWJpbih0KSB7XG52YXIgbjEgPSB0aGlzLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbnZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KCk7XG5pZihrIDw9IDApIHJldHVybiBmYWxzZTtcbnZhciByID0gbjEuc2hpZnRSaWdodChrKTtcbnZhciBwcm5nID0gYm5HZXRQcm5nKCk7XG52YXIgYTtcbmZvcih2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAvLyBzZWxlY3Qgd2l0bmVzcyAnYScgYXQgcmFuZG9tIGZyb20gYmV0d2VlbiAxIGFuZCBuMVxuIGRvIHtcbiAgIGEgPSBuZXcgQmlnSW50ZWdlcih0aGlzLmJpdExlbmd0aCgpLCBwcm5nKTtcbiB9XG4gd2hpbGUoYS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpIDw9IDAgfHwgYS5jb21wYXJlVG8objEpID49IDApO1xuIHZhciB5ID0gYS5tb2RQb3cocix0aGlzKTtcbiBpZih5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgdmFyIGogPSAxO1xuICAgd2hpbGUoaisrIDwgayAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICB5ID0geS5tb2RQb3dJbnQoMix0aGlzKTtcbiAgICAgaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGlmKHkuY29tcGFyZVRvKG4xKSAhPSAwKSByZXR1cm4gZmFsc2U7XG4gfVxufVxucmV0dXJuIHRydWU7XG59XG5cbi8vIGdldCBwc2V1ZG8gcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbmZ1bmN0aW9uIGJuR2V0UHJuZygpIHtcbiAgLy8gY3JlYXRlIHBybmcgd2l0aCBhcGkgdGhhdCBtYXRjaGVzIEJpZ0ludGVnZXIgc2VjdXJlIHJhbmRvbVxuICByZXR1cm4ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4W2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vcHJvdGVjdGVkXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBibnBDaHVua1NpemU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBibnBGcm9tTnVtYmVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gYm5wQml0d2lzZVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gYm5wQ2hhbmdlQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBibnBBZGRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRNdWx0aXBseSA9IGJucERNdWx0aXBseTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlMb3dlclRvID0gYm5wTXVsdGlwbHlMb3dlclRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW50ID0gYm5wTW9kSW50O1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpbjtcblxuLy9wdWJsaWNcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gYm5DbG9uZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gYm5JbnRWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJ5dGVWYWx1ZSA9IGJuQnl0ZVZhbHVlO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNpZ251bSA9IGJuU2lnTnVtO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBiblRvQnl0ZUFycmF5O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gYm5FcXVhbHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5taW4gPSBibk1pbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1heCA9IGJuTWF4O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gYm5BbmQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGJuT3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBiblhvcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZE5vdCA9IGJuQW5kTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gYm5Ob3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBiblNoaWZ0TGVmdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBiblNoaWZ0UmlnaHQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gYm5CaXRDb3VudDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRlc3RCaXQgPSBiblRlc3RCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gYm5DbGVhckJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmZsaXBCaXQgPSBibkZsaXBCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gYm5TdWJ0cmFjdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gYm5NdWx0aXBseTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xuQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gYm5SZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGVBbmRSZW1haW5kZXIgPSBibkRpdmlkZUFuZFJlbWFpbmRlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGJuTW9kUG93O1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IGJuTW9kSW52ZXJzZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGJuUG93O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gYm5HQ0Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZTtcblxuLy9CaWdJbnRlZ2VyIGludGVyZmFjZXMgbm90IGltcGxlbWVudGVkIGluIGpzYm46XG5cbi8vQmlnSW50ZWdlcihpbnQgc2lnbnVtLCBieXRlW10gbWFnbml0dWRlKVxuLy9kb3VibGUgZG91YmxlVmFsdWUoKVxuLy9mbG9hdCBmbG9hdFZhbHVlKClcbi8vaW50IGhhc2hDb2RlKClcbi8vbG9uZyBsb25nVmFsdWUoKVxuLy9zdGF0aWMgQmlnSW50ZWdlciB2YWx1ZU9mKGxvbmcgdmFsKVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJqc2JuIiwiZGJpdHMiLCJjYW5hcnkiLCJqX2xtIiwiQmlnSW50ZWdlciIsImEiLCJiIiwiYyIsImRhdGEiLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsIm5iaSIsImFtMSIsImkiLCJ4IiwidyIsImoiLCJuIiwidiIsIk1hdGgiLCJmbG9vciIsImFtMiIsInhsIiwieGgiLCJsIiwiaCIsIm0iLCJhbTMiLCJuYXZpZ2F0b3IiLCJwcm90b3R5cGUiLCJhbSIsImFwcE5hbWUiLCJEQiIsIkRNIiwiRFYiLCJCSV9GUCIsIkZWIiwicG93IiwiRjEiLCJGMiIsIkJJX1JNIiwiQklfUkMiLCJBcnJheSIsInJyIiwidnYiLCJjaGFyQ29kZUF0IiwiaW50MmNoYXIiLCJjaGFyQXQiLCJpbnRBdCIsInMiLCJibnBDb3B5VG8iLCJyIiwidCIsImJucEZyb21JbnQiLCJuYnYiLCJmcm9tSW50IiwiYm5wRnJvbVN0cmluZyIsImsiLCJmcm9tUmFkaXgiLCJsZW5ndGgiLCJtaSIsInNoIiwiY2xhbXAiLCJaRVJPIiwic3ViVG8iLCJibnBDbGFtcCIsImJuVG9TdHJpbmciLCJuZWdhdGUiLCJ0b1N0cmluZyIsInRvUmFkaXgiLCJrbSIsImQiLCJwIiwiYm5OZWdhdGUiLCJibkFicyIsImJuQ29tcGFyZVRvIiwibmJpdHMiLCJibkJpdExlbmd0aCIsImJucERMU2hpZnRUbyIsImJucERSU2hpZnRUbyIsIm1heCIsImJucExTaGlmdFRvIiwiYnMiLCJjYnMiLCJibSIsImRzIiwiYm5wUlNoaWZ0VG8iLCJibnBTdWJUbyIsIm1pbiIsImJucE11bHRpcGx5VG8iLCJhYnMiLCJ5IiwiYm5wU3F1YXJlVG8iLCJibnBEaXZSZW1UbyIsInEiLCJwbSIsInB0IiwiY29weVRvIiwidHMiLCJtcyIsIm5zaCIsImxTaGlmdFRvIiwieXMiLCJ5MCIsInl0IiwiZDEiLCJkMiIsImUiLCJkbFNoaWZ0VG8iLCJjb21wYXJlVG8iLCJPTkUiLCJxZCIsImRyU2hpZnRUbyIsInJTaGlmdFRvIiwiYm5Nb2QiLCJkaXZSZW1UbyIsIkNsYXNzaWMiLCJjQ29udmVydCIsIm1vZCIsImNSZXZlcnQiLCJjUmVkdWNlIiwiY011bFRvIiwibXVsdGlwbHlUbyIsInJlZHVjZSIsImNTcXJUbyIsInNxdWFyZVRvIiwiY29udmVydCIsInJldmVydCIsIm11bFRvIiwic3FyVG8iLCJibnBJbnZEaWdpdCIsIk1vbnRnb21lcnkiLCJtcCIsImludkRpZ2l0IiwibXBsIiwibXBoIiwidW0iLCJtdDIiLCJtb250Q29udmVydCIsIm1vbnRSZXZlcnQiLCJtb250UmVkdWNlIiwidTAiLCJtb250U3FyVG8iLCJtb250TXVsVG8iLCJibnBJc0V2ZW4iLCJibnBFeHAiLCJ6IiwicjIiLCJnIiwiYm5Nb2RQb3dJbnQiLCJpc0V2ZW4iLCJleHAiLCJiaXRMZW5ndGgiLCJtb2RQb3dJbnQiLCJibkNsb25lIiwiYm5JbnRWYWx1ZSIsImJuQnl0ZVZhbHVlIiwiYm5TaG9ydFZhbHVlIiwiYm5wQ2h1bmtTaXplIiwiTE4yIiwibG9nIiwiYm5TaWdOdW0iLCJibnBUb1JhZGl4Iiwic2lnbnVtIiwiY3MiLCJjaHVua1NpemUiLCJpbnRWYWx1ZSIsInN1YnN0ciIsImJucEZyb21SYWRpeCIsImRNdWx0aXBseSIsImRBZGRPZmZzZXQiLCJibnBGcm9tTnVtYmVyIiwidGVzdEJpdCIsImJpdHdpc2VUbyIsInNoaWZ0TGVmdCIsIm9wX29yIiwiaXNQcm9iYWJsZVByaW1lIiwibmV4dEJ5dGVzIiwiYm5Ub0J5dGVBcnJheSIsImJuRXF1YWxzIiwiYm5NaW4iLCJibk1heCIsImJucEJpdHdpc2VUbyIsIm9wIiwiZiIsIm9wX2FuZCIsImJuQW5kIiwiYm5PciIsIm9wX3hvciIsImJuWG9yIiwib3BfYW5kbm90IiwiYm5BbmROb3QiLCJibk5vdCIsImJuU2hpZnRMZWZ0IiwiYm5TaGlmdFJpZ2h0IiwibGJpdCIsImJuR2V0TG93ZXN0U2V0Qml0IiwiY2JpdCIsImJuQml0Q291bnQiLCJiblRlc3RCaXQiLCJibnBDaGFuZ2VCaXQiLCJiblNldEJpdCIsImNoYW5nZUJpdCIsImJuQ2xlYXJCaXQiLCJibkZsaXBCaXQiLCJibnBBZGRUbyIsImJuQWRkIiwiYWRkVG8iLCJiblN1YnRyYWN0IiwiYm5NdWx0aXBseSIsImJuRGl2aWRlIiwiYm5SZW1haW5kZXIiLCJibkRpdmlkZUFuZFJlbWFpbmRlciIsImJucERNdWx0aXBseSIsImJucERBZGRPZmZzZXQiLCJOdWxsRXhwIiwibk5vcCIsIm5NdWxUbyIsIm5TcXJUbyIsImJuUG93IiwiYm5wTXVsdGlwbHlMb3dlclRvIiwiYm5wTXVsdGlwbHlVcHBlclRvIiwiQmFycmV0dCIsInEzIiwibXUiLCJkaXZpZGUiLCJiYXJyZXR0Q29udmVydCIsImJhcnJldHRSZXZlcnQiLCJiYXJyZXR0UmVkdWNlIiwibXVsdGlwbHlVcHBlclRvIiwibXVsdGlwbHlMb3dlclRvIiwiYmFycmV0dFNxclRvIiwiYmFycmV0dE11bFRvIiwiYm5Nb2RQb3ciLCJrMSIsImcyIiwiaXMxIiwiYm5HQ0QiLCJjbG9uZSIsImdldExvd2VzdFNldEJpdCIsImJucE1vZEludCIsImJuTW9kSW52ZXJzZSIsImFjIiwidSIsInN1YnRyYWN0IiwiYWRkIiwibG93cHJpbWVzIiwibHBsaW0iLCJibklzUHJvYmFibGVQcmltZSIsIm1vZEludCIsIm1pbGxlclJhYmluIiwiYm5wTWlsbGVyUmFiaW4iLCJuMSIsInNoaWZ0UmlnaHQiLCJwcm5nIiwiYm5HZXRQcm5nIiwibW9kUG93IiwicmFuZG9tIiwiYnl0ZVZhbHVlIiwic2hvcnRWYWx1ZSIsInRvQnl0ZUFycmF5IiwiZXF1YWxzIiwiYW5kIiwib3IiLCJ4b3IiLCJhbmROb3QiLCJub3QiLCJiaXRDb3VudCIsInNldEJpdCIsImNsZWFyQml0IiwiZmxpcEJpdCIsIm11bHRpcGx5IiwicmVtYWluZGVyIiwiZGl2aWRlQW5kUmVtYWluZGVyIiwibW9kSW52ZXJzZSIsImdjZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/jsbn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/md.js":
/*!*******************************************!*\
  !*** ./node_modules/node-forge/lib/md.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Node.js module for Forge message digests.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2017 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\nmodule.exports = forge.md = forge.md || {};\nforge.md.algorithms = forge.md.algorithms || {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFFcEJDLE9BQU9DLE9BQU8sR0FBR0gsTUFBTUksRUFBRSxHQUFHSixNQUFNSSxFQUFFLElBQUksQ0FBQztBQUN6Q0osTUFBTUksRUFBRSxDQUFDQyxVQUFVLEdBQUdMLE1BQU1JLEVBQUUsQ0FBQ0MsVUFBVSxJQUFJLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZC5qcz8yMDQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1lc3NhZ2UgZGlnZXN0cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1kID0gZm9yZ2UubWQgfHwge307XG5mb3JnZS5tZC5hbGdvcml0aG1zID0gZm9yZ2UubWQuYWxnb3JpdGhtcyB8fCB7fTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwibWQiLCJhbGdvcml0aG1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/oids.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/oids.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Object IDs for ASN.1.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\nforge.pki = forge.pki || {};\nvar oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};\n// set id to name mapping and name to id mapping\nfunction _IN(id, name) {\n    oids[id] = name;\n    oids[name] = id;\n}\n// set id to name mapping only\nfunction _I_(id, name) {\n    oids[id] = name;\n}\n// algorithm OIDs\n_IN(\"1.2.840.113549.1.1.1\", \"rsaEncryption\");\n// Note: md2 & md4 not implemented\n//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');\n//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');\n_IN(\"1.2.840.113549.1.1.4\", \"md5WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.5\", \"sha1WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.7\", \"RSAES-OAEP\");\n_IN(\"1.2.840.113549.1.1.8\", \"mgf1\");\n_IN(\"1.2.840.113549.1.1.9\", \"pSpecified\");\n_IN(\"1.2.840.113549.1.1.10\", \"RSASSA-PSS\");\n_IN(\"1.2.840.113549.1.1.11\", \"sha256WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.12\", \"sha384WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.13\", \"sha512WithRSAEncryption\");\n// Edwards-curve Digital Signature Algorithm (EdDSA) Ed25519\n_IN(\"1.3.101.112\", \"EdDSA25519\");\n_IN(\"1.2.840.10040.4.3\", \"dsa-with-sha1\");\n_IN(\"1.3.14.3.2.7\", \"desCBC\");\n_IN(\"1.3.14.3.2.26\", \"sha1\");\n// Deprecated equivalent of sha1WithRSAEncryption\n_IN(\"1.3.14.3.2.29\", \"sha1WithRSASignature\");\n_IN(\"2.16.840.1.101.3.4.2.1\", \"sha256\");\n_IN(\"2.16.840.1.101.3.4.2.2\", \"sha384\");\n_IN(\"2.16.840.1.101.3.4.2.3\", \"sha512\");\n_IN(\"2.16.840.1.101.3.4.2.4\", \"sha224\");\n_IN(\"2.16.840.1.101.3.4.2.5\", \"sha512-224\");\n_IN(\"2.16.840.1.101.3.4.2.6\", \"sha512-256\");\n_IN(\"1.2.840.113549.2.2\", \"md2\");\n_IN(\"1.2.840.113549.2.5\", \"md5\");\n// pkcs#7 content types\n_IN(\"1.2.840.113549.1.7.1\", \"data\");\n_IN(\"1.2.840.113549.1.7.2\", \"signedData\");\n_IN(\"1.2.840.113549.1.7.3\", \"envelopedData\");\n_IN(\"1.2.840.113549.1.7.4\", \"signedAndEnvelopedData\");\n_IN(\"1.2.840.113549.1.7.5\", \"digestedData\");\n_IN(\"1.2.840.113549.1.7.6\", \"encryptedData\");\n// pkcs#9 oids\n_IN(\"1.2.840.113549.1.9.1\", \"emailAddress\");\n_IN(\"1.2.840.113549.1.9.2\", \"unstructuredName\");\n_IN(\"1.2.840.113549.1.9.3\", \"contentType\");\n_IN(\"1.2.840.113549.1.9.4\", \"messageDigest\");\n_IN(\"1.2.840.113549.1.9.5\", \"signingTime\");\n_IN(\"1.2.840.113549.1.9.6\", \"counterSignature\");\n_IN(\"1.2.840.113549.1.9.7\", \"challengePassword\");\n_IN(\"1.2.840.113549.1.9.8\", \"unstructuredAddress\");\n_IN(\"1.2.840.113549.1.9.14\", \"extensionRequest\");\n_IN(\"1.2.840.113549.1.9.20\", \"friendlyName\");\n_IN(\"1.2.840.113549.1.9.21\", \"localKeyId\");\n_IN(\"1.2.840.113549.1.9.22.1\", \"x509Certificate\");\n// pkcs#12 safe bags\n_IN(\"1.2.840.113549.1.12.10.1.1\", \"keyBag\");\n_IN(\"1.2.840.113549.1.12.10.1.2\", \"pkcs8ShroudedKeyBag\");\n_IN(\"1.2.840.113549.1.12.10.1.3\", \"certBag\");\n_IN(\"1.2.840.113549.1.12.10.1.4\", \"crlBag\");\n_IN(\"1.2.840.113549.1.12.10.1.5\", \"secretBag\");\n_IN(\"1.2.840.113549.1.12.10.1.6\", \"safeContentsBag\");\n// password-based-encryption for pkcs#12\n_IN(\"1.2.840.113549.1.5.13\", \"pkcs5PBES2\");\n_IN(\"1.2.840.113549.1.5.12\", \"pkcs5PBKDF2\");\n_IN(\"1.2.840.113549.1.12.1.1\", \"pbeWithSHAAnd128BitRC4\");\n_IN(\"1.2.840.113549.1.12.1.2\", \"pbeWithSHAAnd40BitRC4\");\n_IN(\"1.2.840.113549.1.12.1.3\", \"pbeWithSHAAnd3-KeyTripleDES-CBC\");\n_IN(\"1.2.840.113549.1.12.1.4\", \"pbeWithSHAAnd2-KeyTripleDES-CBC\");\n_IN(\"1.2.840.113549.1.12.1.5\", \"pbeWithSHAAnd128BitRC2-CBC\");\n_IN(\"1.2.840.113549.1.12.1.6\", \"pbewithSHAAnd40BitRC2-CBC\");\n// hmac OIDs\n_IN(\"1.2.840.113549.2.7\", \"hmacWithSHA1\");\n_IN(\"1.2.840.113549.2.8\", \"hmacWithSHA224\");\n_IN(\"1.2.840.113549.2.9\", \"hmacWithSHA256\");\n_IN(\"1.2.840.113549.2.10\", \"hmacWithSHA384\");\n_IN(\"1.2.840.113549.2.11\", \"hmacWithSHA512\");\n// symmetric key algorithm oids\n_IN(\"1.2.840.113549.3.7\", \"des-EDE3-CBC\");\n_IN(\"2.16.840.1.101.3.4.1.2\", \"aes128-CBC\");\n_IN(\"2.16.840.1.101.3.4.1.22\", \"aes192-CBC\");\n_IN(\"2.16.840.1.101.3.4.1.42\", \"aes256-CBC\");\n// certificate issuer/subject OIDs\n_IN(\"2.5.4.3\", \"commonName\");\n_IN(\"2.5.4.4\", \"surname\");\n_IN(\"2.5.4.5\", \"serialNumber\");\n_IN(\"2.5.4.6\", \"countryName\");\n_IN(\"2.5.4.7\", \"localityName\");\n_IN(\"2.5.4.8\", \"stateOrProvinceName\");\n_IN(\"2.5.4.9\", \"streetAddress\");\n_IN(\"2.5.4.10\", \"organizationName\");\n_IN(\"2.5.4.11\", \"organizationalUnitName\");\n_IN(\"2.5.4.12\", \"title\");\n_IN(\"2.5.4.13\", \"description\");\n_IN(\"2.5.4.15\", \"businessCategory\");\n_IN(\"2.5.4.17\", \"postalCode\");\n_IN(\"2.5.4.42\", \"givenName\");\n_IN(\"1.3.6.1.4.1.311.60.2.1.2\", \"jurisdictionOfIncorporationStateOrProvinceName\");\n_IN(\"1.3.6.1.4.1.311.60.2.1.3\", \"jurisdictionOfIncorporationCountryName\");\n// X.509 extension OIDs\n_IN(\"2.16.840.1.113730.1.1\", \"nsCertType\");\n_IN(\"2.16.840.1.113730.1.13\", \"nsComment\"); // deprecated in theory; still widely used\n_I_(\"2.5.29.1\", \"authorityKeyIdentifier\"); // deprecated, use .35\n_I_(\"2.5.29.2\", \"keyAttributes\"); // obsolete use .37 or .15\n_I_(\"2.5.29.3\", \"certificatePolicies\"); // deprecated, use .32\n_I_(\"2.5.29.4\", \"keyUsageRestriction\"); // obsolete use .37 or .15\n_I_(\"2.5.29.5\", \"policyMapping\"); // deprecated use .33\n_I_(\"2.5.29.6\", \"subtreesConstraint\"); // obsolete use .30\n_I_(\"2.5.29.7\", \"subjectAltName\"); // deprecated use .17\n_I_(\"2.5.29.8\", \"issuerAltName\"); // deprecated use .18\n_I_(\"2.5.29.9\", \"subjectDirectoryAttributes\");\n_I_(\"2.5.29.10\", \"basicConstraints\"); // deprecated use .19\n_I_(\"2.5.29.11\", \"nameConstraints\"); // deprecated use .30\n_I_(\"2.5.29.12\", \"policyConstraints\"); // deprecated use .36\n_I_(\"2.5.29.13\", \"basicConstraints\"); // deprecated use .19\n_IN(\"2.5.29.14\", \"subjectKeyIdentifier\");\n_IN(\"2.5.29.15\", \"keyUsage\");\n_I_(\"2.5.29.16\", \"privateKeyUsagePeriod\");\n_IN(\"2.5.29.17\", \"subjectAltName\");\n_IN(\"2.5.29.18\", \"issuerAltName\");\n_IN(\"2.5.29.19\", \"basicConstraints\");\n_I_(\"2.5.29.20\", \"cRLNumber\");\n_I_(\"2.5.29.21\", \"cRLReason\");\n_I_(\"2.5.29.22\", \"expirationDate\");\n_I_(\"2.5.29.23\", \"instructionCode\");\n_I_(\"2.5.29.24\", \"invalidityDate\");\n_I_(\"2.5.29.25\", \"cRLDistributionPoints\"); // deprecated use .31\n_I_(\"2.5.29.26\", \"issuingDistributionPoint\"); // deprecated use .28\n_I_(\"2.5.29.27\", \"deltaCRLIndicator\");\n_I_(\"2.5.29.28\", \"issuingDistributionPoint\");\n_I_(\"2.5.29.29\", \"certificateIssuer\");\n_I_(\"2.5.29.30\", \"nameConstraints\");\n_IN(\"2.5.29.31\", \"cRLDistributionPoints\");\n_IN(\"2.5.29.32\", \"certificatePolicies\");\n_I_(\"2.5.29.33\", \"policyMappings\");\n_I_(\"2.5.29.34\", \"policyConstraints\"); // deprecated use .36\n_IN(\"2.5.29.35\", \"authorityKeyIdentifier\");\n_I_(\"2.5.29.36\", \"policyConstraints\");\n_IN(\"2.5.29.37\", \"extKeyUsage\");\n_I_(\"2.5.29.46\", \"freshestCRL\");\n_I_(\"2.5.29.54\", \"inhibitAnyPolicy\");\n// extKeyUsage purposes\n_IN(\"1.3.6.1.4.1.11129.2.4.2\", \"timestampList\");\n_IN(\"1.3.6.1.5.5.7.1.1\", \"authorityInfoAccess\");\n_IN(\"1.3.6.1.5.5.7.3.1\", \"serverAuth\");\n_IN(\"1.3.6.1.5.5.7.3.2\", \"clientAuth\");\n_IN(\"1.3.6.1.5.5.7.3.3\", \"codeSigning\");\n_IN(\"1.3.6.1.5.5.7.3.4\", \"emailProtection\");\n_IN(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvb2lkcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQkQsTUFBTUUsR0FBRyxHQUFHRixNQUFNRSxHQUFHLElBQUksQ0FBQztBQUMxQixJQUFJQyxPQUFPQyxPQUFPQyxPQUFPLEdBQUdMLE1BQU1FLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHSCxNQUFNRyxJQUFJLEdBQUdILE1BQU1HLElBQUksSUFBSSxDQUFDO0FBRXpFLGdEQUFnRDtBQUNoRCxTQUFTRyxJQUFJQyxFQUFFLEVBQUVDLElBQUk7SUFDbkJMLElBQUksQ0FBQ0ksR0FBRyxHQUFHQztJQUNYTCxJQUFJLENBQUNLLEtBQUssR0FBR0Q7QUFDZjtBQUNBLDhCQUE4QjtBQUM5QixTQUFTRSxJQUFJRixFQUFFLEVBQUVDLElBQUk7SUFDbkJMLElBQUksQ0FBQ0ksR0FBRyxHQUFHQztBQUNiO0FBRUEsaUJBQWlCO0FBQ2pCRixJQUFJLHdCQUF3QjtBQUM1QixrQ0FBa0M7QUFDbEMsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0REEsSUFBSSx3QkFBd0I7QUFDNUJBLElBQUksd0JBQXdCO0FBQzVCQSxJQUFJLHdCQUF3QjtBQUM1QkEsSUFBSSx3QkFBd0I7QUFDNUJBLElBQUksd0JBQXdCO0FBQzVCQSxJQUFJLHlCQUF5QjtBQUM3QkEsSUFBSSx5QkFBeUI7QUFDN0JBLElBQUkseUJBQXlCO0FBQzdCQSxJQUFJLHlCQUF5QjtBQUM3Qiw0REFBNEQ7QUFDNURBLElBQUksZUFBZTtBQUVuQkEsSUFBSSxxQkFBcUI7QUFFekJBLElBQUksZ0JBQWdCO0FBRXBCQSxJQUFJLGlCQUFpQjtBQUNyQixpREFBaUQ7QUFDakRBLElBQUksaUJBQWlCO0FBQ3JCQSxJQUFJLDBCQUEwQjtBQUM5QkEsSUFBSSwwQkFBMEI7QUFDOUJBLElBQUksMEJBQTBCO0FBQzlCQSxJQUFJLDBCQUEwQjtBQUM5QkEs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SSxhQUFhO0FBQ2pCQSxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYTtBQUNqQkEsSUFBSSxhQUFhLDBCQUEwQixxQkFBcUI7QUFDaEVBLElBQUksYUFBYSw2QkFBNkIscUJBQXFCO0FBQ25FQSxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYTtBQUNqQkEsSUFBSSxhQUFhO0FBQ2pCQSxJQUFJLGFBQWE7QUFDakJILElBQUksYUFBYTtBQUNqQkEsSUFBSSxhQUFhO0FBQ2pCRyxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYSxzQkFBc0IscUJBQXFCO0FBQzVESCxJQUFJLGFBQWE7QUFDakJHLElBQUksYUFBYTtBQUNqQkgsSUFBSSxhQUFhO0FBQ2pCRyxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYTtBQUVqQix1QkFBdUI7QUFDdkJILElBQUksMkJBQTJCO0FBQy9CQSxJQUFJLHFCQUFxQjtBQUN6QkEsSUFBSSxxQkFBcUI7QUFDekJBLElBQUkscUJBQXFCO0FBQ3pCQSxJQUFJLHFCQUFxQjtBQUN6QkEsSUFBSSxxQkFBcUI7QUFDekJBLElBQUkscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvb2lkcy5qcz82YTJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2JqZWN0IElEcyBmb3IgQVNOLjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5cbmZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbnZhciBvaWRzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kub2lkcyA9IGZvcmdlLm9pZHMgPSBmb3JnZS5vaWRzIHx8IHt9O1xuXG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIGFuZCBuYW1lIHRvIGlkIG1hcHBpbmdcbmZ1bmN0aW9uIF9JTihpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG4gIG9pZHNbbmFtZV0gPSBpZDtcbn1cbi8vIHNldCBpZCB0byBuYW1lIG1hcHBpbmcgb25seVxuZnVuY3Rpb24gX0lfKGlkLCBuYW1lKSB7XG4gIG9pZHNbaWRdID0gbmFtZTtcbn1cblxuLy8gYWxnb3JpdGhtIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEnLCAncnNhRW5jcnlwdGlvbicpO1xuLy8gTm90ZTogbWQyICYgbWQ0IG5vdCBpbXBsZW1lbnRlZFxuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4yJywgJ21kMldpdGhSU0FFbmNyeXB0aW9uJyk7XG4vL19JTignMS4yLjg0MC4xMTM1NDkuMS4xLjMnLCAnbWQ0V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjQnLCAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjUnLCAnc2hhMVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS43JywgJ1JTQUVTLU9BRVAnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjgnLCAnbWdmMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuOScsICdwU3BlY2lmaWVkJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMCcsICdSU0FTU0EtUFNTJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMScsICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTInLCAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEzJywgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJyk7XG4vLyBFZHdhcmRzLWN1cnZlIERpZ2l0YWwgU2lnbmF0dXJlIEFsZ29yaXRobSAoRWREU0EpIEVkMjU1MTlcbl9JTignMS4zLjEwMS4xMTInLCAnRWREU0EyNTUxOScpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG4vLyBEZXByZWNhdGVkIGVxdWl2YWxlbnQgb2Ygc2hhMVdpdGhSU0FFbmNyeXB0aW9uXG5fSU4oJzEuMy4xNC4zLjIuMjknLCAnc2hhMVdpdGhSU0FTaWduYXR1cmUnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjIuMScsICdzaGEyNTYnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjIuMicsICdzaGEzODQnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjIuMycsICdzaGE1MTInKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjIuNCcsICdzaGEyMjQnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjIuNScsICdzaGE1MTItMjI0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjYnLCAnc2hhNTEyLTI1NicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjInLCAnbWQyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC40JywgJ3N1cm5hbWUnKTtcbl9JTignMi41LjQuNScsICdzZXJpYWxOdW1iZXInKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuOScsICdzdHJlZXRBZGRyZXNzJyk7XG5fSU4oJzIuNS40LjEwJywgJ29yZ2FuaXphdGlvbk5hbWUnKTtcbl9JTignMi41LjQuMTEnLCAnb3JnYW5pemF0aW9uYWxVbml0TmFtZScpO1xuX0lOKCcyLjUuNC4xMicsICd0aXRsZScpO1xuX0lOKCcyLjUuNC4xMycsICdkZXNjcmlwdGlvbicpO1xuX0lOKCcyLjUuNC4xNScsICdidXNpbmVzc0NhdGVnb3J5Jyk7XG5fSU4oJzIuNS40LjE3JywgJ3Bvc3RhbENvZGUnKTtcbl9JTignMi41LjQuNDInLCAnZ2l2ZW5OYW1lJyk7XG5fSU4oJzEuMy42LjEuNC4xLjMxMS42MC4yLjEuMicsICdqdXJpc2RpY3Rpb25PZkluY29ycG9yYXRpb25TdGF0ZU9yUHJvdmluY2VOYW1lJyk7XG5fSU4oJzEuMy42LjEuNC4xLjMxMS42MC4yLjEuMycsICdqdXJpc2RpY3Rpb25PZkluY29ycG9yYXRpb25Db3VudHJ5TmFtZScpO1xuXG4vLyBYLjUwOSBleHRlbnNpb24gT0lEc1xuX0lOKCcyLjE2Ljg0MC4xLjExMzczMC4xLjEnLCAnbnNDZXJ0VHlwZScpO1xuX0lOKCcyLjE2Ljg0MC4xLjExMzczMC4xLjEzJywgJ25zQ29tbWVudCcpOyAvLyBkZXByZWNhdGVkIGluIHRoZW9yeTsgc3RpbGwgd2lkZWx5IHVzZWRcbl9JXygnMi41LjI5LjEnLCAnYXV0aG9yaXR5S2V5SWRlbnRpZmllcicpOyAvLyBkZXByZWNhdGVkLCB1c2UgLjM1XG5fSV8oJzIuNS4yOS4yJywgJ2tleUF0dHJpYnV0ZXMnKTsgLy8gb2Jzb2xldGUgdXNlIC4zNyBvciAuMTVcbl9JXygnMi41LjI5LjMnLCAnY2VydGlmaWNhdGVQb2xpY2llcycpOyAvLyBkZXByZWNhdGVkLCB1c2UgLjMyXG5fSV8oJzIuNS4yOS40JywgJ2tleVVzYWdlUmVzdHJpY3Rpb24nKTsgLy8gb2Jzb2xldGUgdXNlIC4zNyBvciAuMTVcbl9JXygnMi41LjI5LjUnLCAncG9saWN5TWFwcGluZycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzNcbl9JXygnMi41LjI5LjYnLCAnc3VidHJlZXNDb25zdHJhaW50Jyk7IC8vIG9ic29sZXRlIHVzZSAuMzBcbl9JXygnMi41LjI5LjcnLCAnc3ViamVjdEFsdE5hbWUnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjE3XG5fSV8oJzIuNS4yOS44JywgJ2lzc3VlckFsdE5hbWUnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjE4XG5fSV8oJzIuNS4yOS45JywgJ3N1YmplY3REaXJlY3RvcnlBdHRyaWJ1dGVzJyk7XG5fSV8oJzIuNS4yOS4xMCcsICdiYXNpY0NvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOVxuX0lfKCcyLjUuMjkuMTEnLCAnbmFtZUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zMFxuX0lfKCcyLjUuMjkuMTInLCAncG9saWN5Q29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjM2XG5fSV8oJzIuNS4yOS4xMycsICdiYXNpY0NvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOVxuX0lOKCcyLjUuMjkuMTQnLCAnc3ViamVjdEtleUlkZW50aWZpZXInKTtcbl9JTignMi41LjI5LjE1JywgJ2tleVVzYWdlJyk7XG5fSV8oJzIuNS4yOS4xNicsICdwcml2YXRlS2V5VXNhZ2VQZXJpb2QnKTtcbl9JTignMi41LjI5LjE3JywgJ3N1YmplY3RBbHROYW1lJyk7XG5fSU4oJzIuNS4yOS4xOCcsICdpc3N1ZXJBbHROYW1lJyk7XG5fSU4oJzIuNS4yOS4xOScsICdiYXNpY0NvbnN0cmFpbnRzJyk7XG5fSV8oJzIuNS4yOS4yMCcsICdjUkxOdW1iZXInKTtcbl9JXygnMi41LjI5LjIxJywgJ2NSTFJlYXNvbicpO1xuX0lfKCcyLjUuMjkuMjInLCAnZXhwaXJhdGlvbkRhdGUnKTtcbl9JXygnMi41LjI5LjIzJywgJ2luc3RydWN0aW9uQ29kZScpO1xuX0lfKCcyLjUuMjkuMjQnLCAnaW52YWxpZGl0eURhdGUnKTtcbl9JXygnMi41LjI5LjI1JywgJ2NSTERpc3RyaWJ1dGlvblBvaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzFcbl9JXygnMi41LjI5LjI2JywgJ2lzc3VpbmdEaXN0cmlidXRpb25Qb2ludCcpOyAvLyBkZXByZWNhdGVkIHVzZSAuMjhcbl9JXygnMi41LjI5LjI3JywgJ2RlbHRhQ1JMSW5kaWNhdG9yJyk7XG5fSV8oJzIuNS4yOS4yOCcsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTtcbl9JXygnMi41LjI5LjI5JywgJ2NlcnRpZmljYXRlSXNzdWVyJyk7XG5fSV8oJzIuNS4yOS4zMCcsICduYW1lQ29uc3RyYWludHMnKTtcbl9JTignMi41LjI5LjMxJywgJ2NSTERpc3RyaWJ1dGlvblBvaW50cycpO1xuX0lOKCcyLjUuMjkuMzInLCAnY2VydGlmaWNhdGVQb2xpY2llcycpO1xuX0lfKCcyLjUuMjkuMzMnLCAncG9saWN5TWFwcGluZ3MnKTtcbl9JXygnMi41LjI5LjM0JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lOKCcyLjUuMjkuMzUnLCAnYXV0aG9yaXR5S2V5SWRlbnRpZmllcicpO1xuX0lfKCcyLjUuMjkuMzYnLCAncG9saWN5Q29uc3RyYWludHMnKTtcbl9JTignMi41LjI5LjM3JywgJ2V4dEtleVVzYWdlJyk7XG5fSV8oJzIuNS4yOS40NicsICdmcmVzaGVzdENSTCcpO1xuX0lfKCcyLjUuMjkuNTQnLCAnaW5oaWJpdEFueVBvbGljeScpO1xuXG4vLyBleHRLZXlVc2FnZSBwdXJwb3Nlc1xuX0lOKCcxLjMuNi4xLjQuMS4xMTEyOS4yLjQuMicsICd0aW1lc3RhbXBMaXN0Jyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMS4xJywgJ2F1dGhvcml0eUluZm9BY2Nlc3MnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjEnLCAnc2VydmVyQXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMicsICdjbGllbnRBdXRoJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4zJywgJ2NvZGVTaWduaW5nJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy40JywgJ2VtYWlsUHJvdGVjdGlvbicpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuOCcsICd0aW1lU3RhbXBpbmcnKTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJwa2kiLCJvaWRzIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9JTiIsImlkIiwibmFtZSIsIl9JXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/oids.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/pbe.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pbe.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Password-based encryption functions.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * An EncryptedPrivateKeyInfo:\n *\n * EncryptedPrivateKeyInfo ::= SEQUENCE {\n *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,\n *   encryptedData        EncryptedData }\n *\n * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * EncryptedData ::= OCTET STRING\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(ssr)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./asn1 */ \"(ssr)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./des */ \"(ssr)/./node_modules/node-forge/lib/des.js\");\n__webpack_require__(/*! ./md */ \"(ssr)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./oids */ \"(ssr)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pbkdf2 */ \"(ssr)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! ./pem */ \"(ssr)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./rc2 */ \"(ssr)/./node_modules/node-forge/lib/rc2.js\");\n__webpack_require__(/*! ./rsa */ \"(ssr)/./node_modules/node-forge/lib/rsa.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nif (typeof BigInteger === \"undefined\") {\n    var BigInteger = forge.jsbn.BigInteger;\n}\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n/* Password-based encryption implementation. */ var pki = forge.pki = forge.pki || {};\nmodule.exports = pki.pbe = forge.pbe = forge.pbe || {};\nvar oids = pki.oids;\n// validator for an EncryptedPrivateKeyInfo structure\n// Note: Currently only works w/algorithm params\nvar encryptedPrivateKeyValidator = {\n    name: \"EncryptedPrivateKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"EncryptedPrivateKeyInfo.encryptionAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"encryptionOid\"\n                },\n                {\n                    name: \"AlgorithmIdentifier.parameters\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    captureAsn1: \"encryptionParams\"\n                }\n            ]\n        },\n        {\n            // encryptedData\n            name: \"EncryptedPrivateKeyInfo.encryptedData\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"encryptedData\"\n        }\n    ]\n};\n// validator for a PBES2Algorithms structure\n// Note: Currently only works w/PBKDF2 + AES encryption schemes\nvar PBES2AlgorithmsValidator = {\n    name: \"PBES2Algorithms\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"PBES2Algorithms.keyDerivationFunc\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"PBES2Algorithms.keyDerivationFunc.oid\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"kdfOid\"\n                },\n                {\n                    name: \"PBES2Algorithms.params\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    value: [\n                        {\n                            name: \"PBES2Algorithms.params.salt\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OCTETSTRING,\n                            constructed: false,\n                            capture: \"kdfSalt\"\n                        },\n                        {\n                            name: \"PBES2Algorithms.params.iterationCount\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.INTEGER,\n                            constructed: false,\n                            capture: \"kdfIterationCount\"\n                        },\n                        {\n                            name: \"PBES2Algorithms.params.keyLength\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.INTEGER,\n                            constructed: false,\n                            optional: true,\n                            capture: \"keyLength\"\n                        },\n                        {\n                            // prf\n                            name: \"PBES2Algorithms.params.prf\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.SEQUENCE,\n                            constructed: true,\n                            optional: true,\n                            value: [\n                                {\n                                    name: \"PBES2Algorithms.params.prf.algorithm\",\n                                    tagClass: asn1.Class.UNIVERSAL,\n                                    type: asn1.Type.OID,\n                                    constructed: false,\n                                    capture: \"prfOid\"\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            name: \"PBES2Algorithms.encryptionScheme\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"PBES2Algorithms.encryptionScheme.oid\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"encOid\"\n                },\n                {\n                    name: \"PBES2Algorithms.encryptionScheme.iv\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OCTETSTRING,\n                    constructed: false,\n                    capture: \"encIv\"\n                }\n            ]\n        }\n    ]\n};\nvar pkcs12PbeParamsValidator = {\n    name: \"pkcs-12PbeParams\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"pkcs-12PbeParams.salt\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"salt\"\n        },\n        {\n            name: \"pkcs-12PbeParams.iterations\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"iterations\"\n        }\n    ]\n};\n/**\n * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.\n *\n * PBES2Algorithms ALGORITHM-IDENTIFIER ::=\n *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}\n *\n * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\n *\n * PBES2-params ::= SEQUENCE {\n *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\n *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}\n * }\n *\n * PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n *\n * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }\n *\n * PBKDF2-params ::= SEQUENCE {\n *   salt CHOICE {\n *     specified OCTET STRING,\n *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n *   },\n *   iterationCount INTEGER (1..MAX),\n *   keyLength INTEGER (1..MAX) OPTIONAL,\n *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n * }\n *\n * @param obj the ASN.1 PrivateKeyInfo object.\n * @param password the password to encrypt with.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          prfAlgorithm the PRF message digest algorithm to use\n *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')\n *\n * @return the ASN.1 EncryptedPrivateKeyInfo.\n */ pki.encryptPrivateKeyInfo = function(obj, password, options) {\n    // set default options\n    options = options || {};\n    options.saltSize = options.saltSize || 8;\n    options.count = options.count || 2048;\n    options.algorithm = options.algorithm || \"aes128\";\n    options.prfAlgorithm = options.prfAlgorithm || \"sha1\";\n    // generate PBE params\n    var salt = forge.random.getBytesSync(options.saltSize);\n    var count = options.count;\n    var countBytes = asn1.integerToDer(count);\n    var dkLen;\n    var encryptionAlgorithm;\n    var encryptedData;\n    if (options.algorithm.indexOf(\"aes\") === 0 || options.algorithm === \"des\") {\n        // do PBES2\n        var ivLen, encOid, cipherFn;\n        switch(options.algorithm){\n            case \"aes128\":\n                dkLen = 16;\n                ivLen = 16;\n                encOid = oids[\"aes128-CBC\"];\n                cipherFn = forge.aes.createEncryptionCipher;\n                break;\n            case \"aes192\":\n                dkLen = 24;\n                ivLen = 16;\n                encOid = oids[\"aes192-CBC\"];\n                cipherFn = forge.aes.createEncryptionCipher;\n                break;\n            case \"aes256\":\n                dkLen = 32;\n                ivLen = 16;\n                encOid = oids[\"aes256-CBC\"];\n                cipherFn = forge.aes.createEncryptionCipher;\n                break;\n            case \"des\":\n                dkLen = 8;\n                ivLen = 8;\n                encOid = oids[\"desCBC\"];\n                cipherFn = forge.des.createEncryptionCipher;\n                break;\n            default:\n                var error = new Error(\"Cannot encrypt private key. Unknown encryption algorithm.\");\n                error.algorithm = options.algorithm;\n                throw error;\n        }\n        // get PRF message digest\n        var prfAlgorithm = \"hmacWith\" + options.prfAlgorithm.toUpperCase();\n        var md = prfAlgorithmToMessageDigest(prfAlgorithm);\n        // encrypt private key using pbe SHA-1 and AES/DES\n        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n        var iv = forge.random.getBytesSync(ivLen);\n        var cipher = cipherFn(dk);\n        cipher.start(iv);\n        cipher.update(asn1.toDer(obj));\n        cipher.finish();\n        encryptedData = cipher.output.getBytes();\n        // get PBKDF2-params\n        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);\n        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[\"pkcs5PBES2\"]).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // keyDerivationFunc\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[\"pkcs5PBKDF2\"]).getBytes()),\n                    // PBKDF2-params\n                    params\n                ]),\n                // encryptionScheme\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),\n                    // iv\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)\n                ])\n            ])\n        ]);\n    } else if (options.algorithm === \"3des\") {\n        // Do PKCS12 PBE\n        dkLen = 24;\n        var saltBytes = new forge.util.ByteBuffer(salt);\n        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);\n        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);\n        var cipher = forge.des.createEncryptionCipher(dk);\n        cipher.start(iv);\n        cipher.update(asn1.toDer(obj));\n        cipher.finish();\n        encryptedData = cipher.output.getBytes();\n        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]).getBytes()),\n            // pkcs-12PbeParams\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // salt\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n                // iteration count\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())\n            ])\n        ]);\n    } else {\n        var error = new Error(\"Cannot encrypt private key. Unknown encryption algorithm.\");\n        error.algorithm = options.algorithm;\n        throw error;\n    }\n    // EncryptedPrivateKeyInfo\n    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // encryptionAlgorithm\n        encryptionAlgorithm,\n        // encryptedData\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)\n    ]);\n    return rval;\n};\n/**\n * Decrypts a ASN.1 PrivateKeyInfo object.\n *\n * @param obj the ASN.1 EncryptedPrivateKeyInfo object.\n * @param password the password to decrypt with.\n *\n * @return the ASN.1 PrivateKeyInfo on success, null on failure.\n */ pki.decryptPrivateKeyInfo = function(obj, password) {\n    var rval = null;\n    // get PBE params\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read encrypted private key. \" + \"ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    // get cipher\n    var oid = asn1.derToOid(capture.encryptionOid);\n    var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);\n    // get encrypted data\n    var encrypted = forge.util.createBuffer(capture.encryptedData);\n    cipher.update(encrypted);\n    if (cipher.finish()) {\n        rval = asn1.fromDer(cipher.output);\n    }\n    return rval;\n};\n/**\n * Converts a EncryptedPrivateKeyInfo to PEM format.\n *\n * @param epki the EncryptedPrivateKeyInfo.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted encrypted private key.\n */ pki.encryptedPrivateKeyToPem = function(epki, maxline) {\n    // convert to DER, then PEM-encode\n    var msg = {\n        type: \"ENCRYPTED PRIVATE KEY\",\n        body: asn1.toDer(epki).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption\n * is not performed.\n *\n * @param pem the EncryptedPrivateKeyInfo in PEM-format.\n *\n * @return the ASN.1 EncryptedPrivateKeyInfo.\n */ pki.encryptedPrivateKeyFromPem = function(pem) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"ENCRYPTED PRIVATE KEY\") {\n        var error = new Error(\"Could not convert encrypted private key from PEM; \" + 'PEM header type is \"ENCRYPTED PRIVATE KEY\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert encrypted private key from PEM; \" + \"PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    return asn1.fromDer(msg.body);\n};\n/**\n * Encrypts an RSA private key. By default, the key will be wrapped in\n * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.\n * This is the standard, preferred way to encrypt a private key.\n *\n * To produce a non-standard PEM-encrypted private key that uses encapsulated\n * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL\n * private key encryption), set the 'legacy' option to true. Note: Using this\n * option will cause the iteration count to be forced to 1.\n *\n * Note: The 'des' algorithm is supported, but it is not considered to be\n * secure because it only uses a single 56-bit key. If possible, it is highly\n * recommended that a different algorithm be used.\n *\n * @param rsaKey the RSA key to encrypt.\n * @param password the password to use.\n * @param options:\n *          algorithm: the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des', 'des').\n *          count: the iteration count to use.\n *          saltSize: the salt size to use.\n *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated\n *            headers (DEK-Info) private key.\n *\n * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.\n */ pki.encryptRsaPrivateKey = function(rsaKey, password, options) {\n    // standard PKCS#8\n    options = options || {};\n    if (!options.legacy) {\n        // encrypt PrivateKeyInfo\n        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));\n        rval = pki.encryptPrivateKeyInfo(rval, password, options);\n        return pki.encryptedPrivateKeyToPem(rval);\n    }\n    // legacy non-PKCS#8\n    var algorithm;\n    var iv;\n    var dkLen;\n    var cipherFn;\n    switch(options.algorithm){\n        case \"aes128\":\n            algorithm = \"AES-128-CBC\";\n            dkLen = 16;\n            iv = forge.random.getBytesSync(16);\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n        case \"aes192\":\n            algorithm = \"AES-192-CBC\";\n            dkLen = 24;\n            iv = forge.random.getBytesSync(16);\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n        case \"aes256\":\n            algorithm = \"AES-256-CBC\";\n            dkLen = 32;\n            iv = forge.random.getBytesSync(16);\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n        case \"3des\":\n            algorithm = \"DES-EDE3-CBC\";\n            dkLen = 24;\n            iv = forge.random.getBytesSync(8);\n            cipherFn = forge.des.createEncryptionCipher;\n            break;\n        case \"des\":\n            algorithm = \"DES-CBC\";\n            dkLen = 8;\n            iv = forge.random.getBytesSync(8);\n            cipherFn = forge.des.createEncryptionCipher;\n            break;\n        default:\n            var error = new Error(\"Could not encrypt RSA private key; unsupported \" + 'encryption algorithm \"' + options.algorithm + '\".');\n            error.algorithm = options.algorithm;\n            throw error;\n    }\n    // encrypt private key using OpenSSL legacy key derivation\n    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n    var cipher = cipherFn(dk);\n    cipher.start(iv);\n    cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));\n    cipher.finish();\n    var msg = {\n        type: \"RSA PRIVATE KEY\",\n        procType: {\n            version: \"4\",\n            type: \"ENCRYPTED\"\n        },\n        dekInfo: {\n            algorithm: algorithm,\n            parameters: forge.util.bytesToHex(iv).toUpperCase()\n        },\n        body: cipher.output.getBytes()\n    };\n    return forge.pem.encode(msg);\n};\n/**\n * Decrypts an RSA private key.\n *\n * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.\n * @param password the password to use.\n *\n * @return the RSA key on success, null on failure.\n */ pki.decryptRsaPrivateKey = function(pem, password) {\n    var rval = null;\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"ENCRYPTED PRIVATE KEY\" && msg.type !== \"PRIVATE KEY\" && msg.type !== \"RSA PRIVATE KEY\") {\n        var error = new Error(\"Could not convert private key from PEM; PEM header type \" + 'is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".');\n        error.headerType = error;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        var dkLen;\n        var cipherFn;\n        switch(msg.dekInfo.algorithm){\n            case \"DES-CBC\":\n                dkLen = 8;\n                cipherFn = forge.des.createDecryptionCipher;\n                break;\n            case \"DES-EDE3-CBC\":\n                dkLen = 24;\n                cipherFn = forge.des.createDecryptionCipher;\n                break;\n            case \"AES-128-CBC\":\n                dkLen = 16;\n                cipherFn = forge.aes.createDecryptionCipher;\n                break;\n            case \"AES-192-CBC\":\n                dkLen = 24;\n                cipherFn = forge.aes.createDecryptionCipher;\n                break;\n            case \"AES-256-CBC\":\n                dkLen = 32;\n                cipherFn = forge.aes.createDecryptionCipher;\n                break;\n            case \"RC2-40-CBC\":\n                dkLen = 5;\n                cipherFn = function(key) {\n                    return forge.rc2.createDecryptionCipher(key, 40);\n                };\n                break;\n            case \"RC2-64-CBC\":\n                dkLen = 8;\n                cipherFn = function(key) {\n                    return forge.rc2.createDecryptionCipher(key, 64);\n                };\n                break;\n            case \"RC2-128-CBC\":\n                dkLen = 16;\n                cipherFn = function(key) {\n                    return forge.rc2.createDecryptionCipher(key, 128);\n                };\n                break;\n            default:\n                var error = new Error(\"Could not decrypt private key; unsupported \" + 'encryption algorithm \"' + msg.dekInfo.algorithm + '\".');\n                error.algorithm = msg.dekInfo.algorithm;\n                throw error;\n        }\n        // use OpenSSL legacy key derivation\n        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);\n        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n        var cipher = cipherFn(dk);\n        cipher.start(iv);\n        cipher.update(forge.util.createBuffer(msg.body));\n        if (cipher.finish()) {\n            rval = cipher.output.getBytes();\n        } else {\n            return rval;\n        }\n    } else {\n        rval = msg.body;\n    }\n    if (msg.type === \"ENCRYPTED PRIVATE KEY\") {\n        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);\n    } else {\n        // decryption already performed above\n        rval = asn1.fromDer(rval);\n    }\n    if (rval !== null) {\n        rval = pki.privateKeyFromAsn1(rval);\n    }\n    return rval;\n};\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */ pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {\n    var j, l;\n    if (typeof md === \"undefined\" || md === null) {\n        if (!(\"sha1\" in forge.md)) {\n            throw new Error('\"sha1\" hash algorithm unavailable.');\n        }\n        md = forge.md.sha1.create();\n    }\n    var u = md.digestLength;\n    var v = md.blockLength;\n    var result = new forge.util.ByteBuffer();\n    /* Convert password to Unicode byte buffer + trailing 0-byte. */ var passBuf = new forge.util.ByteBuffer();\n    if (password !== null && password !== undefined) {\n        for(l = 0; l < password.length; l++){\n            passBuf.putInt16(password.charCodeAt(l));\n        }\n        passBuf.putInt16(0);\n    }\n    /* Length of salt and password in BYTES. */ var p = passBuf.length();\n    var s = salt.length();\n    /* 1. Construct a string, D (the \"diversifier\"), by concatenating\n        v copies of ID. */ var D = new forge.util.ByteBuffer();\n    D.fillWithByte(id, v);\n    /* 2. Concatenate copies of the salt together to create a string S of length\n        v * ceil(s / v) bytes (the final copy of the salt may be trunacted\n        to create S).\n        Note that if the salt is the empty string, then so is S. */ var Slen = v * Math.ceil(s / v);\n    var S = new forge.util.ByteBuffer();\n    for(l = 0; l < Slen; l++){\n        S.putByte(salt.at(l % s));\n    }\n    /* 3. Concatenate copies of the password together to create a string P of\n        length v * ceil(p / v) bytes (the final copy of the password may be\n        truncated to create P).\n        Note that if the password is the empty string, then so is P. */ var Plen = v * Math.ceil(p / v);\n    var P = new forge.util.ByteBuffer();\n    for(l = 0; l < Plen; l++){\n        P.putByte(passBuf.at(l % p));\n    }\n    /* 4. Set I=S||P to be the concatenation of S and P. */ var I = S;\n    I.putBuffer(P);\n    /* 5. Set c=ceil(n / u). */ var c = Math.ceil(n / u);\n    /* 6. For i=1, 2, ..., c, do the following: */ for(var i = 1; i <= c; i++){\n        /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */ var buf = new forge.util.ByteBuffer();\n        buf.putBytes(D.bytes());\n        buf.putBytes(I.bytes());\n        for(var round = 0; round < iter; round++){\n            md.start();\n            md.update(buf.getBytes());\n            buf = md.digest();\n        }\n        /* b) Concatenate copies of Ai to create a string B of length v bytes (the\n          final copy of Ai may be truncated to create B). */ var B = new forge.util.ByteBuffer();\n        for(l = 0; l < v; l++){\n            B.putByte(buf.at(l % u));\n        }\n        /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,\n          where k=ceil(s / v) + ceil(p / v), modify I by setting\n          Ij=(Ij+B+1) mod 2v for each j.  */ var k = Math.ceil(s / v) + Math.ceil(p / v);\n        var Inew = new forge.util.ByteBuffer();\n        for(j = 0; j < k; j++){\n            var chunk = new forge.util.ByteBuffer(I.getBytes(v));\n            var x = 0x1ff;\n            for(l = B.length() - 1; l >= 0; l--){\n                x = x >> 8;\n                x += B.at(l) + chunk.at(l);\n                chunk.setAt(l, x & 0xff);\n            }\n            Inew.putBuffer(chunk);\n        }\n        I = Inew;\n        /* Add Ai to A. */ result.putBuffer(buf);\n    }\n    result.truncate(result.length() - n);\n    return result;\n};\n/**\n * Get new Forge cipher object instance.\n *\n * @param oid the OID (in string notation).\n * @param params the ASN.1 params object.\n * @param password the password to decrypt with.\n *\n * @return new cipher object instance.\n */ pki.pbe.getCipher = function(oid, params, password) {\n    switch(oid){\n        case pki.oids[\"pkcs5PBES2\"]:\n            return pki.pbe.getCipherForPBES2(oid, params, password);\n        case pki.oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]:\n        case pki.oids[\"pbewithSHAAnd40BitRC2-CBC\"]:\n            return pki.pbe.getCipherForPKCS12PBE(oid, params, password);\n        default:\n            var error = new Error(\"Cannot read encrypted PBE data block. Unsupported OID.\");\n            error.oid = oid;\n            error.supportedOids = [\n                \"pkcs5PBES2\",\n                \"pbeWithSHAAnd3-KeyTripleDES-CBC\",\n                \"pbewithSHAAnd40BitRC2-CBC\"\n            ];\n            throw error;\n    }\n};\n/**\n * Get new Forge cipher object instance according to PBES2 params block.\n *\n * The returned cipher instance is already started using the IV\n * from PBES2 parameter block.\n *\n * @param oid the PKCS#5 PBKDF2 OID (in string notation).\n * @param params the ASN.1 PBES2-params object.\n * @param password the password to decrypt with.\n *\n * @return new cipher object instance.\n */ pki.pbe.getCipherForPBES2 = function(oid, params, password) {\n    // get PBE params\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {\n        var error = new Error(\"Cannot read password-based-encryption algorithm \" + \"parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    // check oids\n    oid = asn1.derToOid(capture.kdfOid);\n    if (oid !== pki.oids[\"pkcs5PBKDF2\"]) {\n        var error = new Error(\"Cannot read encrypted private key. \" + \"Unsupported key derivation function OID.\");\n        error.oid = oid;\n        error.supportedOids = [\n            \"pkcs5PBKDF2\"\n        ];\n        throw error;\n    }\n    oid = asn1.derToOid(capture.encOid);\n    if (oid !== pki.oids[\"aes128-CBC\"] && oid !== pki.oids[\"aes192-CBC\"] && oid !== pki.oids[\"aes256-CBC\"] && oid !== pki.oids[\"des-EDE3-CBC\"] && oid !== pki.oids[\"desCBC\"]) {\n        var error = new Error(\"Cannot read encrypted private key. \" + \"Unsupported encryption scheme OID.\");\n        error.oid = oid;\n        error.supportedOids = [\n            \"aes128-CBC\",\n            \"aes192-CBC\",\n            \"aes256-CBC\",\n            \"des-EDE3-CBC\",\n            \"desCBC\"\n        ];\n        throw error;\n    }\n    // set PBE params\n    var salt = capture.kdfSalt;\n    var count = forge.util.createBuffer(capture.kdfIterationCount);\n    count = count.getInt(count.length() << 3);\n    var dkLen;\n    var cipherFn;\n    switch(pki.oids[oid]){\n        case \"aes128-CBC\":\n            dkLen = 16;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n        case \"aes192-CBC\":\n            dkLen = 24;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n        case \"aes256-CBC\":\n            dkLen = 32;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n        case \"des-EDE3-CBC\":\n            dkLen = 24;\n            cipherFn = forge.des.createDecryptionCipher;\n            break;\n        case \"desCBC\":\n            dkLen = 8;\n            cipherFn = forge.des.createDecryptionCipher;\n            break;\n    }\n    // get PRF message digest\n    var md = prfOidToMessageDigest(capture.prfOid);\n    // decrypt private key using pbe with chosen PRF and AES/DES\n    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n    var iv = capture.encIv;\n    var cipher = cipherFn(dk);\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Get new Forge cipher object instance for PKCS#12 PBE.\n *\n * The returned cipher instance is already started using the key & IV\n * derived from the provided password and PKCS#12 PBE salt.\n *\n * @param oid The PKCS#12 PBE OID (in string notation).\n * @param params The ASN.1 PKCS#12 PBE-params object.\n * @param password The password to decrypt with.\n *\n * @return the new cipher object instance.\n */ pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {\n    // get PBE params\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {\n        var error = new Error(\"Cannot read password-based-encryption algorithm \" + \"parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    var salt = forge.util.createBuffer(capture.salt);\n    var count = forge.util.createBuffer(capture.iterations);\n    count = count.getInt(count.length() << 3);\n    var dkLen, dIvLen, cipherFn;\n    switch(oid){\n        case pki.oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]:\n            dkLen = 24;\n            dIvLen = 8;\n            cipherFn = forge.des.startDecrypting;\n            break;\n        case pki.oids[\"pbewithSHAAnd40BitRC2-CBC\"]:\n            dkLen = 5;\n            dIvLen = 8;\n            cipherFn = function(key, iv) {\n                var cipher = forge.rc2.createDecryptionCipher(key, 40);\n                cipher.start(iv, null);\n                return cipher;\n            };\n            break;\n        default:\n            var error = new Error(\"Cannot read PKCS #12 PBE data block. Unsupported OID.\");\n            error.oid = oid;\n            throw error;\n    }\n    // get PRF message digest\n    var md = prfOidToMessageDigest(capture.prfOid);\n    var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);\n    md.start();\n    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);\n    return cipherFn(key, iv);\n};\n/**\n * OpenSSL's legacy key derivation function.\n *\n * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html\n *\n * @param password the password to derive the key from.\n * @param salt the salt to use, null for none.\n * @param dkLen the number of bytes needed for the derived key.\n * @param [options] the options to use:\n *          [md] an optional message digest object to use.\n */ pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {\n    if (typeof md === \"undefined\" || md === null) {\n        if (!(\"md5\" in forge.md)) {\n            throw new Error('\"md5\" hash algorithm unavailable.');\n        }\n        md = forge.md.md5.create();\n    }\n    if (salt === null) {\n        salt = \"\";\n    }\n    var digests = [\n        hash(md, password + salt)\n    ];\n    for(var length = 16, i = 1; length < dkLen; ++i, length += 16){\n        digests.push(hash(md, digests[i - 1] + password + salt));\n    }\n    return digests.join(\"\").substr(0, dkLen);\n};\nfunction hash(md, bytes) {\n    return md.start().update(bytes).digest().getBytes();\n}\nfunction prfOidToMessageDigest(prfOid) {\n    // get PRF algorithm, default to SHA-1\n    var prfAlgorithm;\n    if (!prfOid) {\n        prfAlgorithm = \"hmacWithSHA1\";\n    } else {\n        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];\n        if (!prfAlgorithm) {\n            var error = new Error(\"Unsupported PRF OID.\");\n            error.oid = prfOid;\n            error.supported = [\n                \"hmacWithSHA1\",\n                \"hmacWithSHA224\",\n                \"hmacWithSHA256\",\n                \"hmacWithSHA384\",\n                \"hmacWithSHA512\"\n            ];\n            throw error;\n        }\n    }\n    return prfAlgorithmToMessageDigest(prfAlgorithm);\n}\nfunction prfAlgorithmToMessageDigest(prfAlgorithm) {\n    var factory = forge.md;\n    switch(prfAlgorithm){\n        case \"hmacWithSHA224\":\n            factory = forge.md.sha512;\n        case \"hmacWithSHA1\":\n        case \"hmacWithSHA256\":\n        case \"hmacWithSHA384\":\n        case \"hmacWithSHA512\":\n            prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();\n            break;\n        default:\n            var error = new Error(\"Unsupported PRF algorithm.\");\n            error.algorithm = prfAlgorithm;\n            error.supported = [\n                \"hmacWithSHA1\",\n                \"hmacWithSHA224\",\n                \"hmacWithSHA256\",\n                \"hmacWithSHA384\",\n                \"hmacWithSHA512\"\n            ];\n            throw error;\n    }\n    if (!factory || !(prfAlgorithm in factory)) {\n        throw new Error(\"Unknown hash algorithm: \" + prfAlgorithm);\n    }\n    return factory[prfAlgorithm].create();\n}\nfunction createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {\n    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // salt\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n        // iteration count\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())\n    ]);\n    // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm\n    if (prfAlgorithm !== \"hmacWithSHA1\") {\n        params.value.push(// key length\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), // AlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),\n            // parameters (null)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]));\n    }\n    return params;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJlLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFHLE9BQU9DLGVBQWUsYUFBYTtJQUNwQyxJQUFJQSxhQUFhRixNQUFNRyxJQUFJLENBQUNELFVBQVU7QUFDeEM7QUFFQSx5QkFBeUI7QUFDekIsSUFBSUUsT0FBT0osTUFBTUksSUFBSTtBQUVyQiw2Q0FBNkMsR0FDN0MsSUFBSUMsTUFBTUwsTUFBTUssR0FBRyxHQUFHTCxNQUFNSyxHQUFHLElBQUksQ0FBQztBQUNwQ0MsT0FBT0MsT0FBTyxHQUFHRixJQUFJRyxHQUFHLEdBQUdSLE1BQU1RLEdBQUcsR0FBR1IsTUFBTVEsR0FBRyxJQUFJLENBQUM7QUFDckQsSUFBSUMsT0FBT0osSUFBSUksSUFBSTtBQUVuQixxREFBcUQ7QUFDckQsZ0RBQWdEO0FBQ2hELElBQUlDLCtCQUErQjtJQUNqQ0MsTUFBTTtJQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7SUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtJQUN4QkMsYUFBYTtJQUNiQyxPQUFPO1FBQUM7WUFDTlIsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtZQUN4QkMsYUFBYTtZQUNiQyxPQUFPO2dCQUFDO29CQUNOUixNQUFNO29C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U0FBUyxFQUFFVixLQUFLWSxJQUFJLENBQUNzSyxJQUFJLEVBQUUsT0FBTztTQUMxRDtJQUNMO0lBQ0EsT0FBT25IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wYmUuanM/NjQ3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBhc3N3b3JkLWJhc2VkIGVuY3J5cHRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIEFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvOlxuICpcbiAqIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGVuY3J5cHRpb25BbGdvcml0aG0gIEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBlbmNyeXB0ZWREYXRhICAgICAgICBFbmNyeXB0ZWREYXRhIH1cbiAqXG4gKiBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZERhdGEgOjo9IE9DVEVUIFNUUklOR1xuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2RlcycpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi9vaWRzJyk7XG5yZXF1aXJlKCcuL3Bia2RmMicpO1xucmVxdWlyZSgnLi9wZW0nKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5yZXF1aXJlKCcuL3JjMicpO1xucmVxdWlyZSgnLi9yc2EnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUGFzc3dvcmQtYmFzZWQgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IHBraS5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9hbGdvcml0aG0gcGFyYW1zXG52YXIgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2VuY3J5cHRpb25PaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGlvblBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZW5jcnlwdGVkRGF0YSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQQkVTMkFsZ29yaXRobXMgc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3L1BCS0RGMiArIEFFUyBlbmNyeXB0aW9uIHNjaGVtZXNcbnZhciBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2tkZk9pZCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZlNhbHQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAna2RmSXRlcmF0aW9uQ291bnQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdrZXlMZW5ndGgnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByZlxuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogJ3ByZk9pZCdcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNJdidcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLnNhbHQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzYWx0J1xuICB9LCB7XG4gICAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMuaXRlcmF0aW9ucycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnaXRlcmF0aW9ucydcbiAgfV1cbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QsIHByb2R1Y2luZyBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqXG4gKiBQQkVTMkFsZ29yaXRobXMgQUxHT1JJVEhNLUlERU5USUZJRVIgOjo9XG4gKiAgIHsge1BCRVMyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCRVMyfSwgLi4ufVxuICpcbiAqIGlkLVBCRVMyIE9CSkVDVCBJREVOVElGSUVSIDo6PSB7cGtjcy01IDEzfVxuICpcbiAqIFBCRVMyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBrZXlEZXJpdmF0aW9uRnVuYyBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItS0RGc319LFxuICogICBlbmNyeXB0aW9uU2NoZW1lIEFsZ29yaXRobUlkZW50aWZpZXIge3tQQkVTMi1FbmNzfX1cbiAqIH1cbiAqXG4gKiBQQkVTMi1LREZzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQktERjItcGFyYW1zIElERU5USUZJRUQgQlkgaWQtUEJLREYyfSwgLi4uIH1cbiAqXG4gKiBQQkVTMi1FbmNzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PSB7IC4uLiB9XG4gKlxuICogUEJLREYyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBzYWx0IENIT0lDRSB7XG4gKiAgICAgc3BlY2lmaWVkIE9DVEVUIFNUUklORyxcbiAqICAgICBvdGhlclNvdXJjZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVNhbHRTb3VyY2VzfX1cbiAqICAgfSxcbiAqICAgaXRlcmF0aW9uQ291bnQgSU5URUdFUiAoMS4uTUFYKSxcbiAqICAga2V5TGVuZ3RoIElOVEVHRVIgKDEuLk1BWCkgT1BUSU9OQUwsXG4gKiAgIHByZiBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVBSRnN9fSBERUZBVUxUIGFsZ2lkLWhtYWNXaXRoU0hBMVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnKSwgZGVmYXVsdHMgdG8gJ2FlczEyOCcuXG4gKiAgICAgICAgICBjb3VudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplIHRoZSBzYWx0IHNpemUgdG8gdXNlLlxuICogICAgICAgICAgcHJmQWxnb3JpdGhtIHRoZSBQUkYgbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJylcbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyA9IGZ1bmN0aW9uKG9iaiwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnYWVzMTI4JztcbiAgb3B0aW9ucy5wcmZBbGdvcml0aG0gPSBvcHRpb25zLnByZkFsZ29yaXRobSB8fCAnc2hhMSc7XG5cbiAgLy8gZ2VuZXJhdGUgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gIHZhciBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gIHZhciBjb3VudEJ5dGVzID0gYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpO1xuICB2YXIgZGtMZW47XG4gIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB2YXIgZW5jcnlwdGVkRGF0YTtcbiAgaWYob3B0aW9ucy5hbGdvcml0aG0uaW5kZXhPZignYWVzJykgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdkZXMnKSB7XG4gICAgLy8gZG8gUEJFUzJcbiAgICB2YXIgaXZMZW4sIGVuY09pZCwgY2lwaGVyRm47XG4gICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnYWVzMTI4JzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMTI4LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FlczE5Mic6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczE5Mi1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgZGtMZW4gPSAzMjtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMyNTYtQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVzJzpcbiAgICAgIGRrTGVuID0gODtcbiAgICAgIGl2TGVuID0gODtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2Rlc0NCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gICAgdmFyIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aCcgKyBvcHRpb25zLnByZkFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtZCA9IHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xuXG4gICAgLy8gZW5jcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgU0hBLTEgYW5kIEFFUy9ERVNcbiAgICB2YXIgZGsgPSBmb3JnZS5wa2NzNS5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIGVuY3J5cHRlZERhdGEgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG5cbiAgICAvLyBnZXQgUEJLREYyLXBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBjcmVhdGVQYmtkZjJQYXJhbXMoc2FsdCwgY291bnRCeXRlcywgZGtMZW4sIHByZkFsZ29yaXRobSk7XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQkVTMiddKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8ga2V5RGVyaXZhdGlvbkZ1bmNcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQktERjInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gUEJLREYyLXBhcmFtc1xuICAgICAgICAgIHBhcmFtc1xuICAgICAgICBdKSxcbiAgICAgICAgLy8gZW5jcnlwdGlvblNjaGVtZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlbmNPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIGl2XG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgaXYpXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICczZGVzJykge1xuICAgIC8vIERvIFBLQ1MxMiBQQkVcbiAgICBka0xlbiA9IDI0O1xuXG4gICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgdmFyIGRrID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdEJ5dGVzLCAxLCBjb3VudCwgZGtMZW4pO1xuICAgIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMiwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwa2NzLTEyUGJlUGFyYW1zXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHNhbHRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgICAgICAvLyBpdGVyYXRpb24gY291bnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAvLyBlbmNyeXB0ZWREYXRhXG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgZW5jcnlwdGVkRGF0YSlcbiAgXSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBjaXBoZXJcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNyeXB0aW9uT2lkKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG5cbiAgLy8gZ2V0IGVuY3J5cHRlZCBkYXRhXG4gIHZhciBlbmNyeXB0ZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY3J5cHRlZERhdGEpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGVwa2kgdGhlIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBFTS1lbmNvZGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIEFTTi4xIGZvcm1hdC4gRGVjcnlwdGlvblxuICogaXMgbm90IHBlcmZvcm1lZC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBpbiBQRU0tZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICByZXR1cm4gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LiBCeSBkZWZhdWx0LCB0aGUga2V5IHdpbGwgYmUgd3JhcHBlZCBpblxuICogYSBQcml2YXRlS2V5SW5mbyBhbmQgZW5jcnlwdGVkIHRvIHByb2R1Y2UgYSBQS0NTIzggRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCwgcHJlZmVycmVkIHdheSB0byBlbmNyeXB0IGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogVG8gcHJvZHVjZSBhIG5vbi1zdGFuZGFyZCBQRU0tZW5jcnlwdGVkIHByaXZhdGUga2V5IHRoYXQgdXNlcyBlbmNhcHN1bGF0ZWRcbiAqIGhlYWRlcnMgdG8gaW5kaWNhdGUgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIChvbGQtc3R5bGUgbm9uLVBLQ1MjOCBPcGVuU1NMXG4gKiBwcml2YXRlIGtleSBlbmNyeXB0aW9uKSwgc2V0IHRoZSAnbGVnYWN5JyBvcHRpb24gdG8gdHJ1ZS4gTm90ZTogVXNpbmcgdGhpc1xuICogb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byBiZSBmb3JjZWQgdG8gMS5cbiAqXG4gKiBOb3RlOiBUaGUgJ2RlcycgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZCwgYnV0IGl0IGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlXG4gKiBzZWN1cmUgYmVjYXVzZSBpdCBvbmx5IHVzZXMgYSBzaW5nbGUgNTYtYml0IGtleS4gSWYgcG9zc2libGUsIGl0IGlzIGhpZ2hseVxuICogcmVjb21tZW5kZWQgdGhhdCBhIGRpZmZlcmVudCBhbGdvcml0aG0gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBSU0Ega2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtOiB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycsICdkZXMnKS5cbiAqICAgICAgICAgIGNvdW50OiB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplOiB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIGxlZ2FjeTogb3V0cHV0IGFuIG9sZCBub24tUEtDUyM4IFBFTS1lbmNyeXB0ZWQrZW5jYXBzdWxhdGVkXG4gKiAgICAgICAgICAgIGhlYWRlcnMgKERFSy1JbmZvKSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZW5jb2RlZCBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzdGFuZGFyZCBQS0NTIzhcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCFvcHRpb25zLmxlZ2FjeSkge1xuICAgIC8vIGVuY3J5cHQgUHJpdmF0ZUtleUluZm9cbiAgICB2YXIgcnZhbCA9IHBraS53cmFwUnNhUHJpdmF0ZUtleShwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKTtcbiAgICBydmFsID0gcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0ocnZhbCk7XG4gIH1cblxuICAvLyBsZWdhY3kgbm9uLVBLQ1MjOFxuICB2YXIgYWxnb3JpdGhtO1xuICB2YXIgaXY7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgY2FzZSAnYWVzMTI4JzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTEyOC1DQkMnO1xuICAgIGRrTGVuID0gMTY7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTInOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMTkyLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Nic6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0yNTYtQ0JDJztcbiAgICBka0xlbiA9IDMyO1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnM2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1FREUzLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzJzpcbiAgICBhbGdvcml0aG0gPSAnREVTLUNCQyc7XG4gICAgZGtMZW4gPSA4O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICdlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgT3BlblNTTCBsZWdhY3kga2V5IGRlcml2YXRpb25cbiAgdmFyIGRrID0gZm9yZ2UucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyhwYXNzd29yZCwgaXYuc3Vic3RyKDAsIDgpLCBka0xlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIGNpcGhlci51cGRhdGUoYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKSk7XG4gIGNpcGhlci5maW5pc2goKTtcblxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHByb2NUeXBlOiB7XG4gICAgICB2ZXJzaW9uOiAnNCcsXG4gICAgICB0eXBlOiAnRU5DUllQVEVEJ1xuICAgIH0sXG4gICAgZGVrSW5mbzoge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoaXYpLnRvVXBwZXJDYXNlKClcbiAgICB9LFxuICAgIGJvZHk6IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhbiBSU0EgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBkZWNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgUlNBIGtleSBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1JTQSBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdmFyIGRrTGVuO1xuICAgIHZhciBjaXBoZXJGbjtcbiAgICBzd2l0Y2gobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnREVTLUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnREVTLUVERTMtQ0JDJzpcbiAgICAgIGRrTGVuID0gMjQ7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMTkyLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ0JDJzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTQwLUNCQyc6XG4gICAgICBka0xlbiA9IDU7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTY0LUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA2NCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGRlY3J5cHQgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkICcgK1xuICAgICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgbXNnLmRla0luZm8uYWxnb3JpdGhtICsgJ1wiLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gbXNnLmRla0luZm8uYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdXNlIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCA9IG1zZy5ib2R5O1xuICB9XG5cbiAgaWYobXNnLnR5cGUgPT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgcnZhbCA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYXNuMS5mcm9tRGVyKHJ2YWwpLCBwYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjcnlwdGlvbiBhbHJlYWR5IHBlcmZvcm1lZCBhYm92ZVxuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIocnZhbCk7XG4gIH1cblxuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgcnZhbCA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEocnZhbCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleSA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBpZCwgaXRlciwgbiwgbWQpIHtcbiAgdmFyIGosIGw7XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ3NoYTEnIGluIGZvcmdlLm1kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIHUgPSBtZC5kaWdlc3RMZW5ndGg7XG4gIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgLyogQ29udmVydCBwYXNzd29yZCB0byBVbmljb2RlIGJ5dGUgYnVmZmVyICsgdHJhaWxpbmcgMC1ieXRlLiAqL1xuICB2YXIgcGFzc0J1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgaWYocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsID0gMDsgbCA8IHBhc3N3b3JkLmxlbmd0aDsgbCsrKSB7XG4gICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgIH1cbiAgICBwYXNzQnVmLnB1dEludDE2KDApO1xuICB9XG5cbiAgLyogTGVuZ3RoIG9mIHNhbHQgYW5kIHBhc3N3b3JkIGluIEJZVEVTLiAqL1xuICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gIHZhciBzID0gc2FsdC5sZW5ndGgoKTtcblxuICAvKiAxLiBDb25zdHJ1Y3QgYSBzdHJpbmcsIEQgKHRoZSBcImRpdmVyc2lmaWVyXCIpLCBieSBjb25jYXRlbmF0aW5nXG4gICAgICAgIHYgY29waWVzIG9mIElELiAqL1xuICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgRC5maWxsV2l0aEJ5dGUoaWQsIHYpO1xuXG4gIC8qIDIuIENvbmNhdGVuYXRlIGNvcGllcyBvZiB0aGUgc2FsdCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUyBvZiBsZW5ndGhcbiAgICAgICAgdiAqIGNlaWwocyAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgc2FsdCBtYXkgYmUgdHJ1bmFjdGVkXG4gICAgICAgIHRvIGNyZWF0ZSBTKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc28gaXMgUy4gKi9cbiAgdmFyIFNsZW4gPSB2ICogTWF0aC5jZWlsKHMgLyB2KTtcbiAgdmFyIFMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGZvcihsID0gMDsgbCA8IFNsZW47IGwrKykge1xuICAgIFMucHV0Qnl0ZShzYWx0LmF0KGwgJSBzKSk7XG4gIH1cblxuICAvKiAzLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHBhc3N3b3JkIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIHN0cmluZyBQIG9mXG4gICAgICAgIGxlbmd0aCB2ICogY2VpbChwIC8gdikgYnl0ZXMgKHRoZSBmaW5hbCBjb3B5IG9mIHRoZSBwYXNzd29yZCBtYXkgYmVcbiAgICAgICAgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBQKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBwYXNzd29yZCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFAuICovXG4gIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gIHZhciBQID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICBQLnB1dEJ5dGUocGFzc0J1Zi5hdChsICUgcCkpO1xuICB9XG5cbiAgLyogNC4gU2V0IEk9U3x8UCB0byBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBTIGFuZCBQLiAqL1xuICB2YXIgSSA9IFM7XG4gIEkucHV0QnVmZmVyKFApO1xuXG4gIC8qIDUuIFNldCBjPWNlaWwobiAvIHUpLiAqL1xuICB2YXIgYyA9IE1hdGguY2VpbChuIC8gdSk7XG5cbiAgLyogNi4gRm9yIGk9MSwgMiwgLi4uLCBjLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGM7IGkrKykge1xuICAgIC8qIGEpIFNldCBBaT1IXnIoRHx8SSkuIChsLmUuIHRoZSBydGggaGFzaCBvZiBEfHxJLCBIKEgoSCguLi5IKER8fEkpKSkpICovXG4gICAgdmFyIGJ1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBidWYucHV0Qnl0ZXMoRC5ieXRlcygpKTtcbiAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICBmb3IodmFyIHJvdW5kID0gMDsgcm91bmQgPCBpdGVyOyByb3VuZCsrKSB7XG4gICAgICBtZC5zdGFydCgpO1xuICAgICAgbWQudXBkYXRlKGJ1Zi5nZXRCeXRlcygpKTtcbiAgICAgIGJ1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIC8qIGIpIENvbmNhdGVuYXRlIGNvcGllcyBvZiBBaSB0byBjcmVhdGUgYSBzdHJpbmcgQiBvZiBsZW5ndGggdiBieXRlcyAodGhlXG4gICAgICAgICAgZmluYWwgY29weSBvZiBBaSBtYXkgYmUgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBCKS4gKi9cbiAgICB2YXIgQiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgIEIucHV0Qnl0ZShidWYuYXQobCAlIHUpKTtcbiAgICB9XG5cbiAgICAvKiBjKSBUcmVhdGluZyBJIGFzIGEgY29uY2F0ZW5hdGlvbiBJMCwgSTEsIC4uLiwgSWstMSBvZiB2LWJ5dGUgYmxvY2tzLFxuICAgICAgICAgIHdoZXJlIGs9Y2VpbChzIC8gdikgKyBjZWlsKHAgLyB2KSwgbW9kaWZ5IEkgYnkgc2V0dGluZ1xuICAgICAgICAgIElqPShJaitCKzEpIG1vZCAydiBmb3IgZWFjaCBqLiAgKi9cbiAgICB2YXIgayA9IE1hdGguY2VpbChzIC8gdikgKyBNYXRoLmNlaWwocCAvIHYpO1xuICAgIHZhciBJbmV3ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIGZvcihqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgdmFyIGNodW5rID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihJLmdldEJ5dGVzKHYpKTtcbiAgICAgIHZhciB4ID0gMHgxZmY7XG4gICAgICBmb3IobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB4ID0geCA+PiA4O1xuICAgICAgICB4ICs9IEIuYXQobCkgKyBjaHVuay5hdChsKTtcbiAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgSW5ldy5wdXRCdWZmZXIoY2h1bmspO1xuICAgIH1cbiAgICBJID0gSW5ldztcblxuICAgIC8qIEFkZCBBaSB0byBBLiAqL1xuICAgIHJlc3VsdC5wdXRCdWZmZXIoYnVmKTtcbiAgfVxuXG4gIHJlc3VsdC50cnVuY2F0ZShyZXN1bHQubGVuZ3RoKCkgLSBuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvaWQgdGhlIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIHBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICBzd2l0Y2gob2lkKSB7XG4gIGNhc2UgcGtpLm9pZHNbJ3BrY3M1UEJFUzInXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGNhc2UgcGtpLm9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXTpcbiAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgIHJldHVybiBwa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRShvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGRlZmF1bHQ6XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdwa2NzNVBCRVMyJyxcbiAgICAgICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyxcbiAgICAgICdwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDJ1xuICAgIF07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGFjY29yZGluZyB0byBQQkVTMiBwYXJhbXMgYmxvY2suXG4gKlxuICogVGhlIHJldHVybmVkIGNpcGhlciBpbnN0YW5jZSBpcyBhbHJlYWR5IHN0YXJ0ZWQgdXNpbmcgdGhlIElWXG4gKiBmcm9tIFBCRVMyIHBhcmFtZXRlciBibG9jay5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBQS0NTIzUgUEJLREYyIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIFBCRVMyLXBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hlY2sgb2lkc1xuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUua2RmT2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkc1sncGtjczVQQktERjInXSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbJ3BrY3M1UEJLREYyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY09pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ2FlczEyOC1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczE5Mi1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczI1Ni1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddICYmXG4gICAgb2lkICE9PSBwa2kub2lkc1snZGVzQ0JDJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgJ2FlczEyOC1DQkMnLCAnYWVzMTkyLUNCQycsICdhZXMyNTYtQ0JDJywgJ2Rlcy1FREUzLUNCQycsICdkZXNDQkMnXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHNldCBQQkUgcGFyYW1zXG4gIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmtkZkl0ZXJhdGlvbkNvdW50KTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gocGtpLm9pZHNbb2lkXSkge1xuICBjYXNlICdhZXMxMjgtQ0JDJzpcbiAgICBka0xlbiA9IDE2O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczE5Mi1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMjU2LUNCQyc6XG4gICAgZGtMZW4gPSAzMjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdkZXMtRURFMy1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzQ0JDJzpcbiAgICBka0xlbiA9IDg7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGdldCBQUkYgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcblxuICAvLyBkZWNyeXB0IHByaXZhdGUga2V5IHVzaW5nIHBiZSB3aXRoIGNob3NlbiBQUkYgYW5kIEFFUy9ERVNcbiAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgdmFyIGl2ID0gY2FwdHVyZS5lbmNJdjtcbiAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBHZXQgbmV3IEZvcmdlIGNpcGhlciBvYmplY3QgaW5zdGFuY2UgZm9yIFBLQ1MjMTIgUEJFLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBrZXkgJiBJVlxuICogZGVyaXZlZCBmcm9tIHRoZSBwcm92aWRlZCBwYXNzd29yZCBhbmQgUEtDUyMxMiBQQkUgc2FsdC5cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBQS0NTIzEyIFBCRSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBBU04uMSBQS0NTIzEyIFBCRS1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgbmV3IGNpcGhlciBvYmplY3QgaW5zdGFuY2UuXG4gKi9cbnBraS5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLml0ZXJhdGlvbnMpO1xuICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcblxuICB2YXIgZGtMZW4sIGRJdkxlbiwgY2lwaGVyRm47XG4gIHN3aXRjaChvaWQpIHtcbiAgICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5LCBpdikge1xuICAgICAgICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTICMxMiBQQkUgZGF0YSBibG9jay4gVW5zdXBwb3J0ZWQgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gIHZhciBrZXkgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAxLCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgbWQuc3RhcnQoKTtcbiAgdmFyIGl2ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMiwgY291bnQsIGRJdkxlbiwgbWQpO1xuXG4gIHJldHVybiBjaXBoZXJGbihrZXksIGl2KTtcbn07XG5cbi8qKlxuICogT3BlblNTTCdzIGxlZ2FjeSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBTZWU6IGh0dHA6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0IHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBka0xlbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGRlcml2ZWQga2V5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbbWRdIGFuIG9wdGlvbmFsIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UuXG4gKi9cbnBraS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzID0gZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIGRrTGVuLCBtZCkge1xuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgaWYoISgnbWQ1JyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZDVcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gIH1cbiAgaWYoc2FsdCA9PT0gbnVsbCkge1xuICAgIHNhbHQgPSAnJztcbiAgfVxuICB2YXIgZGlnZXN0cyA9IFtoYXNoKG1kLCBwYXNzd29yZCArIHNhbHQpXTtcbiAgZm9yKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgIGRpZ2VzdHMucHVzaChoYXNoKG1kLCBkaWdlc3RzW2kgLSAxXSArIHBhc3N3b3JkICsgc2FsdCkpO1xuICB9XG4gIHJldHVybiBkaWdlc3RzLmpvaW4oJycpLnN1YnN0cigwLCBka0xlbik7XG59O1xuXG5mdW5jdGlvbiBoYXNoKG1kLCBieXRlcykge1xuICByZXR1cm4gbWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG59XG5cbmZ1bmN0aW9uIHByZk9pZFRvTWVzc2FnZURpZ2VzdChwcmZPaWQpIHtcbiAgLy8gZ2V0IFBSRiBhbGdvcml0aG0sIGRlZmF1bHQgdG8gU0hBLTFcbiAgdmFyIHByZkFsZ29yaXRobTtcbiAgaWYoIXByZk9pZCkge1xuICAgIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aFNIQTEnO1xuICB9IGVsc2Uge1xuICAgIHByZkFsZ29yaXRobSA9IHBraS5vaWRzW2FzbjEuZGVyVG9PaWQocHJmT2lkKV07XG4gICAgaWYoIXByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUkYgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gcHJmT2lkO1xuICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAnaG1hY1dpdGhTSEExJywgJ2htYWNXaXRoU0hBMjI0JywgJ2htYWNXaXRoU0hBMjU2JywgJ2htYWNXaXRoU0hBMzg0JyxcbiAgICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKSB7XG4gIHZhciBmYWN0b3J5ID0gZm9yZ2UubWQ7XG4gIHN3aXRjaChwcmZBbGdvcml0aG0pIHtcbiAgY2FzZSAnaG1hY1dpdGhTSEEyMjQnOlxuICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMSc6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjU2JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEEzODQnOlxuICBjYXNlICdobWFjV2l0aFNIQTUxMic6XG4gICAgcHJmQWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBwcmZBbGdvcml0aG07XG4gICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAnaG1hY1dpdGhTSEE1MTInXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZighZmFjdG9yeSB8fCAhKHByZkFsZ29yaXRobSBpbiBmYWN0b3J5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIHByZkFsZ29yaXRobSk7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnlbcHJmQWxnb3JpdGhtXS5jcmVhdGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pIHtcbiAgdmFyIHBhcmFtcyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBzYWx0XG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGNvdW50Qnl0ZXMuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG4gIC8vIHdoZW4gUFJGIGFsZ29yaXRobSBpcyBub3QgU0hBLTEgZGVmYXVsdCwgYWRkIGtleSBsZW5ndGggYW5kIFBSRiBhbGdvcml0aG1cbiAgaWYocHJmQWxnb3JpdGhtICE9PSAnaG1hY1dpdGhTSEExJykge1xuICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgLy8ga2V5IGxlbmd0aFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGRrTGVuLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHNbcHJmQWxnb3JpdGhtXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgXSkpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwiQmlnSW50ZWdlciIsImpzYm4iLCJhc24xIiwicGtpIiwibW9kdWxlIiwiZXhwb3J0cyIsInBiZSIsIm9pZHMiLCJlbmNyeXB0ZWRQcml2YXRlS2V5VmFsaWRhdG9yIiwibmFtZSIsInRhZ0NsYXNzIiwiQ2xhc3MiLCJVTklWRVJTQUwiLCJ0eXBlIiwiVHlwZSIsIlNFUVVFTkNFIiwiY29uc3RydWN0ZWQiLCJ2YWx1ZSIsIk9JRCIsImNhcHR1cmUiLCJjYXB0dXJlQXNuMSIsIk9DVEVUU1RSSU5HIiwiUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yIiwiSU5URUdFUiIsIm9wdGlvbmFsIiwicGtjczEyUGJlUGFyYW1zVmFsaWRhdG9yIiwiZW5jcnlwdFByaXZhdGVLZXlJbmZvIiwib2JqIiwicGFzc3dvcmQiLCJvcHRpb25zIiwic2FsdFNpemUiLCJjb3VudCIsImFsZ29yaXRobSIsInByZkFsZ29yaXRobSIsInNhbHQiLCJyYW5kb20iLCJnZXRCeXRlc1N5bmMiLCJjb3VudEJ5dGVzIiwiaW50ZWdlclRvRGVyIiwiZGtMZW4iLCJlbmNyeXB0aW9uQWxnb3JpdGhtIiwiZW5jcnlwdGVkRGF0YSIsImluZGV4T2YiLCJpdkxlbiIsImVuY09pZCIsImNpcGhlckZuIiwiYWVzIiwiY3JlYXRlRW5jcnlwdGlvbkNpcGhlciIsImRlcyIsImVycm9yIiwiRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsIm1kIiwicHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0IiwiZGsiLCJwa2NzNSIsInBia2RmMiIsIml2IiwiY2lwaGVyIiwic3RhcnQiLCJ1cGRhdGUiLCJ0b0RlciIsImZpbmlzaCIsIm91dHB1dCIsImdldEJ5dGVzIiwicGFyYW1zIiwiY3JlYXRlUGJrZGYyUGFyYW1zIiwiY3JlYXRlIiwib2lkVG9EZXIiLCJzYWx0Qnl0ZXMiLCJ1dGlsIiwiQnl0ZUJ1ZmZlciIsImdlbmVyYXRlUGtjczEyS2V5IiwicnZhbCIsImRlY3J5cHRQcml2YXRlS2V5SW5mbyIsImVycm9ycyIsInZhbGlkYXRlIiwib2lkIiwiZGVyVG9PaWQiLCJlbmNyeXB0aW9uT2lkIiwiZ2V0Q2lwaGVyIiwiZW5jcnlwdGlvblBhcmFtcyIsImVuY3J5cHRlZCIsImNyZWF0ZUJ1ZmZlciIsImZyb21EZXIiLCJlbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0iLCJlcGtpIiwibWF4bGluZSIsIm1zZyIsImJvZHkiLCJwZW0iLCJlbmNvZGUiLCJlbmNyeXB0ZWRQcml2YXRlS2V5RnJvbVBlbSIsImRlY29kZSIsImhlYWRlclR5cGUiLCJwcm9jVHlwZSIsImVuY3J5cHRSc2FQcml2YXRlS2V5IiwicnNhS2V5IiwibGVnYWN5Iiwid3JhcFJzYVByaXZhdGVLZXkiLCJwcml2YXRlS2V5VG9Bc24xIiwib3BlbnNzbERlcml2ZUJ5dGVzIiwic3Vic3RyIiwidmVyc2lvbiIsImRla0luZm8iLCJwYXJhbWV0ZXJzIiwiYnl0ZXNUb0hleCIsImRlY3J5cHRSc2FQcml2YXRlS2V5IiwiY3JlYXRlRGVjcnlwdGlvbkNpcGhlciIsImtleSIsInJjMiIsImhleFRvQnl0ZXMiLCJwcml2YXRlS2V5RnJvbUFzbjEiLCJpZCIsIml0ZXIiLCJuIiwiaiIsImwiLCJzaGExIiwidSIsImRpZ2VzdExlbmd0aCIsInYiLCJibG9ja0xlbmd0aCIsInJlc3VsdCIsInBhc3NCdWYiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJwdXRJbnQxNiIsImNoYXJDb2RlQXQiLCJwIiwicyIsIkQiLCJmaWxsV2l0aEJ5dGUiLCJTbGVuIiwiTWF0aCIsImNlaWwiLCJTIiwicHV0Qnl0ZSIsImF0IiwiUGxlbiIsIlAiLCJJIiwicHV0QnVmZmVyIiwiYyIsImkiLCJidWYiLCJwdXRCeXRlcyIsImJ5dGVzIiwicm91bmQiLCJkaWdlc3QiLCJCIiwiayIsIkluZXciLCJjaHVuayIsIngiLCJzZXRBdCIsInRydW5jYXRlIiwiZ2V0Q2lwaGVyRm9yUEJFUzIiLCJnZXRDaXBoZXJGb3JQS0NTMTJQQkUiLCJzdXBwb3J0ZWRPaWRzIiwia2RmT2lkIiwia2RmU2FsdCIsImtkZkl0ZXJhdGlvbkNvdW50IiwiZ2V0SW50IiwicHJmT2lkVG9NZXNzYWdlRGlnZXN0IiwicHJmT2lkIiwiZW5jSXYiLCJpdGVyYXRpb25zIiwiZEl2TGVuIiwic3RhcnREZWNyeXB0aW5nIiwibWQ1IiwiZGlnZXN0cyIsImhhc2giLCJwdXNoIiwiam9pbiIsInN1cHBvcnRlZCIsImZhY3RvcnkiLCJzaGE1MTIiLCJ0b0xvd2VyQ2FzZSIsInRvU3RyaW5nIiwiTlVMTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/pbe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/pbkdf2.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/pbkdf2.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Password-Based Key-Derivation Function #2 implementation.\n *\n * See RFC 2898 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./hmac */ \"(ssr)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! ./md */ \"(ssr)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nvar pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\nvar crypto;\nif (forge.util.isNodejs && !forge.options.usePureJavaScript) {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n}\n/**\n * Derives a key from a password.\n *\n * @param p the password as a binary-encoded string of bytes.\n * @param s the salt as a binary-encoded string of bytes.\n * @param c the iteration count, a positive integer.\n * @param dkLen the intended length, in bytes, of the derived key,\n *          (max: 2^32 - 1) * hash length of the PRF.\n * @param [md] the message digest (or algorithm identifier as a string) to use\n *          in the PRF, defaults to SHA-1.\n * @param [callback(err, key)] presence triggers asynchronous version, called\n *          once the operation completes.\n *\n * @return the derived key, as a binary-encoded string of bytes, for the\n *           synchronous version (if no callback is specified).\n */ module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {\n    if (typeof md === \"function\") {\n        callback = md;\n        md = null;\n    }\n    // use native implementation if possible and not disabled, note that\n    // some node versions only support SHA-1, others allow digest to be changed\n    if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== \"object\") && (crypto.pbkdf2Sync.length > 4 || !md || md === \"sha1\")) {\n        if (typeof md !== \"string\") {\n            // default prf to SHA-1\n            md = \"sha1\";\n        }\n        p = Buffer.from(p, \"binary\");\n        s = Buffer.from(s, \"binary\");\n        if (!callback) {\n            if (crypto.pbkdf2Sync.length === 4) {\n                return crypto.pbkdf2Sync(p, s, c, dkLen).toString(\"binary\");\n            }\n            return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString(\"binary\");\n        }\n        if (crypto.pbkdf2Sync.length === 4) {\n            return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\n                if (err) {\n                    return callback(err);\n                }\n                callback(null, key.toString(\"binary\"));\n            });\n        }\n        return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, key.toString(\"binary\"));\n        });\n    }\n    if (typeof md === \"undefined\" || md === null) {\n        // default prf to SHA-1\n        md = \"sha1\";\n    }\n    if (typeof md === \"string\") {\n        if (!(md in forge.md.algorithms)) {\n            throw new Error(\"Unknown hash algorithm: \" + md);\n        }\n        md = forge.md[md].create();\n    }\n    var hLen = md.digestLength;\n    /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\n    stop. */ if (dkLen > 0xFFFFFFFF * hLen) {\n        var err = new Error(\"Derived key is too long.\");\n        if (callback) {\n            return callback(err);\n        }\n        throw err;\n    }\n    /* 2. Let len be the number of hLen-octet blocks in the derived key,\n    rounding up, and let r be the number of octets in the last\n    block:\n\n    len = CEIL(dkLen / hLen),\n    r = dkLen - (len - 1) * hLen. */ var len = Math.ceil(dkLen / hLen);\n    var r = dkLen - (len - 1) * hLen;\n    /* 3. For each block of the derived key apply the function F defined\n    below to the password P, the salt S, the iteration count c, and\n    the block index to compute the block:\n\n    T_1 = F(P, S, c, 1),\n    T_2 = F(P, S, c, 2),\n    ...\n    T_len = F(P, S, c, len),\n\n    where the function F is defined as the exclusive-or sum of the\n    first c iterates of the underlying pseudorandom function PRF\n    applied to the password P and the concatenation of the salt S\n    and the block index i:\n\n    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\n\n    where\n\n    u_1 = PRF(P, S || INT(i)),\n    u_2 = PRF(P, u_1),\n    ...\n    u_c = PRF(P, u_{c-1}).\n\n    Here, INT(i) is a four-octet encoding of the integer i, most\n    significant octet first. */ var prf = forge.hmac.create();\n    prf.start(md, p);\n    var dk = \"\";\n    var xor, u_c, u_c1;\n    // sync version\n    if (!callback) {\n        for(var i = 1; i <= len; ++i){\n            // PRF(P, S || INT(i)) (first iteration)\n            prf.start(null, null);\n            prf.update(s);\n            prf.update(forge.util.int32ToBytes(i));\n            xor = u_c1 = prf.digest().getBytes();\n            // PRF(P, u_{c-1}) (other iterations)\n            for(var j = 2; j <= c; ++j){\n                prf.start(null, null);\n                prf.update(u_c1);\n                u_c = prf.digest().getBytes();\n                // F(p, s, c, i)\n                xor = forge.util.xorBytes(xor, u_c, hLen);\n                u_c1 = u_c;\n            }\n            /* 4. Concatenate the blocks and extract the first dkLen octets to\n        produce a derived key DK:\n\n        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */ dk += i < len ? xor : xor.substr(0, r);\n        }\n        /* 5. Output the derived key DK. */ return dk;\n    }\n    // async version\n    var i = 1, j;\n    function outer() {\n        if (i > len) {\n            // done\n            return callback(null, dk);\n        }\n        // PRF(P, S || INT(i)) (first iteration)\n        prf.start(null, null);\n        prf.update(s);\n        prf.update(forge.util.int32ToBytes(i));\n        xor = u_c1 = prf.digest().getBytes();\n        // PRF(P, u_{c-1}) (other iterations)\n        j = 2;\n        inner();\n    }\n    function inner() {\n        if (j <= c) {\n            prf.start(null, null);\n            prf.update(u_c1);\n            u_c = prf.digest().getBytes();\n            // F(p, s, c, i)\n            xor = forge.util.xorBytes(xor, u_c, hLen);\n            u_c1 = u_c;\n            ++j;\n            return forge.util.setImmediate(inner);\n        }\n        /* 4. Concatenate the blocks and extract the first dkLen octets to\n      produce a derived key DK:\n\n      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */ dk += i < len ? xor : xor.substr(0, r);\n        ++i;\n        outer();\n    }\n    outer();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJrZGYyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsUUFBUUYsTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLElBQUksQ0FBQztBQUUxQyxJQUFJQztBQUNKLElBQUdILE1BQU1JLElBQUksQ0FBQ0MsUUFBUSxJQUFJLENBQUNMLE1BQU1NLE9BQU8sQ0FBQ0MsaUJBQWlCLEVBQUU7SUFDMURKLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ25CO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RPLE9BQU9DLE9BQU8sR0FBR1QsTUFBTVUsTUFBTSxHQUFHUixNQUFNUSxNQUFNLEdBQUcsU0FDN0NDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsRUFBRSxFQUFFQyxRQUFRO0lBQzVCLElBQUcsT0FBT0QsT0FBTyxZQUFZO1FBQzNCQyxXQUFXRDtRQUNYQSxLQUFLO0lBQ1A7SUFFQSxvRUFBb0U7SUFDcEUsMkVBQTJFO0lBQzNFLElBQUdmLE1BQU1JLElBQUksQ0FBQ0MsUUFBUSxJQUFJLENBQUNMLE1BQU1NLE9BQU8sQ0FBQ0MsaUJBQWlCLElBQ3hESixPQUFPTyxNQUFNLElBQUtLLENBQUFBLE9BQU8sUUFBUSxPQUFPQSxPQUFPLFFBQU8sS0FDckRaLENBQUFBLE9BQU9jLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHLEtBQU0sQ0FBQ0gsTUFBTUEsT0FBTyxNQUFNLEdBQUk7UUFDMUQsSUFBRyxPQUFPQSxPQUFPLFVBQVU7WUFDekIsdUJBQXVCO1lBQ3ZCQSxLQUFLO1FBQ1A7UUFDQUosSUFBSVEsT0FBT0MsSUFBSSxDQUFDVCxHQUFHO1FBQ25CQyxJQUFJTyxPQUFPQyxJQUFJLENBQUNSLEdB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O0lBQ1Q7SUFFQSxnQkFBZ0I7SUFDaEIsSUFBSUksSUFBSSxHQUFHSztJQUNYLFNBQVNHO1FBQ1AsSUFBR1IsSUFBSVgsS0FBSztZQUNWLE9BQU87WUFDUCxPQUFPYixTQUFTLE1BQU1vQjtRQUN4QjtRQUVBLHdDQUF3QztRQUN4Q0gsSUFBSUUsS0FBSyxDQUFDLE1BQU07UUFDaEJGLElBQUlRLE1BQU0sQ0FBQzdCO1FBQ1hxQixJQUFJUSxNQUFNLENBQUN6QyxNQUFNSSxJQUFJLENBQUNzQyxZQUFZLENBQUNGO1FBQ25DSCxNQUFNRSxPQUFPTixJQUFJVSxNQUFNLEdBQUdDLFFBQVE7UUFFbEMscUNBQXFDO1FBQ3JDQyxJQUFJO1FBQ0pJO0lBQ0Y7SUFFQSxTQUFTQTtRQUNQLElBQUdKLEtBQUtoQyxHQUFHO1lBQ1RvQixJQUFJRSxLQUFLLENBQUMsTUFBTTtZQUNoQkYsSUFBSVEsTUFBTSxDQUFDRjtZQUNYRCxNQUFNTCxJQUFJVSxNQUFNLEdBQUdDLFFBQVE7WUFDM0IsZ0JBQWdCO1lBQ2hCUCxNQUFNckMsTUFBTUksSUFBSSxDQUFDMEMsUUFBUSxDQUFDVCxLQUFLQyxLQUFLWDtZQUNwQ1ksT0FBT0Q7WUFDUCxFQUFFTztZQUNGLE9BQU83QyxNQUFNSSxJQUFJLENBQUM4QyxZQUFZLENBQUNEO1FBQ2pDO1FBRUE7OztnREFHNEMsR0FDNUNiLE1BQU0sSUFBS1AsTUFBT1EsTUFBTUEsSUFBSVUsTUFBTSxDQUFDLEdBQUdmO1FBRXRDLEVBQUVRO1FBQ0ZRO0lBQ0Y7SUFFQUE7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bia2RmMi5qcz9kOWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24gIzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIFJGQyAyODk4IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9obWFjJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHBrY3M1ID0gZm9yZ2UucGtjczUgPSBmb3JnZS5wa2NzNSB8fCB7fTtcblxudmFyIGNyeXB0bztcbmlmKGZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQpIHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG59XG5cbi8qKlxuICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHAgdGhlIHBhc3N3b3JkIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIHMgdGhlIHNhbHQgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gYyB0aGUgaXRlcmF0aW9uIGNvdW50LCBhIHBvc2l0aXZlIGludGVnZXIuXG4gKiBAcGFyYW0gZGtMZW4gdGhlIGludGVuZGVkIGxlbmd0aCwgaW4gYnl0ZXMsIG9mIHRoZSBkZXJpdmVkIGtleSxcbiAqICAgICAgICAgIChtYXg6IDJeMzIgLSAxKSAqIGhhc2ggbGVuZ3RoIG9mIHRoZSBQUkYuXG4gKiBAcGFyYW0gW21kXSB0aGUgbWVzc2FnZSBkaWdlc3QgKG9yIGFsZ29yaXRobSBpZGVudGlmaWVyIGFzIGEgc3RyaW5nKSB0byB1c2VcbiAqICAgICAgICAgIGluIHRoZSBQUkYsIGRlZmF1bHRzIHRvIFNIQS0xLlxuICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGtleSldIHByZXNlbmNlIHRyaWdnZXJzIGFzeW5jaHJvbm91cyB2ZXJzaW9uLCBjYWxsZWRcbiAqICAgICAgICAgIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgZGVyaXZlZCBrZXksIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLCBmb3IgdGhlXG4gKiAgICAgICAgICAgc3luY2hyb25vdXMgdmVyc2lvbiAoaWYgbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wYmtkZjIgPSBwa2NzNS5wYmtkZjIgPSBmdW5jdGlvbihcbiAgcCwgcywgYywgZGtMZW4sIG1kLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2YgbWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG1kO1xuICAgIG1kID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gaWYgcG9zc2libGUgYW5kIG5vdCBkaXNhYmxlZCwgbm90ZSB0aGF0XG4gIC8vIHNvbWUgbm9kZSB2ZXJzaW9ucyBvbmx5IHN1cHBvcnQgU0hBLTEsIG90aGVycyBhbGxvdyBkaWdlc3QgdG8gYmUgY2hhbmdlZFxuICBpZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmXG4gICAgY3J5cHRvLnBia2RmMiAmJiAobWQgPT09IG51bGwgfHwgdHlwZW9mIG1kICE9PSAnb2JqZWN0JykgJiZcbiAgICAoY3J5cHRvLnBia2RmMlN5bmMubGVuZ3RoID4gNCB8fCAoIW1kIHx8IG1kID09PSAnc2hhMScpKSkge1xuICAgIGlmKHR5cGVvZiBtZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgICBtZCA9ICdzaGExJztcbiAgICB9XG4gICAgcCA9IEJ1ZmZlci5mcm9tKHAsICdiaW5hcnknKTtcbiAgICBzID0gQnVmZmVyLmZyb20ocywgJ2JpbmFyeScpO1xuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgaWYoY3J5cHRvLnBia2RmMlN5bmMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyU3luYyhwLCBzLCBjLCBka0xlbikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuLCBtZCkudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH1cbiAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBmdW5jdGlvbihlcnIsIGtleSkge1xuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBrZXkudG9TdHJpbmcoJ2JpbmFyeScpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3J5cHRvLnBia2RmMihwLCBzLCBjLCBka0xlbiwgbWQsIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBrZXkudG9TdHJpbmcoJ2JpbmFyeScpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWQgPT09IG51bGwpIHtcbiAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgIG1kID0gJ3NoYTEnO1xuICB9XG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZighKG1kIGluIGZvcmdlLm1kLmFsZ29yaXRobXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG06ICcgKyBtZCk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIGhMZW4gPSBtZC5kaWdlc3RMZW5ndGg7XG5cbiAgLyogMS4gSWYgZGtMZW4gPiAoMl4zMiAtIDEpICogaExlbiwgb3V0cHV0IFwiZGVyaXZlZCBrZXkgdG9vIGxvbmdcIiBhbmRcbiAgICBzdG9wLiAqL1xuICBpZihka0xlbiA+ICgweEZGRkZGRkZGICogaExlbikpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdEZXJpdmVkIGtleSBpcyB0b28gbG9uZy4nKTtcbiAgICBpZihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIC8qIDIuIExldCBsZW4gYmUgdGhlIG51bWJlciBvZiBoTGVuLW9jdGV0IGJsb2NrcyBpbiB0aGUgZGVyaXZlZCBrZXksXG4gICAgcm91bmRpbmcgdXAsIGFuZCBsZXQgciBiZSB0aGUgbnVtYmVyIG9mIG9jdGV0cyBpbiB0aGUgbGFzdFxuICAgIGJsb2NrOlxuXG4gICAgbGVuID0gQ0VJTChka0xlbiAvIGhMZW4pLFxuICAgIHIgPSBka0xlbiAtIChsZW4gLSAxKSAqIGhMZW4uICovXG4gIHZhciBsZW4gPSBNYXRoLmNlaWwoZGtMZW4gLyBoTGVuKTtcbiAgdmFyIHIgPSBka0xlbiAtIChsZW4gLSAxKSAqIGhMZW47XG5cbiAgLyogMy4gRm9yIGVhY2ggYmxvY2sgb2YgdGhlIGRlcml2ZWQga2V5IGFwcGx5IHRoZSBmdW5jdGlvbiBGIGRlZmluZWRcbiAgICBiZWxvdyB0byB0aGUgcGFzc3dvcmQgUCwgdGhlIHNhbHQgUywgdGhlIGl0ZXJhdGlvbiBjb3VudCBjLCBhbmRcbiAgICB0aGUgYmxvY2sgaW5kZXggdG8gY29tcHV0ZSB0aGUgYmxvY2s6XG5cbiAgICBUXzEgPSBGKFAsIFMsIGMsIDEpLFxuICAgIFRfMiA9IEYoUCwgUywgYywgMiksXG4gICAgLi4uXG4gICAgVF9sZW4gPSBGKFAsIFMsIGMsIGxlbiksXG5cbiAgICB3aGVyZSB0aGUgZnVuY3Rpb24gRiBpcyBkZWZpbmVkIGFzIHRoZSBleGNsdXNpdmUtb3Igc3VtIG9mIHRoZVxuICAgIGZpcnN0IGMgaXRlcmF0ZXMgb2YgdGhlIHVuZGVybHlpbmcgcHNldWRvcmFuZG9tIGZ1bmN0aW9uIFBSRlxuICAgIGFwcGxpZWQgdG8gdGhlIHBhc3N3b3JkIFAgYW5kIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBzYWx0IFNcbiAgICBhbmQgdGhlIGJsb2NrIGluZGV4IGk6XG5cbiAgICBGKFAsIFMsIGMsIGkpID0gdV8xIFhPUiB1XzIgWE9SIC4uLiBYT1IgdV9jXG5cbiAgICB3aGVyZVxuXG4gICAgdV8xID0gUFJGKFAsIFMgfHwgSU5UKGkpKSxcbiAgICB1XzIgPSBQUkYoUCwgdV8xKSxcbiAgICAuLi5cbiAgICB1X2MgPSBQUkYoUCwgdV97Yy0xfSkuXG5cbiAgICBIZXJlLCBJTlQoaSkgaXMgYSBmb3VyLW9jdGV0IGVuY29kaW5nIG9mIHRoZSBpbnRlZ2VyIGksIG1vc3RcbiAgICBzaWduaWZpY2FudCBvY3RldCBmaXJzdC4gKi9cbiAgdmFyIHByZiA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gIHByZi5zdGFydChtZCwgcCk7XG4gIHZhciBkayA9ICcnO1xuICB2YXIgeG9yLCB1X2MsIHVfYzE7XG5cbiAgLy8gc3luYyB2ZXJzaW9uXG4gIGlmKCFjYWxsYmFjaykge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPD0gbGVuOyArK2kpIHtcbiAgICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICAgIHByZi51cGRhdGUocyk7XG4gICAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICAgIHhvciA9IHVfYzEgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgICAgLy8gUFJGKFAsIHVfe2MtMX0pIChvdGhlciBpdGVyYXRpb25zKVxuICAgICAgZm9yKHZhciBqID0gMjsgaiA8PSBjOyArK2opIHtcbiAgICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgICBwcmYudXBkYXRlKHVfYzEpO1xuICAgICAgICB1X2MgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgICB4b3IgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHhvciwgdV9jLCBoTGVuKTtcbiAgICAgICAgdV9jMSA9IHVfYztcbiAgICAgIH1cblxuICAgICAgLyogNC4gQ29uY2F0ZW5hdGUgdGhlIGJsb2NrcyBhbmQgZXh0cmFjdCB0aGUgZmlyc3QgZGtMZW4gb2N0ZXRzIHRvXG4gICAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgICBESyA9IFRfMSB8fCBUXzIgfHwgIC4uLiAgfHwgVF9sZW48MC4uci0xPiAqL1xuICAgICAgZGsgKz0gKGkgPCBsZW4pID8geG9yIDogeG9yLnN1YnN0cigwLCByKTtcbiAgICB9XG4gICAgLyogNS4gT3V0cHV0IHRoZSBkZXJpdmVkIGtleSBESy4gKi9cbiAgICByZXR1cm4gZGs7XG4gIH1cblxuICAvLyBhc3luYyB2ZXJzaW9uXG4gIHZhciBpID0gMSwgajtcbiAgZnVuY3Rpb24gb3V0ZXIoKSB7XG4gICAgaWYoaSA+IGxlbikge1xuICAgICAgLy8gZG9uZVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRrKTtcbiAgICB9XG5cbiAgICAvLyBQUkYoUCwgUyB8fCBJTlQoaSkpIChmaXJzdCBpdGVyYXRpb24pXG4gICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgIHByZi51cGRhdGUocyk7XG4gICAgcHJmLnVwZGF0ZShmb3JnZS51dGlsLmludDMyVG9CeXRlcyhpKSk7XG4gICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLy8gUFJGKFAsIHVfe2MtMX0pIChvdGhlciBpdGVyYXRpb25zKVxuICAgIGogPSAyO1xuICAgIGlubmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbm5lcigpIHtcbiAgICBpZihqIDw9IGMpIHtcbiAgICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICB1X2MgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgIC8vIEYocCwgcywgYywgaSlcbiAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgdV9jMSA9IHVfYztcbiAgICAgICsrajtcbiAgICAgIHJldHVybiBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShpbm5lcik7XG4gICAgfVxuXG4gICAgLyogNC4gQ29uY2F0ZW5hdGUgdGhlIGJsb2NrcyBhbmQgZXh0cmFjdCB0aGUgZmlyc3QgZGtMZW4gb2N0ZXRzIHRvXG4gICAgICBwcm9kdWNlIGEgZGVyaXZlZCBrZXkgREs6XG5cbiAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgZGsgKz0gKGkgPCBsZW4pID8geG9yIDogeG9yLnN1YnN0cigwLCByKTtcblxuICAgICsraTtcbiAgICBvdXRlcigpO1xuICB9XG5cbiAgb3V0ZXIoKTtcbn07XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwicGtjczUiLCJjcnlwdG8iLCJ1dGlsIiwiaXNOb2RlanMiLCJvcHRpb25zIiwidXNlUHVyZUphdmFTY3JpcHQiLCJtb2R1bGUiLCJleHBvcnRzIiwicGJrZGYyIiwicCIsInMiLCJjIiwiZGtMZW4iLCJtZCIsImNhbGxiYWNrIiwicGJrZGYyU3luYyIsImxlbmd0aCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsImVyciIsImtleSIsImFsZ29yaXRobXMiLCJFcnJvciIsImNyZWF0ZSIsImhMZW4iLCJkaWdlc3RMZW5ndGgiLCJsZW4iLCJNYXRoIiwiY2VpbCIsInIiLCJwcmYiLCJobWFjIiwic3RhcnQiLCJkayIsInhvciIsInVfYyIsInVfYzEiLCJpIiwidXBkYXRlIiwiaW50MzJUb0J5dGVzIiwiZGlnZXN0IiwiZ2V0Qnl0ZXMiLCJqIiwieG9yQnl0ZXMiLCJzdWJzdHIiLCJvdXRlciIsImlubmVyIiwic2V0SW1tZWRpYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/pbkdf2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/pem.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pem.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n// shortcut for pem API\nvar pem = module.exports = forge.pem = forge.pem || {};\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */ pem.encode = function(msg, options) {\n    options = options || {};\n    var rval = \"-----BEGIN \" + msg.type + \"-----\\r\\n\";\n    // encode special headers\n    var header;\n    if (msg.procType) {\n        header = {\n            name: \"Proc-Type\",\n            values: [\n                String(msg.procType.version),\n                msg.procType.type\n            ]\n        };\n        rval += foldHeader(header);\n    }\n    if (msg.contentDomain) {\n        header = {\n            name: \"Content-Domain\",\n            values: [\n                msg.contentDomain\n            ]\n        };\n        rval += foldHeader(header);\n    }\n    if (msg.dekInfo) {\n        header = {\n            name: \"DEK-Info\",\n            values: [\n                msg.dekInfo.algorithm\n            ]\n        };\n        if (msg.dekInfo.parameters) {\n            header.values.push(msg.dekInfo.parameters);\n        }\n        rval += foldHeader(header);\n    }\n    if (msg.headers) {\n        // encode all other headers\n        for(var i = 0; i < msg.headers.length; ++i){\n            rval += foldHeader(msg.headers[i]);\n        }\n    }\n    // terminate header\n    if (msg.procType) {\n        rval += \"\\r\\n\";\n    }\n    // add body\n    rval += forge.util.encode64(msg.body, options.maxline || 64) + \"\\r\\n\";\n    rval += \"-----END \" + msg.type + \"-----\\r\\n\";\n    return rval;\n};\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */ pem.decode = function(str) {\n    var rval = [];\n    // split string into PEM messages (be lenient w/EOF on BEGIN line)\n    var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n    var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n    var rCRLF = /\\r?\\n/;\n    var match;\n    while(true){\n        match = rMessage.exec(str);\n        if (!match) {\n            break;\n        }\n        // accept \"NEW CERTIFICATE REQUEST\" as \"CERTIFICATE REQUEST\"\n        // https://datatracker.ietf.org/doc/html/rfc7468#section-7\n        var type = match[1];\n        if (type === \"NEW CERTIFICATE REQUEST\") {\n            type = \"CERTIFICATE REQUEST\";\n        }\n        var msg = {\n            type: type,\n            procType: null,\n            contentDomain: null,\n            dekInfo: null,\n            headers: [],\n            body: forge.util.decode64(match[3])\n        };\n        rval.push(msg);\n        // no headers\n        if (!match[2]) {\n            continue;\n        }\n        // parse headers\n        var lines = match[2].split(rCRLF);\n        var li = 0;\n        while(match && li < lines.length){\n            // get line, trim any rhs whitespace\n            var line = lines[li].replace(/\\s+$/, \"\");\n            // RFC2822 unfold any following folded lines\n            for(var nl = li + 1; nl < lines.length; ++nl){\n                var next = lines[nl];\n                if (!/\\s/.test(next[0])) {\n                    break;\n                }\n                line += next;\n                li = nl;\n            }\n            // parse header\n            match = line.match(rHeader);\n            if (match) {\n                var header = {\n                    name: match[1],\n                    values: []\n                };\n                var values = match[2].split(\",\");\n                for(var vi = 0; vi < values.length; ++vi){\n                    header.values.push(ltrim(values[vi]));\n                }\n                // Proc-Type must be the first header\n                if (!msg.procType) {\n                    if (header.name !== \"Proc-Type\") {\n                        throw new Error(\"Invalid PEM formatted message. The first \" + 'encapsulated header must be \"Proc-Type\".');\n                    } else if (header.values.length !== 2) {\n                        throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' + \"header must have two subfields.\");\n                    }\n                    msg.procType = {\n                        version: values[0],\n                        type: values[1]\n                    };\n                } else if (!msg.contentDomain && header.name === \"Content-Domain\") {\n                    // special-case Content-Domain\n                    msg.contentDomain = values[0] || \"\";\n                } else if (!msg.dekInfo && header.name === \"DEK-Info\") {\n                    // special-case DEK-Info\n                    if (header.values.length === 0) {\n                        throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + \"header must have at least one subfield.\");\n                    }\n                    msg.dekInfo = {\n                        algorithm: values[0],\n                        parameters: values[1] || null\n                    };\n                } else {\n                    msg.headers.push(header);\n                }\n            }\n            ++li;\n        }\n        if (msg.procType === \"ENCRYPTED\" && !msg.dekInfo) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + 'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n        }\n    }\n    if (rval.length === 0) {\n        throw new Error(\"Invalid PEM formatted message.\");\n    }\n    return rval;\n};\nfunction foldHeader(header) {\n    var rval = header.name + \": \";\n    // ensure values with CRLF are folded\n    var values = [];\n    var insertSpace = function(match, $1) {\n        return \" \" + $1;\n    };\n    for(var i = 0; i < header.values.length; ++i){\n        values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n    }\n    rval += values.join(\",\") + \"\\r\\n\";\n    // do folding\n    var length = 0;\n    var candidate = -1;\n    for(var i = 0; i < rval.length; ++i, ++length){\n        if (length > 65 && candidate !== -1) {\n            var insert = rval[candidate];\n            if (insert === \",\") {\n                ++candidate;\n                rval = rval.substr(0, candidate) + \"\\r\\n \" + rval.substr(candidate);\n            } else {\n                rval = rval.substr(0, candidate) + \"\\r\\n\" + insert + rval.substr(candidate + 1);\n            }\n            length = i - candidate - 1;\n            candidate = -1;\n            ++i;\n        } else if (rval[i] === \" \" || rval[i] === \"\t\" || rval[i] === \",\") {\n            candidate = i;\n        }\n    }\n    return rval;\n}\nfunction ltrim(str) {\n    return str.replace(/^\\s+/, \"\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFFUix1QkFBdUI7QUFDdkIsSUFBSUMsTUFBTUMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxHQUFHLEdBQUdGLE1BQU1FLEdBQUcsSUFBSSxDQUFDO0FBRXJEOzs7Ozs7OztDQVFDLEdBQ0RBLElBQUlHLE1BQU0sR0FBRyxTQUFTQyxHQUFHLEVBQUVDLE9BQU87SUFDaENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJQyxPQUFPLGdCQUFnQkYsSUFBSUcsSUFBSSxHQUFHO0lBRXRDLHlCQUF5QjtJQUN6QixJQUFJQztJQUNKLElBQUdKLElBQUlLLFFBQVEsRUFBRTtRQUNmRCxTQUFTO1lBQ1BFLE1BQU07WUFDTkMsUUFBUTtnQkFBQ0MsT0FBT1IsSUFBSUssUUFBUSxDQUFDSSxPQUFPO2dCQUFHVCxJQUFJSyxRQUFRLENBQUNGLElBQUk7YUFBQztRQUMzRDtRQUNBRCxRQUFRUSxXQUFXTjtJQUNyQjtJQUNBLElBQUdKLElBQUlXLGFBQWEsRUFBRTtRQUNwQlAsU0FBUztZQUFDRSxNQUFNO1lBQWtCQyxRQUFRO2dCQUFDUCxJQUFJVyxhQUFhO2FBQUM7UUFBQTtRQUM3RFQsUUFBUVEsV0FBV047SUFDckI7SUFDQSxJQUFHSixJQUFJWSxPQUFPLEVBQUU7UUFDZFIsU0FBUztZQUFDRSxNQUFNO1lBQVlDLFFBQVE7Z0JBQUNQLElBQUlZLE9BQU8sQ0FBQ0MsU0FBUzthQUFDO1FBQUE7UUFDM0QsSUFBR2IsSUFBSVksT0FBTyxDQUFDRSxVQUFVLEVBQUU7WUFDekJWLE9BQU9HLE1BQU0sQ0FBQ1EsSUFBSSxDQUFDZixJQUFJWSxPQUFPLENBQUNFLFVBQVU7UUFDM0M7UUFDQVosUUFBUVEsV0FBV047SUFDckI7SUFFQSxJQUFHSixJQUFJZ0IsT0FBTyxFQUFFO1FBQ2QsMkJBQTJCO1FBQzNCLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJakIsSUFBSWdCLE9BQU8sQ0FBQ0UsTUFBTSxFQUFFLEVBQUVELEVBQUc7WUFDMUNmLFFBQVFRLFdBQVdWLElBQUlnQixPQUFPLENBQUNDLEVBQUU7UUFDbkM7SUFDRjtJQUVBLG1CQUFtQjtJQUNuQixJQUFHakIsSUFBSUssUUFBUSxFQUFFO1FBQ2ZILFFBQVE7SUFDVjtJQUVBLFdBQVc7SUFDWEEsUUFBUVIsTUFBTXlCLElBQUksQ0FBQ0MsUUFBUSxDQUFDcEIsSUFBSXFCLElBQUksRUFBRXBCLFFBQVFxQixPQUFPLElBQUksTUFBTTtJQUUvRHBCLFFBQVEsY0FBY0YsSUFBSUcsSUFBSSxHQUFHO0lBQ2pDLE9BQU9EO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRE4sSUFBSTJCLE1BQU0sR0FBRyxTQUFTQyxHQUFHO0lBQ3ZCLElBQUl0QixPQUFPLEVBQUU7SUFFYixrRUFBa0U7SUFDbEUsSUFBSXVCLFdBQVc7SUFDZixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUlDO0lBQ0osTUFBTSxLQUFNO1FBQ1ZBLFFBQVFILFNBQVNJLElBQUksQ0FBQ0w7UUFDdEIsSUFBRyxDQUFDSSxPQUFPO1lBQ1Q7UUFDRjtRQUVBLDREQUE0RDtRQUM1RCwwREFBMEQ7UUFDMUQsSUFBSXpCLE9BQU95QixLQUFLLENBQUMsRUFBRTtRQUNuQixJQUFHekIsU0FBUywyQkFBMkI7WUFDckNBLE9BQU87UUFDVDtRQUVBLElBQUlILE1BQU07WUFDUkcsTUFBTUE7WUFDTkUsVUFBVTtZQUNWTSxlQUFlO1lBQ2ZDLFNBQVM7WUFDVEksU0FBUyxFQUFFO1lBQ1hLLE1BQU0zQixNQUFNeUIsSUFBSSxDQUFDVyxRQUFRLENBQUNGLEtBQUssQ0FBQyxFQUFFO1FBQ3BDO1FBQ0ExQixLQUFLYSxJQUFJLENBQUNmO1FBRVYsYUFBYTtRQUNiLElBQUcsQ0FBQzRCLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDWjtRQUNGO1FBRUEsZ0JBQWdCO1FBQ2hCLElBQUlHLFFBQVFILEtBQUssQ0FBQyxFQUFFLENBQUNJLEtBQUssQ0FBQ0w7UUFDM0IsSUFBSU0sS0FBSztRQUNULE1BQU1MLFNBQVNLLEtBQUtGLE1BQU1iLE1BQU0sQ0FBRTtZQUNoQyxvQ0FBb0M7WUFDcEMsSUFBSWdCLE9BQU9ILEtBQUssQ0FBQ0UsR0FBRyxDQUFDRSxPQUFPLENBQUMsUUFBUTtZQUVyQyw0Q0FBNEM7WUFDNUMsSUFBSSxJQUFJQyxLQUFLSCxLQUFLLEdBQUdHLEtBQUtMLE1BQU1iLE1BQU0sRUFBRSxFQUFFa0IsR0FBSTtnQkFDNUMsSUFBSUMsT0FBT04sS0FBSyxDQUFDSyxHQUFHO2dCQUNwQixJQUFHLENBQUMsS0FBS0UsSUFBSSxDQUFDRCxJQUFJLENBQUMsRUFBRSxHQUFHO29CQUN0QjtnQkFDRjtnQkFDQUgsUUFBUUc7Z0JBQ1JKLEtBQUtHO1lBQ1A7WUFFQSxlQUFlO1lBQ2ZSLFFBQVFNLEtBQUtOLEtBQUssQ0FBQ0Y7WUFDbkIsSUFBR0UsT0FBTztnQkFDUixJQUFJeEIsU0FBUztvQkFBQ0UsTUFBTXNCLEtBQUssQ0FBQyxFQUFFO29CQUFFckIsUUFBUSxFQUFFO2dCQUFBO2dCQUN4QyxJQUFJQSxTQUFTcUIsS0FBSyxDQUFDLEVBQUUsQ0FBQ0ksS0FBSyxDQUFDO2dCQUM1QixJQUFJLElBQUlPLEtBQUssR0FBR0EsS0FBS2hDLE9BQU9XLE1BQU0sRUFBRSxFQUFFcUIsR0FBSTtvQkFDeENuQyxPQUFPRyxNQUFNLENBQUNRLElBQUksQ0FBQ3lCLE1BQU1qQyxNQUFNLENBQUNnQyxHQUFHO2dCQUNyQztnQkFFQSxxQ0FBcUM7Z0JBQ3JDLElBQUcsQ0FBQ3ZDLElBQUlLLFFBQVEsRUFBRTtvQkFDaEIsSUFBR0QsT0FBT0UsSUFBSSxLQUFLLGFBQWE7d0JBQzlCLE1BQU0sSUFBSW1DLE1BQU0sOENBQ2Q7b0JBQ0osT0FBTyxJQUFHckMsT0FBT0csTUFBTSxDQUFDVyxNQUFNLEtBQUssR0FBRzt3QkFDcEMsTUFBTSxJQUFJdUIsTUFBTSxvREFDZDtvQkFDSjtvQkFDQXpDLElBQUlLLFFBQVEsR0FBRzt3QkFBQ0ksU0FBU0YsTUFBTSxDQUFDLEVBQUU7d0JBQUVKLE1BQU1JLE1BQU0sQ0FBQyxFQUFFO29CQUFBO2dCQUNyRCxPQUFPLElBQUcsQ0FBQ1AsSUFBSVcsYUFBYSxJQUFJUCxPQUFPRSxJQUFJLEtBQUssa0JBQWtCO29CQUNoRSw4QkFBOEI7b0JBQzlCTixJQUFJVyxhQUFhLEdBQUdKLE1BQU0sQ0FBQyxFQUFFLElBQUk7Z0JBQ25DLE9BQU8sSUFBRyxDQUFDUCxJQUFJWSxPQUFPLElBQUlSLE9BQU9FLElBQUksS0FBSyxZQUFZO29CQUNwRCx3QkFBd0I7b0JBQ3hCLElBQUdGLE9BQU9HLE1BQU0sQ0FBQ1csTUFBTSxLQUFLLEdBQUc7d0JBQzdCLE1BQU0sSUFBSXVCLE1BQU0sbURBQ2Q7b0JBQ0o7b0JBQ0F6QyxJQUFJWSxPQUFPLEdBQUc7d0JBQUNDLFdBQVdOLE1BQU0sQ0FBQyxFQUFFO3dCQUFFTyxZQUFZUCxNQUFNLENBQUMsRUFBRSxJQUFJO29CQUFJO2dCQUNwRSxPQUFPO29CQUNMUCxJQUFJZ0IsT0FBTyxDQUFDRCxJQUFJLENBQUNYO2dCQUNuQjtZQUNGO1lBRUEsRUFBRTZCO1FBQ0o7UUFFQSxJQUFHakMsSUFBSUssUUFBUSxLQUFLLGVBQWUsQ0FBQ0wsSUFBSVksT0FBTyxFQUFFO1lBQy9DLE1BQU0sSUFBSTZCLE1BQU0sbURBQ2Q7UUFDSjtJQUNGO0lBRUEsSUFBR3ZDLEtBQUtnQixNQUFNLEtBQUssR0FBRztRQUNwQixNQUFNLElBQUl1QixNQUFNO0lBQ2xCO0lBRUEsT0FBT3ZDO0FBQ1Q7QUFFQSxTQUFTUSxXQUFXTixNQUFNO0lBQ3hCLElBQUlGLE9BQU9FLE9BQU9FLElBQUksR0FBRztJQUV6QixxQ0FBcUM7SUFDckMsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSW1DLGNBQWMsU0FBU2QsS0FBSyxFQUFFZSxFQUFFO1FBQ2xDLE9BQU8sTUFBTUE7SUFDZjtJQUNBLElBQUksSUFBSTFCLElBQUksR0FBR0EsSUFBSWIsT0FBT0csTUFBTSxDQUFDVyxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUM1Q1YsT0FBT1EsSUFBSSxDQUFDWCxPQUFPRyxNQUFNLENBQUNVLEVBQUUsQ0FBQ2tCLE9BQU8sQ0FBQyxjQUFjTztJQUNyRDtJQUNBeEMsUUFBUUssT0FBT3FDLElBQUksQ0FBQyxPQUFPO0lBRTNCLGFBQWE7SUFDYixJQUFJMUIsU0FBUztJQUNiLElBQUkyQixZQUFZLENBQUM7SUFDakIsSUFBSSxJQUFJNUIsSUFBSSxHQUFHQSxJQUFJZixLQUFLZ0IsTUFBTSxFQUFFLEVBQUVELEdBQUcsRUFBRUMsT0FBUTtRQUM3QyxJQUFHQSxTQUFTLE1BQU0yQixjQUFjLENBQUMsR0FBRztZQUNsQyxJQUFJQyxTQUFTNUMsSUFBSSxDQUFDMkMsVUFBVTtZQUM1QixJQUFHQyxXQUFXLEtBQUs7Z0JBQ2pCLEVBQUVEO2dCQUNGM0MsT0FBT0EsS0FBSzZDLE1BQU0sQ0FBQyxHQUFHRixhQUFhLFVBQVUzQyxLQUFLNkMsTUFBTSxDQUFDRjtZQUMzRCxPQUFPO2dCQUNMM0MsT0FBT0EsS0FBSzZDLE1BQU0sQ0FBQyxHQUFHRixhQUNwQixTQUFTQyxTQUFTNUMsS0FBSzZDLE1BQU0sQ0FBQ0YsWUFBWTtZQUM5QztZQUNBM0IsU0FBVUQsSUFBSTRCLFlBQVk7WUFDMUJBLFlBQVksQ0FBQztZQUNiLEVBQUU1QjtRQUNKLE9BQU8sSUFBR2YsSUFBSSxDQUFDZSxFQUFFLEtBQUssT0FBT2YsSUFBSSxDQUFDZSxFQUFFLEtBQUssT0FBUWYsSUFBSSxDQUFDZSxFQUFFLEtBQUssS0FBSztZQUNoRTRCLFlBQVk1QjtRQUNkO0lBQ0Y7SUFFQSxPQUFPZjtBQUNUO0FBRUEsU0FBU3NDLE1BQU1oQixHQUFHO0lBQ2hCLE9BQU9BLElBQUlXLE9BQU8sQ0FBQyxRQUFRO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzP2ExYjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGJhc2ljIFBFTSAoUHJpdmFjeSBFbmhhbmNlZCBNYWlsKSBhbGdvcml0aG1zLlxuICpcbiAqIFNlZTogUkZDIDE0MjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIEEgRm9yZ2UgUEVNIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gKlxuICogdHlwZTogaWRlbnRpZmllcyB0aGUgdHlwZSBvZiBtZXNzYWdlIChlZzogXCJSU0EgUFJJVkFURSBLRVlcIikuXG4gKlxuICogcHJvY1R5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgcHJvY2Vzc2luZyBwZXJmb3JtZWQgb24gdGhlIG1lc3NhZ2UsXG4gKiAgIGl0IGhhcyB0d28gc3ViZmllbGRzOiB2ZXJzaW9uIGFuZCB0eXBlLCBlZzogNCxFTkNSWVBURUQuXG4gKlxuICogY29udGVudERvbWFpbjogaWRlbnRpZmllcyB0aGUgdHlwZSBvZiBjb250ZW50IGluIHRoZSBtZXNzYWdlLCB0eXBpY2FsbHlcbiAqICAgb25seSB1c2VzIHRoZSB2YWx1ZTogXCJSRkM4MjJcIi5cbiAqXG4gKiBkZWtJbmZvOiBpZGVudGlmaWVzIHRoZSBtZXNzYWdlIGVuY3J5cHRpb24gYWxnb3JpdGhtIGFuZCBtb2RlIGFuZCBpbmNsdWRlc1xuICogICBhbnkgcGFyYW1ldGVycyBmb3IgdGhlIGFsZ29yaXRobSwgaXQgaGFzIHR3byBzdWJmaWVsZHM6IGFsZ29yaXRobSBhbmRcbiAqICAgcGFyYW1ldGVycywgZWc6IERFUy1DQkMsRjgxNDNFREU1OTYwQzU5Ny5cbiAqXG4gKiBoZWFkZXJzOiBjb250YWlucyBhbGwgb3RoZXIgUEVNIGVuY2Fwc3VsYXRlZCBoZWFkZXJzIC0tIHdoZXJlIG9yZGVyIGlzXG4gKiAgIHNpZ25pZmljYW50IChmb3IgcGFpcmluZyBkYXRhIGxpa2UgcmVjaXBpZW50IElEICsga2V5IGluZm8pLlxuICpcbiAqIGJvZHk6IHRoZSBiaW5hcnktZW5jb2RlZCBib2R5LlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gc2hvcnRjdXQgZm9yIHBlbSBBUElcbnZhciBwZW0gPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBlbSA9IGZvcmdlLnBlbSB8fCB7fTtcblxuLyoqXG4gKiBFbmNvZGVzIChzZXJpYWxpemVzKSB0aGUgZ2l2ZW4gUEVNIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbXNnIHRoZSBQRU0gbWVzc2FnZSBvYmplY3QgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lIGZvciB0aGUgYm9keSwgKGRlZmF1bHQ6IDY0KS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHN0cmluZy5cbiAqL1xucGVtLmVuY29kZSA9IGZ1bmN0aW9uKG1zZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJ2YWwgPSAnLS0tLS1CRUdJTiAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuXG4gIC8vIGVuY29kZSBzcGVjaWFsIGhlYWRlcnNcbiAgdmFyIGhlYWRlcjtcbiAgaWYobXNnLnByb2NUeXBlKSB7XG4gICAgaGVhZGVyID0ge1xuICAgICAgbmFtZTogJ1Byb2MtVHlwZScsXG4gICAgICB2YWx1ZXM6IFtTdHJpbmcobXNnLnByb2NUeXBlLnZlcnNpb24pLCBtc2cucHJvY1R5cGUudHlwZV1cbiAgICB9O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5jb250ZW50RG9tYWluKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdDb250ZW50LURvbWFpbicsIHZhbHVlczogW21zZy5jb250ZW50RG9tYWluXX07XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cbiAgaWYobXNnLmRla0luZm8pIHtcbiAgICBoZWFkZXIgPSB7bmFtZTogJ0RFSy1JbmZvJywgdmFsdWVzOiBbbXNnLmRla0luZm8uYWxnb3JpdGhtXX07XG4gICAgaWYobXNnLmRla0luZm8ucGFyYW1ldGVycykge1xuICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuXG4gIGlmKG1zZy5oZWFkZXJzKSB7XG4gICAgLy8gZW5jb2RlIGFsbCBvdGhlciBoZWFkZXJzXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5oZWFkZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBydmFsICs9IGZvbGRIZWFkZXIobXNnLmhlYWRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRlcm1pbmF0ZSBoZWFkZXJcbiAgaWYobXNnLnByb2NUeXBlKSB7XG4gICAgcnZhbCArPSAnXFxyXFxuJztcbiAgfVxuXG4gIC8vIGFkZCBib2R5XG4gIHJ2YWwgKz0gZm9yZ2UudXRpbC5lbmNvZGU2NChtc2cuYm9keSwgb3B0aW9ucy5tYXhsaW5lIHx8IDY0KSArICdcXHJcXG4nO1xuXG4gIHJ2YWwgKz0gJy0tLS0tRU5EICcgKyBtc2cudHlwZSArICctLS0tLVxcclxcbic7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIChkZXNlcmlhbGl6ZXMpIGFsbCBQRU0gbWVzc2FnZXMgZm91bmQgaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBQRU0tZm9ybWF0dGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0cyBpbiBhbiBhcnJheS5cbiAqL1xucGVtLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIHNwbGl0IHN0cmluZyBpbnRvIFBFTSBtZXNzYWdlcyAoYmUgbGVuaWVudCB3L0VPRiBvbiBCRUdJTiBsaW5lKVxuICB2YXIgck1lc3NhZ2UgPSAvXFxzKi0tLS0tQkVHSU4gKFtBLVowLTktIF0rKS0tLS0tXFxyP1xcbj8oW1xceDIxLVxceDdlXFxzXSs/KD86XFxyP1xcblxccj9cXG4pKT8oWzpBLVphLXowLTkrXFwvPVxcc10rPyktLS0tLUVORCBcXDEtLS0tLS9nO1xuICB2YXIgckhlYWRlciA9IC8oW1xceDIxLVxceDdlXSspOlxccyooW1xceDIxLVxceDdlXFxzXjpdKykvO1xuICB2YXIgckNSTEYgPSAvXFxyP1xcbi87XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUodHJ1ZSkge1xuICAgIG1hdGNoID0gck1lc3NhZ2UuZXhlYyhzdHIpO1xuICAgIGlmKCFtYXRjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYWNjZXB0IFwiTkVXIENFUlRJRklDQVRFIFJFUVVFU1RcIiBhcyBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzQ2OCNzZWN0aW9uLTdcbiAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgIGlmKHR5cGUgPT09ICdORVcgQ0VSVElGSUNBVEUgUkVRVUVTVCcpIHtcbiAgICAgIHR5cGUgPSAnQ0VSVElGSUNBVEUgUkVRVUVTVCc7XG4gICAgfVxuXG4gICAgdmFyIG1zZyA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwcm9jVHlwZTogbnVsbCxcbiAgICAgIGNvbnRlbnREb21haW46IG51bGwsXG4gICAgICBkZWtJbmZvOiBudWxsLFxuICAgICAgaGVhZGVyczogW10sXG4gICAgICBib2R5OiBmb3JnZS51dGlsLmRlY29kZTY0KG1hdGNoWzNdKVxuICAgIH07XG4gICAgcnZhbC5wdXNoKG1zZyk7XG5cbiAgICAvLyBubyBoZWFkZXJzXG4gICAgaWYoIW1hdGNoWzJdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBoZWFkZXJzXG4gICAgdmFyIGxpbmVzID0gbWF0Y2hbMl0uc3BsaXQockNSTEYpO1xuICAgIHZhciBsaSA9IDA7XG4gICAgd2hpbGUobWF0Y2ggJiYgbGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIC8vIGdldCBsaW5lLCB0cmltIGFueSByaHMgd2hpdGVzcGFjZVxuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaV0ucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG5cbiAgICAgIC8vIFJGQzI4MjIgdW5mb2xkIGFueSBmb2xsb3dpbmcgZm9sZGVkIGxpbmVzXG4gICAgICBmb3IodmFyIG5sID0gbGkgKyAxOyBubCA8IGxpbmVzLmxlbmd0aDsgKytubCkge1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVzW25sXTtcbiAgICAgICAgaWYoIS9cXHMvLnRlc3QobmV4dFswXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsaW5lICs9IG5leHQ7XG4gICAgICAgIGxpID0gbmw7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGhlYWRlclxuICAgICAgbWF0Y2ggPSBsaW5lLm1hdGNoKHJIZWFkZXIpO1xuICAgICAgaWYobWF0Y2gpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHtuYW1lOiBtYXRjaFsxXSwgdmFsdWVzOiBbXX07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYXRjaFsyXS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCB2YWx1ZXMubGVuZ3RoOyArK3ZpKSB7XG4gICAgICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKGx0cmltKHZhbHVlc1t2aV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2MtVHlwZSBtdXN0IGJlIHRoZSBmaXJzdCBoZWFkZXJcbiAgICAgICAgaWYoIW1zZy5wcm9jVHlwZSkge1xuICAgICAgICAgIGlmKGhlYWRlci5uYW1lICE9PSAnUHJvYy1UeXBlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAnZW5jYXBzdWxhdGVkIGhlYWRlciBtdXN0IGJlIFwiUHJvYy1UeXBlXCIuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmKGhlYWRlci52YWx1ZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJQcm9jLVR5cGVcIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgdHdvIHN1YmZpZWxkcy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLnByb2NUeXBlID0ge3ZlcnNpb246IHZhbHVlc1swXSwgdHlwZTogdmFsdWVzWzFdfTtcbiAgICAgICAgfSBlbHNlIGlmKCFtc2cuY29udGVudERvbWFpbiAmJiBoZWFkZXIubmFtZSA9PT0gJ0NvbnRlbnQtRG9tYWluJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwtY2FzZSBDb250ZW50LURvbWFpblxuICAgICAgICAgIG1zZy5jb250ZW50RG9tYWluID0gdmFsdWVzWzBdIHx8ICcnO1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5kZWtJbmZvICYmIGhlYWRlci5uYW1lID09PSAnREVLLUluZm8nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIERFSy1JbmZvXG4gICAgICAgICAgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgJyArXG4gICAgICAgICAgICAgICdoZWFkZXIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdWJmaWVsZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLmRla0luZm8gPSB7YWxnb3JpdGhtOiB2YWx1ZXNbMF0sIHBhcmFtZXRlcnM6IHZhbHVlc1sxXSB8fCBudWxsfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtc2cuaGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKytsaTtcbiAgICB9XG5cbiAgICBpZihtc2cucHJvY1R5cGUgPT09ICdFTkNSWVBURUQnICYmICFtc2cuZGVrSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgJ2hlYWRlciBtdXN0IGJlIHByZXNlbnQgaWYgXCJQcm9jLVR5cGVcIiBpcyBcIkVOQ1JZUFRFRFwiLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHJ2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuZnVuY3Rpb24gZm9sZEhlYWRlcihoZWFkZXIpIHtcbiAgdmFyIHJ2YWwgPSBoZWFkZXIubmFtZSArICc6ICc7XG5cbiAgLy8gZW5zdXJlIHZhbHVlcyB3aXRoIENSTEYgYXJlIGZvbGRlZFxuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpbnNlcnRTcGFjZSA9IGZ1bmN0aW9uKG1hdGNoLCAkMSkge1xuICAgIHJldHVybiAnICcgKyAkMTtcbiAgfTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGhlYWRlci52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YWx1ZXMucHVzaChoZWFkZXIudmFsdWVzW2ldLnJlcGxhY2UoL14oXFxTK1xcclxcbikvLCBpbnNlcnRTcGFjZSkpO1xuICB9XG4gIHJ2YWwgKz0gdmFsdWVzLmpvaW4oJywnKSArICdcXHJcXG4nO1xuXG4gIC8vIGRvIGZvbGRpbmdcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBjYW5kaWRhdGUgPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHJ2YWwubGVuZ3RoOyArK2ksICsrbGVuZ3RoKSB7XG4gICAgaWYobGVuZ3RoID4gNjUgJiYgY2FuZGlkYXRlICE9PSAtMSkge1xuICAgICAgdmFyIGluc2VydCA9IHJ2YWxbY2FuZGlkYXRlXTtcbiAgICAgIGlmKGluc2VydCA9PT0gJywnKSB7XG4gICAgICAgICsrY2FuZGlkYXRlO1xuICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArICdcXHJcXG4gJyArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArXG4gICAgICAgICAgJ1xcclxcbicgKyBpbnNlcnQgKyBydmFsLnN1YnN0cihjYW5kaWRhdGUgKyAxKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IChpIC0gY2FuZGlkYXRlIC0gMSk7XG4gICAgICBjYW5kaWRhdGUgPSAtMTtcbiAgICAgICsraTtcbiAgICB9IGVsc2UgaWYocnZhbFtpXSA9PT0gJyAnIHx8IHJ2YWxbaV0gPT09ICdcXHQnIHx8IHJ2YWxbaV0gPT09ICcsJykge1xuICAgICAgY2FuZGlkYXRlID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuZnVuY3Rpb24gbHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJyk7XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwicGVtIiwibW9kdWxlIiwiZXhwb3J0cyIsImVuY29kZSIsIm1zZyIsIm9wdGlvbnMiLCJydmFsIiwidHlwZSIsImhlYWRlciIsInByb2NUeXBlIiwibmFtZSIsInZhbHVlcyIsIlN0cmluZyIsInZlcnNpb24iLCJmb2xkSGVhZGVyIiwiY29udGVudERvbWFpbiIsImRla0luZm8iLCJhbGdvcml0aG0iLCJwYXJhbWV0ZXJzIiwicHVzaCIsImhlYWRlcnMiLCJpIiwibGVuZ3RoIiwidXRpbCIsImVuY29kZTY0IiwiYm9keSIsIm1heGxpbmUiLCJkZWNvZGUiLCJzdHIiLCJyTWVzc2FnZSIsInJIZWFkZXIiLCJyQ1JMRiIsIm1hdGNoIiwiZXhlYyIsImRlY29kZTY0IiwibGluZXMiLCJzcGxpdCIsImxpIiwibGluZSIsInJlcGxhY2UiLCJubCIsIm5leHQiLCJ0ZXN0IiwidmkiLCJsdHJpbSIsIkVycm9yIiwiaW5zZXJ0U3BhY2UiLCIkMSIsImpvaW4iLCJjYW5kaWRhdGUiLCJpbnNlcnQiLCJzdWJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/pem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/pkcs1.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs1.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Partial implementation of PKCS#1 v2.2: RSA-OEAP\n *\n * Modified but based on the following MIT and BSD licensed code:\n *\n * https://github.com/kjur/jsjws/blob/master/rsa.js:\n *\n * The 'jsjws'(JSON Web Signature JavaScript Library) License\n *\n * Copyright (c) 2012 Kenji Urushima\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\n *\n * RSAES-OAEP.js\n * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\n * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\n * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\n * Contact: ellis@nukinetics.com\n * Distributed under the BSD License.\n *\n * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\n *\n * @author Evan Jones (http://evanjones.ca/)\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./sha1 */ \"(ssr)/./node_modules/node-forge/lib/sha1.js\");\n// shortcut for PKCS#1 API\nvar pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\n/**\n * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\n * and seed.\n *\n * This method does not perform RSA encryption, it only encodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param message the message to encode.\n * @param options the options to use:\n *          label an optional label to use.\n *          seed the seed to use.\n *          md the message digest object to use, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the encoded message bytes.\n */ pkcs1.encode_rsa_oaep = function(key, message, options) {\n    // parse arguments\n    var label;\n    var seed;\n    var md;\n    var mgf1Md;\n    // legacy args (label, seed, md)\n    if (typeof options === \"string\") {\n        label = options;\n        seed = arguments[3] || undefined;\n        md = arguments[4] || undefined;\n    } else if (options) {\n        label = options.label || undefined;\n        seed = options.seed || undefined;\n        md = options.md || undefined;\n        if (options.mgf1 && options.mgf1.md) {\n            mgf1Md = options.mgf1.md;\n        }\n    }\n    // default OAEP to SHA-1 message digest\n    if (!md) {\n        md = forge.md.sha1.create();\n    } else {\n        md.start();\n    }\n    // default MGF-1 to same as OAEP\n    if (!mgf1Md) {\n        mgf1Md = md;\n    }\n    // compute length in bytes and check output\n    var keyLength = Math.ceil(key.n.bitLength() / 8);\n    var maxLength = keyLength - 2 * md.digestLength - 2;\n    if (message.length > maxLength) {\n        var error = new Error(\"RSAES-OAEP input message length is too long.\");\n        error.length = message.length;\n        error.maxLength = maxLength;\n        throw error;\n    }\n    if (!label) {\n        label = \"\";\n    }\n    md.update(label, \"raw\");\n    var lHash = md.digest();\n    var PS = \"\";\n    var PS_length = maxLength - message.length;\n    for(var i = 0; i < PS_length; i++){\n        PS += \"\\x00\";\n    }\n    var DB = lHash.getBytes() + PS + \"\\x01\" + message;\n    if (!seed) {\n        seed = forge.random.getBytes(md.digestLength);\n    } else if (seed.length !== md.digestLength) {\n        var error = new Error(\"Invalid RSAES-OAEP seed. The seed length must \" + \"match the digest length.\");\n        error.seedLength = seed.length;\n        error.digestLength = md.digestLength;\n        throw error;\n    }\n    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n    var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\n    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n    var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\n    // return encoded message\n    return \"\\x00\" + maskedSeed + maskedDB;\n};\n/**\n * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\n * label (L).\n *\n * This method does not perform RSA decryption, it only decodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param em the encoded message to decode.\n * @param options the options to use:\n *          label an optional label to use.\n *          md the message digest object to use for OAEP, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the decoded message bytes.\n */ pkcs1.decode_rsa_oaep = function(key, em, options) {\n    // parse args\n    var label;\n    var md;\n    var mgf1Md;\n    // legacy args\n    if (typeof options === \"string\") {\n        label = options;\n        md = arguments[3] || undefined;\n    } else if (options) {\n        label = options.label || undefined;\n        md = options.md || undefined;\n        if (options.mgf1 && options.mgf1.md) {\n            mgf1Md = options.mgf1.md;\n        }\n    }\n    // compute length in bytes\n    var keyLength = Math.ceil(key.n.bitLength() / 8);\n    if (em.length !== keyLength) {\n        var error = new Error(\"RSAES-OAEP encoded message length is invalid.\");\n        error.length = em.length;\n        error.expectedLength = keyLength;\n        throw error;\n    }\n    // default OAEP to SHA-1 message digest\n    if (md === undefined) {\n        md = forge.md.sha1.create();\n    } else {\n        md.start();\n    }\n    // default MGF-1 to same as OAEP\n    if (!mgf1Md) {\n        mgf1Md = md;\n    }\n    if (keyLength < 2 * md.digestLength + 2) {\n        throw new Error(\"RSAES-OAEP key is too short for the hash function.\");\n    }\n    if (!label) {\n        label = \"\";\n    }\n    md.update(label, \"raw\");\n    var lHash = md.digest().getBytes();\n    // split the message into its parts\n    var y = em.charAt(0);\n    var maskedSeed = em.substring(1, md.digestLength + 1);\n    var maskedDB = em.substring(1 + md.digestLength);\n    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n    var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\n    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n    var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\n    var lHashPrime = db.substring(0, md.digestLength);\n    // constant time check that all values match what is expected\n    var error = y !== \"\\x00\";\n    // constant time check lHash vs lHashPrime\n    for(var i = 0; i < md.digestLength; ++i){\n        error |= lHash.charAt(i) !== lHashPrime.charAt(i);\n    }\n    // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\n    // message\n    // TODO: It must be possible to do this in a better/smarter way?\n    var in_ps = 1;\n    var index = md.digestLength;\n    for(var j = md.digestLength; j < db.length; j++){\n        var code = db.charCodeAt(j);\n        var is_0 = code & 0x1 ^ 0x1;\n        // non-zero if not 0 or 1 in the ps section\n        var error_mask = in_ps ? 0xfffe : 0x0000;\n        error |= code & error_mask;\n        // latch in_ps to zero after we find 0x1\n        in_ps = in_ps & is_0;\n        index += in_ps;\n    }\n    if (error || db.charCodeAt(index) !== 0x1) {\n        throw new Error(\"Invalid RSAES-OAEP padding.\");\n    }\n    return db.substring(index + 1);\n};\nfunction rsa_mgf1(seed, maskLength, hash) {\n    // default to SHA-1 message digest\n    if (!hash) {\n        hash = forge.md.sha1.create();\n    }\n    var t = \"\";\n    var count = Math.ceil(maskLength / hash.digestLength);\n    for(var i = 0; i < count; ++i){\n        var c = String.fromCharCode(i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF);\n        hash.start();\n        hash.update(seed + c);\n        t += hash.digest().getBytes();\n    }\n    return t.substring(0, maskLength);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsMEJBQTBCO0FBQzFCLElBQUlDLFFBQVFDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLElBQUksQ0FBQztBQUUzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDREEsTUFBTUcsZUFBZSxHQUFHLFNBQVNDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQ3BELGtCQUFrQjtJQUNsQixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLGdDQUFnQztJQUNoQyxJQUFHLE9BQU9KLFlBQVksVUFBVTtRQUM5QkMsUUFBUUQ7UUFDUkUsT0FBT0csU0FBUyxDQUFDLEVBQUUsSUFBSUM7UUFDdkJILEtBQUtFLFNBQVMsQ0FBQyxFQUFFLElBQUlDO0lBQ3ZCLE9BQU8sSUFBR04sU0FBUztRQUNqQkMsUUFBUUQsUUFBUUMsS0FBSyxJQUFJSztRQUN6QkosT0FBT0YsUUFBUUUsSUFBSSxJQUFJSTtRQUN2QkgsS0FBS0gsUUFBUUcsRUFBRSxJQUFJRztRQUNuQixJQUFHTixRQUFRTyxJQUFJLElBQUlQLFFBQVFPLElBQUksQ0FBQ0osRUFBRSxFQUFFO1lBQ2xDQyxTQUFTSixRQUFRTyxJQUFJLENBQUNKLEVBQUU7UUFDMUI7SUFDRjtJQUVBLHVDQUF1QztJQUN2QyxJQUFHLENBQUNBLElBQUk7UUFDTkEsS0FBS1gsTUFBTVcsRUFBRSxDQUFDSyxJQUFJLENBQUNDLE1BQU07SUFDM0IsT0FBTztRQUNMTixHQUFHTyxLQUFLO0lBQ1Y7SUFFQSxnQ0FBZ0M7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MkIsRUFBRVosU0FBUyxDQUFDLEdBQUdVO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEuanM/OTU2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxIHYyLjI6IFJTQS1PRUFQXG4gKlxuICogTW9kaWZpZWQgYnV0IGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgTUlUIGFuZCBCU0QgbGljZW5zZWQgY29kZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20va2p1ci9qc2p3cy9ibG9iL21hc3Rlci9yc2EuanM6XG4gKlxuICogVGhlICdqc2p3cycoSlNPTiBXZWIgU2lnbmF0dXJlIEphdmFTY3JpcHQgTGlicmFyeSkgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBLZW5qaSBVcnVzaGltYVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogaHR0cDovL3dlYnJzYS5jdnMuc291cmNlZm9yZ2UubmV0L3ZpZXd2Yy93ZWJyc2EvQ2xpZW50L1JTQUVTLU9BRVAuanM/Y29udGVudC10eXBlPXRleHQlMkZwbGFpbjpcbiAqXG4gKiBSU0FFUy1PQUVQLmpzXG4gKiAkSWQ6IFJTQUVTLU9BRVAuanMsdiAxLjEuMS4xIDIwMDMvMDMvMTkgMTU6Mzc6MjAgZWxsaXNwcml0Y2hhcmQgRXhwICRcbiAqIEphdmFTY3JpcHQgSW1wbGVtZW50YXRpb24gb2YgUEtDUyAjMSB2Mi4xIFJTQSBDUllQVE9HUkFQSFkgU1RBTkRBUkQgKFJTQSBMYWJvcmF0b3JpZXMsIEp1bmUgMTQsIDIwMDIpXG4gKiBDb3B5cmlnaHQgKEMpIEVsbGlzIFByaXRjaGFyZCwgR3VhcmRpYW4gVW5saW1pdGVkIDIwMDMuXG4gKiBDb250YWN0OiBlbGxpc0BudWtpbmV0aWNzLmNvbVxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuICpcbiAqIE9mZmljaWFsIGRvY3VtZW50YXRpb246IGh0dHA6Ly93d3cucnNhLmNvbS9yc2FsYWJzL25vZGUuYXNwP2lkPTIxMjVcbiAqXG4gKiBAYXV0aG9yIEV2YW4gSm9uZXMgKGh0dHA6Ly9ldmFuam9uZXMuY2EvKVxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5yZXF1aXJlKCcuL3NoYTEnKTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjMSBBUElcbnZhciBwa2NzMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczEgPSBmb3JnZS5wa2NzMSB8fCB7fTtcblxuLyoqXG4gKiBFbmNvZGUgdGhlIGdpdmVuIFJTQUVTLU9BRVAgbWVzc2FnZSAoTSkgdXNpbmcga2V5LCB3aXRoIG9wdGlvbmFsIGxhYmVsIChMKVxuICogYW5kIHNlZWQuXG4gKlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgcGVyZm9ybSBSU0EgZW5jcnlwdGlvbiwgaXQgb25seSBlbmNvZGVzIHRoZSBtZXNzYWdlXG4gKiB1c2luZyBSU0FFUy1PQUVQLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgbGFiZWwgYW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlLlxuICogICAgICAgICAgc2VlZCB0aGUgc2VlZCB0byB1c2UuXG4gKiAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSwgdW5kZWZpbmVkIGZvciBTSEEtMS5cbiAqICAgICAgICAgIG1nZjEgb3B0aW9uYWwgbWdmMSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSBmb3IgTUdGMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgYnl0ZXMuXG4gKi9cbnBrY3MxLmVuY29kZV9yc2Ffb2FlcCA9IGZ1bmN0aW9uKGtleSwgbWVzc2FnZSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmd1bWVudHNcbiAgdmFyIGxhYmVsO1xuICB2YXIgc2VlZDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJncyAobGFiZWwsIHNlZWQsIG1kKVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgc2VlZCA9IGFyZ3VtZW50c1szXSB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBhcmd1bWVudHNbNF0gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgc2VlZCA9IG9wdGlvbnMuc2VlZCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVmYXVsdCBPQUVQIHRvIFNIQS0xIG1lc3NhZ2UgZGlnZXN0XG4gIGlmKCFtZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXMgYW5kIGNoZWNrIG91dHB1dFxuICB2YXIga2V5TGVuZ3RoID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gIHZhciBtYXhMZW5ndGggPSBrZXlMZW5ndGggLSAyICogbWQuZGlnZXN0TGVuZ3RoIC0gMjtcbiAgaWYobWVzc2FnZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAgaW5wdXQgbWVzc2FnZSBsZW5ndGggaXMgdG9vIGxvbmcuJyk7XG4gICAgZXJyb3IubGVuZ3RoID0gbWVzc2FnZS5sZW5ndGg7XG4gICAgZXJyb3IubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYoIWxhYmVsKSB7XG4gICAgbGFiZWwgPSAnJztcbiAgfVxuICBtZC51cGRhdGUobGFiZWwsICdyYXcnKTtcbiAgdmFyIGxIYXNoID0gbWQuZGlnZXN0KCk7XG5cbiAgdmFyIFBTID0gJyc7XG4gIHZhciBQU19sZW5ndGggPSBtYXhMZW5ndGggLSBtZXNzYWdlLmxlbmd0aDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IFBTX2xlbmd0aDsgaSsrKSB7XG4gICAgUFMgKz0gJ1xceDAwJztcbiAgfVxuXG4gIHZhciBEQiA9IGxIYXNoLmdldEJ5dGVzKCkgKyBQUyArICdcXHgwMScgKyBtZXNzYWdlO1xuXG4gIGlmKCFzZWVkKSB7XG4gICAgc2VlZCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhtZC5kaWdlc3RMZW5ndGgpO1xuICB9IGVsc2UgaWYoc2VlZC5sZW5ndGggIT09IG1kLmRpZ2VzdExlbmd0aCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHNlZWQuIFRoZSBzZWVkIGxlbmd0aCBtdXN0ICcgK1xuICAgICAgJ21hdGNoIHRoZSBkaWdlc3QgbGVuZ3RoLicpO1xuICAgIGVycm9yLnNlZWRMZW5ndGggPSBzZWVkLmxlbmd0aDtcbiAgICBlcnJvci5kaWdlc3RMZW5ndGggPSBtZC5kaWdlc3RMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICB2YXIgZGJNYXNrID0gcnNhX21nZjEoc2VlZCwga2V5TGVuZ3RoIC0gbWQuZGlnZXN0TGVuZ3RoIC0gMSwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZERCID0gZm9yZ2UudXRpbC54b3JCeXRlcyhEQiwgZGJNYXNrLCBEQi5sZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBtYXNrZWRTZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhzZWVkLCBzZWVkTWFzaywgc2VlZC5sZW5ndGgpO1xuXG4gIC8vIHJldHVybiBlbmNvZGVkIG1lc3NhZ2VcbiAgcmV0dXJuICdcXHgwMCcgKyBtYXNrZWRTZWVkICsgbWFza2VkREI7XG59O1xuXG4vKipcbiAqIERlY29kZSB0aGUgZ2l2ZW4gUlNBRVMtT0FFUCBlbmNvZGVkIG1lc3NhZ2UgKEVNKSB1c2luZyBrZXksIHdpdGggb3B0aW9uYWxcbiAqIGxhYmVsIChMKS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBwZXJmb3JtIFJTQSBkZWNyeXB0aW9uLCBpdCBvbmx5IGRlY29kZXMgdGhlIG1lc3NhZ2VcbiAqIHVzaW5nIFJTQUVTLU9BRVAuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gZW0gdGhlIGVuY29kZWQgbWVzc2FnZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBsYWJlbCBhbiBvcHRpb25hbCBsYWJlbCB0byB1c2UuXG4gKiAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSBmb3IgT0FFUCwgdW5kZWZpbmVkIGZvciBTSEEtMS5cbiAqICAgICAgICAgIG1nZjEgb3B0aW9uYWwgbWdmMSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSBmb3IgTUdGMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNvZGVkIG1lc3NhZ2UgYnl0ZXMuXG4gKi9cbnBrY3MxLmRlY29kZV9yc2Ffb2FlcCA9IGZ1bmN0aW9uKGtleSwgZW0sIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJnc1xuICB2YXIgbGFiZWw7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3NcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIG1kID0gYXJndW1lbnRzWzNdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzXG4gIHZhciBrZXlMZW5ndGggPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICBpZihlbS5sZW5ndGggIT09IGtleUxlbmd0aCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUlNBRVMtT0FFUCBlbmNvZGVkIG1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWQuJyk7XG4gICAgZXJyb3IubGVuZ3RoID0gZW0ubGVuZ3RoO1xuICAgIGVycm9yLmV4cGVjdGVkTGVuZ3RoID0ga2V5TGVuZ3RoO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBPQUVQIHRvIFNIQS0xIG1lc3NhZ2UgZGlnZXN0XG4gIGlmKG1kID09PSB1bmRlZmluZWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIGlmKGtleUxlbmd0aCA8IDIgKiBtZC5kaWdlc3RMZW5ndGggKyAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSU0FFUy1PQUVQIGtleSBpcyB0b28gc2hvcnQgZm9yIHRoZSBoYXNoIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgaWYoIWxhYmVsKSB7XG4gICAgbGFiZWwgPSAnJztcbiAgfVxuICBtZC51cGRhdGUobGFiZWwsICdyYXcnKTtcbiAgdmFyIGxIYXNoID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAvLyBzcGxpdCB0aGUgbWVzc2FnZSBpbnRvIGl0cyBwYXJ0c1xuICB2YXIgeSA9IGVtLmNoYXJBdCgwKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBlbS5zdWJzdHJpbmcoMSwgbWQuZGlnZXN0TGVuZ3RoICsgMSk7XG4gIHZhciBtYXNrZWREQiA9IGVtLnN1YnN0cmluZygxICsgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICB2YXIgc2VlZE1hc2sgPSByc2FfbWdmMShtYXNrZWREQiwgbWQuZGlnZXN0TGVuZ3RoLCBtZ2YxTWQpO1xuICB2YXIgc2VlZCA9IGZvcmdlLnV0aWwueG9yQnl0ZXMobWFza2VkU2VlZCwgc2VlZE1hc2ssIG1hc2tlZFNlZWQubGVuZ3RoKTtcblxuICB2YXIgZGJNYXNrID0gcnNhX21nZjEoc2VlZCwga2V5TGVuZ3RoIC0gbWQuZGlnZXN0TGVuZ3RoIC0gMSwgbWdmMU1kKTtcbiAgdmFyIGRiID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWREQiwgZGJNYXNrLCBtYXNrZWREQi5sZW5ndGgpO1xuXG4gIHZhciBsSGFzaFByaW1lID0gZGIuc3Vic3RyaW5nKDAsIG1kLmRpZ2VzdExlbmd0aCk7XG5cbiAgLy8gY29uc3RhbnQgdGltZSBjaGVjayB0aGF0IGFsbCB2YWx1ZXMgbWF0Y2ggd2hhdCBpcyBleHBlY3RlZFxuICB2YXIgZXJyb3IgPSAoeSAhPT0gJ1xceDAwJyk7XG5cbiAgLy8gY29uc3RhbnQgdGltZSBjaGVjayBsSGFzaCB2cyBsSGFzaFByaW1lXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5kaWdlc3RMZW5ndGg7ICsraSkge1xuICAgIGVycm9yIHw9IChsSGFzaC5jaGFyQXQoaSkgIT09IGxIYXNoUHJpbWUuY2hhckF0KGkpKTtcbiAgfVxuXG4gIC8vIFwiY29uc3RhbnQgdGltZVwiIGZpbmQgdGhlIDB4MSBieXRlIHNlcGFyYXRpbmcgdGhlIHBhZGRpbmcgKHplcm9zKSBmcm9tIHRoZVxuICAvLyBtZXNzYWdlXG4gIC8vIFRPRE86IEl0IG11c3QgYmUgcG9zc2libGUgdG8gZG8gdGhpcyBpbiBhIGJldHRlci9zbWFydGVyIHdheT9cbiAgdmFyIGluX3BzID0gMTtcbiAgdmFyIGluZGV4ID0gbWQuZGlnZXN0TGVuZ3RoO1xuICBmb3IodmFyIGogPSBtZC5kaWdlc3RMZW5ndGg7IGogPCBkYi5sZW5ndGg7IGorKykge1xuICAgIHZhciBjb2RlID0gZGIuY2hhckNvZGVBdChqKTtcblxuICAgIHZhciBpc18wID0gKGNvZGUgJiAweDEpIF4gMHgxO1xuXG4gICAgLy8gbm9uLXplcm8gaWYgbm90IDAgb3IgMSBpbiB0aGUgcHMgc2VjdGlvblxuICAgIHZhciBlcnJvcl9tYXNrID0gaW5fcHMgPyAweGZmZmUgOiAweDAwMDA7XG4gICAgZXJyb3IgfD0gKGNvZGUgJiBlcnJvcl9tYXNrKTtcblxuICAgIC8vIGxhdGNoIGluX3BzIHRvIHplcm8gYWZ0ZXIgd2UgZmluZCAweDFcbiAgICBpbl9wcyA9IGluX3BzICYgaXNfMDtcbiAgICBpbmRleCArPSBpbl9wcztcbiAgfVxuXG4gIGlmKGVycm9yIHx8IGRiLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUlNBRVMtT0FFUCBwYWRkaW5nLicpO1xuICB9XG5cbiAgcmV0dXJuIGRiLnN1YnN0cmluZyhpbmRleCArIDEpO1xufTtcblxuZnVuY3Rpb24gcnNhX21nZjEoc2VlZCwgbWFza0xlbmd0aCwgaGFzaCkge1xuICAvLyBkZWZhdWx0IHRvIFNIQS0xIG1lc3NhZ2UgZGlnZXN0XG4gIGlmKCFoYXNoKSB7XG4gICAgaGFzaCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH1cbiAgdmFyIHQgPSAnJztcbiAgdmFyIGNvdW50ID0gTWF0aC5jZWlsKG1hc2tMZW5ndGggLyBoYXNoLmRpZ2VzdExlbmd0aCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgKGkgPj4gMjQpICYgMHhGRiwgKGkgPj4gMTYpICYgMHhGRiwgKGkgPj4gOCkgJiAweEZGLCBpICYgMHhGRik7XG4gICAgaGFzaC5zdGFydCgpO1xuICAgIGhhc2gudXBkYXRlKHNlZWQgKyBjKTtcbiAgICB0ICs9IGhhc2guZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgfVxuICByZXR1cm4gdC5zdWJzdHJpbmcoMCwgbWFza0xlbmd0aCk7XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwicGtjczEiLCJtb2R1bGUiLCJleHBvcnRzIiwiZW5jb2RlX3JzYV9vYWVwIiwia2V5IiwibWVzc2FnZSIsIm9wdGlvbnMiLCJsYWJlbCIsInNlZWQiLCJtZCIsIm1nZjFNZCIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm1nZjEiLCJzaGExIiwiY3JlYXRlIiwic3RhcnQiLCJrZXlMZW5ndGgiLCJNYXRoIiwiY2VpbCIsIm4iLCJiaXRMZW5ndGgiLCJtYXhMZW5ndGgiLCJkaWdlc3RMZW5ndGgiLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwidXBkYXRlIiwibEhhc2giLCJkaWdlc3QiLCJQUyIsIlBTX2xlbmd0aCIsImkiLCJEQiIsImdldEJ5dGVzIiwicmFuZG9tIiwic2VlZExlbmd0aCIsImRiTWFzayIsInJzYV9tZ2YxIiwibWFza2VkREIiLCJ1dGlsIiwieG9yQnl0ZXMiLCJzZWVkTWFzayIsIm1hc2tlZFNlZWQiLCJkZWNvZGVfcnNhX29hZXAiLCJlbSIsImV4cGVjdGVkTGVuZ3RoIiwieSIsImNoYXJBdCIsInN1YnN0cmluZyIsImRiIiwibEhhc2hQcmltZSIsImluX3BzIiwiaW5kZXgiLCJqIiwiY29kZSIsImNoYXJDb2RlQXQiLCJpc18wIiwiZXJyb3JfbWFzayIsIm1hc2tMZW5ndGgiLCJoYXNoIiwidCIsImNvdW50IiwiYyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/pkcs1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/prime.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/prime.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Prime number generation API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./jsbn */ \"(ssr)/./node_modules/node-forge/lib/jsbn.js\");\n__webpack_require__(/*! ./random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n(function() {\n    // forge.prime already defined\n    if (forge.prime) {\n        module.exports = forge.prime;\n        return;\n    }\n    /* PRIME API */ var prime = module.exports = forge.prime = forge.prime || {};\n    var BigInteger = forge.jsbn.BigInteger;\n    // primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\n    var GCD_30_DELTA = [\n        6,\n        4,\n        2,\n        4,\n        2,\n        4,\n        6,\n        2\n    ];\n    var THIRTY = new BigInteger(null);\n    THIRTY.fromInt(30);\n    var op_or = function(x, y) {\n        return x | y;\n    };\n    /**\n * Generates a random probable prime with the given number of bits.\n *\n * Alternative algorithms can be specified by name as a string or as an\n * object with custom options like so:\n *\n * {\n *   name: 'PRIMEINC',\n *   options: {\n *     maxBlockTime: <the maximum amount of time to block the main\n *       thread before allowing I/O other JS to run>,\n *     millerRabinTests: <the number of miller-rabin tests to run>,\n *     workerScript: <the worker script URL>,\n *     workers: <the number of web workers (if supported) to use,\n *       -1 to use estimated cores minus one>.\n *     workLoad: the size of the work load, ie: number of possible prime\n *       numbers for each web worker to check per work assignment,\n *       (default: 100).\n *   }\n * }\n *\n * @param bits the number of bits for the prime number.\n * @param options the options to use.\n *          [algorithm] the algorithm to use (default: 'PRIMEINC').\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *\n * @return callback(err, num) called once the operation completes.\n */ prime.generateProbablePrime = function(bits, options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        options = options || {};\n        // default to PRIMEINC algorithm\n        var algorithm = options.algorithm || \"PRIMEINC\";\n        if (typeof algorithm === \"string\") {\n            algorithm = {\n                name: algorithm\n            };\n        }\n        algorithm.options = algorithm.options || {};\n        // create prng with api that matches BigInteger secure random\n        var prng = options.prng || forge.random;\n        var rng = {\n            // x is an array to fill with bytes\n            nextBytes: function(x) {\n                var b = prng.getBytesSync(x.length);\n                for(var i = 0; i < x.length; ++i){\n                    x[i] = b.charCodeAt(i);\n                }\n            }\n        };\n        if (algorithm.name === \"PRIMEINC\") {\n            return primeincFindPrime(bits, rng, algorithm.options, callback);\n        }\n        throw new Error(\"Invalid prime generation algorithm: \" + algorithm.name);\n    };\n    function primeincFindPrime(bits, rng, options, callback) {\n        if (\"workers\" in options) {\n            return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n        }\n        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n    }\n    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n        // initialize random number\n        var num = generateRandom(bits, rng);\n        /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\n  number we are given is always aligned at 30k + 1. Each time the number is\n  determined not to be prime we add to get to the next 'i', eg: if the number\n  was at 30k + 1 we add 6. */ var deltaIdx = 0;\n        // get required number of MR tests\n        var mrTests = getMillerRabinTests(num.bitLength());\n        if (\"millerRabinTests\" in options) {\n            mrTests = options.millerRabinTests;\n        }\n        // find prime nearest to 'num' for maxBlockTime ms\n        // 10 ms gives 5ms of leeway for other calculations before dropping\n        // below 60fps (1000/60 == 16.67), but in reality, the number will\n        // likely be higher due to an 'atomic' big int modPow\n        var maxBlockTime = 10;\n        if (\"maxBlockTime\" in options) {\n            maxBlockTime = options.maxBlockTime;\n        }\n        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n    }\n    function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n        var start = +new Date();\n        do {\n            // overflow, regenerate random number\n            if (num.bitLength() > bits) {\n                num = generateRandom(bits, rng);\n            }\n            // do primality test\n            if (num.isProbablePrime(mrTests)) {\n                return callback(null, num);\n            }\n            // get next potential prime\n            num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n        }while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);\n        // keep trying later\n        forge.util.setImmediate(function() {\n            _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n        });\n    }\n    // NOTE: This algorithm is indeterminate in nature because workers\n    // run in parallel looking at different segments of numbers. Even if this\n    // algorithm is run twice with the same input from a predictable RNG, it\n    // may produce different outputs.\n    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n        // web workers unavailable\n        if (typeof Worker === \"undefined\") {\n            return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n        }\n        // initialize random number\n        var num = generateRandom(bits, rng);\n        // use web workers to generate keys\n        var numWorkers = options.workers;\n        var workLoad = options.workLoad || 100;\n        var range = workLoad * 30 / 8;\n        var workerScript = options.workerScript || \"forge/prime.worker.js\";\n        if (numWorkers === -1) {\n            return forge.util.estimateCores(function(err, cores) {\n                if (err) {\n                    // default to 2\n                    cores = 2;\n                }\n                numWorkers = cores - 1;\n                generate();\n            });\n        }\n        generate();\n        function generate() {\n            // require at least 1 worker\n            numWorkers = Math.max(1, numWorkers);\n            // TODO: consider optimizing by starting workers outside getPrime() ...\n            // note that in order to clean up they will have to be made internally\n            // asynchronous which may actually be slower\n            // start workers immediately\n            var workers = [];\n            for(var i = 0; i < numWorkers; ++i){\n                // FIXME: fix path or use blob URLs\n                workers[i] = new Worker(workerScript);\n            }\n            var running = numWorkers;\n            // listen for requests from workers and assign ranges to find prime\n            for(var i = 0; i < numWorkers; ++i){\n                workers[i].addEventListener(\"message\", workerMessage);\n            }\n            /* Note: The distribution of random numbers is unknown. Therefore, each\n    web worker is continuously allocated a range of numbers to check for a\n    random number until one is found.\n\n    Every 30 numbers will be checked just 8 times, because prime numbers\n    have the form:\n\n    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\n\n    Therefore, if we want a web worker to run N checks before asking for\n    a new range of numbers, each range must contain N*30/8 numbers.\n\n    For 100 checks (workLoad), this is a range of 375. */ var found = false;\n            function workerMessage(e) {\n                // ignore message, prime already found\n                if (found) {\n                    return;\n                }\n                --running;\n                var data = e.data;\n                if (data.found) {\n                    // terminate all workers\n                    for(var i = 0; i < workers.length; ++i){\n                        workers[i].terminate();\n                    }\n                    found = true;\n                    return callback(null, new BigInteger(data.prime, 16));\n                }\n                // overflow, regenerate random number\n                if (num.bitLength() > bits) {\n                    num = generateRandom(bits, rng);\n                }\n                // assign new range to check\n                var hex = num.toString(16);\n                // start prime search\n                e.target.postMessage({\n                    hex: hex,\n                    workLoad: workLoad\n                });\n                num.dAddOffset(range, 0);\n            }\n        }\n    }\n    /**\n * Generates a random number using the given number of bits and RNG.\n *\n * @param bits the number of bits for the number.\n * @param rng the random number generator to use.\n *\n * @return the random number.\n */ function generateRandom(bits, rng) {\n        var num = new BigInteger(bits, rng);\n        // force MSB set\n        var bits1 = bits - 1;\n        if (!num.testBit(bits1)) {\n            num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n        }\n        // align number on 30k+1 boundary\n        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n        return num;\n    }\n    /**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */ function getMillerRabinTests(bits) {\n        if (bits <= 100) return 27;\n        if (bits <= 150) return 18;\n        if (bits <= 200) return 15;\n        if (bits <= 250) return 12;\n        if (bits <= 300) return 9;\n        if (bits <= 350) return 8;\n        if (bits <= 400) return 7;\n        if (bits <= 500) return 6;\n        if (bits <= 600) return 5;\n        if (bits <= 800) return 4;\n        if (bits <= 1250) return 3;\n        return 2;\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJpbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVA7SUFFRCw4QkFBOEI7SUFDOUIsSUFBR0QsTUFBTUUsS0FBSyxFQUFFO1FBQ2RDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsS0FBSztRQUM1QjtJQUNGO0lBRUEsYUFBYSxHQUNiLElBQUlBLFFBQVFDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLElBQUksQ0FBQztJQUUzRCxJQUFJRyxhQUFhTCxNQUFNTSxJQUFJLENBQUNELFVBQVU7SUFFdEMsd0RBQXdEO0lBQ3hELElBQUlFLGVBQWU7UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO0tBQUU7SUFDM0MsSUFBSUMsU0FBUyxJQUFJSCxXQUFXO0lBQzVCRyxPQUFPQyxPQUFPLENBQUM7SUFDZixJQUFJQyxRQUFRLFNBQVNDLENBQUMsRUFBRUMsQ0FBQztRQUFHLE9BQU9ELElBQUVDO0lBQUU7SUFFdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRFYsTUFBTVcscUJBQXFCLEdBQUcsU0FBU0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7UUFDNUQsSUFBRyxPQUFPRCxZQUFZLFlBQVk7WUFDaENDLFdBQVdEO1lBQ1hBLFVBQVUsQ0FBQztRQUNiO1FBQ0FBLFVBQVVBLFdBQVcsQ0FBQztRQUV0QixnQ0FBZ0M7UUFDaEMsSUFBSUUsWUFBWUYsUUFBUUUsU0FBUyxJQUFJO1FBQ3JDLElBQUcsT0FBT0EsY0FBYyxVQUFVO1lBQ2hDQSxZQUFZO2dCQUFDQyxNQUFNRDtZQUFTO1FBQzlCO1FBQ0FBLFVBQVVGLE9BQU8sR0FBR0UsVUFBVUYsT0FBTyxJ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QUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLE1BQU0sT0FBTztRQUN4QixPQUFPO0lBQ1Q7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3ByaW1lLmpzP2MxNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcmltZSBudW1iZXIgZ2VuZXJhdGlvbiBBUEkuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL2pzYm4nKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbihmdW5jdGlvbigpIHtcblxuLy8gZm9yZ2UucHJpbWUgYWxyZWFkeSBkZWZpbmVkXG5pZihmb3JnZS5wcmltZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnByaW1lO1xuICByZXR1cm47XG59XG5cbi8qIFBSSU1FIEFQSSAqL1xudmFyIHByaW1lID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZSA9IGZvcmdlLnByaW1lIHx8IHt9O1xuXG52YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcblxuLy8gcHJpbWVzIGFyZSAzMGsraSBmb3IgaSA9IDEsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjlcbnZhciBHQ0RfMzBfREVMVEEgPSBbNiwgNCwgMiwgNCwgMiwgNCwgNiwgMl07XG52YXIgVEhJUlRZID0gbmV3IEJpZ0ludGVnZXIobnVsbCk7XG5USElSVFkuZnJvbUludCgzMCk7XG52YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7cmV0dXJuIHh8eTt9O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBwcm9iYWJsZSBwcmltZSB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBBbHRlcm5hdGl2ZSBhbGdvcml0aG1zIGNhbiBiZSBzcGVjaWZpZWQgYnkgbmFtZSBhcyBhIHN0cmluZyBvciBhcyBhblxuICogb2JqZWN0IHdpdGggY3VzdG9tIG9wdGlvbnMgbGlrZSBzbzpcbiAqXG4gKiB7XG4gKiAgIG5hbWU6ICdQUklNRUlOQycsXG4gKiAgIG9wdGlvbnM6IHtcbiAqICAgICBtYXhCbG9ja1RpbWU6IDx0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byBibG9jayB0aGUgbWFpblxuICogICAgICAgdGhyZWFkIGJlZm9yZSBhbGxvd2luZyBJL08gb3RoZXIgSlMgdG8gcnVuPixcbiAqICAgICBtaWxsZXJSYWJpblRlc3RzOiA8dGhlIG51bWJlciBvZiBtaWxsZXItcmFiaW4gdGVzdHMgdG8gcnVuPixcbiAqICAgICB3b3JrZXJTY3JpcHQ6IDx0aGUgd29ya2VyIHNjcmlwdCBVUkw+LFxuICogICAgIHdvcmtlcnM6IDx0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lPi5cbiAqICAgICB3b3JrTG9hZDogdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAoZGVmYXVsdDogMTAwKS5cbiAqICAgfVxuICogfVxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIHByaW1lIG51bWJlci5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFthbGdvcml0aG1dIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqICAgICAgICAgIFtwcm5nXSBhIGN1c3RvbSBjcnlwdG8tc2VjdXJlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UsXG4gKiAgICAgICAgICAgIHRoYXQgbXVzdCBkZWZpbmUgXCJnZXRCeXRlc1N5bmNcIi5cbiAqXG4gKiBAcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVtKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqL1xucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lID0gZnVuY3Rpb24oYml0cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGRlZmF1bHQgdG8gUFJJTUVJTkMgYWxnb3JpdGhtXG4gIHZhciBhbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnUFJJTUVJTkMnO1xuICBpZih0eXBlb2YgYWxnb3JpdGhtID09PSAnc3RyaW5nJykge1xuICAgIGFsZ29yaXRobSA9IHtuYW1lOiBhbGdvcml0aG19O1xuICB9XG4gIGFsZ29yaXRobS5vcHRpb25zID0gYWxnb3JpdGhtLm9wdGlvbnMgfHwge307XG5cbiAgLy8gY3JlYXRlIHBybmcgd2l0aCBhcGkgdGhhdCBtYXRjaGVzIEJpZ0ludGVnZXIgc2VjdXJlIHJhbmRvbVxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG4gIHZhciBybmcgPSB7XG4gICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICBuZXh0Qnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBiID0gcHJuZy5nZXRCeXRlc1N5bmMoeC5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYoYWxnb3JpdGhtLm5hbWUgPT09ICdQUklNRUlOQycpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWUoYml0cywgcm5nLCBhbGdvcml0aG0ub3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaW1lIGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtLm5hbWUpO1xufTtcblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWUoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZignd29ya2VycycgaW4gb3B0aW9ucykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8qIE5vdGU6IEFsbCBwcmltZXMgYXJlIG9mIHRoZSBmb3JtIDMwaytpIGZvciBpIDwgMzAgYW5kIGdjZCgzMCwgaSk9MS4gVGhlXG4gIG51bWJlciB3ZSBhcmUgZ2l2ZW4gaXMgYWx3YXlzIGFsaWduZWQgYXQgMzBrICsgMS4gRWFjaCB0aW1lIHRoZSBudW1iZXIgaXNcbiAgZGV0ZXJtaW5lZCBub3QgdG8gYmUgcHJpbWUgd2UgYWRkIHRvIGdldCB0byB0aGUgbmV4dCAnaScsIGVnOiBpZiB0aGUgbnVtYmVyXG4gIHdhcyBhdCAzMGsgKyAxIHdlIGFkZCA2LiAqL1xuICB2YXIgZGVsdGFJZHggPSAwO1xuXG4gIC8vIGdldCByZXF1aXJlZCBudW1iZXIgb2YgTVIgdGVzdHNcbiAgdmFyIG1yVGVzdHMgPSBnZXRNaWxsZXJSYWJpblRlc3RzKG51bS5iaXRMZW5ndGgoKSk7XG4gIGlmKCdtaWxsZXJSYWJpblRlc3RzJyBpbiBvcHRpb25zKSB7XG4gICAgbXJUZXN0cyA9IG9wdGlvbnMubWlsbGVyUmFiaW5UZXN0cztcbiAgfVxuXG4gIC8vIGZpbmQgcHJpbWUgbmVhcmVzdCB0byAnbnVtJyBmb3IgbWF4QmxvY2tUaW1lIG1zXG4gIC8vIDEwIG1zIGdpdmVzIDVtcyBvZiBsZWV3YXkgZm9yIG90aGVyIGNhbGN1bGF0aW9ucyBiZWZvcmUgZHJvcHBpbmdcbiAgLy8gYmVsb3cgNjBmcHMgKDEwMDAvNjAgPT0gMTYuNjcpLCBidXQgaW4gcmVhbGl0eSwgdGhlIG51bWJlciB3aWxsXG4gIC8vIGxpa2VseSBiZSBoaWdoZXIgZHVlIHRvIGFuICdhdG9taWMnIGJpZyBpbnQgbW9kUG93XG4gIHZhciBtYXhCbG9ja1RpbWUgPSAxMDtcbiAgaWYoJ21heEJsb2NrVGltZScgaW4gb3B0aW9ucykge1xuICAgIG1heEJsb2NrVGltZSA9IG9wdGlvbnMubWF4QmxvY2tUaW1lO1xuICB9XG5cbiAgX3ByaW1laW5jKG51bSwgYml0cywgcm5nLCBkZWx0YUlkeCwgbXJUZXN0cywgbWF4QmxvY2tUaW1lLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spIHtcbiAgdmFyIHN0YXJ0ID0gK25ldyBEYXRlKCk7XG4gIGRvIHtcbiAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgaWYobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcbiAgICB9XG4gICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICBpZihudW0uaXNQcm9iYWJsZVByaW1lKG1yVGVzdHMpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVtKTtcbiAgICB9XG4gICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgbnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gIH0gd2hpbGUobWF4QmxvY2tUaW1lIDwgMCB8fCAoK25ldyBEYXRlKCkgLSBzdGFydCA8IG1heEJsb2NrVGltZSkpO1xuXG4gIC8vIGtlZXAgdHJ5aW5nIGxhdGVyXG4gIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xuICB9KTtcbn1cblxuLy8gTk9URTogVGhpcyBhbGdvcml0aG0gaXMgaW5kZXRlcm1pbmF0ZSBpbiBuYXR1cmUgYmVjYXVzZSB3b3JrZXJzXG4vLyBydW4gaW4gcGFyYWxsZWwgbG9va2luZyBhdCBkaWZmZXJlbnQgc2VnbWVudHMgb2YgbnVtYmVycy4gRXZlbiBpZiB0aGlzXG4vLyBhbGdvcml0aG0gaXMgcnVuIHR3aWNlIHdpdGggdGhlIHNhbWUgaW5wdXQgZnJvbSBhIHByZWRpY3RhYmxlIFJORywgaXRcbi8vIG1heSBwcm9kdWNlIGRpZmZlcmVudCBvdXRwdXRzLlxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIHdlYiB3b3JrZXJzIHVuYXZhaWxhYmxlXG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lV2l0aG91dFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHJhbmRvbSBudW1iZXJcbiAgdmFyIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG5cbiAgLy8gdXNlIHdlYiB3b3JrZXJzIHRvIGdlbmVyYXRlIGtleXNcbiAgdmFyIG51bVdvcmtlcnMgPSBvcHRpb25zLndvcmtlcnM7XG4gIHZhciB3b3JrTG9hZCA9IG9wdGlvbnMud29ya0xvYWQgfHwgMTAwO1xuICB2YXIgcmFuZ2UgPSB3b3JrTG9hZCAqIDMwIC8gODtcbiAgdmFyIHdvcmtlclNjcmlwdCA9IG9wdGlvbnMud29ya2VyU2NyaXB0IHx8ICdmb3JnZS9wcmltZS53b3JrZXIuanMnO1xuICBpZihudW1Xb3JrZXJzID09PSAtMSkge1xuICAgIHJldHVybiBmb3JnZS51dGlsLmVzdGltYXRlQ29yZXMoZnVuY3Rpb24oZXJyLCBjb3Jlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gMlxuICAgICAgICBjb3JlcyA9IDI7XG4gICAgICB9XG4gICAgICBudW1Xb3JrZXJzID0gY29yZXMgLSAxO1xuICAgICAgZ2VuZXJhdGUoKTtcbiAgICB9KTtcbiAgfVxuICBnZW5lcmF0ZSgpO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIC8vIHJlcXVpcmUgYXQgbGVhc3QgMSB3b3JrZXJcbiAgICBudW1Xb3JrZXJzID0gTWF0aC5tYXgoMSwgbnVtV29ya2Vycyk7XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBvcHRpbWl6aW5nIGJ5IHN0YXJ0aW5nIHdvcmtlcnMgb3V0c2lkZSBnZXRQcmltZSgpIC4uLlxuICAgIC8vIG5vdGUgdGhhdCBpbiBvcmRlciB0byBjbGVhbiB1cCB0aGV5IHdpbGwgaGF2ZSB0byBiZSBtYWRlIGludGVybmFsbHlcbiAgICAvLyBhc3luY2hyb25vdXMgd2hpY2ggbWF5IGFjdHVhbGx5IGJlIHNsb3dlclxuXG4gICAgLy8gc3RhcnQgd29ya2VycyBpbW1lZGlhdGVseVxuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgLy8gRklYTUU6IGZpeCBwYXRoIG9yIHVzZSBibG9iIFVSTHNcbiAgICAgIHdvcmtlcnNbaV0gPSBuZXcgV29ya2VyKHdvcmtlclNjcmlwdCk7XG4gICAgfVxuICAgIHZhciBydW5uaW5nID0gbnVtV29ya2VycztcblxuICAgIC8vIGxpc3RlbiBmb3IgcmVxdWVzdHMgZnJvbSB3b3JrZXJzIGFuZCBhc3NpZ24gcmFuZ2VzIHRvIGZpbmQgcHJpbWVcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB3b3JrZXJzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB3b3JrZXJNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKiBOb3RlOiBUaGUgZGlzdHJpYnV0aW9uIG9mIHJhbmRvbSBudW1iZXJzIGlzIHVua25vd24uIFRoZXJlZm9yZSwgZWFjaFxuICAgIHdlYiB3b3JrZXIgaXMgY29udGludW91c2x5IGFsbG9jYXRlZCBhIHJhbmdlIG9mIG51bWJlcnMgdG8gY2hlY2sgZm9yIGFcbiAgICByYW5kb20gbnVtYmVyIHVudGlsIG9uZSBpcyBmb3VuZC5cblxuICAgIEV2ZXJ5IDMwIG51bWJlcnMgd2lsbCBiZSBjaGVja2VkIGp1c3QgOCB0aW1lcywgYmVjYXVzZSBwcmltZSBudW1iZXJzXG4gICAgaGF2ZSB0aGUgZm9ybTpcblxuICAgIDMwaytpLCBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEgKHRoZXJlIGFyZSA4IHZhbHVlcyBvZiBpIGZvciB0aGlzKVxuXG4gICAgVGhlcmVmb3JlLCBpZiB3ZSB3YW50IGEgd2ViIHdvcmtlciB0byBydW4gTiBjaGVja3MgYmVmb3JlIGFza2luZyBmb3JcbiAgICBhIG5ldyByYW5nZSBvZiBudW1iZXJzLCBlYWNoIHJhbmdlIG11c3QgY29udGFpbiBOKjMwLzggbnVtYmVycy5cblxuICAgIEZvciAxMDAgY2hlY2tzICh3b3JrTG9hZCksIHRoaXMgaXMgYSByYW5nZSBvZiAzNzUuICovXG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiB3b3JrZXJNZXNzYWdlKGUpIHtcbiAgICAgIC8vIGlnbm9yZSBtZXNzYWdlLCBwcmltZSBhbHJlYWR5IGZvdW5kXG4gICAgICBpZihmb3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC0tcnVubmluZztcbiAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgaWYoZGF0YS5mb3VuZCkge1xuICAgICAgICAvLyB0ZXJtaW5hdGUgYWxsIHdvcmtlcnNcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHdvcmtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5ldyBCaWdJbnRlZ2VyKGRhdGEucHJpbWUsIDE2KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJmbG93LCByZWdlbmVyYXRlIHJhbmRvbSBudW1iZXJcbiAgICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzaWduIG5ldyByYW5nZSB0byBjaGVja1xuICAgICAgdmFyIGhleCA9IG51bS50b1N0cmluZygxNik7XG5cbiAgICAgIC8vIHN0YXJ0IHByaW1lIHNlYXJjaFxuICAgICAgZS50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBoZXg6IGhleCxcbiAgICAgICAgd29ya0xvYWQ6IHdvcmtMb2FkXG4gICAgICB9KTtcblxuICAgICAgbnVtLmRBZGRPZmZzZXQocmFuZ2UsIDApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgdXNpbmcgdGhlIGdpdmVuIG51bWJlciBvZiBiaXRzIGFuZCBSTkcuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIG51bWJlciBvZiBiaXRzIGZvciB0aGUgbnVtYmVyLlxuICogQHBhcmFtIHJuZyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZykge1xuICB2YXIgbnVtID0gbmV3IEJpZ0ludGVnZXIoYml0cywgcm5nKTtcbiAgLy8gZm9yY2UgTVNCIHNldFxuICB2YXIgYml0czEgPSBiaXRzIC0gMTtcbiAgaWYoIW51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgIG51bS5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdHMxKSwgb3Bfb3IsIG51bSk7XG4gIH1cbiAgLy8gYWxpZ24gbnVtYmVyIG9uIDMwaysxIGJvdW5kYXJ5XG4gIG51bS5kQWRkT2Zmc2V0KDMxIC0gbnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgcmV0dXJuIG51bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZ2V0TWlsbGVyUmFiaW5UZXN0cyhiaXRzKSB7XG4gIGlmKGJpdHMgPD0gMTAwKSByZXR1cm4gMjc7XG4gIGlmKGJpdHMgPD0gMTUwKSByZXR1cm4gMTg7XG4gIGlmKGJpdHMgPD0gMjAwKSByZXR1cm4gMTU7XG4gIGlmKGJpdHMgPD0gMjUwKSByZXR1cm4gMTI7XG4gIGlmKGJpdHMgPD0gMzAwKSByZXR1cm4gOTtcbiAgaWYoYml0cyA8PSAzNTApIHJldHVybiA4O1xuICBpZihiaXRzIDw9IDQwMCkgcmV0dXJuIDc7XG4gIGlmKGJpdHMgPD0gNTAwKSByZXR1cm4gNjtcbiAgaWYoYml0cyA8PSA2MDApIHJldHVybiA1O1xuICBpZihiaXRzIDw9IDgwMCkgcmV0dXJuIDQ7XG4gIGlmKGJpdHMgPD0gMTI1MCkgcmV0dXJuIDM7XG4gIHJldHVybiAyO1xufVxuXG59KSgpO1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInByaW1lIiwibW9kdWxlIiwiZXhwb3J0cyIsIkJpZ0ludGVnZXIiLCJqc2JuIiwiR0NEXzMwX0RFTFRBIiwiVEhJUlRZIiwiZnJvbUludCIsIm9wX29yIiwieCIsInkiLCJnZW5lcmF0ZVByb2JhYmxlUHJpbWUiLCJiaXRzIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYWxnb3JpdGhtIiwibmFtZSIsInBybmciLCJyYW5kb20iLCJybmciLCJuZXh0Qnl0ZXMiLCJiIiwiZ2V0Qnl0ZXNTeW5jIiwibGVuZ3RoIiwiaSIsImNoYXJDb2RlQXQiLCJwcmltZWluY0ZpbmRQcmltZSIsIkVycm9yIiwicHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyIsInByaW1laW5jRmluZFByaW1lV2l0aG91dFdvcmtlcnMiLCJudW0iLCJnZW5lcmF0ZVJhbmRvbSIsImRlbHRhSWR4IiwibXJUZXN0cyIsImdldE1pbGxlclJhYmluVGVzdHMiLCJiaXRMZW5ndGgiLCJtaWxsZXJSYWJpblRlc3RzIiwibWF4QmxvY2tUaW1lIiwiX3ByaW1laW5jIiwic3RhcnQiLCJEYXRlIiwiaXNQcm9iYWJsZVByaW1lIiwiZEFkZE9mZnNldCIsInV0aWwiLCJzZXRJbW1lZGlhdGUiLCJXb3JrZXIiLCJudW1Xb3JrZXJzIiwid29ya2VycyIsIndvcmtMb2FkIiwicmFuZ2UiLCJ3b3JrZXJTY3JpcHQiLCJlc3RpbWF0ZUNvcmVzIiwiZXJyIiwiY29yZXMiLCJnZW5lcmF0ZSIsIk1hdGgiLCJtYXgiLCJydW5uaW5nIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndvcmtlck1lc3NhZ2UiLCJmb3VuZCIsImUiLCJkYXRhIiwidGVybWluYXRlIiwiaGV4IiwidG9TdHJpbmciLCJ0YXJnZXQiLCJwb3N0TWVzc2FnZSIsImJpdHMxIiwidGVzdEJpdCIsImJpdHdpc2VUbyIsIk9ORSIsInNoaWZ0TGVmdCIsIm1vZCIsImJ5dGVWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/prime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/prng.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/prng.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nvar _crypto = null;\nif (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions[\"node-webkit\"]) {\n    _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n}\n/* PRNG API */ var prng = module.exports = forge.prng = forge.prng || {};\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */ prng.create = function(plugin) {\n    var ctx = {\n        plugin: plugin,\n        key: null,\n        seed: null,\n        time: null,\n        // number of reseeds so far\n        reseeds: 0,\n        // amount of data generated so far\n        generated: 0,\n        // no initial key bytes\n        keyBytes: \"\"\n    };\n    // create 32 entropy pools (each is a message digest)\n    var md = plugin.md;\n    var pools = new Array(32);\n    for(var i = 0; i < 32; ++i){\n        pools[i] = md.create();\n    }\n    ctx.pools = pools;\n    // entropy pools are written to cyclically, starting at index 0\n    ctx.pool = 0;\n    /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */ ctx.generate = function(count, callback) {\n        // do synchronously\n        if (!callback) {\n            return ctx.generateSync(count);\n        }\n        // simple generator using counter-based CBC\n        var cipher = ctx.plugin.cipher;\n        var increment = ctx.plugin.increment;\n        var formatKey = ctx.plugin.formatKey;\n        var formatSeed = ctx.plugin.formatSeed;\n        var b = forge.util.createBuffer();\n        // paranoid deviation from Fortuna:\n        // reset key for every request to protect previously\n        // generated random bytes should the key be discovered;\n        // there is no 100ms based reseeding because of this\n        // forced reseed for every `generate` call\n        ctx.key = null;\n        generate();\n        function generate(err) {\n            if (err) {\n                return callback(err);\n            }\n            // sufficient bytes generated\n            if (b.length() >= count) {\n                return callback(null, b.getBytes(count));\n            }\n            // if amount of data generated is greater than 1 MiB, trigger reseed\n            if (ctx.generated > 0xfffff) {\n                ctx.key = null;\n            }\n            if (ctx.key === null) {\n                // prevent stack overflow\n                return forge.util.nextTick(function() {\n                    _reseed(generate);\n                });\n            }\n            // generate the random bytes\n            var bytes = cipher(ctx.key, ctx.seed);\n            ctx.generated += bytes.length;\n            b.putBytes(bytes);\n            // generate bytes for a new key and seed\n            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n            forge.util.setImmediate(generate);\n        }\n    };\n    /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */ ctx.generateSync = function(count) {\n        // simple generator using counter-based CBC\n        var cipher = ctx.plugin.cipher;\n        var increment = ctx.plugin.increment;\n        var formatKey = ctx.plugin.formatKey;\n        var formatSeed = ctx.plugin.formatSeed;\n        // paranoid deviation from Fortuna:\n        // reset key for every request to protect previously\n        // generated random bytes should the key be discovered;\n        // there is no 100ms based reseeding because of this\n        // forced reseed for every `generateSync` call\n        ctx.key = null;\n        var b = forge.util.createBuffer();\n        while(b.length() < count){\n            // if amount of data generated is greater than 1 MiB, trigger reseed\n            if (ctx.generated > 0xfffff) {\n                ctx.key = null;\n            }\n            if (ctx.key === null) {\n                _reseedSync();\n            }\n            // generate the random bytes\n            var bytes = cipher(ctx.key, ctx.seed);\n            ctx.generated += bytes.length;\n            b.putBytes(bytes);\n            // generate bytes for a new key and seed\n            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n        }\n        return b.getBytes(count);\n    };\n    /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */ function _reseed(callback) {\n        if (ctx.pools[0].messageLength >= 32) {\n            _seed();\n            return callback();\n        }\n        // not enough seed data...\n        var needed = 32 - ctx.pools[0].messageLength << 5;\n        ctx.seedFile(needed, function(err, bytes) {\n            if (err) {\n                return callback(err);\n            }\n            ctx.collect(bytes);\n            _seed();\n            callback();\n        });\n    }\n    /**\n   * Private function that synchronously reseeds a generator.\n   */ function _reseedSync() {\n        if (ctx.pools[0].messageLength >= 32) {\n            return _seed();\n        }\n        // not enough seed data...\n        var needed = 32 - ctx.pools[0].messageLength << 5;\n        ctx.collect(ctx.seedFileSync(needed));\n        _seed();\n    }\n    /**\n   * Private function that seeds a generator once enough bytes are available.\n   */ function _seed() {\n        // update reseed count\n        ctx.reseeds = ctx.reseeds === 0xffffffff ? 0 : ctx.reseeds + 1;\n        // goal is to update `key` via:\n        // key = hash(key + s)\n        //   where 's' is all collected entropy from selected pools, then...\n        // create a plugin-based message digest\n        var md = ctx.plugin.md.create();\n        // consume current key bytes\n        md.update(ctx.keyBytes);\n        // digest the entropy of pools whose index k meet the\n        // condition 'n mod 2^k == 0' where n is the number of reseeds\n        var _2powK = 1;\n        for(var k = 0; k < 32; ++k){\n            if (ctx.reseeds % _2powK === 0) {\n                md.update(ctx.pools[k].digest().getBytes());\n                ctx.pools[k].start();\n            }\n            _2powK = _2powK << 1;\n        }\n        // get digest for key bytes\n        ctx.keyBytes = md.digest().getBytes();\n        // paranoid deviation from Fortuna:\n        // update `seed` via `seed = hash(key)`\n        // instead of initializing to zero once and only\n        // ever incrementing it\n        md.start();\n        md.update(ctx.keyBytes);\n        var seedBytes = md.digest().getBytes();\n        // update state\n        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n        ctx.seed = ctx.plugin.formatSeed(seedBytes);\n        ctx.generated = 0;\n    }\n    /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */ function defaultSeedFile(needed) {\n        // use window.crypto.getRandomValues strong source of entropy if available\n        var getRandomValues = null;\n        var globalScope = forge.util.globalScope;\n        var _crypto = globalScope.crypto || globalScope.msCrypto;\n        if (_crypto && _crypto.getRandomValues) {\n            getRandomValues = function(arr) {\n                return _crypto.getRandomValues(arr);\n            };\n        }\n        var b = forge.util.createBuffer();\n        if (getRandomValues) {\n            while(b.length() < needed){\n                // max byte length is 65536 before QuotaExceededError is thrown\n                // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n                var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n                var entropy = new Uint32Array(Math.floor(count));\n                try {\n                    getRandomValues(entropy);\n                    for(var i = 0; i < entropy.length; ++i){\n                        b.putInt32(entropy[i]);\n                    }\n                } catch (e) {\n                    /* only ignore QuotaExceededError */ if (!(typeof QuotaExceededError !== \"undefined\" && e instanceof QuotaExceededError)) {\n                        throw e;\n                    }\n                }\n            }\n        }\n        // be sad and add some weak random data\n        if (b.length() < needed) {\n            /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */ var hi, lo, next;\n            var seed = Math.floor(Math.random() * 0x010000);\n            while(b.length() < needed){\n                lo = 16807 * (seed & 0xFFFF);\n                hi = 16807 * (seed >> 16);\n                lo += (hi & 0x7FFF) << 16;\n                lo += hi >> 15;\n                lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n                seed = lo & 0xFFFFFFFF;\n                // consume lower 3 bytes of seed\n                for(var i = 0; i < 3; ++i){\n                    // throw in more pseudo random\n                    next = seed >>> (i << 3);\n                    next ^= Math.floor(Math.random() * 0x0100);\n                    b.putByte(next & 0xFF);\n                }\n            }\n        }\n        return b.getBytes(needed);\n    }\n    // initialize seed file APIs\n    if (_crypto) {\n        // use nodejs async API\n        ctx.seedFile = function(needed, callback) {\n            _crypto.randomBytes(needed, function(err, bytes) {\n                if (err) {\n                    return callback(err);\n                }\n                callback(null, bytes.toString());\n            });\n        };\n        // use nodejs sync API\n        ctx.seedFileSync = function(needed) {\n            return _crypto.randomBytes(needed).toString();\n        };\n    } else {\n        ctx.seedFile = function(needed, callback) {\n            try {\n                callback(null, defaultSeedFile(needed));\n            } catch (e) {\n                callback(e);\n            }\n        };\n        ctx.seedFileSync = defaultSeedFile;\n    }\n    /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */ ctx.collect = function(bytes) {\n        // iterate over pools distributing entropy cyclically\n        var count = bytes.length;\n        for(var i = 0; i < count; ++i){\n            ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n            ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;\n        }\n    };\n    /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */ ctx.collectInt = function(i, n) {\n        var bytes = \"\";\n        for(var x = 0; x < n; x += 8){\n            bytes += String.fromCharCode(i >> x & 0xFF);\n        }\n        ctx.collect(bytes);\n    };\n    /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */ ctx.registerWorker = function(worker) {\n        // worker receives random bytes\n        if (worker === self) {\n            ctx.seedFile = function(needed, callback) {\n                function listener(e) {\n                    var data = e.data;\n                    if (data.forge && data.forge.prng) {\n                        self.removeEventListener(\"message\", listener);\n                        callback(data.forge.prng.err, data.forge.prng.bytes);\n                    }\n                }\n                self.addEventListener(\"message\", listener);\n                self.postMessage({\n                    forge: {\n                        prng: {\n                            needed: needed\n                        }\n                    }\n                });\n            };\n        } else {\n            // main thread sends random bytes upon request\n            var listener = function(e) {\n                var data = e.data;\n                if (data.forge && data.forge.prng) {\n                    ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n                        worker.postMessage({\n                            forge: {\n                                prng: {\n                                    err: err,\n                                    bytes: bytes\n                                }\n                            }\n                        });\n                    });\n                }\n            };\n            // TODO: do we need to remove the event listener when the worker dies?\n            worker.addEventListener(\"message\", listener);\n        }\n    };\n    return ctx;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJuZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztDQVVDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsVUFBVTtBQUNkLElBQUdGLE1BQU1HLElBQUksQ0FBQ0MsUUFBUSxJQUFJLENBQUNKLE1BQU1LLE9BQU8sQ0FBQ0MsaUJBQWlCLElBQ3hELENBQUNDLFFBQVFDLFFBQVEsQ0FBQyxjQUFjLEVBQUU7SUFDbENOLFVBQVVELG1CQUFPQSxDQUFDO0FBQ3BCO0FBRUEsWUFBWSxHQUNaLElBQUlRLE9BQU9DLE9BQU9DLE9BQU8sR0FBR1gsTUFBTVMsSUFBSSxHQUFHVCxNQUFNUyxJQUFJLElBQUksQ0FBQztBQUV4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDREEsS0FBS0csTUFBTSxHQUFHLFNBQVNDLE1BQU07SUFDM0IsSUFBSUMsTUFBTTtRQUNSRCxRQUFRQTtRQUNSRSxLQUFLO1FBQ0xDLE1BQU07UUFDTkMsTUFBTTtRQUNOLDJCQUEyQjtRQUMzQkMsU0FBUztRQUNULGtDQUFrQztRQUNsQ0MsV0FBVztRQUNYLHVCQUF1QjtRQUN2QkMsVUFBVTtJQUNaO0lBRUEscURBQXFEO0lBQ3JELElBQUlDLEtBQUtSLE9BQU9RLEVBQUU7SUFDbEIsSUFBSUMsUUFBUSxJQUFJQyxNQUFNO0lBQ3RCLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBRztRQUMxQkYsS0FBSyxDQUFDRSxFQUFFLEdBQUdILEdBQUdULE1BQU07SUFDdEI7SUFDQUUsSUFBSVEsS0FBSyxHQUFHQTtJQUVaLCtEQUErRDtJQUMvRFIsSUFBSVcsSUFBSSxHQUFHO0lBRVg7Ozs7Ozs7OztHQVNDLEdBQ0RYLElBQUlZLFFBQVEsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLFFBQVE7UUFDckMsbUJBQW1CO1FBQ25CLElBQUcsQ0FBQ0EsVUFBVTtZ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QUN2QixJQUFJbUIsT0FBT25CLEVBQUVtQixJQUFJO2dCQUNqQixJQUFHQSxLQUFLekYsS0FBSyxJQUFJeUYsS0FBS3pGLEtBQUssQ0FBQ1MsSUFBSSxFQUFFO29CQUNoQ0ssSUFBSWtDLFFBQVEsQ0FBQ3lDLEtBQUt6RixLQUFLLENBQUNTLElBQUksQ0FBQ3NDLE1BQU0sRUFBRSxTQUFTWCxHQUFHLEVBQUVLLEtBQUs7d0JBQ3RENkMsT0FBT00sV0FBVyxDQUFDOzRCQUFDNUYsT0FBTztnQ0FBQ1MsTUFBTTtvQ0FBQzJCLEtBQUtBO29DQUFLSyxPQUFPQTtnQ0FBSzs0QkFBQzt3QkFBQztvQkFDN0Q7Z0JBQ0Y7WUFDRjtZQUNBLHNFQUFzRTtZQUN0RTZDLE9BQU9LLGdCQUFnQixDQUFDLFdBQVdIO1FBQ3JDO0lBQ0Y7SUFFQSxPQUFPMUU7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BybmcuanM/MWNkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZVxuICogUHNldWRvIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yIChQUk5HKS4gVGhlIEZvcnR1bmEgYWxnb3JpdGhtIGlzIGZvbGxvd2VkXG4gKiBoZXJlIHRob3VnaCB0aGUgdXNlIG9mIFNIQS0yNTYgaXMgbm90IGVuZm9yY2VkOyB3aGVuIGdlbmVyYXRpbmcgYW5cbiAqIGEgUFJORyBjb250ZXh0LCB0aGUgaGFzaGluZyBhbGdvcml0aG0gYW5kIGJsb2NrIGNpcGhlciB1c2VkIGZvclxuICogdGhlIGdlbmVyYXRvciBhcmUgc3BlY2lmaWVkIHZpYSBhIHBsdWdpbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX2NyeXB0byA9IG51bGw7XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmXG4gICFwcm9jZXNzLnZlcnNpb25zWydub2RlLXdlYmtpdCddKSB7XG4gIF9jcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbn1cblxuLyogUFJORyBBUEkgKi9cbnZhciBwcm5nID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcm5nID0gZm9yZ2UucHJuZyB8fCB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBSTkcgY29udGV4dC5cbiAqXG4gKiBBIFBSTkcgcGx1Z2luIG11c3QgYmUgcGFzc2VkIGluIHRoYXQgd2lsbCBwcm92aWRlOlxuICpcbiAqIDEuIEEgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUga2V5IGFuZCBzZWVkIG9mIGEgUFJORyBjb250ZXh0LiBJdFxuICogICB3aWxsIGJlIGdpdmVuIGEgMTYgYnl0ZSBrZXkgYW5kIGEgMTYgYnl0ZSBzZWVkLiBBbnkga2V5IGV4cGFuc2lvblxuICogICBvciB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgc2VlZCBmcm9tIGEgYnl0ZSBzdHJpbmcgaW50byBhbiBhcnJheSBvZlxuICogICBpbnRlZ2VycyAob3Igc2ltaWxhcikgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAqIDIuIFRoZSBjcnlwdG9ncmFwaGljIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGdlbmVyYXRvci4gSXQgdGFrZXMgYSBrZXkgYW5kXG4gKiAgIGEgc2VlZC5cbiAqIDMuIEEgc2VlZCBpbmNyZW1lbnQgZnVuY3Rpb24uIEl0IHRha2VzIHRoZSBzZWVkIGFuZCByZXR1cm5zIHNlZWQgKyAxLlxuICogNC4gQW4gYXBpIHRvIGNyZWF0ZSBhIG1lc3NhZ2UgZGlnZXN0LlxuICpcbiAqIEZvciBhbiBleGFtcGxlLCBzZWUgcmFuZG9tLmpzLlxuICpcbiAqIEBwYXJhbSBwbHVnaW4gdGhlIFBSTkcgcGx1Z2luIHRvIHVzZS5cbiAqL1xucHJuZy5jcmVhdGUgPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBwbHVnaW46IHBsdWdpbixcbiAgICBrZXk6IG51bGwsXG4gICAgc2VlZDogbnVsbCxcbiAgICB0aW1lOiBudWxsLFxuICAgIC8vIG51bWJlciBvZiByZXNlZWRzIHNvIGZhclxuICAgIHJlc2VlZHM6IDAsXG4gICAgLy8gYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIHNvIGZhclxuICAgIGdlbmVyYXRlZDogMCxcbiAgICAvLyBubyBpbml0aWFsIGtleSBieXRlc1xuICAgIGtleUJ5dGVzOiAnJ1xuICB9O1xuXG4gIC8vIGNyZWF0ZSAzMiBlbnRyb3B5IHBvb2xzIChlYWNoIGlzIGEgbWVzc2FnZSBkaWdlc3QpXG4gIHZhciBtZCA9IHBsdWdpbi5tZDtcbiAgdmFyIHBvb2xzID0gbmV3IEFycmF5KDMyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICBwb29sc1tpXSA9IG1kLmNyZWF0ZSgpO1xuICB9XG4gIGN0eC5wb29scyA9IHBvb2xzO1xuXG4gIC8vIGVudHJvcHkgcG9vbHMgYXJlIHdyaXR0ZW4gdG8gY3ljbGljYWxseSwgc3RhcnRpbmcgYXQgaW5kZXggMFxuICBjdHgucG9vbCA9IDA7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBtYXkgYmUgZ2VuZXJhdGVkIHN5bmNocm9ub3VzbHkgb3JcbiAgICogYXN5bmNocm9ub3VzbHkuIFdlYiB3b3JrZXJzIG11c3QgdXNlIHRoZSBhc3luY2hyb25vdXMgaW50ZXJmYWNlIG9yXG4gICAqIGVsc2UgdGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiBjb3VudCByYW5kb20gYnl0ZXMgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2VuZXJhdGUgPSBmdW5jdGlvbihjb3VudCwgY2FsbGJhY2spIHtcbiAgICAvLyBkbyBzeW5jaHJvbm91c2x5XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY3R4LmdlbmVyYXRlU3luYyhjb3VudCk7XG4gICAgfVxuXG4gICAgLy8gc2ltcGxlIGdlbmVyYXRvciB1c2luZyBjb3VudGVyLWJhc2VkIENCQ1xuICAgIHZhciBjaXBoZXIgPSBjdHgucGx1Z2luLmNpcGhlcjtcbiAgICB2YXIgaW5jcmVtZW50ID0gY3R4LnBsdWdpbi5pbmNyZW1lbnQ7XG4gICAgdmFyIGZvcm1hdEtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5O1xuICAgIHZhciBmb3JtYXRTZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkO1xuICAgIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlYCBjYWxsXG4gICAgY3R4LmtleSA9IG51bGw7XG5cbiAgICBnZW5lcmF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoZXJyKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIHN1ZmZpY2llbnQgYnl0ZXMgZ2VuZXJhdGVkXG4gICAgICBpZihiLmxlbmd0aCgpID49IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBiLmdldEJ5dGVzKGNvdW50KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBpcyBncmVhdGVyIHRoYW4gMSBNaUIsIHRyaWdnZXIgcmVzZWVkXG4gICAgICBpZihjdHguZ2VuZXJhdGVkID4gMHhmZmZmZikge1xuICAgICAgICBjdHgua2V5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYoY3R4LmtleSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBwcmV2ZW50IHN0YWNrIG92ZXJmbG93XG4gICAgICAgIHJldHVybiBmb3JnZS51dGlsLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9yZXNlZWQoZ2VuZXJhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIHJhbmRvbSBieXRlc1xuICAgICAgdmFyIGJ5dGVzID0gY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKTtcbiAgICAgIGN0eC5nZW5lcmF0ZWQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgYi5wdXRCeXRlcyhieXRlcyk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGJ5dGVzIGZvciBhIG5ldyBrZXkgYW5kIHNlZWRcbiAgICAgIGN0eC5rZXkgPSBmb3JtYXRLZXkoY2lwaGVyKGN0eC5rZXksIGluY3JlbWVudChjdHguc2VlZCkpKTtcbiAgICAgIGN0eC5zZWVkID0gZm9ybWF0U2VlZChjaXBoZXIoY3R4LmtleSwgY3R4LnNlZWQpKTtcblxuICAgICAgZm9yZ2UudXRpbC5zZXRJbW1lZGlhdGUoZ2VuZXJhdGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJhbmRvbSBieXRlcyBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlU3luYyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gc2ltcGxlIGdlbmVyYXRvciB1c2luZyBjb3VudGVyLWJhc2VkIENCQ1xuICAgIHZhciBjaXBoZXIgPSBjdHgucGx1Z2luLmNpcGhlcjtcbiAgICB2YXIgaW5jcmVtZW50ID0gY3R4LnBsdWdpbi5pbmNyZW1lbnQ7XG4gICAgdmFyIGZvcm1hdEtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5O1xuICAgIHZhciBmb3JtYXRTZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkO1xuXG4gICAgLy8gcGFyYW5vaWQgZGV2aWF0aW9uIGZyb20gRm9ydHVuYTpcbiAgICAvLyByZXNldCBrZXkgZm9yIGV2ZXJ5IHJlcXVlc3QgdG8gcHJvdGVjdCBwcmV2aW91c2x5XG4gICAgLy8gZ2VuZXJhdGVkIHJhbmRvbSBieXRlcyBzaG91bGQgdGhlIGtleSBiZSBkaXNjb3ZlcmVkO1xuICAgIC8vIHRoZXJlIGlzIG5vIDEwMG1zIGJhc2VkIHJlc2VlZGluZyBiZWNhdXNlIG9mIHRoaXNcbiAgICAvLyBmb3JjZWQgcmVzZWVkIGZvciBldmVyeSBgZ2VuZXJhdGVTeW5jYCBjYWxsXG4gICAgY3R4LmtleSA9IG51bGw7XG5cbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgd2hpbGUoYi5sZW5ndGgoKSA8IGNvdW50KSB7XG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgX3Jlc2VlZFN5bmMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIHJhbmRvbSBieXRlc1xuICAgICAgdmFyIGJ5dGVzID0gY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKTtcbiAgICAgIGN0eC5nZW5lcmF0ZWQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgYi5wdXRCeXRlcyhieXRlcyk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGJ5dGVzIGZvciBhIG5ldyBrZXkgYW5kIHNlZWRcbiAgICAgIGN0eC5rZXkgPSBmb3JtYXRLZXkoY2lwaGVyKGN0eC5rZXksIGluY3JlbWVudChjdHguc2VlZCkpKTtcbiAgICAgIGN0eC5zZWVkID0gZm9ybWF0U2VlZChjaXBoZXIoY3R4LmtleSwgY3R4LnNlZWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYi5nZXRCeXRlcyhjb3VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBhc3luY2hyb25vdXNseSByZXNlZWRzIGEgZ2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2soZXJyKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWQoY2FsbGJhY2spIHtcbiAgICBpZihjdHgucG9vbHNbMF0ubWVzc2FnZUxlbmd0aCA+PSAzMikge1xuICAgICAgX3NlZWQoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHNlZWQgZGF0YS4uLlxuICAgIHZhciBuZWVkZWQgPSAoMzIgLSBjdHgucG9vbHNbMF0ubWVzc2FnZUxlbmd0aCkgPDwgNTtcbiAgICBjdHguc2VlZEZpbGUobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjdHguY29sbGVjdChieXRlcyk7XG4gICAgICBfc2VlZCgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgc3luY2hyb25vdXNseSByZXNlZWRzIGEgZ2VuZXJhdG9yLlxuICAgKi9cbiAgZnVuY3Rpb24gX3Jlc2VlZFN5bmMoKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIHJldHVybiBfc2VlZCgpO1xuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHNlZWQgZGF0YS4uLlxuICAgIHZhciBuZWVkZWQgPSAoMzIgLSBjdHgucG9vbHNbMF0ubWVzc2FnZUxlbmd0aCkgPDwgNTtcbiAgICBjdHguY29sbGVjdChjdHguc2VlZEZpbGVTeW5jKG5lZWRlZCkpO1xuICAgIF9zZWVkKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHNlZWRzIGEgZ2VuZXJhdG9yIG9uY2UgZW5vdWdoIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBmdW5jdGlvbiBfc2VlZCgpIHtcbiAgICAvLyB1cGRhdGUgcmVzZWVkIGNvdW50XG4gICAgY3R4LnJlc2VlZHMgPSAoY3R4LnJlc2VlZHMgPT09IDB4ZmZmZmZmZmYpID8gMCA6IGN0eC5yZXNlZWRzICsgMTtcblxuICAgIC8vIGdvYWwgaXMgdG8gdXBkYXRlIGBrZXlgIHZpYTpcbiAgICAvLyBrZXkgPSBoYXNoKGtleSArIHMpXG4gICAgLy8gICB3aGVyZSAncycgaXMgYWxsIGNvbGxlY3RlZCBlbnRyb3B5IGZyb20gc2VsZWN0ZWQgcG9vbHMsIHRoZW4uLi5cblxuICAgIC8vIGNyZWF0ZSBhIHBsdWdpbi1iYXNlZCBtZXNzYWdlIGRpZ2VzdFxuICAgIHZhciBtZCA9IGN0eC5wbHVnaW4ubWQuY3JlYXRlKCk7XG5cbiAgICAvLyBjb25zdW1lIGN1cnJlbnQga2V5IGJ5dGVzXG4gICAgbWQudXBkYXRlKGN0eC5rZXlCeXRlcyk7XG5cbiAgICAvLyBkaWdlc3QgdGhlIGVudHJvcHkgb2YgcG9vbHMgd2hvc2UgaW5kZXggayBtZWV0IHRoZVxuICAgIC8vIGNvbmRpdGlvbiAnbiBtb2QgMl5rID09IDAnIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiByZXNlZWRzXG4gICAgdmFyIF8ycG93SyA9IDE7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IDMyOyArK2spIHtcbiAgICAgIGlmKGN0eC5yZXNlZWRzICUgXzJwb3dLID09PSAwKSB7XG4gICAgICAgIG1kLnVwZGF0ZShjdHgucG9vbHNba10uZGlnZXN0KCkuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIGN0eC5wb29sc1trXS5zdGFydCgpO1xuICAgICAgfVxuICAgICAgXzJwb3dLID0gXzJwb3dLIDw8IDE7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGRpZ2VzdCBmb3Iga2V5IGJ5dGVzXG4gICAgY3R4LmtleUJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gdXBkYXRlIGBzZWVkYCB2aWEgYHNlZWQgPSBoYXNoKGtleSlgXG4gICAgLy8gaW5zdGVhZCBvZiBpbml0aWFsaXppbmcgdG8gemVybyBvbmNlIGFuZCBvbmx5XG4gICAgLy8gZXZlciBpbmNyZW1lbnRpbmcgaXRcbiAgICBtZC5zdGFydCgpO1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuICAgIHZhciBzZWVkQnl0ZXMgPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLy8gdXBkYXRlIHN0YXRlXG4gICAgY3R4LmtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5KGN0eC5rZXlCeXRlcyk7XG4gICAgY3R4LnNlZWQgPSBjdHgucGx1Z2luLmZvcm1hdFNlZWQoc2VlZEJ5dGVzKTtcbiAgICBjdHguZ2VuZXJhdGVkID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYnVpbHQtaW4gZGVmYXVsdCBzZWVkRmlsZS4gVGhpcyBzZWVkRmlsZSBpcyB1c2VkIHdoZW4gZW50cm9weVxuICAgKiBpcyBuZWVkZWQgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBuZWVkZWQgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJhbmRvbSBieXRlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRTZWVkRmlsZShuZWVkZWQpIHtcbiAgICAvLyB1c2Ugd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgc3Ryb25nIHNvdXJjZSBvZiBlbnRyb3B5IGlmIGF2YWlsYWJsZVxuICAgIHZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xuICAgIHZhciBnbG9iYWxTY29wZSA9IGZvcmdlLnV0aWwuZ2xvYmFsU2NvcGU7XG4gICAgdmFyIF9jcnlwdG8gPSBnbG9iYWxTY29wZS5jcnlwdG8gfHwgZ2xvYmFsU2NvcGUubXNDcnlwdG87XG4gICAgaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHJldHVybiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIC8vIG1heCBieXRlIGxlbmd0aCBpcyA2NTUzNiBiZWZvcmUgUXVvdGFFeGNlZWRlZEVycm9yIGlzIHRocm93blxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XZWJDcnlwdG9BUEkvI1JhbmRvbVNvdXJjZS1tZXRob2QtZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAgIHZhciBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGgubWluKG5lZWRlZCAtIGIubGVuZ3RoKCksIDY1NTM2KSAvIDQpO1xuICAgICAgICB2YXIgZW50cm9weSA9IG5ldyBVaW50MzJBcnJheShNYXRoLmZsb29yKGNvdW50KSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2V0UmFuZG9tVmFsdWVzKGVudHJvcHkpO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyb3B5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBiLnB1dEludDMyKGVudHJvcHlbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgLyogb25seSBpZ25vcmUgUXVvdGFFeGNlZWRlZEVycm9yICovXG4gICAgICAgICAgaWYoISh0eXBlb2YgUXVvdGFFeGNlZWRlZEVycm9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZSBpbnN0YW5jZW9mIFF1b3RhRXhjZWVkZWRFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmUgc2FkIGFuZCBhZGQgc29tZSB3ZWFrIHJhbmRvbSBkYXRhXG4gICAgaWYoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgLyogRHJhd3MgZnJvbSBQYXJrLU1pbGxlciBcIm1pbmltYWwgc3RhbmRhcmRcIiAzMSBiaXQgUFJORyxcbiAgICAgIGltcGxlbWVudGVkIHdpdGggRGF2aWQgRy4gQ2FydGEncyBvcHRpbWl6YXRpb246IHdpdGggMzIgYml0IG1hdGhcbiAgICAgIGFuZCB3aXRob3V0IGRpdmlzaW9uIChQdWJsaWMgRG9tYWluKS4gKi9cbiAgICAgIHZhciBoaSwgbG8sIG5leHQ7XG4gICAgICB2YXIgc2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMDAwKTtcbiAgICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgICAgbG8gPSAxNjgwNyAqIChzZWVkICYgMHhGRkZGKTtcbiAgICAgICAgaGkgPSAxNjgwNyAqIChzZWVkID4+IDE2KTtcbiAgICAgICAgbG8gKz0gKGhpICYgMHg3RkZGKSA8PCAxNjtcbiAgICAgICAgbG8gKz0gaGkgPj4gMTU7XG4gICAgICAgIGxvID0gKGxvICYgMHg3RkZGRkZGRikgKyAobG8gPj4gMzEpO1xuICAgICAgICBzZWVkID0gbG8gJiAweEZGRkZGRkZGO1xuXG4gICAgICAgIC8vIGNvbnN1bWUgbG93ZXIgMyBieXRlcyBvZiBzZWVkXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAvLyB0aHJvdyBpbiBtb3JlIHBzZXVkbyByYW5kb21cbiAgICAgICAgICBuZXh0ID0gc2VlZCA+Pj4gKGkgPDwgMyk7XG4gICAgICAgICAgbmV4dCBePSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDApO1xuICAgICAgICAgIGIucHV0Qnl0ZShuZXh0ICYgMHhGRik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYi5nZXRCeXRlcyhuZWVkZWQpO1xuICB9XG4gIC8vIGluaXRpYWxpemUgc2VlZCBmaWxlIEFQSXNcbiAgaWYoX2NyeXB0bykge1xuICAgIC8vIHVzZSBub2RlanMgYXN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgX2NyeXB0by5yYW5kb21CeXRlcyhuZWVkZWQsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYnl0ZXMudG9TdHJpbmcoKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHVzZSBub2RlanMgc3luYyBBUElcbiAgICBjdHguc2VlZEZpbGVTeW5jID0gZnVuY3Rpb24obmVlZGVkKSB7XG4gICAgICByZXR1cm4gX2NyeXB0by5yYW5kb21CeXRlcyhuZWVkZWQpLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdHguc2VlZEZpbGVTeW5jID0gZGVmYXVsdFNlZWRGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZW50cm9weSB0byBhIHBybmcgY3R4J3MgYWNjdW11bGF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgb2YgZW50cm9weSBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5jb2xsZWN0ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAvLyBpdGVyYXRlIG92ZXIgcG9vbHMgZGlzdHJpYnV0aW5nIGVudHJvcHkgY3ljbGljYWxseVxuICAgIHZhciBjb3VudCA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgY3R4LnBvb2xzW2N0eC5wb29sXS51cGRhdGUoYnl0ZXMuc3Vic3RyKGksIDEpKTtcbiAgICAgIGN0eC5wb29sID0gKGN0eC5wb29sID09PSAzMSkgPyAwIDogY3R4LnBvb2wgKyAxO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29sbGVjdHMgYW4gaW50ZWdlciBvZiBuIGJpdHMuXG4gICAqXG4gICAqIEBwYXJhbSBpIHRoZSBpbnRlZ2VyIGVudHJvcHkuXG4gICAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlci5cbiAgICovXG4gIGN0eC5jb2xsZWN0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICAgIHZhciBieXRlcyA9ICcnO1xuICAgIGZvcih2YXIgeCA9IDA7IHggPCBuOyB4ICs9IDgpIHtcbiAgICAgIGJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGkgPj4geCkgJiAweEZGKTtcbiAgICB9XG4gICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBXZWIgV29ya2VyIHRvIHJlY2VpdmUgaW1tZWRpYXRlIGVudHJvcHkgZnJvbSB0aGUgbWFpbiB0aHJlYWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIHVudGlsIFdlYiBXb3JrZXJzIGNhbiBhY2Nlc3MgdGhlIG5hdGl2ZSBjcnlwdG9cbiAgICogQVBJLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHR3aWNlIGZvciBlYWNoIGNyZWF0ZWQgd29ya2VyLCBvbmNlIGluXG4gICAqIHRoZSBtYWluIHRocmVhZCwgYW5kIG9uY2UgaW4gdGhlIHdvcmtlciBpdHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSB3b3JrZXIgdGhlIHdvcmtlciB0byByZWdpc3Rlci5cbiAgICovXG4gIGN0eC5yZWdpc3RlcldvcmtlciA9IGZ1bmN0aW9uKHdvcmtlcikge1xuICAgIC8vIHdvcmtlciByZWNlaXZlcyByYW5kb20gYnl0ZXNcbiAgICBpZih3b3JrZXIgPT09IHNlbGYpIHtcbiAgICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgIGlmKGRhdGEuZm9yZ2UgJiYgZGF0YS5mb3JnZS5wcm5nKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhLmZvcmdlLnBybmcuZXJyLCBkYXRhLmZvcmdlLnBybmcuYnl0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge25lZWRlZDogbmVlZGVkfX19KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1haW4gdGhyZWFkIHNlbmRzIHJhbmRvbSBieXRlcyB1cG9uIHJlcXVlc3RcbiAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgIGlmKGRhdGEuZm9yZ2UgJiYgZGF0YS5mb3JnZS5wcm5nKSB7XG4gICAgICAgICAgY3R4LnNlZWRGaWxlKGRhdGEuZm9yZ2UucHJuZy5uZWVkZWQsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7Zm9yZ2U6IHtwcm5nOiB7ZXJyOiBlcnIsIGJ5dGVzOiBieXRlc319fSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGUgd29ya2VyIGRpZXM/XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGN0eDtcbn07XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwiX2NyeXB0byIsInV0aWwiLCJpc05vZGVqcyIsIm9wdGlvbnMiLCJ1c2VQdXJlSmF2YVNjcmlwdCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsInBybmciLCJtb2R1bGUiLCJleHBvcnRzIiwiY3JlYXRlIiwicGx1Z2luIiwiY3R4Iiwia2V5Iiwic2VlZCIsInRpbWUiLCJyZXNlZWRzIiwiZ2VuZXJhdGVkIiwia2V5Qnl0ZXMiLCJtZCIsInBvb2xzIiwiQXJyYXkiLCJpIiwicG9vbCIsImdlbmVyYXRlIiwiY291bnQiLCJjYWxsYmFjayIsImdlbmVyYXRlU3luYyIsImNpcGhlciIsImluY3JlbWVudCIsImZvcm1hdEtleSIsImZvcm1hdFNlZWQiLCJiIiwiY3JlYXRlQnVmZmVyIiwiZXJyIiwibGVuZ3RoIiwiZ2V0Qnl0ZXMiLCJuZXh0VGljayIsIl9yZXNlZWQiLCJieXRlcyIsInB1dEJ5dGVzIiwic2V0SW1tZWRpYXRlIiwiX3Jlc2VlZFN5bmMiLCJtZXNzYWdlTGVuZ3RoIiwiX3NlZWQiLCJuZWVkZWQiLCJzZWVkRmlsZSIsImNvbGxlY3QiLCJzZWVkRmlsZVN5bmMiLCJ1cGRhdGUiLCJfMnBvd0siLCJrIiwiZGlnZXN0Iiwic3RhcnQiLCJzZWVkQnl0ZXMiLCJkZWZhdWx0U2VlZEZpbGUiLCJnZXRSYW5kb21WYWx1ZXMiLCJnbG9iYWxTY29wZSIsImNyeXB0byIsIm1zQ3J5cHRvIiwiYXJyIiwiTWF0aCIsIm1heCIsIm1pbiIsImVudHJvcHkiLCJVaW50MzJBcnJheSIsImZsb29yIiwicHV0SW50MzIiLCJlIiwiUXVvdGFFeGNlZWRlZEVycm9yIiwiaGkiLCJsbyIsIm5leHQiLCJyYW5kb20iLCJwdXRCeXRlIiwicmFuZG9tQnl0ZXMiLCJ0b1N0cmluZyIsInN1YnN0ciIsImNvbGxlY3RJbnQiLCJuIiwieCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJlZ2lzdGVyV29ya2VyIiwid29ya2VyIiwic2VsZiIsImxpc3RlbmVyIiwiZGF0YSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicG9zdE1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/prng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/random.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/random.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * An API for getting cryptographically-secure random bytes. The bytes are\n * generated using the Fortuna algorithm devised by Bruce Schneier and\n * Niels Ferguson.\n *\n * Getting strong random bytes is not yet easy to do in javascript. The only\n * truish random entropy that can be collected is from the mouse, keyboard, or\n * from timing with respect to page loads, etc. This generator makes a poor\n * attempt at providing random bytes when those sources haven't yet provided\n * enough entropy to initially seed or to reseed the PRNG.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(ssr)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./sha256 */ \"(ssr)/./node_modules/node-forge/lib/sha256.js\");\n__webpack_require__(/*! ./prng */ \"(ssr)/./node_modules/node-forge/lib/prng.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n(function() {\n    // forge.random already defined\n    if (forge.random && forge.random.getBytes) {\n        module.exports = forge.random;\n        return;\n    }\n    (function(jQuery1) {\n        // the default prng plugin, uses AES-128\n        var prng_aes = {};\n        var _prng_aes_output = new Array(4);\n        var _prng_aes_buffer = forge.util.createBuffer();\n        prng_aes.formatKey = function(key) {\n            // convert the key into 32-bit integers\n            var tmp = forge.util.createBuffer(key);\n            key = new Array(4);\n            key[0] = tmp.getInt32();\n            key[1] = tmp.getInt32();\n            key[2] = tmp.getInt32();\n            key[3] = tmp.getInt32();\n            // return the expanded key\n            return forge.aes._expandKey(key, false);\n        };\n        prng_aes.formatSeed = function(seed) {\n            // convert seed into 32-bit integers\n            var tmp = forge.util.createBuffer(seed);\n            seed = new Array(4);\n            seed[0] = tmp.getInt32();\n            seed[1] = tmp.getInt32();\n            seed[2] = tmp.getInt32();\n            seed[3] = tmp.getInt32();\n            return seed;\n        };\n        prng_aes.cipher = function(key, seed) {\n            forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n            _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n            _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n            _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n            _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n            return _prng_aes_buffer.getBytes();\n        };\n        prng_aes.increment = function(seed) {\n            // FIXME: do we care about carry or signed issues?\n            ++seed[3];\n            return seed;\n        };\n        prng_aes.md = forge.md.sha256;\n        /**\n * Creates a new PRNG.\n */ function spawnPrng() {\n            var ctx = forge.prng.create(prng_aes);\n            /**\n   * Gets random bytes. If a native secure crypto API is unavailable, this\n   * method tries to make the bytes more unpredictable by drawing from data that\n   * can be collected from the user of the browser, eg: mouse movement.\n   *\n   * If a callback is given, this method will be called asynchronously.\n   *\n   * @param count the number of random bytes to get.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return the random bytes in a string.\n   */ ctx.getBytes = function(count, callback) {\n                return ctx.generate(count, callback);\n            };\n            /**\n   * Gets random bytes asynchronously. If a native secure crypto API is\n   * unavailable, this method tries to make the bytes more unpredictable by\n   * drawing from data that can be collected from the user of the browser,\n   * eg: mouse movement.\n   *\n   * @param count the number of random bytes to get.\n   *\n   * @return the random bytes in a string.\n   */ ctx.getBytesSync = function(count) {\n                return ctx.generate(count);\n            };\n            return ctx;\n        }\n        // create default prng context\n        var _ctx = spawnPrng();\n        // add other sources of entropy only if window.crypto.getRandomValues is not\n        // available -- otherwise this source will be automatically used by the prng\n        var getRandomValues = null;\n        var globalScope = forge.util.globalScope;\n        var _crypto = globalScope.crypto || globalScope.msCrypto;\n        if (_crypto && _crypto.getRandomValues) {\n            getRandomValues = function(arr) {\n                return _crypto.getRandomValues(arr);\n            };\n        }\n        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {\n            // if this is a web worker, do not use weak entropy, instead register to\n            // receive strong entropy asynchronously from the main thread\n            if (true) {\n            // FIXME:\n            }\n            // get load time entropy\n            _ctx.collectInt(+new Date(), 32);\n            // add some entropy from navigator object\n            if (typeof navigator !== \"undefined\") {\n                var _navBytes = \"\";\n                for(var key in navigator){\n                    try {\n                        if (typeof navigator[key] == \"string\") {\n                            _navBytes += navigator[key];\n                        }\n                    } catch (e) {\n                    /* Some navigator keys might not be accessible, e.g. the geolocation\n          attribute throws an exception if touched in Mozilla chrome://\n          context.\n\n          Silently ignore this and just don't use this as a source of\n          entropy. */ }\n                }\n                _ctx.collect(_navBytes);\n                _navBytes = null;\n            }\n            // add mouse and keyboard collectors if jquery is available\n            if (jQuery1) {\n                // set up mouse entropy capture\n                jQuery1().mousemove(function(e) {\n                    // add mouse coords\n                    _ctx.collectInt(e.clientX, 16);\n                    _ctx.collectInt(e.clientY, 16);\n                });\n                // set up keyboard entropy capture\n                jQuery1().keypress(function(e) {\n                    _ctx.collectInt(e.charCode, 8);\n                });\n            }\n        }\n        /* Random API */ if (!forge.random) {\n            forge.random = _ctx;\n        } else {\n            // extend forge.random with _ctx\n            for(var key in _ctx){\n                forge.random[key] = _ctx[key];\n            }\n        }\n        // expose spawn PRNG\n        forge.random.createInstance = spawnPrng;\n        module.exports = forge.random;\n    })(typeof jQuery !== \"undefined\" ? jQuery : null);\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmFuZG9tLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztDQWNDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVA7SUFFRCwrQkFBK0I7SUFDL0IsSUFBR0QsTUFBTUUsTUFBTSxJQUFJRixNQUFNRSxNQUFNLENBQUNDLFFBQVEsRUFBRTtRQUN4Q0MsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRSxNQUFNO1FBQzdCO0lBQ0Y7SUFFQyxVQUFTSSxPQUFNO1FBRWhCLHdDQUF3QztRQUN4QyxJQUFJQyxXQUFXLENBQUM7UUFDaEIsSUFBSUMsbUJBQW1CLElBQUlDLE1BQU07UUFDakMsSUFBSUMsbUJBQW1CVixNQUFNVyxJQUFJLENBQUNDLFlBQVk7UUFDOUNMLFNBQVNNLFNBQVMsR0FBRyxTQUFTQyxHQUFHO1lBQy9CLHVDQUF1QztZQUN2QyxJQUFJQyxNQUFNZixNQUFNVyxJQUFJLENBQUNDLFlBQVksQ0FBQ0U7WUFDbENBLE1BQU0sSUFBSUwsTUFBTTtZQUNoQkssR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUNyQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUNyQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUNyQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUVyQiwwQkFBMEI7WUFDMUIsT0FBT2hCLE1BQU1pQixHQUFHLENBQUNDLFVBQVUsQ0FBQ0osS0FBSztRQUNuQztRQUNBUCxTQUFTWSxVQUFVLEdBQUcsU0FBU0MsSUFBSTtZQUNqQyxvQ0FBb0M7WUFDcEMsSUFBSUwsTUFBTWYsTUFBTVcsSUFBSSxDQUFDQyxZQUFZLENBQUNRO1lBQ2xDQSxPQUFPLElBQUlYLE1BQU07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QUFDSSxFQUFFSSxPQUFPLEVBQUU7Z0JBQzdCO2dCQUVBLGtDQUFrQztnQkFDbENsRCxVQUFTbUQsUUFBUSxDQUFDLFNBQVNMLENBQUM7b0JBQzFCakIsS0FBS2EsVUFBVSxDQUFDSSxFQUFFTSxRQUFRLEVBQUU7Z0JBQzlCO1lBQ0Y7UUFDRjtRQUVBLGNBQWMsR0FDZCxJQUFHLENBQUMxRCxNQUFNRSxNQUFNLEVBQUU7WUFDaEJGLE1BQU1FLE1BQU0sR0FBR2lDO1FBQ2pCLE9BQU87WUFDTCxnQ0FBZ0M7WUFDaEMsSUFBSSxJQUFJckIsT0FBT3FCLEtBQU07Z0JBQ25CbkMsTUFBTUUsTUFBTSxDQUFDWSxJQUFJLEdBQUdxQixJQUFJLENBQUNyQixJQUFJO1lBQy9CO1FBQ0Y7UUFFQSxvQkFBb0I7UUFDcEJkLE1BQU1FLE1BQU0sQ0FBQ3lELGNBQWMsR0FBR2hDO1FBRTlCdkIsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRSxNQUFNO0lBRTdCLEdBQUcsT0FBT0ksV0FBWSxjQUFjQSxTQUFTO0FBRTdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmFuZG9tLmpzP2ZhYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBbiBBUEkgZm9yIGdldHRpbmcgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBieXRlcy4gVGhlIGJ5dGVzIGFyZVxuICogZ2VuZXJhdGVkIHVzaW5nIHRoZSBGb3J0dW5hIGFsZ29yaXRobSBkZXZpc2VkIGJ5IEJydWNlIFNjaG5laWVyIGFuZFxuICogTmllbHMgRmVyZ3Vzb24uXG4gKlxuICogR2V0dGluZyBzdHJvbmcgcmFuZG9tIGJ5dGVzIGlzIG5vdCB5ZXQgZWFzeSB0byBkbyBpbiBqYXZhc2NyaXB0LiBUaGUgb25seVxuICogdHJ1aXNoIHJhbmRvbSBlbnRyb3B5IHRoYXQgY2FuIGJlIGNvbGxlY3RlZCBpcyBmcm9tIHRoZSBtb3VzZSwga2V5Ym9hcmQsIG9yXG4gKiBmcm9tIHRpbWluZyB3aXRoIHJlc3BlY3QgdG8gcGFnZSBsb2FkcywgZXRjLiBUaGlzIGdlbmVyYXRvciBtYWtlcyBhIHBvb3JcbiAqIGF0dGVtcHQgYXQgcHJvdmlkaW5nIHJhbmRvbSBieXRlcyB3aGVuIHRob3NlIHNvdXJjZXMgaGF2ZW4ndCB5ZXQgcHJvdmlkZWRcbiAqIGVub3VnaCBlbnRyb3B5IHRvIGluaXRpYWxseSBzZWVkIG9yIHRvIHJlc2VlZCB0aGUgUFJORy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYWVzJyk7XG5yZXF1aXJlKCcuL3NoYTI1NicpO1xucmVxdWlyZSgnLi9wcm5nJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4vLyBmb3JnZS5yYW5kb20gYWxyZWFkeSBkZWZpbmVkXG5pZihmb3JnZS5yYW5kb20gJiYgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucmFuZG9tO1xuICByZXR1cm47XG59XG5cbihmdW5jdGlvbihqUXVlcnkpIHtcblxuLy8gdGhlIGRlZmF1bHQgcHJuZyBwbHVnaW4sIHVzZXMgQUVTLTEyOFxudmFyIHBybmdfYWVzID0ge307XG52YXIgX3BybmdfYWVzX291dHB1dCA9IG5ldyBBcnJheSg0KTtcbnZhciBfcHJuZ19hZXNfYnVmZmVyID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbnBybmdfYWVzLmZvcm1hdEtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIHRtcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIGtleSA9IG5ldyBBcnJheSg0KTtcbiAga2V5WzBdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsxXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzNdID0gdG1wLmdldEludDMyKCk7XG5cbiAgLy8gcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlcbiAgcmV0dXJuIGZvcmdlLmFlcy5fZXhwYW5kS2V5KGtleSwgZmFsc2UpO1xufTtcbnBybmdfYWVzLmZvcm1hdFNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIGNvbnZlcnQgc2VlZCBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoc2VlZCk7XG4gIHNlZWQgPSBuZXcgQXJyYXkoNCk7XG4gIHNlZWRbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFsxXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzJdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbM10gPSB0bXAuZ2V0SW50MzIoKTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMuY2lwaGVyID0gZnVuY3Rpb24oa2V5LCBzZWVkKSB7XG4gIGZvcmdlLmFlcy5fdXBkYXRlQmxvY2soa2V5LCBzZWVkLCBfcHJuZ19hZXNfb3V0cHV0LCBmYWxzZSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFswXSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFsxXSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFsyXSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFszXSk7XG4gIHJldHVybiBfcHJuZ19hZXNfYnVmZmVyLmdldEJ5dGVzKCk7XG59O1xucHJuZ19hZXMuaW5jcmVtZW50ID0gZnVuY3Rpb24oc2VlZCkge1xuICAvLyBGSVhNRTogZG8gd2UgY2FyZSBhYm91dCBjYXJyeSBvciBzaWduZWQgaXNzdWVzP1xuICArK3NlZWRbM107XG4gIHJldHVybiBzZWVkO1xufTtcbnBybmdfYWVzLm1kID0gZm9yZ2UubWQuc2hhMjU2O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUFJORy5cbiAqL1xuZnVuY3Rpb24gc3Bhd25Qcm5nKCkge1xuICB2YXIgY3R4ID0gZm9yZ2UucHJuZy5jcmVhdGUocHJuZ19hZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcy4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXMgdW5hdmFpbGFibGUsIHRoaXNcbiAgICogbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieSBkcmF3aW5nIGZyb20gZGF0YSB0aGF0XG4gICAqIGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlciwgZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBJZiBhIGNhbGxiYWNrIGlzIGdpdmVuLCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdldC5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJhbmRvbSBieXRlcyBpbiBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjdHguZ2VuZXJhdGUoY291bnQsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyByYW5kb20gYnl0ZXMgYXN5bmNocm9ub3VzbHkuIElmIGEgbmF0aXZlIHNlY3VyZSBjcnlwdG8gQVBJIGlzXG4gICAqIHVuYXZhaWxhYmxlLCB0aGlzIG1ldGhvZCB0cmllcyB0byBtYWtlIHRoZSBieXRlcyBtb3JlIHVucHJlZGljdGFibGUgYnlcbiAgICogZHJhd2luZyBmcm9tIGRhdGEgdGhhdCBjYW4gYmUgY29sbGVjdGVkIGZyb20gdGhlIHVzZXIgb2YgdGhlIGJyb3dzZXIsXG4gICAqIGVnOiBtb3VzZSBtb3ZlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzU3luYyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCk7XG4gIH07XG5cbiAgcmV0dXJuIGN0eDtcbn1cblxuLy8gY3JlYXRlIGRlZmF1bHQgcHJuZyBjb250ZXh0XG52YXIgX2N0eCA9IHNwYXduUHJuZygpO1xuXG4vLyBhZGQgb3RoZXIgc291cmNlcyBvZiBlbnRyb3B5IG9ubHkgaWYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaXMgbm90XG4vLyBhdmFpbGFibGUgLS0gb3RoZXJ3aXNlIHRoaXMgc291cmNlIHdpbGwgYmUgYXV0b21hdGljYWxseSB1c2VkIGJ5IHRoZSBwcm5nXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbnZhciBnbG9iYWxTY29wZSA9IGZvcmdlLnV0aWwuZ2xvYmFsU2NvcGU7XG52YXIgX2NyeXB0byA9IGdsb2JhbFNjb3BlLmNyeXB0byB8fCBnbG9iYWxTY29wZS5tc0NyeXB0bztcbmlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gIH07XG59XG5cbmlmKGZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgfHxcbiAgKCFmb3JnZS51dGlsLmlzTm9kZWpzICYmICFnZXRSYW5kb21WYWx1ZXMpKSB7XG4gIC8vIGlmIHRoaXMgaXMgYSB3ZWIgd29ya2VyLCBkbyBub3QgdXNlIHdlYWsgZW50cm9weSwgaW5zdGVhZCByZWdpc3RlciB0b1xuICAvLyByZWNlaXZlIHN0cm9uZyBlbnRyb3B5IGFzeW5jaHJvbm91c2x5IGZyb20gdGhlIG1haW4gdGhyZWFkXG4gIGlmKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdy5kb2N1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRklYTUU6XG4gIH1cblxuICAvLyBnZXQgbG9hZCB0aW1lIGVudHJvcHlcbiAgX2N0eC5jb2xsZWN0SW50KCtuZXcgRGF0ZSgpLCAzMik7XG5cbiAgLy8gYWRkIHNvbWUgZW50cm9weSBmcm9tIG5hdmlnYXRvciBvYmplY3RcbiAgaWYodHlwZW9mKG5hdmlnYXRvcikgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF9uYXZCeXRlcyA9ICcnO1xuICAgIGZvcih2YXIga2V5IGluIG5hdmlnYXRvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYodHlwZW9mKG5hdmlnYXRvcltrZXldKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIF9uYXZCeXRlcyArPSBuYXZpZ2F0b3Jba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8qIFNvbWUgbmF2aWdhdG9yIGtleXMgbWlnaHQgbm90IGJlIGFjY2Vzc2libGUsIGUuZy4gdGhlIGdlb2xvY2F0aW9uXG4gICAgICAgICAgYXR0cmlidXRlIHRocm93cyBhbiBleGNlcHRpb24gaWYgdG91Y2hlZCBpbiBNb3ppbGxhIGNocm9tZTovL1xuICAgICAgICAgIGNvbnRleHQuXG5cbiAgICAgICAgICBTaWxlbnRseSBpZ25vcmUgdGhpcyBhbmQganVzdCBkb24ndCB1c2UgdGhpcyBhcyBhIHNvdXJjZSBvZlxuICAgICAgICAgIGVudHJvcHkuICovXG4gICAgICB9XG4gICAgfVxuICAgIF9jdHguY29sbGVjdChfbmF2Qnl0ZXMpO1xuICAgIF9uYXZCeXRlcyA9IG51bGw7XG4gIH1cblxuICAvLyBhZGQgbW91c2UgYW5kIGtleWJvYXJkIGNvbGxlY3RvcnMgaWYganF1ZXJ5IGlzIGF2YWlsYWJsZVxuICBpZihqUXVlcnkpIHtcbiAgICAvLyBzZXQgdXAgbW91c2UgZW50cm9weSBjYXB0dXJlXG4gICAgalF1ZXJ5KCkubW91c2Vtb3ZlKGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIGFkZCBtb3VzZSBjb29yZHNcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNsaWVudFgsIDE2KTtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNsaWVudFksIDE2KTtcbiAgICB9KTtcblxuICAgIC8vIHNldCB1cCBrZXlib2FyZCBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5rZXlwcmVzcyhmdW5jdGlvbihlKSB7XG4gICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jaGFyQ29kZSwgOCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyogUmFuZG9tIEFQSSAqL1xuaWYoIWZvcmdlLnJhbmRvbSkge1xuICBmb3JnZS5yYW5kb20gPSBfY3R4O1xufSBlbHNlIHtcbiAgLy8gZXh0ZW5kIGZvcmdlLnJhbmRvbSB3aXRoIF9jdHhcbiAgZm9yKHZhciBrZXkgaW4gX2N0eCkge1xuICAgIGZvcmdlLnJhbmRvbVtrZXldID0gX2N0eFtrZXldO1xuICB9XG59XG5cbi8vIGV4cG9zZSBzcGF3biBQUk5HXG5mb3JnZS5yYW5kb20uY3JlYXRlSW5zdGFuY2UgPSBzcGF3blBybmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucmFuZG9tO1xuXG59KSh0eXBlb2YoalF1ZXJ5KSAhPT0gJ3VuZGVmaW5lZCcgPyBqUXVlcnkgOiBudWxsKTtcblxufSkoKTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJyYW5kb20iLCJnZXRCeXRlcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJqUXVlcnkiLCJwcm5nX2FlcyIsIl9wcm5nX2Flc19vdXRwdXQiLCJBcnJheSIsIl9wcm5nX2Flc19idWZmZXIiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiZm9ybWF0S2V5Iiwia2V5IiwidG1wIiwiZ2V0SW50MzIiLCJhZXMiLCJfZXhwYW5kS2V5IiwiZm9ybWF0U2VlZCIsInNlZWQiLCJjaXBoZXIiLCJfdXBkYXRlQmxvY2siLCJwdXRJbnQzMiIsImluY3JlbWVudCIsIm1kIiwic2hhMjU2Iiwic3Bhd25Qcm5nIiwiY3R4IiwicHJuZyIsImNyZWF0ZSIsImNvdW50IiwiY2FsbGJhY2siLCJnZW5lcmF0ZSIsImdldEJ5dGVzU3luYyIsIl9jdHgiLCJnZXRSYW5kb21WYWx1ZXMiLCJnbG9iYWxTY29wZSIsIl9jcnlwdG8iLCJjcnlwdG8iLCJtc0NyeXB0byIsImFyciIsIm9wdGlvbnMiLCJ1c2VQdXJlSmF2YVNjcmlwdCIsImlzTm9kZWpzIiwid2luZG93IiwiZG9jdW1lbnQiLCJ1bmRlZmluZWQiLCJjb2xsZWN0SW50IiwiRGF0ZSIsIm5hdmlnYXRvciIsIl9uYXZCeXRlcyIsImUiLCJjb2xsZWN0IiwibW91c2Vtb3ZlIiwiY2xpZW50WCIsImNsaWVudFkiLCJrZXlwcmVzcyIsImNoYXJDb2RlIiwiY3JlYXRlSW5zdGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/random.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/rc2.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/rc2.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * RC2 implementation.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * Information on the RC2 cipher is available from RFC #2268,\n * http://www.ietf.org/rfc/rfc2268.txt\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nvar piTable = [\n    0xd9,\n    0x78,\n    0xf9,\n    0xc4,\n    0x19,\n    0xdd,\n    0xb5,\n    0xed,\n    0x28,\n    0xe9,\n    0xfd,\n    0x79,\n    0x4a,\n    0xa0,\n    0xd8,\n    0x9d,\n    0xc6,\n    0x7e,\n    0x37,\n    0x83,\n    0x2b,\n    0x76,\n    0x53,\n    0x8e,\n    0x62,\n    0x4c,\n    0x64,\n    0x88,\n    0x44,\n    0x8b,\n    0xfb,\n    0xa2,\n    0x17,\n    0x9a,\n    0x59,\n    0xf5,\n    0x87,\n    0xb3,\n    0x4f,\n    0x13,\n    0x61,\n    0x45,\n    0x6d,\n    0x8d,\n    0x09,\n    0x81,\n    0x7d,\n    0x32,\n    0xbd,\n    0x8f,\n    0x40,\n    0xeb,\n    0x86,\n    0xb7,\n    0x7b,\n    0x0b,\n    0xf0,\n    0x95,\n    0x21,\n    0x22,\n    0x5c,\n    0x6b,\n    0x4e,\n    0x82,\n    0x54,\n    0xd6,\n    0x65,\n    0x93,\n    0xce,\n    0x60,\n    0xb2,\n    0x1c,\n    0x73,\n    0x56,\n    0xc0,\n    0x14,\n    0xa7,\n    0x8c,\n    0xf1,\n    0xdc,\n    0x12,\n    0x75,\n    0xca,\n    0x1f,\n    0x3b,\n    0xbe,\n    0xe4,\n    0xd1,\n    0x42,\n    0x3d,\n    0xd4,\n    0x30,\n    0xa3,\n    0x3c,\n    0xb6,\n    0x26,\n    0x6f,\n    0xbf,\n    0x0e,\n    0xda,\n    0x46,\n    0x69,\n    0x07,\n    0x57,\n    0x27,\n    0xf2,\n    0x1d,\n    0x9b,\n    0xbc,\n    0x94,\n    0x43,\n    0x03,\n    0xf8,\n    0x11,\n    0xc7,\n    0xf6,\n    0x90,\n    0xef,\n    0x3e,\n    0xe7,\n    0x06,\n    0xc3,\n    0xd5,\n    0x2f,\n    0xc8,\n    0x66,\n    0x1e,\n    0xd7,\n    0x08,\n    0xe8,\n    0xea,\n    0xde,\n    0x80,\n    0x52,\n    0xee,\n    0xf7,\n    0x84,\n    0xaa,\n    0x72,\n    0xac,\n    0x35,\n    0x4d,\n    0x6a,\n    0x2a,\n    0x96,\n    0x1a,\n    0xd2,\n    0x71,\n    0x5a,\n    0x15,\n    0x49,\n    0x74,\n    0x4b,\n    0x9f,\n    0xd0,\n    0x5e,\n    0x04,\n    0x18,\n    0xa4,\n    0xec,\n    0xc2,\n    0xe0,\n    0x41,\n    0x6e,\n    0x0f,\n    0x51,\n    0xcb,\n    0xcc,\n    0x24,\n    0x91,\n    0xaf,\n    0x50,\n    0xa1,\n    0xf4,\n    0x70,\n    0x39,\n    0x99,\n    0x7c,\n    0x3a,\n    0x85,\n    0x23,\n    0xb8,\n    0xb4,\n    0x7a,\n    0xfc,\n    0x02,\n    0x36,\n    0x5b,\n    0x25,\n    0x55,\n    0x97,\n    0x31,\n    0x2d,\n    0x5d,\n    0xfa,\n    0x98,\n    0xe3,\n    0x8a,\n    0x92,\n    0xae,\n    0x05,\n    0xdf,\n    0x29,\n    0x10,\n    0x67,\n    0x6c,\n    0xba,\n    0xc9,\n    0xd3,\n    0x00,\n    0xe6,\n    0xcf,\n    0xe1,\n    0x9e,\n    0xa8,\n    0x2c,\n    0x63,\n    0x16,\n    0x01,\n    0x3f,\n    0x58,\n    0xe2,\n    0x89,\n    0xa9,\n    0x0d,\n    0x38,\n    0x34,\n    0x1b,\n    0xab,\n    0x33,\n    0xff,\n    0xb0,\n    0xbb,\n    0x48,\n    0x0c,\n    0x5f,\n    0xb9,\n    0xb1,\n    0xcd,\n    0x2e,\n    0xc5,\n    0xf3,\n    0xdb,\n    0x47,\n    0xe5,\n    0xa5,\n    0x9c,\n    0x77,\n    0x0a,\n    0xa6,\n    0x20,\n    0x68,\n    0xfe,\n    0x7f,\n    0xc1,\n    0xad\n];\nvar s = [\n    1,\n    2,\n    3,\n    5\n];\n/**\n * Rotate a word left by given number of bits.\n *\n * Bits that are shifted out on the left are put back in on the right\n * hand side.\n *\n * @param word The word to shift left.\n * @param bits The number of bits to shift by.\n * @return The rotated word.\n */ var rol = function(word, bits) {\n    return word << bits & 0xffff | (word & 0xffff) >> 16 - bits;\n};\n/**\n * Rotate a word right by given number of bits.\n *\n * Bits that are shifted out on the right are put back in on the left\n * hand side.\n *\n * @param word The word to shift right.\n * @param bits The number of bits to shift by.\n * @return The rotated word.\n */ var ror = function(word, bits) {\n    return (word & 0xffff) >> bits | word << 16 - bits & 0xffff;\n};\n/* RC2 API */ module.exports = forge.rc2 = forge.rc2 || {};\n/**\n * Perform RC2 key expansion as per RFC #2268, section 2.\n *\n * @param key variable-length user key (between 1 and 128 bytes)\n * @param effKeyBits number of effective key bits (default: 128)\n * @return the expanded RC2 key (ByteBuffer of 128 bytes)\n */ forge.rc2.expandKey = function(key, effKeyBits) {\n    if (typeof key === \"string\") {\n        key = forge.util.createBuffer(key);\n    }\n    effKeyBits = effKeyBits || 128;\n    /* introduce variables that match the names used in RFC #2268 */ var L = key;\n    var T = key.length();\n    var T1 = effKeyBits;\n    var T8 = Math.ceil(T1 / 8);\n    var TM = 0xff >> (T1 & 0x07);\n    var i;\n    for(i = T; i < 128; i++){\n        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 0xff]);\n    }\n    L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);\n    for(i = 127 - T8; i >= 0; i--){\n        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);\n    }\n    return L;\n};\n/**\n * Creates a RC2 cipher object.\n *\n * @param key the symmetric key to use (as base for key generation).\n * @param bits the number of effective key bits.\n * @param encrypt false for decryption, true for encryption.\n *\n * @return the cipher.\n */ var createCipher = function(key, bits, encrypt) {\n    var _finish = false, _input = null, _output = null, _iv = null;\n    var mixRound, mashRound;\n    var i, j, K = [];\n    /* Expand key and fill into K[] Array */ key = forge.rc2.expandKey(key, bits);\n    for(i = 0; i < 64; i++){\n        K.push(key.getInt16Le());\n    }\n    if (encrypt) {\n        /**\n     * Perform one mixing round \"in place\".\n     *\n     * @param R Array of four words to perform mixing on.\n     */ mixRound = function(R) {\n            for(i = 0; i < 4; i++){\n                R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);\n                R[i] = rol(R[i], s[i]);\n                j++;\n            }\n        };\n        /**\n     * Perform one mashing round \"in place\".\n     *\n     * @param R Array of four words to perform mashing on.\n     */ mashRound = function(R) {\n            for(i = 0; i < 4; i++){\n                R[i] += K[R[(i + 3) % 4] & 63];\n            }\n        };\n    } else {\n        /**\n     * Perform one r-mixing round \"in place\".\n     *\n     * @param R Array of four words to perform mixing on.\n     */ mixRound = function(R) {\n            for(i = 3; i >= 0; i--){\n                R[i] = ror(R[i], s[i]);\n                R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);\n                j--;\n            }\n        };\n        /**\n     * Perform one r-mashing round \"in place\".\n     *\n     * @param R Array of four words to perform mashing on.\n     */ mashRound = function(R) {\n            for(i = 3; i >= 0; i--){\n                R[i] -= K[R[(i + 3) % 4] & 63];\n            }\n        };\n    }\n    /**\n   * Run the specified cipher execution plan.\n   *\n   * This function takes four words from the input buffer, applies the IV on\n   * it (if requested) and runs the provided execution plan.\n   *\n   * The plan must be put together in form of a array of arrays.  Where the\n   * outer one is simply a list of steps to perform and the inner one needs\n   * to have two elements: the first one telling how many rounds to perform,\n   * the second one telling what to do (i.e. the function to call).\n   *\n   * @param {Array} plan The plan to execute.\n   */ var runPlan = function(plan) {\n        var R = [];\n        /* Get data from input buffer and fill the four words into R */ for(i = 0; i < 4; i++){\n            var val = _input.getInt16Le();\n            if (_iv !== null) {\n                if (encrypt) {\n                    /* We're encrypting, apply the IV first. */ val ^= _iv.getInt16Le();\n                } else {\n                    /* We're decryption, keep cipher text for next block. */ _iv.putInt16Le(val);\n                }\n            }\n            R.push(val & 0xffff);\n        }\n        /* Reset global \"j\" variable as per spec. */ j = encrypt ? 0 : 63;\n        /* Run execution plan. */ for(var ptr = 0; ptr < plan.length; ptr++){\n            for(var ctr = 0; ctr < plan[ptr][0]; ctr++){\n                plan[ptr][1](R);\n            }\n        }\n        /* Write back result to output buffer. */ for(i = 0; i < 4; i++){\n            if (_iv !== null) {\n                if (encrypt) {\n                    /* We're encrypting in CBC-mode, feed back encrypted bytes into\n             IV buffer to carry it forward to next block. */ _iv.putInt16Le(R[i]);\n                } else {\n                    R[i] ^= _iv.getInt16Le();\n                }\n            }\n            _output.putInt16Le(R[i]);\n        }\n    };\n    /* Create cipher object */ var cipher = null;\n    cipher = {\n        /**\n     * Starts or restarts the encryption or decryption process, whichever\n     * was previously configured.\n     *\n     * To use the cipher in CBC mode, iv may be given either as a string\n     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.\n     *\n     * @param iv the initialization vector to use, null for ECB mode.\n     * @param output the output the buffer to write to, null to create one.\n     */ start: function(iv, output) {\n            if (iv) {\n                /* CBC mode */ if (typeof iv === \"string\") {\n                    iv = forge.util.createBuffer(iv);\n                }\n            }\n            _finish = false;\n            _input = forge.util.createBuffer();\n            _output = output || new forge.util.createBuffer();\n            _iv = iv;\n            cipher.output = _output;\n        },\n        /**\n     * Updates the next block.\n     *\n     * @param input the buffer to read from.\n     */ update: function(input) {\n            if (!_finish) {\n                // not finishing, so fill the input buffer with more input\n                _input.putBuffer(input);\n            }\n            while(_input.length() >= 8){\n                runPlan([\n                    [\n                        5,\n                        mixRound\n                    ],\n                    [\n                        1,\n                        mashRound\n                    ],\n                    [\n                        6,\n                        mixRound\n                    ],\n                    [\n                        1,\n                        mashRound\n                    ],\n                    [\n                        5,\n                        mixRound\n                    ]\n                ]);\n            }\n        },\n        /**\n     * Finishes encrypting or decrypting.\n     *\n     * @param pad a padding function to use, null for PKCS#7 padding,\n     *           signature(blockSize, buffer, decrypt).\n     *\n     * @return true if successful, false on error.\n     */ finish: function(pad) {\n            var rval = true;\n            if (encrypt) {\n                if (pad) {\n                    rval = pad(8, _input, !encrypt);\n                } else {\n                    // add PKCS#7 padding to block (each pad byte is the\n                    // value of the number of pad bytes)\n                    var padding = _input.length() === 8 ? 8 : 8 - _input.length();\n                    _input.fillWithByte(padding, padding);\n                }\n            }\n            if (rval) {\n                // do final update\n                _finish = true;\n                cipher.update();\n            }\n            if (!encrypt) {\n                // check for error: input data not a multiple of block size\n                rval = _input.length() === 0;\n                if (rval) {\n                    if (pad) {\n                        rval = pad(8, _output, !encrypt);\n                    } else {\n                        // ensure padding byte count is valid\n                        var len = _output.length();\n                        var count = _output.at(len - 1);\n                        if (count > len) {\n                            rval = false;\n                        } else {\n                            // trim off padding bytes\n                            _output.truncate(count);\n                        }\n                    }\n                }\n            }\n            return rval;\n        }\n    };\n    return cipher;\n};\n/**\n * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\n * given symmetric key. The output will be stored in the 'output' member\n * of the returned cipher.\n *\n * The key and iv may be given as a string of bytes or a byte buffer.\n * The cipher is initialized to use 128 effective key bits.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n *\n * @return the cipher.\n */ forge.rc2.startEncrypting = function(key, iv, output) {\n    var cipher = forge.rc2.createEncryptionCipher(key, 128);\n    cipher.start(iv, output);\n    return cipher;\n};\n/**\n * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\n * given symmetric key.\n *\n * The key may be given as a string of bytes or a byte buffer.\n *\n * To start encrypting call start() on the cipher with an iv and optional\n * output buffer.\n *\n * @param key the symmetric key to use.\n *\n * @return the cipher.\n */ forge.rc2.createEncryptionCipher = function(key, bits) {\n    return createCipher(key, bits, true);\n};\n/**\n * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\n * given symmetric key. The output will be stored in the 'output' member\n * of the returned cipher.\n *\n * The key and iv may be given as a string of bytes or a byte buffer.\n * The cipher is initialized to use 128 effective key bits.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n *\n * @return the cipher.\n */ forge.rc2.startDecrypting = function(key, iv, output) {\n    var cipher = forge.rc2.createDecryptionCipher(key, 128);\n    cipher.start(iv, output);\n    return cipher;\n};\n/**\n * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\n * given symmetric key.\n *\n * The key may be given as a string of bytes or a byte buffer.\n *\n * To start decrypting call start() on the cipher with an iv and optional\n * output buffer.\n *\n * @param key the symmetric key to use.\n *\n * @return the cipher.\n */ forge.rc2.createDecryptionCipher = function(key, bits) {\n    return createCipher(key, bits, false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmMyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Q0FTQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlDLFVBQVU7SUFDWjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRjtBQUVELElBQUlDLElBQUk7SUFBQztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRXBCOzs7Ozs7Ozs7Q0FTQyxHQUNELElBQUlDLE1BQU0sU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQzNCLE9BQU8sUUFBVUEsT0FBUSxTQUFXLENBQUNELE9BQU8sTUFBSyxLQUFPLEtBQUtDO0FBQy9EO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsSUFBSUMsTUFBTSxTQUFTRixJQUFJLEVBQUVDLElBQUk7SUFDM0IsT0FBTyxDQUFFRCxPQUFPLE1BQUssS0FBTUMsT0FBUyxRQUFVLEtBQUtBLE9BQVM7QUFDOUQ7QUFFQSxXQUFXLEdBQ1hFLE9BQU9DLE9BQU8sR0FBR1QsTUFBTVUsR0FBRyxHQUFHVixNQUFNVSxHQUFHLElBQUks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QUFDbkQsS0FBSztJQUNuRG1DLE9BQU9DLEtBQUssQ0FBQ0MsSUFBSUM7SUFDakIsT0FBT0g7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEL0MsTUFBTVUsR0FBRyxDQUFDcUQsc0JBQXNCLEdBQUcsU0FBU25ELEdBQUcsRUFBRU4sSUFBSTtJQUNuRCxPQUFPc0IsYUFBYWhCLEtBQUtOLE1BQU07QUFDakM7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0ROLE1BQU1VLEdBQUcsQ0FBQ3NELGVBQWUsR0FBRyxTQUFTcEQsR0FBRyxFQUFFcUMsRUFBRSxFQUFFQyxNQUFNO0lBQ2xELElBQUlILFNBQVMvQyxNQUFNVSxHQUFHLENBQUN1RCxzQkFBc0IsQ0FBQ3JELEtBQUs7SUFDbkRtQyxPQUFPQyxLQUFLLENBQUNDLElBQUlDO0lBQ2pCLE9BQU9IO0FBQ1Q7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRC9DLE1BQU1VLEdBQUcsQ0FBQ3VELHNCQUFzQixHQUFHLFNBQVNyRCxHQUFHLEVBQUVOLElBQUk7SUFDbkQsT0FBT3NCLGFBQWFoQixLQUFLTixNQUFNO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmMyLmpzPzBlNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSQzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgUkMyIGNpcGhlciBpcyBhdmFpbGFibGUgZnJvbSBSRkMgIzIyNjgsXG4gKiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjY4LnR4dFxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHBpVGFibGUgPSBbXG4gIDB4ZDksIDB4NzgsIDB4ZjksIDB4YzQsIDB4MTksIDB4ZGQsIDB4YjUsIDB4ZWQsIDB4MjgsIDB4ZTksIDB4ZmQsIDB4NzksIDB4NGEsIDB4YTAsIDB4ZDgsIDB4OWQsXG4gIDB4YzYsIDB4N2UsIDB4MzcsIDB4ODMsIDB4MmIsIDB4NzYsIDB4NTMsIDB4OGUsIDB4NjIsIDB4NGMsIDB4NjQsIDB4ODgsIDB4NDQsIDB4OGIsIDB4ZmIsIDB4YTIsXG4gIDB4MTcsIDB4OWEsIDB4NTksIDB4ZjUsIDB4ODcsIDB4YjMsIDB4NGYsIDB4MTMsIDB4NjEsIDB4NDUsIDB4NmQsIDB4OGQsIDB4MDksIDB4ODEsIDB4N2QsIDB4MzIsXG4gIDB4YmQsIDB4OGYsIDB4NDAsIDB4ZWIsIDB4ODYsIDB4YjcsIDB4N2IsIDB4MGIsIDB4ZjAsIDB4OTUsIDB4MjEsIDB4MjIsIDB4NWMsIDB4NmIsIDB4NGUsIDB4ODIsXG4gIDB4NTQsIDB4ZDYsIDB4NjUsIDB4OTMsIDB4Y2UsIDB4NjAsIDB4YjIsIDB4MWMsIDB4NzMsIDB4NTYsIDB4YzAsIDB4MTQsIDB4YTcsIDB4OGMsIDB4ZjEsIDB4ZGMsXG4gIDB4MTIsIDB4NzUsIDB4Y2EsIDB4MWYsIDB4M2IsIDB4YmUsIDB4ZTQsIDB4ZDEsIDB4NDIsIDB4M2QsIDB4ZDQsIDB4MzAsIDB4YTMsIDB4M2MsIDB4YjYsIDB4MjYsXG4gIDB4NmYsIDB4YmYsIDB4MGUsIDB4ZGEsIDB4NDYsIDB4NjksIDB4MDcsIDB4NTcsIDB4MjcsIDB4ZjIsIDB4MWQsIDB4OWIsIDB4YmMsIDB4OTQsIDB4NDMsIDB4MDMsXG4gIDB4ZjgsIDB4MTEsIDB4YzcsIDB4ZjYsIDB4OTAsIDB4ZWYsIDB4M2UsIDB4ZTcsIDB4MDYsIDB4YzMsIDB4ZDUsIDB4MmYsIDB4YzgsIDB4NjYsIDB4MWUsIDB4ZDcsXG4gIDB4MDgsIDB4ZTgsIDB4ZWEsIDB4ZGUsIDB4ODAsIDB4NTIsIDB4ZWUsIDB4ZjcsIDB4ODQsIDB4YWEsIDB4NzIsIDB4YWMsIDB4MzUsIDB4NGQsIDB4NmEsIDB4MmEsXG4gIDB4OTYsIDB4MWEsIDB4ZDIsIDB4NzEsIDB4NWEsIDB4MTUsIDB4NDksIDB4NzQsIDB4NGIsIDB4OWYsIDB4ZDAsIDB4NWUsIDB4MDQsIDB4MTgsIDB4YTQsIDB4ZWMsXG4gIDB4YzIsIDB4ZTAsIDB4NDEsIDB4NmUsIDB4MGYsIDB4NTEsIDB4Y2IsIDB4Y2MsIDB4MjQsIDB4OTEsIDB4YWYsIDB4NTAsIDB4YTEsIDB4ZjQsIDB4NzAsIDB4MzksXG4gIDB4OTksIDB4N2MsIDB4M2EsIDB4ODUsIDB4MjMsIDB4YjgsIDB4YjQsIDB4N2EsIDB4ZmMsIDB4MDIsIDB4MzYsIDB4NWIsIDB4MjUsIDB4NTUsIDB4OTcsIDB4MzEsXG4gIDB4MmQsIDB4NWQsIDB4ZmEsIDB4OTgsIDB4ZTMsIDB4OGEsIDB4OTIsIDB4YWUsIDB4MDUsIDB4ZGYsIDB4MjksIDB4MTAsIDB4NjcsIDB4NmMsIDB4YmEsIDB4YzksXG4gIDB4ZDMsIDB4MDAsIDB4ZTYsIDB4Y2YsIDB4ZTEsIDB4OWUsIDB4YTgsIDB4MmMsIDB4NjMsIDB4MTYsIDB4MDEsIDB4M2YsIDB4NTgsIDB4ZTIsIDB4ODksIDB4YTksXG4gIDB4MGQsIDB4MzgsIDB4MzQsIDB4MWIsIDB4YWIsIDB4MzMsIDB4ZmYsIDB4YjAsIDB4YmIsIDB4NDgsIDB4MGMsIDB4NWYsIDB4YjksIDB4YjEsIDB4Y2QsIDB4MmUsXG4gIDB4YzUsIDB4ZjMsIDB4ZGIsIDB4NDcsIDB4ZTUsIDB4YTUsIDB4OWMsIDB4NzcsIDB4MGEsIDB4YTYsIDB4MjAsIDB4NjgsIDB4ZmUsIDB4N2YsIDB4YzEsIDB4YWRcbl07XG5cbnZhciBzID0gWzEsIDIsIDMsIDVdO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgbGVmdCBieSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBCaXRzIHRoYXQgYXJlIHNoaWZ0ZWQgb3V0IG9uIHRoZSBsZWZ0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgcmlnaHRcbiAqIGhhbmQgc2lkZS5cbiAqXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0byBzaGlmdCBsZWZ0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9sID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkIDw8IGJpdHMpICYgMHhmZmZmKSB8ICgod29yZCAmIDB4ZmZmZikgPj4gKDE2IC0gYml0cykpO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB3b3JkIHJpZ2h0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIHJpZ2h0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgbGVmdFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IHJpZ2h0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9yID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkICYgMHhmZmZmKSA+PiBiaXRzKSB8ICgod29yZCA8PCAoMTYgLSBiaXRzKSkgJiAweGZmZmYpO1xufTtcblxuLyogUkMyIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYzIgPSBmb3JnZS5yYzIgfHwge307XG5cbi8qKlxuICogUGVyZm9ybSBSQzIga2V5IGV4cGFuc2lvbiBhcyBwZXIgUkZDICMyMjY4LCBzZWN0aW9uIDIuXG4gKlxuICogQHBhcmFtIGtleSB2YXJpYWJsZS1sZW5ndGggdXNlciBrZXkgKGJldHdlZW4gMSBhbmQgMTI4IGJ5dGVzKVxuICogQHBhcmFtIGVmZktleUJpdHMgbnVtYmVyIG9mIGVmZmVjdGl2ZSBrZXkgYml0cyAoZGVmYXVsdDogMTI4KVxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgUkMyIGtleSAoQnl0ZUJ1ZmZlciBvZiAxMjggYnl0ZXMpXG4gKi9cbmZvcmdlLnJjMi5leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGVmZktleUJpdHMpIHtcbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9XG4gIGVmZktleUJpdHMgPSBlZmZLZXlCaXRzIHx8IDEyODtcblxuICAvKiBpbnRyb2R1Y2UgdmFyaWFibGVzIHRoYXQgbWF0Y2ggdGhlIG5hbWVzIHVzZWQgaW4gUkZDICMyMjY4ICovXG4gIHZhciBMID0ga2V5O1xuICB2YXIgVCA9IGtleS5sZW5ndGgoKTtcbiAgdmFyIFQxID0gZWZmS2V5Qml0cztcbiAgdmFyIFQ4ID0gTWF0aC5jZWlsKFQxIC8gOCk7XG4gIHZhciBUTSA9IDB4ZmYgPj4gKFQxICYgMHgwNyk7XG4gIHZhciBpO1xuXG4gIGZvcihpID0gVDsgaSA8IDEyODsgaSsrKSB7XG4gICAgTC5wdXRCeXRlKHBpVGFibGVbKEwuYXQoaSAtIDEpICsgTC5hdChpIC0gVCkpICYgMHhmZl0pO1xuICB9XG5cbiAgTC5zZXRBdCgxMjggLSBUOCwgcGlUYWJsZVtMLmF0KDEyOCAtIFQ4KSAmIFRNXSk7XG5cbiAgZm9yKGkgPSAxMjcgLSBUODsgaSA+PSAwOyBpLS0pIHtcbiAgICBMLnNldEF0KGksIHBpVGFibGVbTC5hdChpICsgMSkgXiBMLmF0KGkgKyBUOCldKTtcbiAgfVxuXG4gIHJldHVybiBMO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUkMyIGNpcGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKGFzIGJhc2UgZm9yIGtleSBnZW5lcmF0aW9uKS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzLlxuICogQHBhcmFtIGVuY3J5cHQgZmFsc2UgZm9yIGRlY3J5cHRpb24sIHRydWUgZm9yIGVuY3J5cHRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG52YXIgY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzLCBlbmNyeXB0KSB7XG4gIHZhciBfZmluaXNoID0gZmFsc2UsIF9pbnB1dCA9IG51bGwsIF9vdXRwdXQgPSBudWxsLCBfaXYgPSBudWxsO1xuICB2YXIgbWl4Um91bmQsIG1hc2hSb3VuZDtcbiAgdmFyIGksIGosIEsgPSBbXTtcblxuICAvKiBFeHBhbmQga2V5IGFuZCBmaWxsIGludG8gS1tdIEFycmF5ICovXG4gIGtleSA9IGZvcmdlLnJjMi5leHBhbmRLZXkoa2V5LCBiaXRzKTtcbiAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIEsucHVzaChrZXkuZ2V0SW50MTZMZSgpKTtcbiAgfVxuXG4gIGlmKGVuY3J5cHQpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtaXhpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1peGluZyBvbi5cbiAgICAgKi9cbiAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgUltpXSA9IHJvbChSW2ldLCBzW2ldKTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtYXNoaW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtYXNoaW5nIG9uLlxuICAgICAqL1xuICAgIG1hc2hSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldID0gcm9yKFJbaV0sIHNbaV0pO1xuICAgICAgICBSW2ldIC09IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldIC09IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHNwZWNpZmllZCBjaXBoZXIgZXhlY3V0aW9uIHBsYW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgZm91ciB3b3JkcyBmcm9tIHRoZSBpbnB1dCBidWZmZXIsIGFwcGxpZXMgdGhlIElWIG9uXG4gICAqIGl0IChpZiByZXF1ZXN0ZWQpIGFuZCBydW5zIHRoZSBwcm92aWRlZCBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhlIHBsYW4gbXVzdCBiZSBwdXQgdG9nZXRoZXIgaW4gZm9ybSBvZiBhIGFycmF5IG9mIGFycmF5cy4gIFdoZXJlIHRoZVxuICAgKiBvdXRlciBvbmUgaXMgc2ltcGx5IGEgbGlzdCBvZiBzdGVwcyB0byBwZXJmb3JtIGFuZCB0aGUgaW5uZXIgb25lIG5lZWRzXG4gICAqIHRvIGhhdmUgdHdvIGVsZW1lbnRzOiB0aGUgZmlyc3Qgb25lIHRlbGxpbmcgaG93IG1hbnkgcm91bmRzIHRvIHBlcmZvcm0sXG4gICAqIHRoZSBzZWNvbmQgb25lIHRlbGxpbmcgd2hhdCB0byBkbyAoaS5lLiB0aGUgZnVuY3Rpb24gdG8gY2FsbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBsYW4gVGhlIHBsYW4gdG8gZXhlY3V0ZS5cbiAgICovXG4gIHZhciBydW5QbGFuID0gZnVuY3Rpb24ocGxhbikge1xuICAgIHZhciBSID0gW107XG5cbiAgICAvKiBHZXQgZGF0YSBmcm9tIGlucHV0IGJ1ZmZlciBhbmQgZmlsbCB0aGUgZm91ciB3b3JkcyBpbnRvIFIgKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBfaW5wdXQuZ2V0SW50MTZMZSgpO1xuXG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcsIGFwcGx5IHRoZSBJViBmaXJzdC4gKi9cbiAgICAgICAgICB2YWwgXj0gX2l2LmdldEludDE2TGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBXZSdyZSBkZWNyeXB0aW9uLCBrZWVwIGNpcGhlciB0ZXh0IGZvciBuZXh0IGJsb2NrLiAqL1xuICAgICAgICAgIF9pdi5wdXRJbnQxNkxlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUi5wdXNoKHZhbCAmIDB4ZmZmZik7XG4gICAgfVxuXG4gICAgLyogUmVzZXQgZ2xvYmFsIFwialwiIHZhcmlhYmxlIGFzIHBlciBzcGVjLiAqL1xuICAgIGogPSBlbmNyeXB0ID8gMCA6IDYzO1xuXG4gICAgLyogUnVuIGV4ZWN1dGlvbiBwbGFuLiAqL1xuICAgIGZvcih2YXIgcHRyID0gMDsgcHRyIDwgcGxhbi5sZW5ndGg7IHB0cisrKSB7XG4gICAgICBmb3IodmFyIGN0ciA9IDA7IGN0ciA8IHBsYW5bcHRyXVswXTsgY3RyKyspIHtcbiAgICAgICAgcGxhbltwdHJdWzFdKFIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFdyaXRlIGJhY2sgcmVzdWx0IHRvIG91dHB1dCBidWZmZXIuICovXG4gICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcgaW4gQ0JDLW1vZGUsIGZlZWQgYmFjayBlbmNyeXB0ZWQgYnl0ZXMgaW50b1xuICAgICAgICAgICAgIElWIGJ1ZmZlciB0byBjYXJyeSBpdCBmb3J3YXJkIHRvIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUoUltpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUltpXSBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vdXRwdXQucHV0SW50MTZMZShSW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyogQ3JlYXRlIGNpcGhlciBvYmplY3QgKi9cbiAgdmFyIGNpcGhlciA9IG51bGw7XG4gIGNpcGhlciA9IHtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAgICAgKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSBjaXBoZXIgaW4gQ0JDIG1vZGUsIGl2IG1heSBiZSBnaXZlbiBlaXRoZXIgYXMgYSBzdHJpbmdcbiAgICAgKiBvZiBieXRlcywgb3IgYXMgYSBieXRlIGJ1ZmZlci4gIEZvciBFQ0IgbW9kZSwgZ2l2ZSBudWxsIGFzIGl2LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLCBudWxsIGZvciBFQ0IgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3V0cHV0IHRoZSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbihpdiwgb3V0cHV0KSB7XG4gICAgICBpZihpdikge1xuICAgICAgICAvKiBDQkMgbW9kZSAqL1xuICAgICAgICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vdXRwdXQgPSBvdXRwdXQgfHwgbmV3IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfaXYgPSBpdjtcblxuICAgICAgY2lwaGVyLm91dHB1dCA9IF9vdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIV9maW5pc2gpIHtcbiAgICAgICAgLy8gbm90IGZpbmlzaGluZywgc28gZmlsbCB0aGUgaW5wdXQgYnVmZmVyIHdpdGggbW9yZSBpbnB1dFxuICAgICAgICBfaW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoX2lucHV0Lmxlbmd0aCgpID49IDgpIHtcbiAgICAgICAgcnVuUGxhbihbXG4gICAgICAgICAgICBbIDUsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA2LCBtaXhSb3VuZCBdLFxuICAgICAgICAgICAgWyAxLCBtYXNoUm91bmQgXSxcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXVxuICAgICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFkIGEgcGFkZGluZyBmdW5jdGlvbiB0byB1c2UsIG51bGwgZm9yIFBLQ1MjNyBwYWRkaW5nLFxuICAgICAqICAgICAgICAgICBzaWduYXR1cmUoYmxvY2tTaXplLCBidWZmZXIsIGRlY3J5cHQpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICAgICAqL1xuICAgIGZpbmlzaDogZnVuY3Rpb24ocGFkKSB7XG4gICAgICB2YXIgcnZhbCA9IHRydWU7XG5cbiAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgaWYocGFkKSB7XG4gICAgICAgICAgcnZhbCA9IHBhZCg4LCBfaW5wdXQsICFlbmNyeXB0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gICAgICAgICAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAoX2lucHV0Lmxlbmd0aCgpID09PSA4KSA/IDggOiAoOCAtIF9pbnB1dC5sZW5ndGgoKSk7XG4gICAgICAgICAgX2lucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsKSB7XG4gICAgICAgIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICAgICAgICBfZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZighZW5jcnlwdCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2sgc2l6ZVxuICAgICAgICBydmFsID0gKF9pbnB1dC5sZW5ndGgoKSA9PT0gMCk7XG4gICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX291dHB1dCwgIWVuY3J5cHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgbGVuID0gX291dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IF9vdXRwdXQuYXQobGVuIC0gMSk7XG5cbiAgICAgICAgICAgIGlmKGNvdW50ID4gbGVuKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgICAgICAgX291dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXJcbiAqIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKiBUaGUgY2lwaGVyIGlzIGluaXRpYWxpemVkIHRvIHVzZSAxMjggZWZmZWN0aXZlIGtleSBiaXRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0KSB7XG4gIHZhciBjaXBoZXIgPSBmb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRvIHN0YXJ0IGVuY3J5cHRpbmcgY2FsbCBzdGFydCgpIG9uIHRoZSBjaXBoZXIgd2l0aCBhbiBpdiBhbmQgb3B0aW9uYWxcbiAqIG91dHB1dCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICByZXR1cm4gY3JlYXRlQ2lwaGVyKGtleSwgYml0cywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZGVjcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCBmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInBpVGFibGUiLCJzIiwicm9sIiwid29yZCIsImJpdHMiLCJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwicmMyIiwiZXhwYW5kS2V5Iiwia2V5IiwiZWZmS2V5Qml0cyIsInV0aWwiLCJjcmVhdGVCdWZmZXIiLCJMIiwiVCIsImxlbmd0aCIsIlQxIiwiVDgiLCJNYXRoIiwiY2VpbCIsIlRNIiwiaSIsInB1dEJ5dGUiLCJhdCIsInNldEF0IiwiY3JlYXRlQ2lwaGVyIiwiZW5jcnlwdCIsIl9maW5pc2giLCJfaW5wdXQiLCJfb3V0cHV0IiwiX2l2IiwibWl4Um91bmQiLCJtYXNoUm91bmQiLCJqIiwiSyIsInB1c2giLCJnZXRJbnQxNkxlIiwiUiIsInJ1blBsYW4iLCJwbGFuIiwidmFsIiwicHV0SW50MTZMZSIsInB0ciIsImN0ciIsImNpcGhlciIsInN0YXJ0IiwiaXYiLCJvdXRwdXQiLCJ1cGRhdGUiLCJpbnB1dCIsInB1dEJ1ZmZlciIsImZpbmlzaCIsInBhZCIsInJ2YWwiLCJwYWRkaW5nIiwiZmlsbFdpdGhCeXRlIiwibGVuIiwiY291bnQiLCJ0cnVuY2F0ZSIsInN0YXJ0RW5jcnlwdGluZyIsImNyZWF0ZUVuY3J5cHRpb25DaXBoZXIiLCJzdGFydERlY3J5cHRpbmciLCJjcmVhdGVEZWNyeXB0aW9uQ2lwaGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/rc2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/rsa.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/rsa.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Javascript implementation of basic RSA algorithms.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The only algorithm currently supported for PKI is RSA.\n *\n * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo\n * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier\n * and a subjectPublicKey of type bit string.\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of RSA, there aren't any.\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm AlgorithmIdentifier,\n *   subjectPublicKey BIT STRING\n * }\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * For an RSA public key, the subjectPublicKey is:\n *\n * RSAPublicKey ::= SEQUENCE {\n *   modulus            INTEGER,    -- n\n *   publicExponent     INTEGER     -- e\n * }\n *\n * PrivateKeyInfo ::= SEQUENCE {\n *   version                   Version,\n *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\n *   privateKey                PrivateKey,\n *   attributes           [0]  IMPLICIT Attributes OPTIONAL\n * }\n *\n * Version ::= INTEGER\n * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n * PrivateKey ::= OCTET STRING\n * Attributes ::= SET OF Attribute\n *\n * An RSA private key as the following structure:\n *\n * RSAPrivateKey ::= SEQUENCE {\n *   version Version,\n *   modulus INTEGER, -- n\n *   publicExponent INTEGER, -- e\n *   privateExponent INTEGER, -- d\n *   prime1 INTEGER, -- p\n *   prime2 INTEGER, -- q\n *   exponent1 INTEGER, -- d mod (p-1)\n *   exponent2 INTEGER, -- d mod (q-1)\n *   coefficient INTEGER -- (inverse of q) mod p\n * }\n *\n * Version ::= INTEGER\n *\n * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(ssr)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./jsbn */ \"(ssr)/./node_modules/node-forge/lib/jsbn.js\");\n__webpack_require__(/*! ./oids */ \"(ssr)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pkcs1 */ \"(ssr)/./node_modules/node-forge/lib/pkcs1.js\");\n__webpack_require__(/*! ./prime */ \"(ssr)/./node_modules/node-forge/lib/prime.js\");\n__webpack_require__(/*! ./random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nif (typeof BigInteger === \"undefined\") {\n    var BigInteger = forge.jsbn.BigInteger;\n}\nvar _crypto = forge.util.isNodejs ? __webpack_require__(/*! crypto */ \"crypto\") : null;\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n// shortcut for util API\nvar util = forge.util;\n/*\n * RSA encryption and decryption, see RFC 2313.\n */ forge.pki = forge.pki || {};\nmodule.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\nvar pki = forge.pki;\n// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [\n    6,\n    4,\n    2,\n    4,\n    2,\n    4,\n    6,\n    2\n];\n// validator for a PrivateKeyInfo structure\nvar privateKeyValidator = {\n    // PrivateKeyInfo\n    name: \"PrivateKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // Version (INTEGER)\n            name: \"PrivateKeyInfo.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyVersion\"\n        },\n        {\n            // privateKeyAlgorithm\n            name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"privateKeyOid\"\n                }\n            ]\n        },\n        {\n            // PrivateKey\n            name: \"PrivateKeyInfo\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"privateKey\"\n        }\n    ]\n};\n// validator for an RSA private key\nvar rsaPrivateKeyValidator = {\n    // RSAPrivateKey\n    name: \"RSAPrivateKey\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // Version (INTEGER)\n            name: \"RSAPrivateKey.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyVersion\"\n        },\n        {\n            // modulus (n)\n            name: \"RSAPrivateKey.modulus\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyModulus\"\n        },\n        {\n            // publicExponent (e)\n            name: \"RSAPrivateKey.publicExponent\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPublicExponent\"\n        },\n        {\n            // privateExponent (d)\n            name: \"RSAPrivateKey.privateExponent\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPrivateExponent\"\n        },\n        {\n            // prime1 (p)\n            name: \"RSAPrivateKey.prime1\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPrime1\"\n        },\n        {\n            // prime2 (q)\n            name: \"RSAPrivateKey.prime2\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPrime2\"\n        },\n        {\n            // exponent1 (d mod (p-1))\n            name: \"RSAPrivateKey.exponent1\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyExponent1\"\n        },\n        {\n            // exponent2 (d mod (q-1))\n            name: \"RSAPrivateKey.exponent2\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyExponent2\"\n        },\n        {\n            // coefficient ((inverse of q) mod p)\n            name: \"RSAPrivateKey.coefficient\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyCoefficient\"\n        }\n    ]\n};\n// validator for an RSA public key\nvar rsaPublicKeyValidator = {\n    // RSAPublicKey\n    name: \"RSAPublicKey\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // modulus (n)\n            name: \"RSAPublicKey.modulus\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"publicKeyModulus\"\n        },\n        {\n            // publicExponent (e)\n            name: \"RSAPublicKey.exponent\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"publicKeyExponent\"\n        }\n    ]\n};\n// validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\n    name: \"SubjectPublicKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: \"subjectPublicKeyInfo\",\n    value: [\n        {\n            name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"publicKeyOid\"\n                }\n            ]\n        },\n        {\n            // subjectPublicKey\n            name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.BITSTRING,\n            constructed: false,\n            value: [\n                {\n                    // RSAPublicKey\n                    name: \"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    optional: true,\n                    captureAsn1: \"rsaPublicKey\"\n                }\n            ]\n        }\n    ]\n};\n// validator for a DigestInfo structure\nvar digestInfoValidator = {\n    name: \"DigestInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"DigestInfo.DigestAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"DigestInfo.DigestAlgorithm.algorithmIdentifier\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"algorithmIdentifier\"\n                },\n                {\n                    // NULL paramters\n                    name: \"DigestInfo.DigestAlgorithm.parameters\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.NULL,\n                    // captured only to check existence for md2 and md5\n                    capture: \"parameters\",\n                    optional: true,\n                    constructed: false\n                }\n            ]\n        },\n        {\n            // digest\n            name: \"DigestInfo.digest\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"digest\"\n        }\n    ]\n};\n/**\n * Wrap digest in DigestInfo object.\n *\n * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n * Digest ::= OCTET STRING\n *\n * @param md the message digest object with the hash to sign.\n *\n * @return the encoded message (ready for RSA encrytion)\n */ var emsaPkcs1v15encode = function(md) {\n    // get the oid for the algorithm\n    var oid;\n    if (md.algorithm in pki.oids) {\n        oid = pki.oids[md.algorithm];\n    } else {\n        var error = new Error(\"Unknown message digest algorithm.\");\n        error.algorithm = md.algorithm;\n        throw error;\n    }\n    var oidBytes = asn1.oidToDer(oid).getBytes();\n    // create the digest info\n    var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));\n    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\"));\n    var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());\n    digestInfo.value.push(digestAlgorithm);\n    digestInfo.value.push(digest);\n    // encode digest info\n    return asn1.toDer(digestInfo).getBytes();\n};\n/**\n * Performs x^c mod n (RSA encryption or decryption operation).\n *\n * @param x the number to raise and mod.\n * @param key the key to use.\n * @param pub true if the key is public, false if private.\n *\n * @return the result of x^c mod n.\n */ var _modPow = function(x, key, pub) {\n    if (pub) {\n        return x.modPow(key.e, key.n);\n    }\n    if (!key.p || !key.q) {\n        // allow calculation without CRT params (slow)\n        return x.modPow(key.d, key.n);\n    }\n    // pre-compute dP, dQ, and qInv if necessary\n    if (!key.dP) {\n        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\n    }\n    if (!key.dQ) {\n        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\n    }\n    if (!key.qInv) {\n        key.qInv = key.q.modInverse(key.p);\n    }\n    /* Chinese remainder theorem (CRT) states:\n\n    Suppose n1, n2, ..., nk are positive integers which are pairwise\n    coprime (n1 and n2 have no common factors other than 1). For any\n    integers x1, x2, ..., xk there exists an integer x solving the\n    system of simultaneous congruences (where ~= means modularly\n    congruent so a ~= b mod n means a mod n = b mod n):\n\n    x ~= x1 mod n1\n    x ~= x2 mod n2\n    ...\n    x ~= xk mod nk\n\n    This system of congruences has a single simultaneous solution x\n    between 0 and n - 1. Furthermore, each xk solution and x itself\n    is congruent modulo the product n = n1*n2*...*nk.\n    So x1 mod n = x2 mod n = xk mod n = x mod n.\n\n    The single simultaneous solution x can be solved with the following\n    equation:\n\n    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\n\n    Where x is less than n, xi = x mod ni.\n\n    For RSA we are only concerned with k = 2. The modulus n = pq, where\n    p and q are coprime. The RSA decryption algorithm is:\n\n    y = x^d mod n\n\n    Given the above:\n\n    x1 = x^d mod p\n    r1 = n/p = q\n    s1 = q^-1 mod p\n    x2 = x^d mod q\n    r2 = n/q = p\n    s2 = p^-1 mod q\n\n    So y = (x1r1s1 + x2r2s2) mod n\n         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\n\n    According to Fermat's Little Theorem, if the modulus P is prime,\n    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\n    Since A is not divisible by P it follows that if:\n    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\n\n    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\n    to calculate). In order to calculate x^d mod p more quickly the\n    exponent d mod (p - 1) is stored in the RSA private key (the same\n    is done for x^d mod q). These values are referred to as dP and dQ\n    respectively. Therefore we now have:\n\n    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\n\n    Since we'll be reducing x^dP by modulo p (same for q) we can also\n    reduce x by p (and q respectively) before hand. Therefore, let\n\n    xp = ((x mod p)^dP mod p), and\n    xq = ((x mod q)^dQ mod q), yielding:\n\n    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\n\n    This can be further reduced to a simple algorithm that only\n    requires 1 inverse (the q inverse is used) to be used and stored.\n    The algorithm is called Garner's algorithm. If qInv is the\n    inverse of q, we simply calculate:\n\n    y = (qInv*(xp - xq) mod p) * q + xq\n\n    However, there are two further complications. First, we need to\n    ensure that xp > xq to prevent signed BigIntegers from being used\n    so we add p until this is true (since we will be mod'ing with\n    p anyway). Then, there is a known timing attack on algorithms\n    using the CRT. To mitigate this risk, \"cryptographic blinding\"\n    should be used. This requires simply generating a random number r\n    between 0 and n-1 and its inverse and multiplying x by r^e before\n    calculating y and then multiplying y by r^-1 afterwards. Note that\n    r must be coprime with n (gcd(r, n) === 1) in order to have an\n    inverse.\n  */ // cryptographic blinding\n    var r;\n    do {\n        r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);\n    }while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\n    x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\n    // calculate xp and xq\n    var xp = x.mod(key.p).modPow(key.dP, key.p);\n    var xq = x.mod(key.q).modPow(key.dQ, key.q);\n    // xp must be larger than xq to avoid signed bit usage\n    while(xp.compareTo(xq) < 0){\n        xp = xp.add(key.p);\n    }\n    // do last step\n    var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);\n    // remove effect of random for cryptographic blinding\n    y = y.multiply(r.modInverse(key.n)).mod(key.n);\n    return y;\n};\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or\n * 'encrypt' on a public key object instead.\n *\n * Performs RSA encryption.\n *\n * The parameter bt controls whether to put padding bytes before the\n * message passed in. Set bt to either true or false to disable padding\n * completely (in order to handle e.g. EMSA-PSS encoding seperately before),\n * signaling whether the encryption operation is a public key operation\n * (i.e. encrypting data) or not, i.e. private key operation (data signing).\n *\n * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01\n * (for signing) or 0x02 (for encryption). The key operation mode (private\n * or public) is derived from this flag in that case).\n *\n * @param m the message to encrypt as a byte string.\n * @param key the RSA key to use.\n * @param bt for PKCS#1 v1.5 padding, the block type to use\n *   (0x01 for private key, 0x02 for public),\n *   to disable padding: true = public key, false = private key.\n *\n * @return the encrypted bytes as a string.\n */ pki.rsa.encrypt = function(m, key, bt) {\n    var pub = bt;\n    var eb;\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    if (bt !== false && bt !== true) {\n        // legacy, default to PKCS#1 v1.5 padding\n        pub = bt === 0x02;\n        eb = _encodePkcs1_v1_5(m, key, bt);\n    } else {\n        eb = forge.util.createBuffer();\n        eb.putBytes(m);\n    }\n    // load encryption block as big integer 'x'\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var x = new BigInteger(eb.toHex(), 16);\n    // do RSA encryption\n    var y = _modPow(x, key, pub);\n    // convert y into the encrypted data byte string, if y is shorter in\n    // bytes than k, then prepend zero bytes to fill up ed\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var yhex = y.toString(16);\n    var ed = forge.util.createBuffer();\n    var zeros = k - Math.ceil(yhex.length / 2);\n    while(zeros > 0){\n        ed.putByte(0x00);\n        --zeros;\n    }\n    ed.putBytes(forge.util.hexToBytes(yhex));\n    return ed.getBytes();\n};\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or\n * 'verify' on a public key object instead.\n *\n * Performs RSA decryption.\n *\n * The parameter ml controls whether to apply PKCS#1 v1.5 padding\n * or not.  Set ml = false to disable padding removal completely\n * (in order to handle e.g. EMSA-PSS later on) and simply pass back\n * the RSA encryption block.\n *\n * @param ed the encrypted data to decrypt in as a byte string.\n * @param key the RSA key to use.\n * @param pub true for a public key operation, false for private.\n * @param ml the message length, if known, false to disable padding.\n *\n * @return the decrypted message as a byte string.\n */ pki.rsa.decrypt = function(ed, key, pub, ml) {\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    // error if the length of the encrypted data ED is not k\n    if (ed.length !== k) {\n        var error = new Error(\"Encrypted message length is invalid.\");\n        error.length = ed.length;\n        error.expected = k;\n        throw error;\n    }\n    // convert encrypted data into a big integer\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\n    // y must be less than the modulus or it wasn't the result of\n    // a previous mod operation (encryption) using that modulus\n    if (y.compareTo(key.n) >= 0) {\n        throw new Error(\"Encrypted message is invalid.\");\n    }\n    // do RSA decryption\n    var x = _modPow(y, key, pub);\n    // create the encryption block, if x is shorter in bytes than k, then\n    // prepend zero bytes to fill up eb\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var xhex = x.toString(16);\n    var eb = forge.util.createBuffer();\n    var zeros = k - Math.ceil(xhex.length / 2);\n    while(zeros > 0){\n        eb.putByte(0x00);\n        --zeros;\n    }\n    eb.putBytes(forge.util.hexToBytes(xhex));\n    if (ml !== false) {\n        // legacy, default to PKCS#1 v1.5 padding\n        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\n    }\n    // return message\n    return eb.getBytes();\n};\n/**\n * Creates an RSA key-pair generation state object. It is used to allow\n * key-generation to be performed in steps. It also allows for a UI to\n * display progress updates.\n *\n * @param bits the size for the private key in bits, defaults to 2048.\n * @param e the public exponent to use, defaults to 65537 (0x10001).\n * @param [options] the options to use.\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n *\n * @return the state object to use to generate the key-pair.\n */ pki.rsa.createKeyPairGenerationState = function(bits, e, options) {\n    // TODO: migrate step-based prime generation code to forge.prime\n    // set default bits\n    if (typeof bits === \"string\") {\n        bits = parseInt(bits, 10);\n    }\n    bits = bits || 2048;\n    // create prng with api that matches BigInteger secure random\n    options = options || {};\n    var prng = options.prng || forge.random;\n    var rng = {\n        // x is an array to fill with bytes\n        nextBytes: function(x) {\n            var b = prng.getBytesSync(x.length);\n            for(var i = 0; i < x.length; ++i){\n                x[i] = b.charCodeAt(i);\n            }\n        }\n    };\n    var algorithm = options.algorithm || \"PRIMEINC\";\n    // create PRIMEINC algorithm state\n    var rval;\n    if (algorithm === \"PRIMEINC\") {\n        rval = {\n            algorithm: algorithm,\n            state: 0,\n            bits: bits,\n            rng: rng,\n            eInt: e || 65537,\n            e: new BigInteger(null),\n            p: null,\n            q: null,\n            qBits: bits >> 1,\n            pBits: bits - (bits >> 1),\n            pqState: 0,\n            num: null,\n            keys: null\n        };\n        rval.e.fromInt(rval.eInt);\n    } else {\n        throw new Error(\"Invalid key generation algorithm: \" + algorithm);\n    }\n    return rval;\n};\n/**\n * Attempts to runs the key-generation algorithm for at most n seconds\n * (approximately) using the given state. When key-generation has completed,\n * the keys will be stored in state.keys.\n *\n * To use this function to update a UI while generating a key or to prevent\n * causing browser lockups/warnings, set \"n\" to a value other than 0. A\n * simple pattern for generating a key and showing a progress indicator is:\n *\n * var state = pki.rsa.createKeyPairGenerationState(2048);\n * var step = function() {\n *   // step key-generation, run algorithm for 100 ms, repeat\n *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {\n *     setTimeout(step, 1);\n *   } else {\n *     // key-generation complete\n *     // TODO: turn off progress indicator here\n *     // TODO: use the generated key-pair in \"state.keys\"\n *   }\n * };\n * // TODO: turn on progress indicator here\n * setTimeout(step, 0);\n *\n * @param state the state to use.\n * @param n the maximum number of milliseconds to run the algorithm for, 0\n *          to run the algorithm to completion.\n *\n * @return true if the key-generation completed, false if not.\n */ pki.rsa.stepKeyPairGenerationState = function(state, n) {\n    // set default algorithm if not set\n    if (!(\"algorithm\" in state)) {\n        state.algorithm = \"PRIMEINC\";\n    }\n    // TODO: migrate step-based prime generation code to forge.prime\n    // TODO: abstract as PRIMEINC algorithm\n    // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)\n    // with some minor optimizations and designed to run in steps\n    // local state vars\n    var THIRTY = new BigInteger(null);\n    THIRTY.fromInt(30);\n    var deltaIdx = 0;\n    var op_or = function(x, y) {\n        return x | y;\n    };\n    // keep stepping until time limit is reached or done\n    var t1 = +new Date();\n    var t2;\n    var total = 0;\n    while(state.keys === null && (n <= 0 || total < n)){\n        // generate p or q\n        if (state.state === 0) {\n            /* Note: All primes are of the form:\n\n        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i\n\n        When we generate a random number, we always align it at 30k + 1. Each\n        time the number is determined not to be prime we add to get to the\n        next 'i', eg: if the number was at 30k + 1 we add 6. */ var bits = state.p === null ? state.pBits : state.qBits;\n            var bits1 = bits - 1;\n            // get a random number\n            if (state.pqState === 0) {\n                state.num = new BigInteger(bits, state.rng);\n                // force MSB set\n                if (!state.num.testBit(bits1)) {\n                    state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);\n                }\n                // align number on 30k+1 boundary\n                state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\n                deltaIdx = 0;\n                ++state.pqState;\n            } else if (state.pqState === 1) {\n                // try to make the number a prime\n                if (state.num.bitLength() > bits) {\n                    // overflow, try again\n                    state.pqState = 0;\n                // do primality test\n                } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {\n                    ++state.pqState;\n                } else {\n                    // get next potential prime\n                    state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n                }\n            } else if (state.pqState === 2) {\n                // ensure number is coprime with e\n                state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;\n            } else if (state.pqState === 3) {\n                // store p or q\n                state.pqState = 0;\n                if (state.p === null) {\n                    state.p = state.num;\n                } else {\n                    state.q = state.num;\n                }\n                // advance state if both p and q are ready\n                if (state.p !== null && state.q !== null) {\n                    ++state.state;\n                }\n                state.num = null;\n            }\n        } else if (state.state === 1) {\n            // ensure p is larger than q (swap them if not)\n            if (state.p.compareTo(state.q) < 0) {\n                state.num = state.p;\n                state.p = state.q;\n                state.q = state.num;\n            }\n            ++state.state;\n        } else if (state.state === 2) {\n            // compute phi: (p - 1)(q - 1) (Euler's totient function)\n            state.p1 = state.p.subtract(BigInteger.ONE);\n            state.q1 = state.q.subtract(BigInteger.ONE);\n            state.phi = state.p1.multiply(state.q1);\n            ++state.state;\n        } else if (state.state === 3) {\n            // ensure e and phi are coprime\n            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\n                // phi and e are coprime, advance\n                ++state.state;\n            } else {\n                // phi and e aren't coprime, so generate a new p and q\n                state.p = null;\n                state.q = null;\n                state.state = 0;\n            }\n        } else if (state.state === 4) {\n            // create n, ensure n is has the right number of bits\n            state.n = state.p.multiply(state.q);\n            // ensure n is right number of bits\n            if (state.n.bitLength() === state.bits) {\n                // success, advance\n                ++state.state;\n            } else {\n                // failed, get new q\n                state.q = null;\n                state.state = 0;\n            }\n        } else if (state.state === 5) {\n            // set keys\n            var d = state.e.modInverse(state.phi);\n            state.keys = {\n                privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),\n                publicKey: pki.rsa.setPublicKey(state.n, state.e)\n            };\n        }\n        // update timing\n        t2 = +new Date();\n        total += t2 - t1;\n        t1 = t2;\n    }\n    return state.keys !== null;\n};\n/**\n * Generates an RSA public-private key pair in a single call.\n *\n * To generate a key-pair in steps (to allow for progress updates and to\n * prevent blocking or warnings in slow browsers) then use the key-pair\n * generation state functions.\n *\n * To generate a key-pair asynchronously (either through web-workers, if\n * available, or by breaking up the work on the main thread), pass a\n * callback function.\n *\n * @param [bits] the size for the private key in bits, defaults to 2048.\n * @param [e] the public exponent to use, defaults to 65537.\n * @param [options] options for key-pair generation, if given then 'bits'\n *            and 'e' must *not* be given:\n *          bits the size for the private key in bits, (default: 2048).\n *          e the public exponent to use, (default: 65537 (0x10001)).\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\". Disables use of native APIs.\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n * @param [callback(err, keypair)] called once the operation completes.\n *\n * @return an object with privateKey and publicKey properties.\n */ pki.rsa.generateKeyPair = function(bits, e, options, callback) {\n    // (bits), (options), (callback)\n    if (arguments.length === 1) {\n        if (typeof bits === \"object\") {\n            options = bits;\n            bits = undefined;\n        } else if (typeof bits === \"function\") {\n            callback = bits;\n            bits = undefined;\n        }\n    } else if (arguments.length === 2) {\n        // (bits, e), (bits, options), (bits, callback), (options, callback)\n        if (typeof bits === \"number\") {\n            if (typeof e === \"function\") {\n                callback = e;\n                e = undefined;\n            } else if (typeof e !== \"number\") {\n                options = e;\n                e = undefined;\n            }\n        } else {\n            options = bits;\n            callback = e;\n            bits = undefined;\n            e = undefined;\n        }\n    } else if (arguments.length === 3) {\n        // (bits, e, options), (bits, e, callback), (bits, options, callback)\n        if (typeof e === \"number\") {\n            if (typeof options === \"function\") {\n                callback = options;\n                options = undefined;\n            }\n        } else {\n            callback = options;\n            options = e;\n            e = undefined;\n        }\n    }\n    options = options || {};\n    if (bits === undefined) {\n        bits = options.bits || 2048;\n    }\n    if (e === undefined) {\n        e = options.e || 0x10001;\n    }\n    // use native code if permitted, available, and parameters are acceptable\n    if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {\n        if (callback) {\n            // try native async\n            if (_detectNodeCrypto(\"generateKeyPair\")) {\n                return _crypto.generateKeyPair(\"rsa\", {\n                    modulusLength: bits,\n                    publicExponent: e,\n                    publicKeyEncoding: {\n                        type: \"spki\",\n                        format: \"pem\"\n                    },\n                    privateKeyEncoding: {\n                        type: \"pkcs8\",\n                        format: \"pem\"\n                    }\n                }, function(err, pub, priv) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    callback(null, {\n                        privateKey: pki.privateKeyFromPem(priv),\n                        publicKey: pki.publicKeyFromPem(pub)\n                    });\n                });\n            }\n            if (_detectSubtleCrypto(\"generateKey\") && _detectSubtleCrypto(\"exportKey\")) {\n                // use standard native generateKey\n                return util.globalScope.crypto.subtle.generateKey({\n                    name: \"RSASSA-PKCS1-v1_5\",\n                    modulusLength: bits,\n                    publicExponent: _intToUint8Array(e),\n                    hash: {\n                        name: \"SHA-256\"\n                    }\n                }, true, [\n                    \"sign\",\n                    \"verify\"\n                ]).then(function(pair) {\n                    return util.globalScope.crypto.subtle.exportKey(\"pkcs8\", pair.privateKey);\n                // avoiding catch(function(err) {...}) to support IE <= 8\n                }).then(undefined, function(err) {\n                    callback(err);\n                }).then(function(pkcs8) {\n                    if (pkcs8) {\n                        var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));\n                        callback(null, {\n                            privateKey: privateKey,\n                            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n                        });\n                    }\n                });\n            }\n            if (_detectSubtleMsCrypto(\"generateKey\") && _detectSubtleMsCrypto(\"exportKey\")) {\n                var genOp = util.globalScope.msCrypto.subtle.generateKey({\n                    name: \"RSASSA-PKCS1-v1_5\",\n                    modulusLength: bits,\n                    publicExponent: _intToUint8Array(e),\n                    hash: {\n                        name: \"SHA-256\"\n                    }\n                }, true, [\n                    \"sign\",\n                    \"verify\"\n                ]);\n                genOp.oncomplete = function(e) {\n                    var pair = e.target.result;\n                    var exportOp = util.globalScope.msCrypto.subtle.exportKey(\"pkcs8\", pair.privateKey);\n                    exportOp.oncomplete = function(e) {\n                        var pkcs8 = e.target.result;\n                        var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));\n                        callback(null, {\n                            privateKey: privateKey,\n                            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n                        });\n                    };\n                    exportOp.onerror = function(err) {\n                        callback(err);\n                    };\n                };\n                genOp.onerror = function(err) {\n                    callback(err);\n                };\n                return;\n            }\n        } else {\n            // try native sync\n            if (_detectNodeCrypto(\"generateKeyPairSync\")) {\n                var keypair = _crypto.generateKeyPairSync(\"rsa\", {\n                    modulusLength: bits,\n                    publicExponent: e,\n                    publicKeyEncoding: {\n                        type: \"spki\",\n                        format: \"pem\"\n                    },\n                    privateKeyEncoding: {\n                        type: \"pkcs8\",\n                        format: \"pem\"\n                    }\n                });\n                return {\n                    privateKey: pki.privateKeyFromPem(keypair.privateKey),\n                    publicKey: pki.publicKeyFromPem(keypair.publicKey)\n                };\n            }\n        }\n    }\n    // use JavaScript implementation\n    var state = pki.rsa.createKeyPairGenerationState(bits, e, options);\n    if (!callback) {\n        pki.rsa.stepKeyPairGenerationState(state, 0);\n        return state.keys;\n    }\n    _generateKeyPair(state, options, callback);\n};\n/**\n * Sets an RSA public key from BigIntegers modulus and exponent.\n *\n * @param n the modulus.\n * @param e the exponent.\n *\n * @return the public key.\n */ pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {\n    var key = {\n        n: n,\n        e: e\n    };\n    /**\n   * Encrypts the given data with this public key. Newer applications\n   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for\n   * legacy applications.\n   *\n   * @param data the byte string to encrypt.\n   * @param scheme the encryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA encryption,\n   *          an object with an 'encode' property set to a function\n   *          with the signature 'function(data, key)' that returns\n   *          a binary-encoded string representing the encoded data.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the encrypted byte string.\n   */ key.encrypt = function(data, scheme, schemeOptions) {\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        } else if (scheme === undefined) {\n            scheme = \"RSAES-PKCS1-V1_5\";\n        }\n        if (scheme === \"RSAES-PKCS1-V1_5\") {\n            scheme = {\n                encode: function(m, key, pub) {\n                    return _encodePkcs1_v1_5(m, key, 0x02).getBytes();\n                }\n            };\n        } else if (scheme === \"RSA-OAEP\" || scheme === \"RSAES-OAEP\") {\n            scheme = {\n                encode: function(m, key) {\n                    return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);\n                }\n            };\n        } else if ([\n            \"RAW\",\n            \"NONE\",\n            \"NULL\",\n            null\n        ].indexOf(scheme) !== -1) {\n            scheme = {\n                encode: function(e) {\n                    return e;\n                }\n            };\n        } else if (typeof scheme === \"string\") {\n            throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n        }\n        // do scheme-based encoding then rsa encryption\n        var e = scheme.encode(data, key, true);\n        return pki.rsa.encrypt(e, key, true);\n    };\n    /**\n   * Verifies the given signature against the given digest.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the\n   * signature is an OCTET STRING that holds a DigestInfo.\n   *\n   * DigestInfo ::= SEQUENCE {\n   *   digestAlgorithm DigestAlgorithmIdentifier,\n   *   digest Digest\n   * }\n   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n   * Digest ::= OCTET STRING\n   *\n   * To perform PSS signature verification, provide an instance\n   * of Forge PSS object as the scheme parameter.\n   *\n   * @param digest the message digest hash to compare against the signature,\n   *          as a binary-encoded string.\n   * @param signature the signature to verify, as a binary-encoded string.\n   * @param scheme signature verification scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be expected, but\n   *            PKCS#1 v1.5 padding will still be used.\n   * @param options optional verify options\n   *          _parseAllDigestBytes testing flag to control parsing of all\n   *            digest bytes. Unsupported and not for general usage.\n   *            (default: true)\n   *\n   * @return true if the signature was verified, false if not.\n   */ key.verify = function(digest, signature, scheme, options) {\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        } else if (scheme === undefined) {\n            scheme = \"RSASSA-PKCS1-V1_5\";\n        }\n        if (options === undefined) {\n            options = {\n                _parseAllDigestBytes: true\n            };\n        }\n        if (!(\"_parseAllDigestBytes\" in options)) {\n            options._parseAllDigestBytes = true;\n        }\n        if (scheme === \"RSASSA-PKCS1-V1_5\") {\n            scheme = {\n                verify: function(digest, d) {\n                    // remove padding\n                    d = _decodePkcs1_v1_5(d, key, true);\n                    // d is ASN.1 BER-encoded DigestInfo\n                    var obj = asn1.fromDer(d, {\n                        parseAllBytes: options._parseAllDigestBytes\n                    });\n                    // validate DigestInfo\n                    var capture = {};\n                    var errors = [];\n                    if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {\n                        var error = new Error(\"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 \" + \"DigestInfo value.\");\n                        error.errors = errors;\n                        throw error;\n                    }\n                    // check hash algorithm identifier\n                    // see PKCS1-v1-5DigestAlgorithms in RFC 8017\n                    // FIXME: add support to vaidator for strict value choices\n                    var oid = asn1.derToOid(capture.algorithmIdentifier);\n                    if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids[\"sha512-224\"] || oid === forge.oids[\"sha512-256\"])) {\n                        var error = new Error(\"Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.\");\n                        error.oid = oid;\n                        throw error;\n                    }\n                    // special check for md2 and md5 that NULL parameters exist\n                    if (oid === forge.oids.md2 || oid === forge.oids.md5) {\n                        if (!(\"parameters\" in capture)) {\n                            throw new Error(\"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 \" + \"DigestInfo value. \" + \"Missing algorithm identifer NULL parameters.\");\n                        }\n                    }\n                    // compare the given digest to the decrypted one\n                    return digest === capture.digest;\n                }\n            };\n        } else if (scheme === \"NONE\" || scheme === \"NULL\" || scheme === null) {\n            scheme = {\n                verify: function(digest, d) {\n                    // remove padding\n                    d = _decodePkcs1_v1_5(d, key, true);\n                    return digest === d;\n                }\n            };\n        }\n        // do rsa decryption w/o any decoding, then verify -- which does decoding\n        var d = pki.rsa.decrypt(signature, key, true, false);\n        return scheme.verify(digest, d, key.n.bitLength());\n    };\n    return key;\n};\n/**\n * Sets an RSA private key from BigIntegers modulus, exponent, primes,\n * prime exponents, and modular multiplicative inverse.\n *\n * @param n the modulus.\n * @param e the public exponent.\n * @param d the private exponent ((inverse of e) mod n).\n * @param p the first prime.\n * @param q the second prime.\n * @param dP exponent1 (d mod (p-1)).\n * @param dQ exponent2 (d mod (q-1)).\n * @param qInv ((inverse of q) mod p)\n *\n * @return the private key.\n */ pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {\n    var key = {\n        n: n,\n        e: e,\n        d: d,\n        p: p,\n        q: q,\n        dP: dP,\n        dQ: dQ,\n        qInv: qInv\n    };\n    /**\n   * Decrypts the given data with this private key. The decryption scheme\n   * must match the one used to encrypt the data.\n   *\n   * @param data the byte string to decrypt.\n   * @param scheme the decryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA decryption.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the decrypted byte string.\n   */ key.decrypt = function(data, scheme, schemeOptions) {\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        } else if (scheme === undefined) {\n            scheme = \"RSAES-PKCS1-V1_5\";\n        }\n        // do rsa decryption w/o any decoding\n        var d = pki.rsa.decrypt(data, key, false, false);\n        if (scheme === \"RSAES-PKCS1-V1_5\") {\n            scheme = {\n                decode: _decodePkcs1_v1_5\n            };\n        } else if (scheme === \"RSA-OAEP\" || scheme === \"RSAES-OAEP\") {\n            scheme = {\n                decode: function(d, key) {\n                    return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);\n                }\n            };\n        } else if ([\n            \"RAW\",\n            \"NONE\",\n            \"NULL\",\n            null\n        ].indexOf(scheme) !== -1) {\n            scheme = {\n                decode: function(d) {\n                    return d;\n                }\n            };\n        } else {\n            throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n        }\n        // decode according to scheme\n        return scheme.decode(d, key, false);\n    };\n    /**\n   * Signs the given digest, producing a signature.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide\n   * an instance of Forge PSS object as the scheme parameter.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param scheme the signature scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be used but\n   *            PKCS#1 v1.5 padding will still be used.\n   *\n   * @return the signature as a byte string.\n   */ key.sign = function(md, scheme) {\n        /* Note: The internal implementation of RSA operations is being\n      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy\n      code like the use of an encoding block identifier 'bt' will eventually\n      be removed. */ // private key operation\n        var bt = false;\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        }\n        if (scheme === undefined || scheme === \"RSASSA-PKCS1-V1_5\") {\n            scheme = {\n                encode: emsaPkcs1v15encode\n            };\n            bt = 0x01;\n        } else if (scheme === \"NONE\" || scheme === \"NULL\" || scheme === null) {\n            scheme = {\n                encode: function() {\n                    return md;\n                }\n            };\n            bt = 0x01;\n        }\n        // encode and then encrypt\n        var d = scheme.encode(md, key.n.bitLength());\n        return pki.rsa.encrypt(d, key, bt);\n    };\n    return key;\n};\n/**\n * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.\n *\n * @param rsaKey the ASN.1 RSAPrivateKey.\n *\n * @return the ASN.1 PrivateKeyInfo.\n */ pki.wrapRsaPrivateKey = function(rsaKey) {\n    // PrivateKeyInfo\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (0)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),\n        // privateKeyAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // PrivateKey\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())\n    ]);\n};\n/**\n * Converts a private key from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a PrivateKeyInfo containing an\n *          RSAPrivateKey or an RSAPrivateKey.\n *\n * @return the private key.\n */ pki.privateKeyFromAsn1 = function(obj) {\n    // get PrivateKeyInfo\n    var capture = {};\n    var errors = [];\n    if (asn1.validate(obj, privateKeyValidator, capture, errors)) {\n        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\n    }\n    // get RSAPrivateKey\n    capture = {};\n    errors = [];\n    if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read private key. \" + \"ASN.1 object does not contain an RSAPrivateKey.\");\n        error.errors = errors;\n        throw error;\n    }\n    // Note: Version is currently ignored.\n    // capture.privateKeyVersion\n    // FIXME: inefficient, get a BigInteger that uses byte strings\n    var n, e, d, p, q, dP, dQ, qInv;\n    n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\n    e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\n    d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\n    p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\n    q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\n    dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\n    dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\n    qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\n    // set private key\n    return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));\n};\n/**\n * Converts a private key to an ASN.1 RSAPrivateKey.\n *\n * @param key the private key.\n *\n * @return the ASN.1 representation of an RSAPrivateKey.\n */ pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {\n    // RSAPrivateKey\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (0 = only 2 primes, 1 multiple primes)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),\n        // modulus (n)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),\n        // publicExponent (e)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),\n        // privateExponent (d)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),\n        // privateKeyPrime1 (p)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),\n        // privateKeyPrime2 (q)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),\n        // privateKeyExponent1 (dP)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),\n        // privateKeyExponent2 (dQ)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),\n        // coefficient (qInv)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))\n    ]);\n};\n/**\n * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @return the public key.\n */ pki.publicKeyFromAsn1 = function(obj) {\n    // get SubjectPublicKeyInfo\n    var capture = {};\n    var errors = [];\n    if (asn1.validate(obj, publicKeyValidator, capture, errors)) {\n        // get oid\n        var oid = asn1.derToOid(capture.publicKeyOid);\n        if (oid !== pki.oids.rsaEncryption) {\n            var error = new Error(\"Cannot read public key. Unknown OID.\");\n            error.oid = oid;\n            throw error;\n        }\n        obj = capture.rsaPublicKey;\n    }\n    // get RSA params\n    errors = [];\n    if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read public key. \" + \"ASN.1 object does not contain an RSAPublicKey.\");\n        error.errors = errors;\n        throw error;\n    }\n    // FIXME: inefficient, get a BigInteger that uses byte strings\n    var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\n    var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\n    // set public key\n    return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));\n};\n/**\n * Converts a public key to an ASN.1 SubjectPublicKeyInfo.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a SubjectPublicKeyInfo.\n */ pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {\n    // SubjectPublicKeyInfo\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // AlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n            // parameters (null)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // subjectPublicKey\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n            pki.publicKeyToRSAPublicKey(key)\n        ])\n    ]);\n};\n/**\n * Converts a public key to an ASN.1 RSAPublicKey.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a RSAPublicKey.\n */ pki.publicKeyToRSAPublicKey = function(key) {\n    // RSAPublicKey\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // modulus (n)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),\n        // publicExponent (e)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))\n    ]);\n};\n/**\n * Encodes a message using PKCS#1 v1.5 padding.\n *\n * @param m the message to encode.\n * @param key the RSA key to use.\n * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02\n *          (for encryption).\n *\n * @return the padded byte buffer.\n */ function _encodePkcs1_v1_5(m, key, bt) {\n    var eb = forge.util.createBuffer();\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    /* use PKCS#1 v1.5 padding */ if (m.length > k - 11) {\n        var error = new Error(\"Message is too long for PKCS#1 v1.5 padding.\");\n        error.length = m.length;\n        error.max = k - 11;\n        throw error;\n    }\n    /* A block type BT, a padding string PS, and the data D shall be\n    formatted into an octet string EB, the encryption block:\n\n    EB = 00 || BT || PS || 00 || D\n\n    The block type BT shall be a single octet indicating the structure of\n    the encryption block. For this version of the document it shall have\n    value 00, 01, or 02. For a private-key operation, the block type\n    shall be 00 or 01. For a public-key operation, it shall be 02.\n\n    The padding string PS shall consist of k-3-||D|| octets. For block\n    type 00, the octets shall have value 00; for block type 01, they\n    shall have value FF; and for block type 02, they shall be\n    pseudorandomly generated and nonzero. This makes the length of the\n    encryption block EB equal to k. */ // build the encryption block\n    eb.putByte(0x00);\n    eb.putByte(bt);\n    // create the padding\n    var padNum = k - 3 - m.length;\n    var padByte;\n    // private key op\n    if (bt === 0x00 || bt === 0x01) {\n        padByte = bt === 0x00 ? 0x00 : 0xFF;\n        for(var i = 0; i < padNum; ++i){\n            eb.putByte(padByte);\n        }\n    } else {\n        // public key op\n        // pad with random non-zero values\n        while(padNum > 0){\n            var numZeros = 0;\n            var padBytes = forge.random.getBytes(padNum);\n            for(var i = 0; i < padNum; ++i){\n                padByte = padBytes.charCodeAt(i);\n                if (padByte === 0) {\n                    ++numZeros;\n                } else {\n                    eb.putByte(padByte);\n                }\n            }\n            padNum = numZeros;\n        }\n    }\n    // zero followed by message\n    eb.putByte(0x00);\n    eb.putBytes(m);\n    return eb;\n}\n/**\n * Decodes a message using PKCS#1 v1.5 padding.\n *\n * @param em the message to decode.\n * @param key the RSA key to use.\n * @param pub true if the key is a public key, false if it is private.\n * @param ml the message length, if specified.\n *\n * @return the decoded bytes.\n */ function _decodePkcs1_v1_5(em, key, pub, ml) {\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    /* It is an error if any of the following conditions occurs:\n\n    1. The encryption block EB cannot be parsed unambiguously.\n    2. The padding string PS consists of fewer than eight octets\n      or is inconsisent with the block type BT.\n    3. The decryption process is a public-key operation and the block\n      type BT is not 00 or 01, or the decryption process is a\n      private-key operation and the block type is not 02.\n   */ // parse the encryption block\n    var eb = forge.util.createBuffer(em);\n    var first = eb.getByte();\n    var bt = eb.getByte();\n    if (first !== 0x00 || pub && bt !== 0x00 && bt !== 0x01 || !pub && bt != 0x02 || pub && bt === 0x00 && typeof ml === \"undefined\") {\n        throw new Error(\"Encryption block is invalid.\");\n    }\n    var padNum = 0;\n    if (bt === 0x00) {\n        // check all padding bytes for 0x00\n        padNum = k - 3 - ml;\n        for(var i = 0; i < padNum; ++i){\n            if (eb.getByte() !== 0x00) {\n                throw new Error(\"Encryption block is invalid.\");\n            }\n        }\n    } else if (bt === 0x01) {\n        // find the first byte that isn't 0xFF, should be after all padding\n        padNum = 0;\n        while(eb.length() > 1){\n            if (eb.getByte() !== 0xFF) {\n                --eb.read;\n                break;\n            }\n            ++padNum;\n        }\n    } else if (bt === 0x02) {\n        // look for 0x00 byte\n        padNum = 0;\n        while(eb.length() > 1){\n            if (eb.getByte() === 0x00) {\n                --eb.read;\n                break;\n            }\n            ++padNum;\n        }\n    }\n    // zero must be 0x00 and padNum must be (k - 3 - message length)\n    var zero = eb.getByte();\n    if (zero !== 0x00 || padNum !== k - 3 - eb.length()) {\n        throw new Error(\"Encryption block is invalid.\");\n    }\n    return eb.getBytes();\n}\n/**\n * Runs the key-generation algorithm asynchronously, either in the background\n * via Web Workers, or using the main thread and setImmediate.\n *\n * @param state the key-pair generation state.\n * @param [options] options for key-pair generation:\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2, -1 to use estimated cores minus one).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n * @param callback(err, keypair) called once the operation completes.\n */ function _generateKeyPair(state, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = options || {};\n    var opts = {\n        algorithm: {\n            name: options.algorithm || \"PRIMEINC\",\n            options: {\n                workers: options.workers || 2,\n                workLoad: options.workLoad || 100,\n                workerScript: options.workerScript\n            }\n        }\n    };\n    if (\"prng\" in options) {\n        opts.prng = options.prng;\n    }\n    generate();\n    function generate() {\n        // find p and then q (done in series to simplify)\n        getPrime(state.pBits, function(err, num) {\n            if (err) {\n                return callback(err);\n            }\n            state.p = num;\n            if (state.q !== null) {\n                return finish(err, state.q);\n            }\n            getPrime(state.qBits, finish);\n        });\n    }\n    function getPrime(bits, callback) {\n        forge.prime.generateProbablePrime(bits, opts, callback);\n    }\n    function finish(err, num) {\n        if (err) {\n            return callback(err);\n        }\n        // set q\n        state.q = num;\n        // ensure p is larger than q (swap them if not)\n        if (state.p.compareTo(state.q) < 0) {\n            var tmp = state.p;\n            state.p = state.q;\n            state.q = tmp;\n        }\n        // ensure p is coprime with e\n        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n            state.p = null;\n            generate();\n            return;\n        }\n        // ensure q is coprime with e\n        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n            state.q = null;\n            getPrime(state.qBits, finish);\n            return;\n        }\n        // compute phi: (p - 1)(q - 1) (Euler's totient function)\n        state.p1 = state.p.subtract(BigInteger.ONE);\n        state.q1 = state.q.subtract(BigInteger.ONE);\n        state.phi = state.p1.multiply(state.q1);\n        // ensure e and phi are coprime\n        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n            // phi and e aren't coprime, so generate a new p and q\n            state.p = state.q = null;\n            generate();\n            return;\n        }\n        // create n, ensure n is has the right number of bits\n        state.n = state.p.multiply(state.q);\n        if (state.n.bitLength() !== state.bits) {\n            // failed, get new q\n            state.q = null;\n            getPrime(state.qBits, finish);\n            return;\n        }\n        // set keys\n        var d = state.e.modInverse(state.phi);\n        state.keys = {\n            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),\n            publicKey: pki.rsa.setPublicKey(state.n, state.e)\n        };\n        callback(null, state.keys);\n    }\n}\n/**\n * Converts a positive BigInteger into 2's-complement big-endian bytes.\n *\n * @param b the big integer to convert.\n *\n * @return the bytes.\n */ function _bnToBytes(b) {\n    // prepend 0x00 if first byte >= 0x80\n    var hex = b.toString(16);\n    if (hex[0] >= \"8\") {\n        hex = \"00\" + hex;\n    }\n    var bytes = forge.util.hexToBytes(hex);\n    // ensure integer is minimally-encoded\n    if (bytes.length > 1 && // leading 0x00 for positive integer\n    (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 0x80) === 0 || // leading 0xFF for negative integer\n    bytes.charCodeAt(0) === 0xFF && (bytes.charCodeAt(1) & 0x80) === 0x80)) {\n        return bytes.substr(1);\n    }\n    return bytes;\n}\n/**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */ function _getMillerRabinTests(bits) {\n    if (bits <= 100) return 27;\n    if (bits <= 150) return 18;\n    if (bits <= 200) return 15;\n    if (bits <= 250) return 12;\n    if (bits <= 300) return 9;\n    if (bits <= 350) return 8;\n    if (bits <= 400) return 7;\n    if (bits <= 500) return 6;\n    if (bits <= 600) return 5;\n    if (bits <= 800) return 4;\n    if (bits <= 1250) return 3;\n    return 2;\n}\n/**\n * Performs feature detection on the Node crypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */ function _detectNodeCrypto(fn) {\n    return forge.util.isNodejs && typeof _crypto[fn] === \"function\";\n}\n/**\n * Performs feature detection on the SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */ function _detectSubtleCrypto(fn) {\n    return typeof util.globalScope !== \"undefined\" && typeof util.globalScope.crypto === \"object\" && typeof util.globalScope.crypto.subtle === \"object\" && typeof util.globalScope.crypto.subtle[fn] === \"function\";\n}\n/**\n * Performs feature detection on the deprecated Microsoft Internet Explorer\n * outdated SubtleCrypto interface. This function should only be used after\n * checking for the modern, standard SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */ function _detectSubtleMsCrypto(fn) {\n    return typeof util.globalScope !== \"undefined\" && typeof util.globalScope.msCrypto === \"object\" && typeof util.globalScope.msCrypto.subtle === \"object\" && typeof util.globalScope.msCrypto.subtle[fn] === \"function\";\n}\nfunction _intToUint8Array(x) {\n    var bytes = forge.util.hexToBytes(x.toString(16));\n    var buffer = new Uint8Array(bytes.length);\n    for(var i = 0; i < bytes.length; ++i){\n        buffer[i] = bytes.charCodeAt(i);\n    }\n    return buffer;\n}\nfunction _privateKeyFromJwk(jwk) {\n    if (jwk.kty !== \"RSA\") {\n        throw new Error('Unsupported key algorithm \"' + jwk.kty + '\"; algorithm must be \"RSA\".');\n    }\n    return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e), _base64ToBigInt(jwk.d), _base64ToBigInt(jwk.p), _base64ToBigInt(jwk.q), _base64ToBigInt(jwk.dp), _base64ToBigInt(jwk.dq), _base64ToBigInt(jwk.qi));\n}\nfunction _publicKeyFromJwk(jwk) {\n    if (jwk.kty !== \"RSA\") {\n        throw new Error('Key algorithm must be \"RSA\".');\n    }\n    return pki.setRsaPublicKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e));\n}\nfunction _base64ToBigInt(b64) {\n    return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcnNhLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThEQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUcsT0FBT0MsZUFBZSxhQUFhO0lBQ3BDLElBQUlBLGFBQWFGLE1BQU1HLElBQUksQ0FBQ0QsVUFBVTtBQUN4QztBQUVBLElBQUlFLFVBQVVKLE1BQU1LLElBQUksQ0FBQ0MsUUFBUSxHQUFHTCxtQkFBT0EsQ0FBQywwQkFBWTtBQUV4RCx5QkFBeUI7QUFDekIsSUFBSU0sT0FBT1AsTUFBTU8sSUFBSTtBQUVyQix3QkFBd0I7QUFDeEIsSUFBSUYsT0FBT0wsTUFBTUssSUFBSTtBQUVyQjs7Q0FFQyxHQUNETCxNQUFNUSxHQUFHLEdBQUdSLE1BQU1RLEdBQUcsSUFBSSxDQUFDO0FBQzFCQyxPQUFPQyxPQUFPLEdBQUdWLE1BQU1RLEdBQUcsQ0FBQ0csR0FBRyxHQUFHWCxNQUFNVyxHQUFHLEdBQUdYLE1BQU1XLEdBQUcsSUFBSSxDQUFDO0FBQzNELElBQUlILE1BQU1SLE1BQU1RLEdBQUc7QUFFbkIsMkVBQTJFO0FBQzNFLElBQUlJLGVBQWU7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0NBQUU7QUFFM0MsMkNBQTJDO0FBQzNDLElBQUlDLHNCQUFzQjtJQUN4QixpQkFBaUI7SUFDakJDLE1BQU07SUFDTkMsVUFBVVIsS0FBS1MsS0FBSyxDQUFDQyxTQUFTO0lBQzlCQyxNQUFNWCxLQUFLWSxJQUFJLENBQUNDLFFBQVE7SUFDeEJDLGFBQWE7SUFDYkMsT0FBTztRQUFDO1lBQ04sb0JBQW9CO1lBQ3BCUixNQUFNO1lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDSSxPQUFPO1lBQ3ZCRixhQUFhO1lBQ2JHLFNBQVM7UUFDWDtRQUFHO1lBQ0Qsc0JBQXNCO1lBQ3RCVixNQUFNO1lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDQyxRQUFRO1lBQ3hCQyxhQUFhO1lBQ2JDLE9BQU87Z0JBQUM7b0JBQ05SLE1BQU07b0JBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztvQkFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ00sR0FBRztvQkFDbkJKLGFBQWE7b0JBQ2JHLFNBQVM7Z0JBQ1g7YUFBRTtRQUNKO1FBQUc7WUFDRCxhQUFhO1lBQ2JWLE1BQU07WUFDTkMsVUFBVVIsS0FBS1MsS0FBSyxDQUFDQyxTQUFTO1lBQzlCQyxNQUFNWCxLQUFLWSxJQUFJLENBQUNPLFdBQVc7WUFDM0JMLGFBQWE7WUFDYkcsU0FBUztRQUNYO0tBQUU7QUFDSjtBQUVBLG1DQUFtQztBQUNuQyxJQUFJRyx5QkFBeUI7SUFDM0IsZ0JBQWdCO0lBQ2hCYixNQUFNO0lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztJQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDQyxRQUFRO0lBQ3hCQyxhQUFhO0lBQ2JDLE9BQU87UUFBQztZQUNOLG9CQUFvQjtZQUNwQlIsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELGNBQWM7WUFDZFYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELHFCQUFxQjtZQUNyQlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELHNCQUFzQjtZQUN0QlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELGFBQWE7WUFDYlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELGFBQWE7WUFDYlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELDBCQUEwQjtZQUMxQlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELDBCQUEwQjtZQUMxQlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELHFDQUFxQztZQUNyQ1YsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFT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TztRQUNwQixNQUFNLElBQUloTyxNQUNSLGdDQUFnQytOLElBQUlDLEdBQUcsR0FBRztJQUM5QztJQUNBLE9BQU9qUSxJQUFJME0sZ0JBQWdCLENBQ3pCd0QsZ0JBQWdCRixJQUFJL00sQ0FBQyxHQUNyQmlOLGdCQUFnQkYsSUFBSWhOLENBQUMsR0FDckJrTixnQkFBZ0JGLElBQUk1TSxDQUFDLEdBQ3JCOE0sZ0JBQWdCRixJQUFJOU0sQ0FBQyxHQUNyQmdOLGdCQUFnQkYsSUFBSTdNLENBQUMsR0FDckIrTSxnQkFBZ0JGLElBQUlHLEVBQUUsR0FDdEJELGdCQUFnQkYsSUFBSUksRUFBRSxHQUN0QkYsZ0JBQWdCRixJQUFJSyxFQUFFO0FBQzFCO0FBRUEsU0FBU0Msa0JBQWtCTixHQUFHO0lBQzVCLElBQUdBLElBQUlDLEdBQUcsS0FBSyxPQUFPO1FBQ3BCLE1BQU0sSUFBSWhPLE1BQU07SUFDbEI7SUFDQSxPQUFPakMsSUFBSXNLLGVBQWUsQ0FDeEI0RixnQkFBZ0JGLElBQUkvTSxDQUFDLEdBQ3JCaU4sZ0JBQWdCRixJQUFJaE4sQ0FBQztBQUN6QjtBQUVBLFNBQVNrTixnQkFBZ0JLLEdBQUc7SUFDMUIsT0FBTyxJQUFJN1EsV0FBV0YsTUFBTUssSUFBSSxDQUFDZ0UsVUFBVSxDQUFDckUsTUFBTUssSUFBSSxDQUFDMlEsUUFBUSxDQUFDRCxPQUFPO0FBQ3pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcnNhLmpzPzE4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGJhc2ljIFJTQSBhbGdvcml0aG1zLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBUaGUgb25seSBhbGdvcml0aG0gY3VycmVudGx5IHN1cHBvcnRlZCBmb3IgUEtJIGlzIFJTQS5cbiAqXG4gKiBBbiBSU0Ega2V5IGlzIG9mdGVuIHN0b3JlZCBpbiBBU04uMSBERVIgZm9ybWF0LiBUaGUgU3ViamVjdFB1YmxpY0tleUluZm9cbiAqIEFTTi4xIHN0cnVjdHVyZSBpcyBjb21wb3NlZCBvZiBhbiBhbGdvcml0aG0gb2YgdHlwZSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKiBhbmQgYSBzdWJqZWN0UHVibGljS2V5IG9mIHR5cGUgYml0IHN0cmluZy5cbiAqXG4gKiBUaGUgQWxnb3JpdGhtSWRlbnRpZmllciBjb250YWlucyBhbiBPYmplY3QgSWRlbnRpZmllciAoT0lEKSBhbmQgcGFyYW1ldGVyc1xuICogZm9yIHRoZSBhbGdvcml0aG0sIGlmIGFueS4gSW4gdGhlIGNhc2Ugb2YgUlNBLCB0aGVyZSBhcmVuJ3QgYW55LlxuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzdWJqZWN0UHVibGljS2V5IEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBBbGdvcml0aG1JZGVudGlmZXIgOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIE9CSkVDVCBJREVOVElGSUVSLFxuICogICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEZvciBhbiBSU0EgcHVibGljIGtleSwgdGhlIHN1YmplY3RQdWJsaWNLZXkgaXM6XG4gKlxuICogUlNBUHVibGljS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIG1vZHVsdXMgICAgICAgICAgICBJTlRFR0VSLCAgICAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50ICAgICBJTlRFR0VSICAgICAtLSBlXG4gKiB9XG4gKlxuICogUHJpdmF0ZUtleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBwcml2YXRlS2V5QWxnb3JpdGhtICAgICAgIFByaXZhdGVLZXlBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBwcml2YXRlS2V5ICAgICAgICAgICAgICAgIFByaXZhdGVLZXksXG4gKiAgIGF0dHJpYnV0ZXMgICAgICAgICAgIFswXSAgSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqIFByaXZhdGVLZXlBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKiBQcml2YXRlS2V5IDo6PSBPQ1RFVCBTVFJJTkdcbiAqIEF0dHJpYnV0ZXMgOjo9IFNFVCBPRiBBdHRyaWJ1dGVcbiAqXG4gKiBBbiBSU0EgcHJpdmF0ZSBrZXkgYXMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogUlNBUHJpdmF0ZUtleSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uIFZlcnNpb24sXG4gKiAgIG1vZHVsdXMgSU5URUdFUiwgLS0gblxuICogICBwdWJsaWNFeHBvbmVudCBJTlRFR0VSLCAtLSBlXG4gKiAgIHByaXZhdGVFeHBvbmVudCBJTlRFR0VSLCAtLSBkXG4gKiAgIHByaW1lMSBJTlRFR0VSLCAtLSBwXG4gKiAgIHByaW1lMiBJTlRFR0VSLCAtLSBxXG4gKiAgIGV4cG9uZW50MSBJTlRFR0VSLCAtLSBkIG1vZCAocC0xKVxuICogICBleHBvbmVudDIgSU5URUdFUiwgLS0gZCBtb2QgKHEtMSlcbiAqICAgY29lZmZpY2llbnQgSU5URUdFUiAtLSAoaW52ZXJzZSBvZiBxKSBtb2QgcFxuICogfVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBUaGUgT0lEIGZvciB0aGUgUlNBIGtleSBhbGdvcml0aG0gaXM6IDEuMi44NDAuMTEzNTQ5LjEuMS4xXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9qc2JuJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGtjczEnKTtcbnJlcXVpcmUoJy4vcHJpbWUnKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuaWYodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xufVxuXG52YXIgX2NyeXB0byA9IGZvcmdlLnV0aWwuaXNOb2RlanMgPyByZXF1aXJlKCdjcnlwdG8nKSA6IG51bGw7XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIHV0aWwgQVBJXG52YXIgdXRpbCA9IGZvcmdlLnV0aWw7XG5cbi8qXG4gKiBSU0EgZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiwgc2VlIFJGQyAyMzEzLlxuICovXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBraS5yc2EgPSBmb3JnZS5yc2EgPSBmb3JnZS5yc2EgfHwge307XG52YXIgcGtpID0gZm9yZ2UucGtpO1xuXG4vLyBmb3IgZmluZGluZyBwcmltZXMsIHdoaWNoIGFyZSAzMGsraSBmb3IgaSA9IDEsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjlcbnZhciBHQ0RfMzBfREVMVEEgPSBbNiwgNCwgMiwgNCwgMiwgNCwgNiwgMl07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQcml2YXRlS2V5SW5mbyBzdHJ1Y3R1cmVcbnZhciBwcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAvLyBQcml2YXRlS2V5SW5mb1xuICBuYW1lOiAnUHJpdmF0ZUtleUluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlWZXJzaW9uJ1xuICB9LCB7XG4gICAgLy8gcHJpdmF0ZUtleUFsZ29yaXRobVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAncHJpdmF0ZUtleU9pZCdcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gUHJpdmF0ZUtleVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mbycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXknXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFJTQSBwcml2YXRlIGtleVxudmFyIHJzYVByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIC8vIFJTQVByaXZhdGVLZXlcbiAgbmFtZTogJ1JTQVByaXZhdGVLZXknLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkudmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5Lm1vZHVsdXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlNb2R1bHVzJ1xuICB9LCB7XG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHVibGljRXhwb25lbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCdcbiAgfSwge1xuICAgIC8vIHByaXZhdGVFeHBvbmVudCAoZClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcml2YXRlRXhwb25lbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQnXG4gIH0sIHtcbiAgICAvLyBwcmltZTEgKHApXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpbWUxJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpbWUxJ1xuICB9LCB7XG4gICAgLy8gcHJpbWUyIChxKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaW1lMicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaW1lMidcbiAgfSwge1xuICAgIC8vIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuZXhwb25lbnQxJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5RXhwb25lbnQxJ1xuICB9LCB7XG4gICAgLy8gZXhwb25lbnQyIChkIG1vZCAocS0xKSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5leHBvbmVudDInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlFeHBvbmVudDInXG4gIH0sIHtcbiAgICAvLyBjb2VmZmljaWVudCAoKGludmVyc2Ugb2YgcSkgbW9kIHApXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuY29lZmZpY2llbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlDb2VmZmljaWVudCdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gUlNBIHB1YmxpYyBrZXlcbnZhciByc2FQdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIC8vIFJTQVB1YmxpY0tleVxuICBuYW1lOiAnUlNBUHVibGljS2V5JyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIG5hbWU6ICdSU0FQdWJsaWNLZXkubW9kdWx1cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHVibGljS2V5TW9kdWx1cydcbiAgfSwge1xuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIG5hbWU6ICdSU0FQdWJsaWNLZXkuZXhwb25lbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3B1YmxpY0tleUV4cG9uZW50J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBTdWJqZWN0UHVibGljS2V5SW5mbyBzdHJ1Y3R1cmVcbi8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHdvcmtzIHdpdGggYW4gUlNBIHB1YmxpYyBrZXlcbnZhciBwdWJsaWNLZXlWYWxpZGF0b3IgPSBmb3JnZS5wa2kucnNhLnB1YmxpY0tleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ3N1YmplY3RQdWJsaWNLZXlJbmZvJyxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLkFsZ29yaXRobUlkZW50aWZpZXInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlPaWQnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIHN1YmplY3RQdWJsaWNLZXlcbiAgICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8uc3ViamVjdFB1YmxpY0tleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gUlNBUHVibGljS2V5XG4gICAgICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8uc3ViamVjdFB1YmxpY0tleS5SU0FQdWJsaWNLZXknLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAncnNhUHVibGljS2V5J1xuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgRGlnZXN0SW5mbyBzdHJ1Y3R1cmVcbnZhciBkaWdlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRGlnZXN0SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0RpZ2VzdEluZm8uRGlnZXN0QWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0RpZ2VzdEluZm8uRGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobUlkZW50aWZpZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdhbGdvcml0aG1JZGVudGlmaWVyJ1xuICAgIH0sIHtcbiAgICAgIC8vIE5VTEwgcGFyYW10ZXJzXG4gICAgICBuYW1lOiAnRGlnZXN0SW5mby5EaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuTlVMTCxcbiAgICAgIC8vIGNhcHR1cmVkIG9ubHkgdG8gY2hlY2sgZXhpc3RlbmNlIGZvciBtZDIgYW5kIG1kNVxuICAgICAgY2FwdHVyZTogJ3BhcmFtZXRlcnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZGlnZXN0XG4gICAgbmFtZTogJ0RpZ2VzdEluZm8uZGlnZXN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZGlnZXN0J1xuICB9XVxufTtcblxuLyoqXG4gKiBXcmFwIGRpZ2VzdCBpbiBEaWdlc3RJbmZvIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QS0NTMS12MV81LUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcuXG4gKlxuICogRGlnZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBkaWdlc3RBbGdvcml0aG0gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZGlnZXN0IERpZ2VzdFxuICogfVxuICpcbiAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAocmVhZHkgZm9yIFJTQSBlbmNyeXRpb24pXG4gKi9cbnZhciBlbXNhUGtjczF2MTVlbmNvZGUgPSBmdW5jdGlvbihtZCkge1xuICAvLyBnZXQgdGhlIG9pZCBmb3IgdGhlIGFsZ29yaXRobVxuICB2YXIgb2lkO1xuICBpZihtZC5hbGdvcml0aG0gaW4gcGtpLm9pZHMpIHtcbiAgICBvaWQgPSBwa2kub2lkc1ttZC5hbGdvcml0aG1dO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gbWQuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHZhciBvaWRCeXRlcyA9IGFzbjEub2lkVG9EZXIob2lkKS5nZXRCeXRlcygpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZGlnZXN0IGluZm9cbiAgdmFyIGRpZ2VzdEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHZhciBkaWdlc3RBbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkQnl0ZXMpKTtcbiAgZGlnZXN0QWxnb3JpdGhtLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpKTtcbiAgdmFyIGRpZ2VzdCA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgZmFsc2UsIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0QWxnb3JpdGhtKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdCk7XG5cbiAgLy8gZW5jb2RlIGRpZ2VzdCBpbmZvXG4gIHJldHVybiBhc24xLnRvRGVyKGRpZ2VzdEluZm8pLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHheYyBtb2QgbiAoUlNBIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBvcGVyYXRpb24pLlxuICpcbiAqIEBwYXJhbSB4IHRoZSBudW1iZXIgdG8gcmFpc2UgYW5kIG1vZC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBwdWJsaWMsIGZhbHNlIGlmIHByaXZhdGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0IG9mIHheYyBtb2Qgbi5cbiAqL1xudmFyIF9tb2RQb3cgPSBmdW5jdGlvbih4LCBrZXksIHB1Yikge1xuICBpZihwdWIpIHtcbiAgICByZXR1cm4geC5tb2RQb3coa2V5LmUsIGtleS5uKTtcbiAgfVxuXG4gIGlmKCFrZXkucCB8fCAha2V5LnEpIHtcbiAgICAvLyBhbGxvdyBjYWxjdWxhdGlvbiB3aXRob3V0IENSVCBwYXJhbXMgKHNsb3cpXG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5kLCBrZXkubik7XG4gIH1cblxuICAvLyBwcmUtY29tcHV0ZSBkUCwgZFEsIGFuZCBxSW52IGlmIG5lY2Vzc2FyeVxuICBpZigha2V5LmRQKSB7XG4gICAga2V5LmRQID0ga2V5LmQubW9kKGtleS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk7XG4gIH1cbiAgaWYoIWtleS5kUSkge1xuICAgIGtleS5kUSA9IGtleS5kLm1vZChrZXkucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkucUludikge1xuICAgIGtleS5xSW52ID0ga2V5LnEubW9kSW52ZXJzZShrZXkucCk7XG4gIH1cblxuICAvKiBDaGluZXNlIHJlbWFpbmRlciB0aGVvcmVtIChDUlQpIHN0YXRlczpcblxuICAgIFN1cHBvc2UgbjEsIG4yLCAuLi4sIG5rIGFyZSBwb3NpdGl2ZSBpbnRlZ2VycyB3aGljaCBhcmUgcGFpcndpc2VcbiAgICBjb3ByaW1lIChuMSBhbmQgbjIgaGF2ZSBubyBjb21tb24gZmFjdG9ycyBvdGhlciB0aGFuIDEpLiBGb3IgYW55XG4gICAgaW50ZWdlcnMgeDEsIHgyLCAuLi4sIHhrIHRoZXJlIGV4aXN0cyBhbiBpbnRlZ2VyIHggc29sdmluZyB0aGVcbiAgICBzeXN0ZW0gb2Ygc2ltdWx0YW5lb3VzIGNvbmdydWVuY2VzICh3aGVyZSB+PSBtZWFucyBtb2R1bGFybHlcbiAgICBjb25ncnVlbnQgc28gYSB+PSBiIG1vZCBuIG1lYW5zIGEgbW9kIG4gPSBiIG1vZCBuKTpcblxuICAgIHggfj0geDEgbW9kIG4xXG4gICAgeCB+PSB4MiBtb2QgbjJcbiAgICAuLi5cbiAgICB4IH49IHhrIG1vZCBua1xuXG4gICAgVGhpcyBzeXN0ZW0gb2YgY29uZ3J1ZW5jZXMgaGFzIGEgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4XG4gICAgYmV0d2VlbiAwIGFuZCBuIC0gMS4gRnVydGhlcm1vcmUsIGVhY2ggeGsgc29sdXRpb24gYW5kIHggaXRzZWxmXG4gICAgaXMgY29uZ3J1ZW50IG1vZHVsbyB0aGUgcHJvZHVjdCBuID0gbjEqbjIqLi4uKm5rLlxuICAgIFNvIHgxIG1vZCBuID0geDIgbW9kIG4gPSB4ayBtb2QgbiA9IHggbW9kIG4uXG5cbiAgICBUaGUgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4IGNhbiBiZSBzb2x2ZWQgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgZXF1YXRpb246XG5cbiAgICB4ID0gc3VtKHhpKnJpKnNpKSBtb2QgbiB3aGVyZSByaSA9IG4vbmkgYW5kIHNpID0gcmleLTEgbW9kIG5pLlxuXG4gICAgV2hlcmUgeCBpcyBsZXNzIHRoYW4gbiwgeGkgPSB4IG1vZCBuaS5cblxuICAgIEZvciBSU0Egd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggayA9IDIuIFRoZSBtb2R1bHVzIG4gPSBwcSwgd2hlcmVcbiAgICBwIGFuZCBxIGFyZSBjb3ByaW1lLiBUaGUgUlNBIGRlY3J5cHRpb24gYWxnb3JpdGhtIGlzOlxuXG4gICAgeSA9IHheZCBtb2QgblxuXG4gICAgR2l2ZW4gdGhlIGFib3ZlOlxuXG4gICAgeDEgPSB4XmQgbW9kIHBcbiAgICByMSA9IG4vcCA9IHFcbiAgICBzMSA9IHFeLTEgbW9kIHBcbiAgICB4MiA9IHheZCBtb2QgcVxuICAgIHIyID0gbi9xID0gcFxuICAgIHMyID0gcF4tMSBtb2QgcVxuXG4gICAgU28geSA9ICh4MXIxczEgKyB4MnIyczIpIG1vZCBuXG4gICAgICAgICA9ICgoeF5kIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kIG1vZCBxKXAocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBBY2NvcmRpbmcgdG8gRmVybWF0J3MgTGl0dGxlIFRoZW9yZW0sIGlmIHRoZSBtb2R1bHVzIFAgaXMgcHJpbWUsXG4gICAgZm9yIGFueSBpbnRlZ2VyIEEgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgUCwgQV4oUC0xKSB+PSAxIG1vZCBQLlxuICAgIFNpbmNlIEEgaXMgbm90IGRpdmlzaWJsZSBieSBQIGl0IGZvbGxvd3MgdGhhdCBpZjpcbiAgICBOIH49IE0gbW9kIChQIC0gMSksIHRoZW4gQV5OIG1vZCBQID0gQV5NIG1vZCBQLiBUaGVyZWZvcmU6XG5cbiAgICBBXk4gbW9kIFAgPSBBXihNIG1vZCAoUCAtIDEpKSBtb2QgUC4gKFRoZSBsYXR0ZXIgdGFrZXMgbGVzcyBlZmZvcnRcbiAgICB0byBjYWxjdWxhdGUpLiBJbiBvcmRlciB0byBjYWxjdWxhdGUgeF5kIG1vZCBwIG1vcmUgcXVpY2tseSB0aGVcbiAgICBleHBvbmVudCBkIG1vZCAocCAtIDEpIGlzIHN0b3JlZCBpbiB0aGUgUlNBIHByaXZhdGUga2V5ICh0aGUgc2FtZVxuICAgIGlzIGRvbmUgZm9yIHheZCBtb2QgcSkuIFRoZXNlIHZhbHVlcyBhcmUgcmVmZXJyZWQgdG8gYXMgZFAgYW5kIGRRXG4gICAgcmVzcGVjdGl2ZWx5LiBUaGVyZWZvcmUgd2Ugbm93IGhhdmU6XG5cbiAgICB5ID0gKCh4XmRQIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kUSBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgU2luY2Ugd2UnbGwgYmUgcmVkdWNpbmcgeF5kUCBieSBtb2R1bG8gcCAoc2FtZSBmb3IgcSkgd2UgY2FuIGFsc29cbiAgICByZWR1Y2UgeCBieSBwIChhbmQgcSByZXNwZWN0aXZlbHkpIGJlZm9yZSBoYW5kLiBUaGVyZWZvcmUsIGxldFxuXG4gICAgeHAgPSAoKHggbW9kIHApXmRQIG1vZCBwKSwgYW5kXG4gICAgeHEgPSAoKHggbW9kIHEpXmRRIG1vZCBxKSwgeWllbGRpbmc6XG5cbiAgICB5ID0gKHhwKnEqKHFeLTEgbW9kIHApICsgeHEqcCoocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBUaGlzIGNhbiBiZSBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW1wbGUgYWxnb3JpdGhtIHRoYXQgb25seVxuICAgIHJlcXVpcmVzIDEgaW52ZXJzZSAodGhlIHEgaW52ZXJzZSBpcyB1c2VkKSB0byBiZSB1c2VkIGFuZCBzdG9yZWQuXG4gICAgVGhlIGFsZ29yaXRobSBpcyBjYWxsZWQgR2FybmVyJ3MgYWxnb3JpdGhtLiBJZiBxSW52IGlzIHRoZVxuICAgIGludmVyc2Ugb2YgcSwgd2Ugc2ltcGx5IGNhbGN1bGF0ZTpcblxuICAgIHkgPSAocUludiooeHAgLSB4cSkgbW9kIHApICogcSArIHhxXG5cbiAgICBIb3dldmVyLCB0aGVyZSBhcmUgdHdvIGZ1cnRoZXIgY29tcGxpY2F0aW9ucy4gRmlyc3QsIHdlIG5lZWQgdG9cbiAgICBlbnN1cmUgdGhhdCB4cCA+IHhxIHRvIHByZXZlbnQgc2lnbmVkIEJpZ0ludGVnZXJzIGZyb20gYmVpbmcgdXNlZFxuICAgIHNvIHdlIGFkZCBwIHVudGlsIHRoaXMgaXMgdHJ1ZSAoc2luY2Ugd2Ugd2lsbCBiZSBtb2QnaW5nIHdpdGhcbiAgICBwIGFueXdheSkuIFRoZW4sIHRoZXJlIGlzIGEga25vd24gdGltaW5nIGF0dGFjayBvbiBhbGdvcml0aG1zXG4gICAgdXNpbmcgdGhlIENSVC4gVG8gbWl0aWdhdGUgdGhpcyByaXNrLCBcImNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcIlxuICAgIHNob3VsZCBiZSB1c2VkLiBUaGlzIHJlcXVpcmVzIHNpbXBseSBnZW5lcmF0aW5nIGEgcmFuZG9tIG51bWJlciByXG4gICAgYmV0d2VlbiAwIGFuZCBuLTEgYW5kIGl0cyBpbnZlcnNlIGFuZCBtdWx0aXBseWluZyB4IGJ5IHJeZSBiZWZvcmVcbiAgICBjYWxjdWxhdGluZyB5IGFuZCB0aGVuIG11bHRpcGx5aW5nIHkgYnkgcl4tMSBhZnRlcndhcmRzLiBOb3RlIHRoYXRcbiAgICByIG11c3QgYmUgY29wcmltZSB3aXRoIG4gKGdjZChyLCBuKSA9PT0gMSkgaW4gb3JkZXIgdG8gaGF2ZSBhblxuICAgIGludmVyc2UuXG4gICovXG5cbiAgLy8gY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB2YXIgcjtcbiAgZG8ge1xuICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KSksXG4gICAgICAxNik7XG4gIH0gd2hpbGUoci5jb21wYXJlVG8oa2V5Lm4pID49IDAgfHwgIXIuZ2NkKGtleS5uKS5lcXVhbHMoQmlnSW50ZWdlci5PTkUpKTtcbiAgeCA9IHgubXVsdGlwbHkoci5tb2RQb3coa2V5LmUsIGtleS5uKSkubW9kKGtleS5uKTtcblxuICAvLyBjYWxjdWxhdGUgeHAgYW5kIHhxXG4gIHZhciB4cCA9IHgubW9kKGtleS5wKS5tb2RQb3coa2V5LmRQLCBrZXkucCk7XG4gIHZhciB4cSA9IHgubW9kKGtleS5xKS5tb2RQb3coa2V5LmRRLCBrZXkucSk7XG5cbiAgLy8geHAgbXVzdCBiZSBsYXJnZXIgdGhhbiB4cSB0byBhdm9pZCBzaWduZWQgYml0IHVzYWdlXG4gIHdoaWxlKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgeHAgPSB4cC5hZGQoa2V5LnApO1xuICB9XG5cbiAgLy8gZG8gbGFzdCBzdGVwXG4gIHZhciB5ID0geHAuc3VidHJhY3QoeHEpXG4gICAgLm11bHRpcGx5KGtleS5xSW52KS5tb2Qoa2V5LnApXG4gICAgLm11bHRpcGx5KGtleS5xKS5hZGQoeHEpO1xuXG4gIC8vIHJlbW92ZSBlZmZlY3Qgb2YgcmFuZG9tIGZvciBjcnlwdG9ncmFwaGljIGJsaW5kaW5nXG4gIHkgPSB5Lm11bHRpcGx5KHIubW9kSW52ZXJzZShrZXkubikpLm1vZChrZXkubik7XG5cbiAgcmV0dXJuIHk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnc2lnbicgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICdlbmNyeXB0JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGVuY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBidCBjb250cm9scyB3aGV0aGVyIHRvIHB1dCBwYWRkaW5nIGJ5dGVzIGJlZm9yZSB0aGVcbiAqIG1lc3NhZ2UgcGFzc2VkIGluLiBTZXQgYnQgdG8gZWl0aGVyIHRydWUgb3IgZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nXG4gKiBjb21wbGV0ZWx5IChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBlbmNvZGluZyBzZXBlcmF0ZWx5IGJlZm9yZSksXG4gKiBzaWduYWxpbmcgd2hldGhlciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYSBwdWJsaWMga2V5IG9wZXJhdGlvblxuICogKGkuZS4gZW5jcnlwdGluZyBkYXRhKSBvciBub3QsIGkuZS4gcHJpdmF0ZSBrZXkgb3BlcmF0aW9uIChkYXRhIHNpZ25pbmcpLlxuICpcbiAqIEZvciBQS0NTIzEgdjEuNSBwYWRkaW5nIHBhc3MgaW4gdGhlIGJsb2NrIHR5cGUgdG8gdXNlLCBpLmUuIGVpdGhlciAweDAxXG4gKiAoZm9yIHNpZ25pbmcpIG9yIDB4MDIgKGZvciBlbmNyeXB0aW9uKS4gVGhlIGtleSBvcGVyYXRpb24gbW9kZSAocHJpdmF0ZVxuICogb3IgcHVibGljKSBpcyBkZXJpdmVkIGZyb20gdGhpcyBmbGFnIGluIHRoYXQgY2FzZSkuXG4gKlxuICogQHBhcmFtIG0gdGhlIG1lc3NhZ2UgdG8gZW5jcnlwdCBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gYnQgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcsIHRoZSBibG9jayB0eXBlIHRvIHVzZVxuICogICAoMHgwMSBmb3IgcHJpdmF0ZSBrZXksIDB4MDIgZm9yIHB1YmxpYyksXG4gKiAgIHRvIGRpc2FibGUgcGFkZGluZzogdHJ1ZSA9IHB1YmxpYyBrZXksIGZhbHNlID0gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICovXG5wa2kucnNhLmVuY3J5cHQgPSBmdW5jdGlvbihtLCBrZXksIGJ0KSB7XG4gIHZhciBwdWIgPSBidDtcbiAgdmFyIGViO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoYnQgIT09IGZhbHNlICYmIGJ0ICE9PSB0cnVlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICBwdWIgPSAoYnQgPT09IDB4MDIpO1xuICAgIGViID0gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCk7XG4gIH0gZWxzZSB7XG4gICAgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGViLnB1dEJ5dGVzKG0pO1xuICB9XG5cbiAgLy8gbG9hZCBlbmNyeXB0aW9uIGJsb2NrIGFzIGJpZyBpbnRlZ2VyICd4J1xuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4ID0gbmV3IEJpZ0ludGVnZXIoZWIudG9IZXgoKSwgMTYpO1xuXG4gIC8vIGRvIFJTQSBlbmNyeXB0aW9uXG4gIHZhciB5ID0gX21vZFBvdyh4LCBrZXksIHB1Yik7XG5cbiAgLy8gY29udmVydCB5IGludG8gdGhlIGVuY3J5cHRlZCBkYXRhIGJ5dGUgc3RyaW5nLCBpZiB5IGlzIHNob3J0ZXIgaW5cbiAgLy8gYnl0ZXMgdGhhbiBrLCB0aGVuIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGVkXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHloZXggPSB5LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh5aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlZC5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWQucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHloZXgpKTtcbiAgcmV0dXJuIGVkLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnZGVjcnlwdCcgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICd2ZXJpZnknIG9uIGEgcHVibGljIGtleSBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBQZXJmb3JtcyBSU0EgZGVjcnlwdGlvbi5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIG1sIGNvbnRyb2xzIHdoZXRoZXIgdG8gYXBwbHkgUEtDUyMxIHYxLjUgcGFkZGluZ1xuICogb3Igbm90LiAgU2V0IG1sID0gZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nIHJlbW92YWwgY29tcGxldGVseVxuICogKGluIG9yZGVyIHRvIGhhbmRsZSBlLmcuIEVNU0EtUFNTIGxhdGVyIG9uKSBhbmQgc2ltcGx5IHBhc3MgYmFja1xuICogdGhlIFJTQSBlbmNyeXB0aW9uIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBlZCB0aGUgZW5jcnlwdGVkIGRhdGEgdG8gZGVjcnlwdCBpbiBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgZm9yIGEgcHVibGljIGtleSBvcGVyYXRpb24sIGZhbHNlIGZvciBwcml2YXRlLlxuICogQHBhcmFtIG1sIHRoZSBtZXNzYWdlIGxlbmd0aCwgaWYga25vd24sIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNyeXB0ZWQgbWVzc2FnZSBhcyBhIGJ5dGUgc3RyaW5nLlxuICovXG5wa2kucnNhLmRlY3J5cHQgPSBmdW5jdGlvbihlZCwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLy8gZXJyb3IgaWYgdGhlIGxlbmd0aCBvZiB0aGUgZW5jcnlwdGVkIGRhdGEgRUQgaXMgbm90IGtcbiAgaWYoZWQubGVuZ3RoICE9PSBrKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlZC5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWQgPSBrO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY29udmVydCBlbmNyeXB0ZWQgZGF0YSBpbnRvIGEgYmlnIGludGVnZXJcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeSA9IG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVkKS50b0hleCgpLCAxNik7XG5cbiAgLy8geSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbW9kdWx1cyBvciBpdCB3YXNuJ3QgdGhlIHJlc3VsdCBvZlxuICAvLyBhIHByZXZpb3VzIG1vZCBvcGVyYXRpb24gKGVuY3J5cHRpb24pIHVzaW5nIHRoYXQgbW9kdWx1c1xuICBpZih5LmNvbXBhcmVUbyhrZXkubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIC8vIGRvIFJTQSBkZWNyeXB0aW9uXG4gIHZhciB4ID0gX21vZFBvdyh5LCBrZXksIHB1Yik7XG5cbiAgLy8gY3JlYXRlIHRoZSBlbmNyeXB0aW9uIGJsb2NrLCBpZiB4IGlzIHNob3J0ZXIgaW4gYnl0ZXMgdGhhbiBrLCB0aGVuXG4gIC8vIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGViXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHhoZXggPSB4LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh4aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlYi5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWIucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHhoZXgpKTtcblxuICBpZihtbCAhPT0gZmFsc2UpIHtcbiAgICAvLyBsZWdhY3ksIGRlZmF1bHQgdG8gUEtDUyMxIHYxLjUgcGFkZGluZ1xuICAgIHJldHVybiBfZGVjb2RlUGtjczFfdjFfNShlYi5nZXRCeXRlcygpLCBrZXksIHB1Yik7XG4gIH1cblxuICAvLyByZXR1cm4gbWVzc2FnZVxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSU0Ega2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZSBvYmplY3QuIEl0IGlzIHVzZWQgdG8gYWxsb3dcbiAqIGtleS1nZW5lcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBpbiBzdGVwcy4gSXQgYWxzbyBhbGxvd3MgZm9yIGEgVUkgdG9cbiAqIGRpc3BsYXkgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIGRlZmF1bHRzIHRvIDIwNDguXG4gKiBAcGFyYW0gZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcgKDB4MTAwMDEpLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdGF0ZSBvYmplY3QgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBrZXktcGFpci5cbiAqL1xucGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucykge1xuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG5cbiAgLy8gc2V0IGRlZmF1bHQgYml0c1xuICBpZih0eXBlb2YoYml0cykgPT09ICdzdHJpbmcnKSB7XG4gICAgYml0cyA9IHBhcnNlSW50KGJpdHMsIDEwKTtcbiAgfVxuICBiaXRzID0gYml0cyB8fCAyMDQ4O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwcm5nID0gb3B0aW9ucy5wcm5nIHx8IGZvcmdlLnJhbmRvbTtcbiAgdmFyIHJuZyA9IHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGIgPSBwcm5nLmdldEJ5dGVzU3luYyh4Lmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcblxuICAvLyBjcmVhdGUgUFJJTUVJTkMgYWxnb3JpdGhtIHN0YXRlXG4gIHZhciBydmFsO1xuICBpZihhbGdvcml0aG0gPT09ICdQUklNRUlOQycpIHtcbiAgICBydmFsID0ge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBzdGF0ZTogMCxcbiAgICAgIGJpdHM6IGJpdHMsXG4gICAgICBybmc6IHJuZyxcbiAgICAgIGVJbnQ6IGUgfHwgNjU1MzcsXG4gICAgICBlOiBuZXcgQmlnSW50ZWdlcihudWxsKSxcbiAgICAgIHA6IG51bGwsXG4gICAgICBxOiBudWxsLFxuICAgICAgcUJpdHM6IGJpdHMgPj4gMSxcbiAgICAgIHBCaXRzOiBiaXRzIC0gKGJpdHMgPj4gMSksXG4gICAgICBwcVN0YXRlOiAwLFxuICAgICAgbnVtOiBudWxsLFxuICAgICAga2V5czogbnVsbFxuICAgIH07XG4gICAgcnZhbC5lLmZyb21JbnQocnZhbC5lSW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBydW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gZm9yIGF0IG1vc3QgbiBzZWNvbmRzXG4gKiAoYXBwcm94aW1hdGVseSkgdXNpbmcgdGhlIGdpdmVuIHN0YXRlLiBXaGVuIGtleS1nZW5lcmF0aW9uIGhhcyBjb21wbGV0ZWQsXG4gKiB0aGUga2V5cyB3aWxsIGJlIHN0b3JlZCBpbiBzdGF0ZS5rZXlzLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHVwZGF0ZSBhIFVJIHdoaWxlIGdlbmVyYXRpbmcgYSBrZXkgb3IgdG8gcHJldmVudFxuICogY2F1c2luZyBicm93c2VyIGxvY2t1cHMvd2FybmluZ3MsIHNldCBcIm5cIiB0byBhIHZhbHVlIG90aGVyIHRoYW4gMC4gQVxuICogc2ltcGxlIHBhdHRlcm4gZm9yIGdlbmVyYXRpbmcgYSBrZXkgYW5kIHNob3dpbmcgYSBwcm9ncmVzcyBpbmRpY2F0b3IgaXM6XG4gKlxuICogdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKDIwNDgpO1xuICogdmFyIHN0ZXAgPSBmdW5jdGlvbigpIHtcbiAqICAgLy8gc3RlcCBrZXktZ2VuZXJhdGlvbiwgcnVuIGFsZ29yaXRobSBmb3IgMTAwIG1zLCByZXBlYXRcbiAqICAgaWYoIWZvcmdlLnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDEwMCkpIHtcbiAqICAgICBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICogICB9IGVsc2Uge1xuICogICAgIC8vIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlXG4gKiAgICAgLy8gVE9ETzogdHVybiBvZmYgcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqICAgICAvLyBUT0RPOiB1c2UgdGhlIGdlbmVyYXRlZCBrZXktcGFpciBpbiBcInN0YXRlLmtleXNcIlxuICogICB9XG4gKiB9O1xuICogLy8gVE9ETzogdHVybiBvbiBwcm9ncmVzcyBpbmRpY2F0b3IgaGVyZVxuICogc2V0VGltZW91dChzdGVwLCAwKTtcbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIHVzZS5cbiAqIEBwYXJhbSBuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gcnVuIHRoZSBhbGdvcml0aG0gZm9yLCAwXG4gKiAgICAgICAgICB0byBydW4gdGhlIGFsZ29yaXRobSB0byBjb21wbGV0aW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5LWdlbmVyYXRpb24gY29tcGxldGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbikge1xuICAvLyBzZXQgZGVmYXVsdCBhbGdvcml0aG0gaWYgbm90IHNldFxuICBpZighKCdhbGdvcml0aG0nIGluIHN0YXRlKSkge1xuICAgIHN0YXRlLmFsZ29yaXRobSA9ICdQUklNRUlOQyc7XG4gIH1cblxuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG4gIC8vIFRPRE86IGFic3RyYWN0IGFzIFBSSU1FSU5DIGFsZ29yaXRobVxuXG4gIC8vIGRvIGtleSBnZW5lcmF0aW9uIChiYXNlZCBvbiBUb20gV3UncyByc2EuanMsIHNlZSBqc2JuLmpzIGxpY2Vuc2UpXG4gIC8vIHdpdGggc29tZSBtaW5vciBvcHRpbWl6YXRpb25zIGFuZCBkZXNpZ25lZCB0byBydW4gaW4gc3RlcHNcblxuICAvLyBsb2NhbCBzdGF0ZSB2YXJzXG4gIHZhciBUSElSVFkgPSBuZXcgQmlnSW50ZWdlcihudWxsKTtcbiAgVEhJUlRZLmZyb21JbnQoMzApO1xuICB2YXIgZGVsdGFJZHggPSAwO1xuICB2YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7cmV0dXJuIHggfCB5O307XG5cbiAgLy8ga2VlcCBzdGVwcGluZyB1bnRpbCB0aW1lIGxpbWl0IGlzIHJlYWNoZWQgb3IgZG9uZVxuICB2YXIgdDEgPSArbmV3IERhdGUoKTtcbiAgdmFyIHQyO1xuICB2YXIgdG90YWwgPSAwO1xuICB3aGlsZShzdGF0ZS5rZXlzID09PSBudWxsICYmIChuIDw9IDAgfHwgdG90YWwgPCBuKSkge1xuICAgIC8vIGdlbmVyYXRlIHAgb3IgcVxuICAgIGlmKHN0YXRlLnN0YXRlID09PSAwKSB7XG4gICAgICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybTpcblxuICAgICAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xLCB3aGVyZSB0aGVyZSBhcmUgOCB2YWx1ZXMgZm9yIGlcblxuICAgICAgICBXaGVuIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciwgd2UgYWx3YXlzIGFsaWduIGl0IGF0IDMwayArIDEuIEVhY2hcbiAgICAgICAgdGltZSB0aGUgbnVtYmVyIGlzIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlXG4gICAgICAgIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlciB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgICAgIHZhciBiaXRzID0gKHN0YXRlLnAgPT09IG51bGwpID8gc3RhdGUucEJpdHMgOiBzdGF0ZS5xQml0cztcbiAgICAgIHZhciBiaXRzMSA9IGJpdHMgLSAxO1xuXG4gICAgICAvLyBnZXQgYSByYW5kb20gbnVtYmVyXG4gICAgICBpZihzdGF0ZS5wcVN0YXRlID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHN0YXRlLnJuZyk7XG4gICAgICAgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgaWYoIXN0YXRlLm51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgICAgICAgIHN0YXRlLm51bS5iaXR3aXNlVG8oXG4gICAgICAgICAgICBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYml0czEpLCBvcF9vciwgc3RhdGUubnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGlnbiBudW1iZXIgb24gMzBrKzEgYm91bmRhcnlcbiAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoMzEgLSBzdGF0ZS5udW0ubW9kKFRISVJUWSkuYnl0ZVZhbHVlKCksIDApO1xuICAgICAgICBkZWx0YUlkeCA9IDA7XG5cbiAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDEpIHtcbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgdGhlIG51bWJlciBhIHByaW1lXG4gICAgICAgIGlmKHN0YXRlLm51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgICAvLyBvdmVyZmxvdywgdHJ5IGFnYWluXG4gICAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICAgICAgfSBlbHNlIGlmKHN0YXRlLm51bS5pc1Byb2JhYmxlUHJpbWUoXG4gICAgICAgICAgX2dldE1pbGxlclJhYmluVGVzdHMoc3RhdGUubnVtLmJpdExlbmd0aCgpKSkpIHtcbiAgICAgICAgICArK3N0YXRlLnBxU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAyKSB7XG4gICAgICAgIC8vIGVuc3VyZSBudW1iZXIgaXMgY29wcmltZSB3aXRoIGVcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9XG4gICAgICAgICAgKHN0YXRlLm51bS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAgICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkgPyAzIDogMDtcbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAzKSB7XG4gICAgICAgIC8vIHN0b3JlIHAgb3IgcVxuICAgICAgICBzdGF0ZS5wcVN0YXRlID0gMDtcbiAgICAgICAgaWYoc3RhdGUucCA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLnAgPSBzdGF0ZS5udW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkdmFuY2Ugc3RhdGUgaWYgYm90aCBwIGFuZCBxIGFyZSByZWFkeVxuICAgICAgICBpZihzdGF0ZS5wICE9PSBudWxsICYmIHN0YXRlLnEgIT09IG51bGwpIHtcbiAgICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm51bSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAxKSB7XG4gICAgICAvLyBlbnN1cmUgcCBpcyBsYXJnZXIgdGhhbiBxIChzd2FwIHRoZW0gaWYgbm90KVxuICAgICAgaWYoc3RhdGUucC5jb21wYXJlVG8oc3RhdGUucSkgPCAwKSB7XG4gICAgICAgIHN0YXRlLm51bSA9IHN0YXRlLnA7XG4gICAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xO1xuICAgICAgICBzdGF0ZS5xID0gc3RhdGUubnVtO1xuICAgICAgfVxuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDIpIHtcbiAgICAgIC8vIGNvbXB1dGUgcGhpOiAocCAtIDEpKHEgLSAxKSAoRXVsZXIncyB0b3RpZW50IGZ1bmN0aW9uKVxuICAgICAgc3RhdGUucDEgPSBzdGF0ZS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5waGkgPSBzdGF0ZS5wMS5tdWx0aXBseShzdGF0ZS5xMSk7XG4gICAgICArK3N0YXRlLnN0YXRlO1xuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMykge1xuICAgICAgLy8gZW5zdXJlIGUgYW5kIHBoaSBhcmUgY29wcmltZVxuICAgICAgaWYoc3RhdGUucGhpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09PSAwKSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmUgY29wcmltZSwgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGhpIGFuZCBlIGFyZW4ndCBjb3ByaW1lLCBzbyBnZW5lcmF0ZSBhIG5ldyBwIGFuZCBxXG4gICAgICAgIHN0YXRlLnAgPSBudWxsO1xuICAgICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgICAgc3RhdGUuc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gNCkge1xuICAgICAgLy8gY3JlYXRlIG4sIGVuc3VyZSBuIGlzIGhhcyB0aGUgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIHN0YXRlLm4gPSBzdGF0ZS5wLm11bHRpcGx5KHN0YXRlLnEpO1xuXG4gICAgICAvLyBlbnN1cmUgbiBpcyByaWdodCBudW1iZXIgb2YgYml0c1xuICAgICAgaWYoc3RhdGUubi5iaXRMZW5ndGgoKSA9PT0gc3RhdGUuYml0cykge1xuICAgICAgICAvLyBzdWNjZXNzLCBhZHZhbmNlXG4gICAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWlsZWQsIGdldCBuZXcgcVxuICAgICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgICAgc3RhdGUuc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gNSkge1xuICAgICAgLy8gc2V0IGtleXNcbiAgICAgIHZhciBkID0gc3RhdGUuZS5tb2RJbnZlcnNlKHN0YXRlLnBoaSk7XG4gICAgICBzdGF0ZS5rZXlzID0ge1xuICAgICAgICBwcml2YXRlS2V5OiBwa2kucnNhLnNldFByaXZhdGVLZXkoXG4gICAgICAgICAgc3RhdGUubiwgc3RhdGUuZSwgZCwgc3RhdGUucCwgc3RhdGUucSxcbiAgICAgICAgICBkLm1vZChzdGF0ZS5wMSksIGQubW9kKHN0YXRlLnExKSxcbiAgICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucCkpLFxuICAgICAgICBwdWJsaWNLZXk6IHBraS5yc2Euc2V0UHVibGljS2V5KHN0YXRlLm4sIHN0YXRlLmUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aW1pbmdcbiAgICB0MiA9ICtuZXcgRGF0ZSgpO1xuICAgIHRvdGFsICs9IHQyIC0gdDE7XG4gICAgdDEgPSB0MjtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5rZXlzICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gUlNBIHB1YmxpYy1wcml2YXRlIGtleSBwYWlyIGluIGEgc2luZ2xlIGNhbGwuXG4gKlxuICogVG8gZ2VuZXJhdGUgYSBrZXktcGFpciBpbiBzdGVwcyAodG8gYWxsb3cgZm9yIHByb2dyZXNzIHVwZGF0ZXMgYW5kIHRvXG4gKiBwcmV2ZW50IGJsb2NraW5nIG9yIHdhcm5pbmdzIGluIHNsb3cgYnJvd3NlcnMpIHRoZW4gdXNlIHRoZSBrZXktcGFpclxuICogZ2VuZXJhdGlvbiBzdGF0ZSBmdW5jdGlvbnMuXG4gKlxuICogVG8gZ2VuZXJhdGUgYSBrZXktcGFpciBhc3luY2hyb25vdXNseSAoZWl0aGVyIHRocm91Z2ggd2ViLXdvcmtlcnMsIGlmXG4gKiBhdmFpbGFibGUsIG9yIGJ5IGJyZWFraW5nIHVwIHRoZSB3b3JrIG9uIHRoZSBtYWluIHRocmVhZCksIHBhc3MgYVxuICogY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIFtiaXRzXSB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIGRlZmF1bHRzIHRvIDIwNDguXG4gKiBAcGFyYW0gW2VdIHRoZSBwdWJsaWMgZXhwb25lbnQgdG8gdXNlLCBkZWZhdWx0cyB0byA2NTUzNy5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb3B0aW9ucyBmb3Iga2V5LXBhaXIgZ2VuZXJhdGlvbiwgaWYgZ2l2ZW4gdGhlbiAnYml0cydcbiAqICAgICAgICAgICAgYW5kICdlJyBtdXN0ICpub3QqIGJlIGdpdmVuOlxuICogICAgICAgICAgYml0cyB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIChkZWZhdWx0OiAyMDQ4KS5cbiAqICAgICAgICAgIGUgdGhlIHB1YmxpYyBleHBvbmVudCB0byB1c2UsIChkZWZhdWx0OiA2NTUzNyAoMHgxMDAwMSkpLlxuICogICAgICAgICAgd29ya2VyU2NyaXB0IHRoZSB3b3JrZXIgc2NyaXB0IFVSTC5cbiAqICAgICAgICAgIHdvcmtlcnMgdGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAyKS5cbiAqICAgICAgICAgIHdvcmtMb2FkIHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAxMDApLlxuICogICAgICAgICAgcHJuZyBhIGN1c3RvbSBjcnlwdG8tc2VjdXJlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UsXG4gKiAgICAgICAgICAgIHRoYXQgbXVzdCBkZWZpbmUgXCJnZXRCeXRlc1N5bmNcIi4gRGlzYWJsZXMgdXNlIG9mIG5hdGl2ZSBBUElzLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXlwYWlyKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiBhbiBvYmplY3Qgd2l0aCBwcml2YXRlS2V5IGFuZCBwdWJsaWNLZXkgcHJvcGVydGllcy5cbiAqL1xucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyAoYml0cyksIChvcHRpb25zKSwgKGNhbGxiYWNrKVxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYodHlwZW9mIGJpdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gYml0cztcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBiaXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyAoYml0cywgZSksIChiaXRzLCBvcHRpb25zKSwgKGJpdHMsIGNhbGxiYWNrKSwgKG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgICBlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmKHR5cGVvZiBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBjYWxsYmFjayA9IGU7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgLy8gKGJpdHMsIGUsIG9wdGlvbnMpLCAoYml0cywgZSwgY2FsbGJhY2spLCAoYml0cywgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgaWYodHlwZW9mIGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKGJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGJpdHMgPSBvcHRpb25zLmJpdHMgfHwgMjA0ODtcbiAgfVxuICBpZihlID09PSB1bmRlZmluZWQpIHtcbiAgICBlID0gb3B0aW9ucy5lIHx8IDB4MTAwMDE7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGNvZGUgaWYgcGVybWl0dGVkLCBhdmFpbGFibGUsIGFuZCBwYXJhbWV0ZXJzIGFyZSBhY2NlcHRhYmxlXG4gIGlmKCFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmICFvcHRpb25zLnBybmcgJiZcbiAgICBiaXRzID49IDI1NiAmJiBiaXRzIDw9IDE2Mzg0ICYmIChlID09PSAweDEwMDAxIHx8IGUgPT09IDMpKSB7XG4gICAgaWYoY2FsbGJhY2spIHtcbiAgICAgIC8vIHRyeSBuYXRpdmUgYXN5bmNcbiAgICAgIGlmKF9kZXRlY3ROb2RlQ3J5cHRvKCdnZW5lcmF0ZUtleVBhaXInKSkge1xuICAgICAgICByZXR1cm4gX2NyeXB0by5nZW5lcmF0ZUtleVBhaXIoJ3JzYScsIHtcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBlLFxuICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3BraScsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwa2NzOCcsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnIsIHB1YiwgcHJpdikge1xuICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHBraS5wcml2YXRlS2V5RnJvbVBlbShwcml2KSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnB1YmxpY0tleUZyb21QZW0ocHViKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKF9kZXRlY3RTdWJ0bGVDcnlwdG8oJ2dlbmVyYXRlS2V5JykgJiZcbiAgICAgICAgX2RldGVjdFN1YnRsZUNyeXB0bygnZXhwb3J0S2V5JykpIHtcbiAgICAgICAgLy8gdXNlIHN0YW5kYXJkIG5hdGl2ZSBnZW5lcmF0ZUtleVxuICAgICAgICByZXR1cm4gdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J31cbiAgICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgIHJldHVybiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFxuICAgICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgLy8gYXZvaWRpbmcgY2F0Y2goZnVuY3Rpb24oZXJyKSB7Li4ufSkgdG8gc3VwcG9ydCBJRSA8PSA4XG4gICAgICAgIH0pLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHBrY3M4KSB7XG4gICAgICAgICAgaWYocGtjczgpIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlS2V5ID0gcGtpLnByaXZhdGVLZXlGcm9tQXNuMShcbiAgICAgICAgICAgICAgYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBrY3M4KSkpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYoX2RldGVjdFN1YnRsZU1zQ3J5cHRvKCdnZW5lcmF0ZUtleScpICYmXG4gICAgICAgIF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZXhwb3J0S2V5JykpIHtcbiAgICAgICAgdmFyIGdlbk9wID0gdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICBwdWJsaWNFeHBvbmVudDogX2ludFRvVWludDhBcnJheShlKSxcbiAgICAgICAgICBoYXNoOiB7bmFtZTogJ1NIQS0yNTYnfVxuICAgICAgICB9LCB0cnVlIC8qIGtleSBjYW4gYmUgZXhwb3J0ZWQqLywgWydzaWduJywgJ3ZlcmlmeSddKTtcbiAgICAgICAgZ2VuT3Aub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICB2YXIgZXhwb3J0T3AgPSB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgICAncGtjczgnLCBwYWlyLnByaXZhdGVLZXkpO1xuICAgICAgICAgIGV4cG9ydE9wLm9uY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgcGtjczggPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICAgIGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihwa2NzOCkpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kuc2V0UnNhUHVibGljS2V5KHByaXZhdGVLZXkubiwgcHJpdmF0ZUtleS5lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBvcnRPcC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGdlbk9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRyeSBuYXRpdmUgc3luY1xuICAgICAgaWYoX2RldGVjdE5vZGVDcnlwdG8oJ2dlbmVyYXRlS2V5UGFpclN5bmMnKSkge1xuICAgICAgICB2YXIga2V5cGFpciA9IF9jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyU3luYygncnNhJywge1xuICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgcHVibGljRXhwb25lbnQ6IGUsXG4gICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGtpJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3BlbSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ3BrY3M4JyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3BlbSdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByaXZhdGVLZXk6IHBraS5wcml2YXRlS2V5RnJvbVBlbShrZXlwYWlyLnByaXZhdGVLZXkpLFxuICAgICAgICAgIHB1YmxpY0tleTogcGtpLnB1YmxpY0tleUZyb21QZW0oa2V5cGFpci5wdWJsaWNLZXkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiAgdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKGJpdHMsIGUsIG9wdGlvbnMpO1xuICBpZighY2FsbGJhY2spIHtcbiAgICBwa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAwKTtcbiAgICByZXR1cm4gc3RhdGUua2V5cztcbiAgfVxuICBfZ2VuZXJhdGVLZXlQYWlyKHN0YXRlLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHB1YmxpYyBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzIGFuZCBleHBvbmVudC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBleHBvbmVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kuc2V0UnNhUHVibGljS2V5ID0gcGtpLnJzYS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbihuLCBlKSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlXG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwdWJsaWMga2V5LiBOZXdlciBhcHBsaWNhdGlvbnNcbiAgICogc2hvdWxkIHVzZSB0aGUgJ1JTQS1PQUVQJyBkZWNyeXB0aW9uIHNjaGVtZSwgJ1JTQUVTLVBLQ1MxLVYxXzUnIGlzIGZvclxuICAgKiBsZWdhY3kgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZW5jcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBlbmNyeXB0aW9uLFxuICAgKiAgICAgICAgICBhbiBvYmplY3Qgd2l0aCBhbiAnZW5jb2RlJyBwcm9wZXJ0eSBzZXQgdG8gYSBmdW5jdGlvblxuICAgKiAgICAgICAgICB3aXRoIHRoZSBzaWduYXR1cmUgJ2Z1bmN0aW9uKGRhdGEsIGtleSknIHRoYXQgcmV0dXJuc1xuICAgKiAgICAgICAgICBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZGF0YS5cbiAgICogQHBhcmFtIHNjaGVtZU9wdGlvbnMgYW55IHNjaGVtZS1zcGVjaWZpYyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNyeXB0ZWQgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuZW5jcnlwdCA9IGZ1bmN0aW9uKGRhdGEsIHNjaGVtZSwgc2NoZW1lT3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FFUy1QS0NTMS1WMV81JztcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSwgcHViKSB7XG4gICAgICAgICAgcmV0dXJuIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgMHgwMikuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmVuY29kZV9yc2Ffb2FlcChrZXksIG0sIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7ZW5jb2RlOiBmdW5jdGlvbihlKSB7cmV0dXJuIGU7fX07XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgfVxuXG4gICAgLy8gZG8gc2NoZW1lLWJhc2VkIGVuY29kaW5nIHRoZW4gcnNhIGVuY3J5cHRpb25cbiAgICB2YXIgZSA9IHNjaGVtZS5lbmNvZGUoZGF0YSwga2V5LCB0cnVlKTtcbiAgICByZXR1cm4gcGtpLnJzYS5lbmNyeXB0KGUsIGtleSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSBnaXZlbiBzaWduYXR1cmUgYWdhaW5zdCB0aGUgZ2l2ZW4gZGlnZXN0LlxuICAgKlxuICAgKiBQS0NTIzEgc3VwcG9ydHMgbXVsdGlwbGUgKGN1cnJlbnRseSB0d28pIHNpZ25hdHVyZSBzY2hlbWVzOlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSBhbmQgUlNBU1NBLVBTUy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIFwib2xkIHNjaGVtZVwiLCBpLmUuXG4gICAqIFJTQVNTQS1QS0NTMS1WMV81LCBpbiB3aGljaCBjYXNlIG9uY2UgUlNBLWRlY3J5cHRlZCwgdGhlXG4gICAqIHNpZ25hdHVyZSBpcyBhbiBPQ1RFVCBTVFJJTkcgdGhhdCBob2xkcyBhIERpZ2VzdEluZm8uXG4gICAqXG4gICAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAgICogICBkaWdlc3RBbGdvcml0aG0gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcixcbiAgICogICBkaWdlc3QgRGlnZXN0XG4gICAqIH1cbiAgICogRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgKiBEaWdlc3QgOjo9IE9DVEVUIFNUUklOR1xuICAgKlxuICAgKiBUbyBwZXJmb3JtIFBTUyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uLCBwcm92aWRlIGFuIGluc3RhbmNlXG4gICAqIG9mIEZvcmdlIFBTUyBvYmplY3QgYXMgdGhlIHNjaGVtZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBkaWdlc3QgdGhlIG1lc3NhZ2UgZGlnZXN0IGhhc2ggdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSBzaWduYXR1cmUsXG4gICAqICAgICAgICAgIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNjaGVtZSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FTU0EtUEtDUzEtVjFfNScgb3IgdW5kZWZpbmVkIGZvciBSU0FTU0EgUEtDUyMxIHYxLjUsXG4gICAqICAgICAgICAgIGEgRm9yZ2UgUFNTIG9iamVjdCBmb3IgUlNBU1NBLVBTUyxcbiAgICogICAgICAgICAgJ05PTkUnIG9yIG51bGwgZm9yIG5vbmUsIERpZ2VzdEluZm8gd2lsbCBub3QgYmUgZXhwZWN0ZWQsIGJ1dFxuICAgKiAgICAgICAgICAgIFBLQ1MjMSB2MS41IHBhZGRpbmcgd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25hbCB2ZXJpZnkgb3B0aW9uc1xuICAgKiAgICAgICAgICBfcGFyc2VBbGxEaWdlc3RCeXRlcyB0ZXN0aW5nIGZsYWcgdG8gY29udHJvbCBwYXJzaW5nIG9mIGFsbFxuICAgKiAgICAgICAgICAgIGRpZ2VzdCBieXRlcy4gVW5zdXBwb3J0ZWQgYW5kIG5vdCBmb3IgZ2VuZXJhbCB1c2FnZS5cbiAgICogICAgICAgICAgICAoZGVmYXVsdDogdHJ1ZSlcbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBrZXkudmVyaWZ5ID0gZnVuY3Rpb24oZGlnZXN0LCBzaWduYXR1cmUsIHNjaGVtZSwgb3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FTU0EtUEtDUzEtVjFfNSc7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgX3BhcnNlQWxsRGlnZXN0Qnl0ZXM6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmKCEoJ19wYXJzZUFsbERpZ2VzdEJ5dGVzJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5fcGFyc2VBbGxEaWdlc3RCeXRlcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBU1NBLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICBkID0gX2RlY29kZVBrY3MxX3YxXzUoZCwga2V5LCB0cnVlKTtcbiAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKGQsIHtcbiAgICAgICAgICAgIHBhcnNlQWxsQnl0ZXM6IG9wdGlvbnMuX3BhcnNlQWxsRGlnZXN0Qnl0ZXNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHZhbGlkYXRlIERpZ2VzdEluZm9cbiAgICAgICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICBpZighYXNuMS52YWxpZGF0ZShvYmosIGRpZ2VzdEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0FTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgUlNBU1NBLVBLQ1MxLXYxXzUgJyArXG4gICAgICAgICAgICAgICdEaWdlc3RJbmZvIHZhbHVlLicpO1xuICAgICAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoZWNrIGhhc2ggYWxnb3JpdGhtIGlkZW50aWZpZXJcbiAgICAgICAgICAvLyBzZWUgUEtDUzEtdjEtNURpZ2VzdEFsZ29yaXRobXMgaW4gUkZDIDgwMTdcbiAgICAgICAgICAvLyBGSVhNRTogYWRkIHN1cHBvcnQgdG8gdmFpZGF0b3IgZm9yIHN0cmljdCB2YWx1ZSBjaG9pY2VzXG4gICAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5hbGdvcml0aG1JZGVudGlmaWVyKTtcbiAgICAgICAgICBpZighKG9pZCA9PT0gZm9yZ2Uub2lkcy5tZDIgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkcy5tZDUgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkcy5zaGExIHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHMuc2hhMjI0IHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHMuc2hhMjU2IHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHMuc2hhMzg0IHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHMuc2hhNTEyIHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHNbJ3NoYTUxMi0yMjQnXSB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzWydzaGE1MTItMjU2J10pKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbmtub3duIFJTQVNTQS1QS0NTMS12MV81IERpZ2VzdEFsZ29yaXRobSBpZGVudGlmaWVyLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc3BlY2lhbCBjaGVjayBmb3IgbWQyIGFuZCBtZDUgdGhhdCBOVUxMIHBhcmFtZXRlcnMgZXhpc3RcbiAgICAgICAgICBpZihvaWQgPT09IGZvcmdlLm9pZHMubWQyIHx8IG9pZCA9PT0gZm9yZ2Uub2lkcy5tZDUpIHtcbiAgICAgICAgICAgIGlmKCEoJ3BhcmFtZXRlcnMnIGluIGNhcHR1cmUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBSU0FTU0EtUEtDUzEtdjFfNSAnICtcbiAgICAgICAgICAgICAgICAnRGlnZXN0SW5mbyB2YWx1ZS4gJyArXG4gICAgICAgICAgICAgICAgJ01pc3NpbmcgYWxnb3JpdGhtIGlkZW50aWZlciBOVUxMIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29tcGFyZSB0aGUgZ2l2ZW4gZGlnZXN0IHRvIHRoZSBkZWNyeXB0ZWQgb25lXG4gICAgICAgICAgcmV0dXJuIGRpZ2VzdCA9PT0gY2FwdHVyZS5kaWdlc3Q7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ05PTkUnIHx8IHNjaGVtZSA9PT0gJ05VTEwnIHx8IHNjaGVtZSA9PT0gbnVsbCkge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICB2ZXJpZnk6IGZ1bmN0aW9uKGRpZ2VzdCwgZCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgZCA9IF9kZWNvZGVQa2NzMV92MV81KGQsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGRpZ2VzdCA9PT0gZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBkbyByc2EgZGVjcnlwdGlvbiB3L28gYW55IGRlY29kaW5nLCB0aGVuIHZlcmlmeSAtLSB3aGljaCBkb2VzIGRlY29kaW5nXG4gICAgdmFyIGQgPSBwa2kucnNhLmRlY3J5cHQoc2lnbmF0dXJlLCBrZXksIHRydWUsIGZhbHNlKTtcbiAgICByZXR1cm4gc2NoZW1lLnZlcmlmeShkaWdlc3QsIGQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgfTtcblxuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIFJTQSBwcml2YXRlIGtleSBmcm9tIEJpZ0ludGVnZXJzIG1vZHVsdXMsIGV4cG9uZW50LCBwcmltZXMsXG4gKiBwcmltZSBleHBvbmVudHMsIGFuZCBtb2R1bGFyIG11bHRpcGxpY2F0aXZlIGludmVyc2UuXG4gKlxuICogQHBhcmFtIG4gdGhlIG1vZHVsdXMuXG4gKiBAcGFyYW0gZSB0aGUgcHVibGljIGV4cG9uZW50LlxuICogQHBhcmFtIGQgdGhlIHByaXZhdGUgZXhwb25lbnQgKChpbnZlcnNlIG9mIGUpIG1vZCBuKS5cbiAqIEBwYXJhbSBwIHRoZSBmaXJzdCBwcmltZS5cbiAqIEBwYXJhbSBxIHRoZSBzZWNvbmQgcHJpbWUuXG4gKiBAcGFyYW0gZFAgZXhwb25lbnQxIChkIG1vZCAocC0xKSkuXG4gKiBAcGFyYW0gZFEgZXhwb25lbnQyIChkIG1vZCAocS0xKSkuXG4gKiBAcGFyYW0gcUludiAoKGludmVyc2Ugb2YgcSkgbW9kIHApXG4gKlxuICogQHJldHVybiB0aGUgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5zZXRSc2FQcml2YXRlS2V5ID0gcGtpLnJzYS5zZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24oXG4gIG4sIGUsIGQsIHAsIHEsIGRQLCBkUSwgcUludikge1xuICB2YXIga2V5ID0ge1xuICAgIG46IG4sXG4gICAgZTogZSxcbiAgICBkOiBkLFxuICAgIHA6IHAsXG4gICAgcTogcSxcbiAgICBkUDogZFAsXG4gICAgZFE6IGRRLFxuICAgIHFJbnY6IHFJbnZcbiAgfTtcblxuICAvKipcbiAgICogRGVjcnlwdHMgdGhlIGdpdmVuIGRhdGEgd2l0aCB0aGlzIHByaXZhdGUga2V5LiBUaGUgZGVjcnlwdGlvbiBzY2hlbWVcbiAgICogbXVzdCBtYXRjaCB0aGUgb25lIHVzZWQgdG8gZW5jcnlwdCB0aGUgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIGJ5dGUgc3RyaW5nIHRvIGRlY3J5cHQuXG4gICAqIEBwYXJhbSBzY2hlbWUgdGhlIGRlY3J5cHRpb24gc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQUVTLVBLQ1MxLVYxXzUnIChkZWZhdWx0KSxcbiAgICogICAgICAgICAgJ1JTQS1PQUVQJyxcbiAgICogICAgICAgICAgJ1JBVycsICdOT05FJywgb3IgbnVsbCB0byBwZXJmb3JtIHJhdyBSU0EgZGVjcnlwdGlvbi5cbiAgICogQHBhcmFtIHNjaGVtZU9wdGlvbnMgYW55IHNjaGVtZS1zcGVjaWZpYyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBkZWNyeXB0ZWQgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuZGVjcnlwdCA9IGZ1bmN0aW9uKGRhdGEsIHNjaGVtZSwgc2NoZW1lT3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FFUy1QS0NTMS1WMV81JztcbiAgICB9XG5cbiAgICAvLyBkbyByc2EgZGVjcnlwdGlvbiB3L28gYW55IGRlY29kaW5nXG4gICAgdmFyIGQgPSBwa2kucnNhLmRlY3J5cHQoZGF0YSwga2V5LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBRVMtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtkZWNvZGU6IF9kZWNvZGVQa2NzMV92MV81fTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmRlY29kZV9yc2Ffb2FlcChrZXksIGQsIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7ZGVjb2RlOiBmdW5jdGlvbihkKSB7cmV0dXJuIGQ7fX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWU6IFwiJyArIHNjaGVtZSArICdcIi4nKTtcbiAgICB9XG5cbiAgICAvLyBkZWNvZGUgYWNjb3JkaW5nIHRvIHNjaGVtZVxuICAgIHJldHVybiBzY2hlbWUuZGVjb2RlKGQsIGtleSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGUgZ2l2ZW4gZGlnZXN0LCBwcm9kdWNpbmcgYSBzaWduYXR1cmUuXG4gICAqXG4gICAqIFBLQ1MjMSBzdXBwb3J0cyBtdWx0aXBsZSAoY3VycmVudGx5IHR3bykgc2lnbmF0dXJlIHNjaGVtZXM6XG4gICAqIFJTQVNTQS1QS0NTMS1WMV81IGFuZCBSU0FTU0EtUFNTLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgXCJvbGQgc2NoZW1lXCIsIGkuZS5cbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUuIEluIG9yZGVyIHRvIGdlbmVyYXRlIGEgUFNTIHNpZ25hdHVyZSwgcHJvdmlkZVxuICAgKiBhbiBpbnN0YW5jZSBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB3aXRoIHRoZSBoYXNoIHRvIHNpZ24uXG4gICAqIEBwYXJhbSBzY2hlbWUgdGhlIHNpZ25hdHVyZSBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIHVzZWQgYnV0XG4gICAqICAgICAgICAgICAgUEtDUyMxIHYxLjUgcGFkZGluZyB3aWxsIHN0aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHNpZ25hdHVyZSBhcyBhIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LnNpZ24gPSBmdW5jdGlvbihtZCwgc2NoZW1lKSB7XG4gICAgLyogTm90ZTogVGhlIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIFJTQSBvcGVyYXRpb25zIGlzIGJlaW5nXG4gICAgICB0cmFuc2l0aW9uZWQgYXdheSBmcm9tIGEgUEtDUyMxIHYxLjUgaGFyZC1jb2RlZCBzY2hlbWUuIFNvbWUgbGVnYWN5XG4gICAgICBjb2RlIGxpa2UgdGhlIHVzZSBvZiBhbiBlbmNvZGluZyBibG9jayBpZGVudGlmaWVyICdidCcgd2lsbCBldmVudHVhbGx5XG4gICAgICBiZSByZW1vdmVkLiAqL1xuXG4gICAgLy8gcHJpdmF0ZSBrZXkgb3BlcmF0aW9uXG4gICAgdmFyIGJ0ID0gZmFsc2U7XG5cbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSB1bmRlZmluZWQgfHwgc2NoZW1lID09PSAnUlNBU1NBLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7ZW5jb2RlOiBlbXNhUGtjczF2MTVlbmNvZGV9O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdOT05FJyB8fCBzY2hlbWUgPT09ICdOVUxMJyB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgIHNjaGVtZSA9IHtlbmNvZGU6IGZ1bmN0aW9uKCkge3JldHVybiBtZDt9fTtcbiAgICAgIGJ0ID0gMHgwMTtcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgYW5kIHRoZW4gZW5jcnlwdFxuICAgIHZhciBkID0gc2NoZW1lLmVuY29kZShtZCwga2V5Lm4uYml0TGVuZ3RoKCkpO1xuICAgIHJldHVybiBwa2kucnNhLmVuY3J5cHQoZCwga2V5LCBidCk7XG4gIH07XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogV3JhcHMgYW4gUlNBUHJpdmF0ZUtleSBBU04uMSBvYmplY3QgaW4gYW4gQVNOLjEgUHJpdmF0ZUtleUluZm8gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByc2FLZXkgdGhlIEFTTi4xIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS53cmFwUnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHJzYUtleSkge1xuICAvLyBQcml2YXRlS2V5SW5mb1xuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDApXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKDApLmdldEJ5dGVzKCkpLFxuICAgIC8vIHByaXZhdGVLZXlBbGdvcml0aG1cbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLnJzYUVuY3J5cHRpb24pLmdldEJ5dGVzKCkpLFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gUHJpdmF0ZUtleVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgYXNuMS50b0Rlcihyc2FLZXkpLmdldEJ5dGVzKCkpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGEgUHJpdmF0ZUtleUluZm8gY29udGFpbmluZyBhblxuICogICAgICAgICAgUlNBUHJpdmF0ZUtleSBvciBhbiBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIGdldCBQcml2YXRlS2V5SW5mb1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKGFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgb2JqID0gYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleSkpO1xuICB9XG5cbiAgLy8gZ2V0IFJTQVByaXZhdGVLZXlcbiAgY2FwdHVyZSA9IHt9O1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYW4gUlNBUHJpdmF0ZUtleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBOb3RlOiBWZXJzaW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAvLyBjYXB0dXJlLnByaXZhdGVLZXlWZXJzaW9uXG4gIC8vIEZJWE1FOiBpbmVmZmljaWVudCwgZ2V0IGEgQmlnSW50ZWdlciB0aGF0IHVzZXMgYnl0ZSBzdHJpbmdzXG4gIHZhciBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnY7XG4gIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlNb2R1bHVzKS50b0hleCgpO1xuICBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHVibGljRXhwb25lbnQpLnRvSGV4KCk7XG4gIGQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQpLnRvSGV4KCk7XG4gIHAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTEpLnRvSGV4KCk7XG4gIHEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTIpLnRvSGV4KCk7XG4gIGRQID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpO1xuICBkUSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUV4cG9uZW50MikudG9IZXgoKTtcbiAgcUludiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUNvZWZmaWNpZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwcml2YXRlIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVByaXZhdGVLZXkoXG4gICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkUCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRRLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocUludiwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwcml2YXRlIGtleSB0byBhbiBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGFuIFJTQVByaXZhdGVLZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5VG9Bc24xID0gcGtpLnByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDAgPSBvbmx5IDIgcHJpbWVzLCAxIG11bHRpcGxlIHByaW1lcylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkubikpLFxuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5lKSksXG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMSAocClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucCkpLFxuICAgIC8vIHByaXZhdGVLZXlQcmltZTIgKHEpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnEpKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQxIChkUClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFApKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQyIChkUSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFEpKSxcbiAgICAvLyBjb2VmZmljaWVudCAocUludilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucUludikpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgZnJvbSBhbiBBU04uMSBTdWJqZWN0UHVibGljS2V5SW5mbyBvciBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIC8vIGdldCBvaWRcbiAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIFVua25vd24gT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIG9iaiA9IGNhcHR1cmUucnNhUHVibGljS2V5O1xuICB9XG5cbiAgLy8gZ2V0IFJTQSBwYXJhbXNcbiAgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQdWJsaWNLZXkuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleU1vZHVsdXMpLnRvSGV4KCk7XG4gIHZhciBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlFeHBvbmVudCkudG9IZXgoKTtcblxuICAvLyBzZXQgcHVibGljIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVB1YmxpY0tleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICovXG5wa2kucHVibGljS2V5VG9Bc24xID0gcGtpLnB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8gPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgW1xuICAgICAgcGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSlcbiAgICBdKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBSU0FQdWJsaWNLZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKVxuICBdKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gbSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBidCB0aGUgYmxvY2sgdHlwZSB0byB1c2UsIGkuZS4gZWl0aGVyIDB4MDEgKGZvciBzaWduaW5nKSBvciAweDAyXG4gKiAgICAgICAgICAoZm9yIGVuY3J5cHRpb24pLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhZGRlZCBieXRlIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCkge1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgKi9cbiAgaWYobS5sZW5ndGggPiAoayAtIDExKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtLmxlbmd0aDtcbiAgICBlcnJvci5tYXggPSBrIC0gMTE7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvKiBBIGJsb2NrIHR5cGUgQlQsIGEgcGFkZGluZyBzdHJpbmcgUFMsIGFuZCB0aGUgZGF0YSBEIHNoYWxsIGJlXG4gICAgZm9ybWF0dGVkIGludG8gYW4gb2N0ZXQgc3RyaW5nIEVCLCB0aGUgZW5jcnlwdGlvbiBibG9jazpcblxuICAgIEVCID0gMDAgfHwgQlQgfHwgUFMgfHwgMDAgfHwgRFxuXG4gICAgVGhlIGJsb2NrIHR5cGUgQlQgc2hhbGwgYmUgYSBzaW5nbGUgb2N0ZXQgaW5kaWNhdGluZyB0aGUgc3RydWN0dXJlIG9mXG4gICAgdGhlIGVuY3J5cHRpb24gYmxvY2suIEZvciB0aGlzIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50IGl0IHNoYWxsIGhhdmVcbiAgICB2YWx1ZSAwMCwgMDEsIG9yIDAyLiBGb3IgYSBwcml2YXRlLWtleSBvcGVyYXRpb24sIHRoZSBibG9jayB0eXBlXG4gICAgc2hhbGwgYmUgMDAgb3IgMDEuIEZvciBhIHB1YmxpYy1rZXkgb3BlcmF0aW9uLCBpdCBzaGFsbCBiZSAwMi5cblxuICAgIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBzaGFsbCBjb25zaXN0IG9mIGstMy18fER8fCBvY3RldHMuIEZvciBibG9ja1xuICAgIHR5cGUgMDAsIHRoZSBvY3RldHMgc2hhbGwgaGF2ZSB2YWx1ZSAwMDsgZm9yIGJsb2NrIHR5cGUgMDEsIHRoZXlcbiAgICBzaGFsbCBoYXZlIHZhbHVlIEZGOyBhbmQgZm9yIGJsb2NrIHR5cGUgMDIsIHRoZXkgc2hhbGwgYmVcbiAgICBwc2V1ZG9yYW5kb21seSBnZW5lcmF0ZWQgYW5kIG5vbnplcm8uIFRoaXMgbWFrZXMgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBlbmNyeXB0aW9uIGJsb2NrIEVCIGVxdWFsIHRvIGsuICovXG5cbiAgLy8gYnVpbGQgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgZWIucHV0Qnl0ZShidCk7XG5cbiAgLy8gY3JlYXRlIHRoZSBwYWRkaW5nXG4gIHZhciBwYWROdW0gPSBrIC0gMyAtIG0ubGVuZ3RoO1xuICB2YXIgcGFkQnl0ZTtcbiAgLy8gcHJpdmF0ZSBrZXkgb3BcbiAgaWYoYnQgPT09IDB4MDAgfHwgYnQgPT09IDB4MDEpIHtcbiAgICBwYWRCeXRlID0gKGJ0ID09PSAweDAwKSA/IDB4MDAgOiAweEZGO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVibGljIGtleSBvcFxuICAgIC8vIHBhZCB3aXRoIHJhbmRvbSBub24temVybyB2YWx1ZXNcbiAgICB3aGlsZShwYWROdW0gPiAwKSB7XG4gICAgICB2YXIgbnVtWmVyb3MgPSAwO1xuICAgICAgdmFyIHBhZEJ5dGVzID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKHBhZE51bSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgICAgcGFkQnl0ZSA9IHBhZEJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKHBhZEJ5dGUgPT09IDApIHtcbiAgICAgICAgICArK251bVplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZE51bSA9IG51bVplcm9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gZm9sbG93ZWQgYnkgbWVzc2FnZVxuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlcyhtKTtcblxuICByZXR1cm4gZWI7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gZW0gdGhlIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBhIHB1YmxpYyBrZXksIGZhbHNlIGlmIGl0IGlzIHByaXZhdGUuXG4gKiBAcGFyYW0gbWwgdGhlIG1lc3NhZ2UgbGVuZ3RoLCBpZiBzcGVjaWZpZWQuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZVBrY3MxX3YxXzUoZW0sIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8qIEl0IGlzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgb2NjdXJzOlxuXG4gICAgMS4gVGhlIGVuY3J5cHRpb24gYmxvY2sgRUIgY2Fubm90IGJlIHBhcnNlZCB1bmFtYmlndW91c2x5LlxuICAgIDIuIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBjb25zaXN0cyBvZiBmZXdlciB0aGFuIGVpZ2h0IG9jdGV0c1xuICAgICAgb3IgaXMgaW5jb25zaXNlbnQgd2l0aCB0aGUgYmxvY2sgdHlwZSBCVC5cbiAgICAzLiBUaGUgZGVjcnlwdGlvbiBwcm9jZXNzIGlzIGEgcHVibGljLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9ja1xuICAgICAgdHlwZSBCVCBpcyBub3QgMDAgb3IgMDEsIG9yIHRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYVxuICAgICAgcHJpdmF0ZS1rZXkgb3BlcmF0aW9uIGFuZCB0aGUgYmxvY2sgdHlwZSBpcyBub3QgMDIuXG4gICAqL1xuXG4gIC8vIHBhcnNlIHRoZSBlbmNyeXB0aW9uIGJsb2NrXG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVtKTtcbiAgdmFyIGZpcnN0ID0gZWIuZ2V0Qnl0ZSgpO1xuICB2YXIgYnQgPSBlYi5nZXRCeXRlKCk7XG4gIGlmKGZpcnN0ICE9PSAweDAwIHx8XG4gICAgKHB1YiAmJiBidCAhPT0gMHgwMCAmJiBidCAhPT0gMHgwMSkgfHxcbiAgICAoIXB1YiAmJiBidCAhPSAweDAyKSB8fFxuICAgIChwdWIgJiYgYnQgPT09IDB4MDAgJiYgdHlwZW9mKG1sKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICB2YXIgcGFkTnVtID0gMDtcbiAgaWYoYnQgPT09IDB4MDApIHtcbiAgICAvLyBjaGVjayBhbGwgcGFkZGluZyBieXRlcyBmb3IgMHgwMFxuICAgIHBhZE51bSA9IGsgLSAzIC0gbWw7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDEpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBieXRlIHRoYXQgaXNuJ3QgMHhGRiwgc2hvdWxkIGJlIGFmdGVyIGFsbCBwYWRkaW5nXG4gICAgcGFkTnVtID0gMDtcbiAgICB3aGlsZShlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHhGRikge1xuICAgICAgICAtLWViLnJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwYWROdW07XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDIpIHtcbiAgICAvLyBsb29rIGZvciAweDAwIGJ5dGVcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpID09PSAweDAwKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH1cblxuICAvLyB6ZXJvIG11c3QgYmUgMHgwMCBhbmQgcGFkTnVtIG11c3QgYmUgKGsgLSAzIC0gbWVzc2FnZSBsZW5ndGgpXG4gIHZhciB6ZXJvID0gZWIuZ2V0Qnl0ZSgpO1xuICBpZih6ZXJvICE9PSAweDAwIHx8IHBhZE51bSAhPT0gKGsgLSAzIC0gZWIubGVuZ3RoKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gYXN5bmNocm9ub3VzbHksIGVpdGhlciBpbiB0aGUgYmFja2dyb3VuZFxuICogdmlhIFdlYiBXb3JrZXJzLCBvciB1c2luZyB0aGUgbWFpbiB0aHJlYWQgYW5kIHNldEltbWVkaWF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb246XG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIsIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lKS5cbiAqICAgICAgICAgIHdvcmtMb2FkIHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAxMDApLlxuICogQHBhcmFtIGNhbGxiYWNrKGVyciwga2V5cGFpcikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgb3B0cyA9IHtcbiAgICBhbGdvcml0aG06IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHdvcmtlcnM6IG9wdGlvbnMud29ya2VycyB8fCAyLFxuICAgICAgICB3b3JrTG9hZDogb3B0aW9ucy53b3JrTG9hZCB8fCAxMDAsXG4gICAgICAgIHdvcmtlclNjcmlwdDogb3B0aW9ucy53b3JrZXJTY3JpcHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmKCdwcm5nJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0cy5wcm5nID0gb3B0aW9ucy5wcm5nO1xuICB9XG5cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyBmaW5kIHAgYW5kIHRoZW4gcSAoZG9uZSBpbiBzZXJpZXMgdG8gc2ltcGxpZnkpXG4gICAgZ2V0UHJpbWUoc3RhdGUucEJpdHMsIGZ1bmN0aW9uKGVyciwgbnVtKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wID0gbnVtO1xuICAgICAgaWYoc3RhdGUucSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmluaXNoKGVyciwgc3RhdGUucSk7XG4gICAgICB9XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByaW1lKGJpdHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yZ2UucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lKGJpdHMsIG9wdHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaChlcnIsIG51bSkge1xuICAgIGlmKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0IHFcbiAgICBzdGF0ZS5xID0gbnVtO1xuXG4gICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICBpZihzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBzdGF0ZS5wO1xuICAgICAgc3RhdGUucCA9IHN0YXRlLnE7XG4gICAgICBzdGF0ZS5xID0gdG1wO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBxIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuXG4gICAgLy8gZW5zdXJlIGUgYW5kIHBoaSBhcmUgY29wcmltZVxuICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgLy8gcGhpIGFuZCBlIGFyZW4ndCBjb3ByaW1lLCBzbyBnZW5lcmF0ZSBhIG5ldyBwIGFuZCBxXG4gICAgICBzdGF0ZS5wID0gc3RhdGUucSA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgc3RhdGUubiA9IHN0YXRlLnAubXVsdGlwbHkoc3RhdGUucSk7XG4gICAgaWYoc3RhdGUubi5iaXRMZW5ndGgoKSAhPT0gc3RhdGUuYml0cykge1xuICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGtleXNcbiAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICBwcml2YXRlS2V5OiBwa2kucnNhLnNldFByaXZhdGVLZXkoXG4gICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgIGQubW9kKHN0YXRlLnAxKSwgZC5tb2Qoc3RhdGUucTEpLFxuICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucCkpLFxuICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgIH07XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0ZS5rZXlzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcG9zaXRpdmUgQmlnSW50ZWdlciBpbnRvIDIncy1jb21wbGVtZW50IGJpZy1lbmRpYW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJpZyBpbnRlZ2VyIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9iblRvQnl0ZXMoYikge1xuICAvLyBwcmVwZW5kIDB4MDAgaWYgZmlyc3QgYnl0ZSA+PSAweDgwXG4gIHZhciBoZXggPSBiLnRvU3RyaW5nKDE2KTtcbiAgaWYoaGV4WzBdID49ICc4Jykge1xuICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gIH1cbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGhleCk7XG5cbiAgLy8gZW5zdXJlIGludGVnZXIgaXMgbWluaW1hbGx5LWVuY29kZWRcbiAgaWYoYnl0ZXMubGVuZ3RoID4gMSAmJlxuICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICgoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMCAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgLy8gbGVhZGluZyAweEZGIGZvciBuZWdhdGl2ZSBpbnRlZ2VyXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICByZXR1cm4gYnl0ZXMuc3Vic3RyKDEpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgTm9kZSBjcnlwdG8gaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBmbiB0aGUgZmVhdHVyZSAoZnVuY3Rpb24pIHRvIGRldGVjdC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgZGV0ZWN0ZWQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gX2RldGVjdE5vZGVDcnlwdG8oZm4pIHtcbiAgcmV0dXJuIGZvcmdlLnV0aWwuaXNOb2RlanMgJiYgdHlwZW9mIF9jcnlwdG9bZm5dID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBTdWJ0bGVDcnlwdG8gaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBmbiB0aGUgZmVhdHVyZSAoZnVuY3Rpb24pIHRvIGRldGVjdC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgZGV0ZWN0ZWQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gX2RldGVjdFN1YnRsZUNyeXB0byhmbikge1xuICByZXR1cm4gKHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0byA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgZGVwcmVjYXRlZCBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIG91dGRhdGVkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBhZnRlclxuICogY2hlY2tpbmcgZm9yIHRoZSBtb2Rlcm4sIHN0YW5kYXJkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2YgdXRpbC5nbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0byA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlW2ZuXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIF9pbnRUb1VpbnQ4QXJyYXkoeCkge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoeC50b1N0cmluZygxNikpO1xuICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBfcHJpdmF0ZUtleUZyb21Kd2soandrKSB7XG4gIGlmKGp3ay5rdHkgIT09ICdSU0EnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1Vuc3VwcG9ydGVkIGtleSBhbGdvcml0aG0gXCInICsgandrLmt0eSArICdcIjsgYWxnb3JpdGhtIG11c3QgYmUgXCJSU0FcIi4nKTtcbiAgfVxuICByZXR1cm4gcGtpLnNldFJzYVByaXZhdGVLZXkoXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5uKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLmUpLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5wKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnEpLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZHApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZHEpLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucWkpKTtcbn1cblxuZnVuY3Rpb24gX3B1YmxpY0tleUZyb21Kd2soandrKSB7XG4gIGlmKGp3ay5rdHkgIT09ICdSU0EnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgYWxnb3JpdGhtIG11c3QgYmUgXCJSU0FcIi4nKTtcbiAgfVxuICByZXR1cm4gcGtpLnNldFJzYVB1YmxpY0tleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSkpO1xufVxuXG5mdW5jdGlvbiBfYmFzZTY0VG9CaWdJbnQoYjY0KSB7XG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihmb3JnZS51dGlsLmJ5dGVzVG9IZXgoZm9yZ2UudXRpbC5kZWNvZGU2NChiNjQpKSwgMTYpO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsIkJpZ0ludGVnZXIiLCJqc2JuIiwiX2NyeXB0byIsInV0aWwiLCJpc05vZGVqcyIsImFzbjEiLCJwa2kiLCJtb2R1bGUiLCJleHBvcnRzIiwicnNhIiwiR0NEXzMwX0RFTFRBIiwicHJpdmF0ZUtleVZhbGlkYXRvciIsIm5hbWUiLCJ0YWdDbGFzcyIsIkNsYXNzIiwiVU5JVkVSU0FMIiwidHlwZSIsIlR5cGUiLCJTRVFVRU5DRSIsImNvbnN0cnVjdGVkIiwidmFsdWUiLCJJTlRFR0VSIiwiY2FwdHVyZSIsIk9JRCIsIk9DVEVUU1RSSU5HIiwicnNhUHJpdmF0ZUtleVZhbGlkYXRvciIsInJzYVB1YmxpY0tleVZhbGlkYXRvciIsInB1YmxpY0tleVZhbGlkYXRvciIsImNhcHR1cmVBc24xIiwiQklUU1RSSU5HIiwib3B0aW9uYWwiLCJkaWdlc3RJbmZvVmFsaWRhdG9yIiwiTlVMTCIsImVtc2FQa2NzMXYxNWVuY29kZSIsIm1kIiwib2lkIiwiYWxnb3JpdGhtIiwib2lkcyIsImVycm9yIiwiRXJyb3IiLCJvaWRCeXRlcyIsIm9pZFRvRGVyIiwiZ2V0Qnl0ZXMiLCJkaWdlc3RJbmZvIiwiY3JlYXRlIiwiZGlnZXN0QWxnb3JpdGhtIiwicHVzaCIsImRpZ2VzdCIsInRvRGVyIiwiX21vZFBvdyIsIngiLCJrZXkiLCJwdWIiLCJtb2RQb3ciLCJlIiwibiIsInAiLCJxIiwiZCIsImRQIiwibW9kIiwic3VidHJhY3QiLCJPTkUiLCJkUSIsInFJbnYiLCJtb2RJbnZlcnNlIiwiciIsImJ5dGVzVG9IZXgiLCJyYW5kb20iLCJiaXRMZW5ndGgiLCJjb21wYXJlVG8iLCJnY2QiLCJlcXVhbHMiLCJtdWx0aXBseSIsInhwIiwieHEiLCJhZGQiLCJ5IiwiZW5jcnlwdCIsIm0iLCJidCIsImViIiwiayIsIk1hdGgiLCJjZWlsIiwiX2VuY29kZVBrY3MxX3YxXzUiLCJjcmVhdGVCdWZmZXIiLCJwdXRCeXRlcyIsInRvSGV4IiwieWhleCIsInRvU3RyaW5nIiwiZWQiLCJ6ZXJvcyIsImxlbmd0aCIsInB1dEJ5dGUiLCJoZXhUb0J5dGVzIiwiZGVjcnlwdCIsIm1sIiwiZXhwZWN0ZWQiLCJ4aGV4IiwiX2RlY29kZVBrY3MxX3YxXzUiLCJjcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlIiwiYml0cyIsIm9wdGlvbnMiLCJwYXJzZUludCIsInBybmciLCJybmciLCJuZXh0Qnl0ZXMiLCJiIiwiZ2V0Qnl0ZXNTeW5jIiwiaSIsImNoYXJDb2RlQXQiLCJydmFsIiwic3RhdGUiLCJlSW50IiwicUJpdHMiLCJwQml0cyIsInBxU3RhdGUiLCJudW0iLCJrZXlzIiwiZnJvbUludCIsInN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlIiwiVEhJUlRZIiwiZGVsdGFJZHgiLCJvcF9vciIsInQxIiwiRGF0ZSIsInQyIiwidG90YWwiLCJiaXRzMSIsInRlc3RCaXQiLCJiaXR3aXNlVG8iLCJzaGlmdExlZnQiLCJkQWRkT2Zmc2V0IiwiYnl0ZVZhbHVlIiwiaXNQcm9iYWJsZVByaW1lIiwiX2dldE1pbGxlclJhYmluVGVzdHMiLCJwMSIsInExIiwicGhpIiwicHJpdmF0ZUtleSIsInNldFByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJzZXRQdWJsaWNLZXkiLCJnZW5lcmF0ZUtleVBhaXIiLCJjYWxsYmFjayIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInVzZVB1cmVKYXZhU2NyaXB0IiwiX2RldGVjdE5vZGVDcnlwdG8iLCJtb2R1bHVzTGVuZ3RoIiwicHVibGljRXhwb25lbnQiLCJwdWJsaWNLZXlFbmNvZGluZyIsImZvcm1hdCIsInByaXZhdGVLZXlFbmNvZGluZyIsImVyciIsInByaXYiLCJwcml2YXRlS2V5RnJvbVBlbSIsInB1YmxpY0tleUZyb21QZW0iLCJfZGV0ZWN0U3VidGxlQ3J5cHRvIiwiZ2xvYmFsU2NvcGUiLCJjcnlwdG8iLCJzdWJ0bGUiLCJnZW5lcmF0ZUtleSIsIl9pbnRUb1VpbnQ4QXJyYXkiLCJoYXNoIiwidGhlbiIsInBhaXIiLCJleHBvcnRLZXkiLCJwa2NzOCIsInByaXZhdGVLZXlGcm9tQXNuMSIsImZyb21EZXIiLCJzZXRSc2FQdWJsaWNLZXkiLCJfZGV0ZWN0U3VidGxlTXNDcnlwdG8iLCJnZW5PcCIsIm1zQ3J5cHRvIiwib25jb21wbGV0ZSIsInRhcmdldCIsInJlc3VsdCIsImV4cG9ydE9wIiwib25lcnJvciIsImtleXBhaXIiLCJnZW5lcmF0ZUtleVBhaXJTeW5jIiwiX2dlbmVyYXRlS2V5UGFpciIsImRhdGEiLCJzY2hlbWUiLCJzY2hlbWVPcHRpb25zIiwidG9VcHBlckNhc2UiLCJlbmNvZGUiLCJwa2NzMSIsImVuY29kZV9yc2Ffb2FlcCIsImluZGV4T2YiLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJfcGFyc2VBbGxEaWdlc3RCeXRlcyIsIm9iaiIsInBhcnNlQWxsQnl0ZXMiLCJlcnJvcnMiLCJ2YWxpZGF0ZSIsImRlclRvT2lkIiwiYWxnb3JpdGhtSWRlbnRpZmllciIsIm1kMiIsIm1kNSIsInNoYTEiLCJzaGEyMjQiLCJzaGEyNTYiLCJzaGEzODQiLCJzaGE1MTIiLCJzZXRSc2FQcml2YXRlS2V5IiwiZGVjb2RlIiwiZGVjb2RlX3JzYV9vYWVwIiwic2lnbiIsIndyYXBSc2FQcml2YXRlS2V5IiwicnNhS2V5IiwiaW50ZWdlclRvRGVyIiwicnNhRW5jcnlwdGlvbiIsInByaXZhdGVLZXlNb2R1bHVzIiwicHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50IiwicHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCIsInByaXZhdGVLZXlQcmltZTEiLCJwcml2YXRlS2V5UHJpbWUyIiwicHJpdmF0ZUtleUV4cG9uZW50MSIsInByaXZhdGVLZXlFeHBvbmVudDIiLCJwcml2YXRlS2V5Q29lZmZpY2llbnQiLCJwcml2YXRlS2V5VG9Bc24xIiwicHJpdmF0ZUtleVRvUlNBUHJpdmF0ZUtleSIsIl9iblRvQnl0ZXMiLCJwdWJsaWNLZXlGcm9tQXNuMSIsInB1YmxpY0tleU9pZCIsInJzYVB1YmxpY0tleSIsInB1YmxpY0tleU1vZHVsdXMiLCJwdWJsaWNLZXlFeHBvbmVudCIsInB1YmxpY0tleVRvQXNuMSIsInB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8iLCJwdWJsaWNLZXlUb1JTQVB1YmxpY0tleSIsIm1heCIsInBhZE51bSIsInBhZEJ5dGUiLCJudW1aZXJvcyIsInBhZEJ5dGVzIiwiZW0iLCJmaXJzdCIsImdldEJ5dGUiLCJyZWFkIiwiemVybyIsIm9wdHMiLCJ3b3JrZXJzIiwid29ya0xvYWQiLCJ3b3JrZXJTY3JpcHQiLCJnZW5lcmF0ZSIsImdldFByaW1lIiwiZmluaXNoIiwicHJpbWUiLCJnZW5lcmF0ZVByb2JhYmxlUHJpbWUiLCJ0bXAiLCJoZXgiLCJieXRlcyIsInN1YnN0ciIsImZuIiwiYnVmZmVyIiwiVWludDhBcnJheSIsIl9wcml2YXRlS2V5RnJvbUp3ayIsImp3ayIsImt0eSIsIl9iYXNlNjRUb0JpZ0ludCIsImRwIiwiZHEiLCJxaSIsIl9wdWJsaWNLZXlGcm9tSndrIiwiYjY0IiwiZGVjb2RlNjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/rsa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/sha1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/sha1.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(ssr)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nvar sha1 = module.exports = forge.sha1 = forge.sha1 || {};\nforge.md.sha1 = forge.md.algorithms.sha1 = sha1;\n/**\n * Creates a SHA-1 message digest object.\n *\n * @return a message digest object.\n */ sha1.create = function() {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    // SHA-1 state contains five 32-bit integers\n    var _state = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for word storage\n    var _w = new Array(80);\n    // message digest object\n    var md = {\n        algorithm: \"sha1\",\n        blockLength: 64,\n        digestLength: 20,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength64 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n            h0: 0x67452301,\n            h1: 0xEFCDAB89,\n            h2: 0x98BADCFE,\n            h3: 0x10325476,\n            h4: 0xC3D2E1F0\n        };\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_state, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-1 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in big-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry from next int\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for(var i = 0; i < md.fullMessageLength.length - 1; ++i){\n            next = md.fullMessageLength[i + 1] * 8;\n            carry = next / 0x100000000 >>> 0;\n            bits += carry;\n            finalBlock.putInt32(bits >>> 0);\n            bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var s2 = {\n            h0: _state.h0,\n            h1: _state.h1,\n            h2: _state.h2,\n            h3: _state.h3,\n            h4: _state.h4\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32(s2.h0);\n        rval.putInt32(s2.h1);\n        rval.putInt32(s2.h2);\n        rval.putInt32(s2.h3);\n        rval.putInt32(s2.h4);\n        return rval;\n    };\n    return md;\n};\n// sha-1 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates a SHA-1 state with the given byte buffer.\n *\n * @param s the SHA-1 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (64 byte) chunks\n    var t, a, b, c, d, e, f, i;\n    var len = bytes.length();\n    while(len >= 64){\n        // the w array will be populated with sixteen 32-bit big-endian words\n        // and then extended into 80 32-bit words according to SHA-1 algorithm\n        // and for 32-79 using Max Locktyukhin's optimization\n        // initialize hash value for this chunk\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        e = s.h4;\n        // round 1\n        for(i = 0; i < 16; ++i){\n            t = bytes.getInt32();\n            w[i] = t;\n            f = d ^ b & (c ^ d);\n            t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        for(; i < 20; ++i){\n            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];\n            t = t << 1 | t >>> 31;\n            w[i] = t;\n            f = d ^ b & (c ^ d);\n            t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // round 2\n        for(; i < 32; ++i){\n            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];\n            t = t << 1 | t >>> 31;\n            w[i] = t;\n            f = b ^ c ^ d;\n            t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        for(; i < 40; ++i){\n            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n            t = t << 2 | t >>> 30;\n            w[i] = t;\n            f = b ^ c ^ d;\n            t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // round 3\n        for(; i < 60; ++i){\n            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n            t = t << 2 | t >>> 30;\n            w[i] = t;\n            f = b & c | d & (b ^ c);\n            t = (a << 5 | a >>> 27) + f + e + 0x8F1BBCDC + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // round 4\n        for(; i < 80; ++i){\n            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n            t = t << 2 | t >>> 30;\n            w[i] = t;\n            f = b ^ c ^ d;\n            t = (a << 5 | a >>> 27) + f + e + 0xCA62C1D6 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // update hash state\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        s.h4 = s.h4 + e | 0;\n        len -= 64;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFJQyxPQUFPQyxPQUFPQyxPQUFPLEdBQUdKLE1BQU1FLElBQUksR0FBR0YsTUFBTUUsSUFBSSxJQUFJLENBQUM7QUFDeERGLE1BQU1LLEVBQUUsQ0FBQ0gsSUFBSSxHQUFHRixNQUFNSyxFQUFFLENBQUNDLFVBQVUsQ0FBQ0osSUFBSSxHQUFHQTtBQUUzQzs7OztDQUlDLEdBQ0RBLEtBQUtLLE1BQU0sR0FBRztJQUNaLGlDQUFpQztJQUNqQyxJQUFHLENBQUNDLGNBQWM7UUFDaEJDO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsSUFBSUMsU0FBUztJQUViLGVBQWU7SUFDZixJQUFJQyxTQUFTWCxNQUFNWSxJQUFJLENBQUNDLFlBQVk7SUFFcEMsd0JBQXdCO0lBQ3hCLElBQUlDLEtBQUssSUFBSUMsTUFBTTtJQUVuQix3QkFBd0I7SUFDeEIsSUFBSVYsS0FBSztRQUNQVyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsY0FBYztRQUNkLCtEQUErRDtRQUMvREMsZUFBZTtRQUNmLHNCQUFzQjtRQUN0QkMsbUJBQW1CO1FBQ25CLGtDQUFrQztRQUNsQ0MsbUJBQW1CO0lBQ3JCO0lBRUE7Ozs7R0FJQyxHQUNEaEIsR0FBR2lCLEtBQUssR0FBRztRQUNULDhDQUE4QztRQUM5Q2pCLEdBQUdjLGFBQWEsR0FBRztRQUVuQiwyRUFBMkU7UUFDM0VkLEdBQUdlLGlCQUFpQixHQUFHZixHQUFHa0IsZUFBZSxHQUFHLEVBQUU7UUFDOUMsSUFBSUMsU0FBU25CLEdBQUdnQixpQkFBaUIsR0FBRztRQUNwQyxJQUFJLElBQUlJLElBQUksR0FBR0EsSUFBSUQsUUFBUSxFQUFFQyxFQUFHO1lBQzlCcEIsR0FBR2UsaUJBQWlCLENBQUNN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N0IsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGExLmpzP2MyODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZWN1cmUgSGFzaCBBbGdvcml0aG0gd2l0aCAxNjAtYml0IGRpZ2VzdCAoU0hBLTEpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzaGExID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGExID0gZm9yZ2Uuc2hhMSB8fCB7fTtcbmZvcmdlLm1kLnNoYTEgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTEgPSBzaGExO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTSEEtMSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgLy8gU0hBLTEgc3RhdGUgY29udGFpbnMgZml2ZSAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIF9zdGF0ZSA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoODApO1xuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgYWxnb3JpdGhtOiAnc2hhMScsXG4gICAgYmxvY2tMZW5ndGg6IDY0LFxuICAgIGRpZ2VzdExlbmd0aDogMjAsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiA4XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGg2NCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfc3RhdGUgPSB7XG4gICAgICBoMDogMHg2NzQ1MjMwMSxcbiAgICAgIGgxOiAweEVGQ0RBQjg5LFxuICAgICAgaDI6IDB4OThCQURDRkUsXG4gICAgICBoMzogMHgxMDMyNTQ3NixcbiAgICAgIGg0OiAweEMzRDJFMUYwXG4gICAgfTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG5cbiAgICAvLyBjb21wYWN0IGlucHV0IGJ1ZmZlciBldmVyeSAySyBvciBpZiBlbXB0eVxuICAgIGlmKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIF9pbnB1dC5jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm90ZTogSGVyZSB3ZSBjb3B5IHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIGlucHV0IGJ1ZmZlciBhbmRcbiAgICBhZGQgdGhlIGFwcHJvcHJpYXRlIFNIQS0xIHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDRcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTEgcGFkZGluZyBieXRlcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDY0KTtcblxuICAvLyBub3cgaW5pdGlhbGl6ZWRcbiAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgU0hBLTEgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0xIHN0YXRlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB3IHRoZSBhcnJheSB0byB1c2UgdG8gc3RvcmUgd29yZHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHVwZGF0ZSB3aXRoLlxuICovXG5mdW5jdGlvbiBfdXBkYXRlKHMsIHcsIGJ5dGVzKSB7XG4gIC8vIGNvbnN1bWUgNTEyIGJpdCAoNjQgYnl0ZSkgY2h1bmtzXG4gIHZhciB0LCBhLCBiLCBjLCBkLCBlLCBmLCBpO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gODAgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMSBhbGdvcml0aG1cbiAgICAvLyBhbmQgZm9yIDMyLTc5IHVzaW5nIE1heCBMb2NrdHl1a2hpbidzIG9wdGltaXphdGlvblxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG5cbiAgICAvLyByb3VuZCAxXG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgdCA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg1QTgyNzk5OSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICBmb3IoOyBpIDwgMjA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg1QTgyNzk5OSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAyXG4gICAgZm9yKDsgaSA8IDMyOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gM10gXiB3W2kgLSA4XSBeIHdbaSAtIDE0XSBeIHdbaSAtIDE2XSk7XG4gICAgICB0ID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDZFRDlFQkExICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCA0MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgM1xuICAgIGZvcig7IGkgPCA2MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiBeIGMpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg4RjFCQkNEQyArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCA0XG4gICAgZm9yKDsgaSA8IDgwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHhDQTYyQzFENiArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlXG4gICAgcy5oMCA9IChzLmgwICsgYSkgfCAwO1xuICAgIHMuaDEgPSAocy5oMSArIGIpIHwgMDtcbiAgICBzLmgyID0gKHMuaDIgKyBjKSB8IDA7XG4gICAgcy5oMyA9IChzLmgzICsgZCkgfCAwO1xuICAgIHMuaDQgPSAocy5oNCArIGUpIHwgMDtcblxuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInNoYTEiLCJtb2R1bGUiLCJleHBvcnRzIiwibWQiLCJhbGdvcml0aG1zIiwiY3JlYXRlIiwiX2luaXRpYWxpemVkIiwiX2luaXQiLCJfc3RhdGUiLCJfaW5wdXQiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiX3ciLCJBcnJheSIsImFsZ29yaXRobSIsImJsb2NrTGVuZ3RoIiwiZGlnZXN0TGVuZ3RoIiwibWVzc2FnZUxlbmd0aCIsImZ1bGxNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZUxlbmd0aFNpemUiLCJzdGFydCIsIm1lc3NhZ2VMZW5ndGg2NCIsImludDMycyIsImkiLCJwdXNoIiwiaDAiLCJoMSIsImgyIiwiaDMiLCJoNCIsInVwZGF0ZSIsIm1zZyIsImVuY29kaW5nIiwiZW5jb2RlVXRmOCIsImxlbiIsImxlbmd0aCIsInB1dEJ5dGVzIiwiX3VwZGF0ZSIsInJlYWQiLCJjb21wYWN0IiwiZGlnZXN0IiwiZmluYWxCbG9jayIsImJ5dGVzIiwicmVtYWluaW5nIiwib3ZlcmZsb3ciLCJfcGFkZGluZyIsInN1YnN0ciIsIm5leHQiLCJjYXJyeSIsImJpdHMiLCJwdXRJbnQzMiIsInMyIiwicnZhbCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImZpbGxTdHJpbmciLCJzIiwidyIsInQiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnZXRJbnQzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/sha256.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/sha256.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.\n *\n * See FIPS 180-2 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(ssr)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nvar sha256 = module.exports = forge.sha256 = forge.sha256 || {};\nforge.md.sha256 = forge.md.algorithms.sha256 = sha256;\n/**\n * Creates a SHA-256 message digest object.\n *\n * @return a message digest object.\n */ sha256.create = function() {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    // SHA-256 state contains eight 32-bit integers\n    var _state = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for word storage\n    var _w = new Array(64);\n    // message digest object\n    var md = {\n        algorithm: \"sha256\",\n        blockLength: 64,\n        digestLength: 32,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength64 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n            h0: 0x6A09E667,\n            h1: 0xBB67AE85,\n            h2: 0x3C6EF372,\n            h3: 0xA54FF53A,\n            h4: 0x510E527F,\n            h5: 0x9B05688C,\n            h6: 0x1F83D9AB,\n            h7: 0x5BE0CD19\n        };\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_state, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-256 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in big-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry from next int\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for(var i = 0; i < md.fullMessageLength.length - 1; ++i){\n            next = md.fullMessageLength[i + 1] * 8;\n            carry = next / 0x100000000 >>> 0;\n            bits += carry;\n            finalBlock.putInt32(bits >>> 0);\n            bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var s2 = {\n            h0: _state.h0,\n            h1: _state.h1,\n            h2: _state.h2,\n            h3: _state.h3,\n            h4: _state.h4,\n            h5: _state.h5,\n            h6: _state.h6,\n            h7: _state.h7\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32(s2.h0);\n        rval.putInt32(s2.h1);\n        rval.putInt32(s2.h2);\n        rval.putInt32(s2.h3);\n        rval.putInt32(s2.h4);\n        rval.putInt32(s2.h5);\n        rval.putInt32(s2.h6);\n        rval.putInt32(s2.h7);\n        return rval;\n    };\n    return md;\n};\n// sha-256 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n// table of constants\nvar _k = null;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n    // create K table for SHA-256\n    _k = [\n        0x428a2f98,\n        0x71374491,\n        0xb5c0fbcf,\n        0xe9b5dba5,\n        0x3956c25b,\n        0x59f111f1,\n        0x923f82a4,\n        0xab1c5ed5,\n        0xd807aa98,\n        0x12835b01,\n        0x243185be,\n        0x550c7dc3,\n        0x72be5d74,\n        0x80deb1fe,\n        0x9bdc06a7,\n        0xc19bf174,\n        0xe49b69c1,\n        0xefbe4786,\n        0x0fc19dc6,\n        0x240ca1cc,\n        0x2de92c6f,\n        0x4a7484aa,\n        0x5cb0a9dc,\n        0x76f988da,\n        0x983e5152,\n        0xa831c66d,\n        0xb00327c8,\n        0xbf597fc7,\n        0xc6e00bf3,\n        0xd5a79147,\n        0x06ca6351,\n        0x14292967,\n        0x27b70a85,\n        0x2e1b2138,\n        0x4d2c6dfc,\n        0x53380d13,\n        0x650a7354,\n        0x766a0abb,\n        0x81c2c92e,\n        0x92722c85,\n        0xa2bfe8a1,\n        0xa81a664b,\n        0xc24b8b70,\n        0xc76c51a3,\n        0xd192e819,\n        0xd6990624,\n        0xf40e3585,\n        0x106aa070,\n        0x19a4c116,\n        0x1e376c08,\n        0x2748774c,\n        0x34b0bcb5,\n        0x391c0cb3,\n        0x4ed8aa4a,\n        0x5b9cca4f,\n        0x682e6ff3,\n        0x748f82ee,\n        0x78a5636f,\n        0x84c87814,\n        0x8cc70208,\n        0x90befffa,\n        0xa4506ceb,\n        0xbef9a3f7,\n        0xc67178f2\n    ];\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates a SHA-256 state with the given byte buffer.\n *\n * @param s the SHA-256 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (64 byte) chunks\n    var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;\n    var len = bytes.length();\n    while(len >= 64){\n        // the w array will be populated with sixteen 32-bit big-endian words\n        // and then extended into 64 32-bit words according to SHA-256\n        for(i = 0; i < 16; ++i){\n            w[i] = bytes.getInt32();\n        }\n        for(; i < 64; ++i){\n            // XOR word 2 words ago rot right 17, rot right 19, shft right 10\n            t1 = w[i - 2];\n            t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;\n            // XOR word 15 words ago rot right 7, rot right 18, shft right 3\n            t2 = w[i - 15];\n            t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;\n            // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32\n            w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;\n        }\n        // initialize hash value for this chunk\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        e = s.h4;\n        f = s.h5;\n        g = s.h6;\n        h = s.h7;\n        // round function\n        for(i = 0; i < 64; ++i){\n            // Sum1(e)\n            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);\n            // Ch(e, f, g) (optimized the same way as SHA-1)\n            ch = g ^ e & (f ^ g);\n            // Sum0(a)\n            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);\n            // Maj(a, b, c) (optimized the same way as SHA-1)\n            maj = a & b | c & (a ^ b);\n            // main algorithm\n            t1 = h + s1 + ch + _k[i] + w[i];\n            t2 = s0 + maj;\n            h = g;\n            g = f;\n            f = e;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            // can't truncate with `| 0`\n            e = d + t1 >>> 0;\n            d = c;\n            c = b;\n            b = a;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            // can't truncate with `| 0`\n            a = t1 + t2 >>> 0;\n        }\n        // update hash state\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        s.h4 = s.h4 + e | 0;\n        s.h5 = s.h5 + f | 0;\n        s.h6 = s.h6 + g | 0;\n        s.h7 = s.h7 + h | 0;\n        len -= 64;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsU0FBU0MsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxNQUFNLEdBQUdGLE1BQU1FLE1BQU0sSUFBSSxDQUFDO0FBQzlERixNQUFNSyxFQUFFLENBQUNILE1BQU0sR0FBR0YsTUFBTUssRUFBRSxDQUFDQyxVQUFVLENBQUNKLE1BQU0sR0FBR0E7QUFFL0M7Ozs7Q0FJQyxHQUNEQSxPQUFPSyxNQUFNLEdBQUc7SUFDZCxpQ0FBaUM7SUFDakMsSUFBRyxDQUFDQyxjQUFjO1FBQ2hCQztJQUNGO0lBRUEsK0NBQStDO0lBQy9DLElBQUlDLFNBQVM7SUFFYixlQUFlO0lBQ2YsSUFBSUMsU0FBU1gsTUFBTVksSUFBSSxDQUFDQyxZQUFZO0lBRXBDLHdCQUF3QjtJQUN4QixJQUFJQyxLQUFLLElBQUlDLE1BQU07SUFFbkIsd0JBQXdCO0lBQ3hCLElBQUlWLEtBQUs7UUFDUFcsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLGNBQWM7UUFDZCwrREFBK0Q7UUFDL0RDLGVBQWU7UUFDZixzQkFBc0I7UUFDdEJDLG1CQUFtQjtRQUNuQixrQ0FBa0M7UUFDbENDLG1CQUFtQjtJQUNyQjtJQUVBOzs7O0dBSUMsR0FDRGhCLEdBQUdpQixLQUFLLEdBQUc7UUFDVCw4Q0FBOEM7UUFDOUNqQixHQUFHYyxhQUFhLEdBQUc7UUFFbkIsMkVBQTJFO1FBQzNFZCxHQUFHZSxpQkFBaUIsR0FBR2YsR0FBR2tCLGVBQWUsR0FBRyxFQUFFO1FBQzlDLElBQUlDLFNBQVNuQixHQUFHZ0IsaUJBQWlCLEdBQUc7UUFDcEMsSUFBSSxJQUFJSSxJQUFJLEdBQUdBLElBQUlELFFBQVEsRUFBRUMsRUFBRztZQUM5QnBCLEdBQUdlLGlCQUFpQixD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QUNKQSxJQUFJRDtZQUNKQSxJQUFJRDtZQUNKLDREQUE0RDtZQUM1RCw0QkFBNEI7WUFDNUJBLElBQUksS0FBTUwsT0FBUTtRQUNwQjtRQUVBLG9CQUFvQjtRQUNwQkgsRUFBRW5DLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUcyQyxJQUFLO1FBQ3BCUixFQUFFbEMsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBRzJDLElBQUs7UUFDcEJULEVBQUVqQyxFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHMkMsSUFBSztRQUNwQlYsRUFBRWhDLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUcyQyxJQUFLO1FBQ3BCWCxFQUFFL0IsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBRzJDLElBQUs7UUFDcEJaLEVBQUU5QixFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHMkMsSUFBSztRQUNwQmIsRUFBRTdCLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUcyQyxJQUFLO1FBQ3BCZCxFQUFFNUIsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBRzJDLElBQUs7UUFDcEJ0QyxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTI1Ni5qcz9mMzJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMjU2LWJpdCBkaWdlc3QgKFNIQS0yNTYpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBGSVBTIDE4MC0yIGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzaGEyNTYgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTI1NiA9IGZvcmdlLnNoYTI1NiB8fCB7fTtcbmZvcmdlLm1kLnNoYTI1NiA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMjU2ID0gc2hhMjU2O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTSEEtMjU2IG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGEyNTYuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIGluaXRpYWxpemF0aW9uIGFzIG5lY2Vzc2FyeVxuICBpZighX2luaXRpYWxpemVkKSB7XG4gICAgX2luaXQoKTtcbiAgfVxuXG4gIC8vIFNIQS0yNTYgc3RhdGUgY29udGFpbnMgZWlnaHQgMzItYml0IGludGVnZXJzXG4gIHZhciBfc3RhdGUgPSBudWxsO1xuXG4gIC8vIGlucHV0IGJ1ZmZlclxuICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyB1c2VkIGZvciB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDY0KTtcblxuICAvLyBtZXNzYWdlIGRpZ2VzdCBvYmplY3RcbiAgdmFyIG1kID0ge1xuICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgYmxvY2tMZW5ndGg6IDY0LFxuICAgIGRpZ2VzdExlbmd0aDogMzIsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiA4XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGg2NCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfc3RhdGUgPSB7XG4gICAgICBoMDogMHg2QTA5RTY2NyxcbiAgICAgIGgxOiAweEJCNjdBRTg1LFxuICAgICAgaDI6IDB4M0M2RUYzNzIsXG4gICAgICBoMzogMHhBNTRGRjUzQSxcbiAgICAgIGg0OiAweDUxMEU1MjdGLFxuICAgICAgaDU6IDB4OUIwNTY4OEMsXG4gICAgICBoNjogMHgxRjgzRDlBQixcbiAgICAgIGg3OiAweDVCRTBDRDE5XG4gICAgfTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG5cbiAgICAvLyBjb21wYWN0IGlucHV0IGJ1ZmZlciBldmVyeSAySyBvciBpZiBlbXB0eVxuICAgIGlmKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIF9pbnB1dC5jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm90ZTogSGVyZSB3ZSBjb3B5IHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIGlucHV0IGJ1ZmZlciBhbmRcbiAgICBhZGQgdGhlIGFwcHJvcHJpYXRlIFNIQS0yNTYgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNCxcbiAgICAgIGg1OiBfc3RhdGUuaDUsXG4gICAgICBoNjogX3N0YXRlLmg2LFxuICAgICAgaDc6IF9zdGF0ZS5oN1xuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg1KTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg2KTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg3KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMjU2IHBhZGRpbmcgYnl0ZXMgbm90IGluaXRpYWxpemVkIHlldFxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gdGFibGUgb2YgY29uc3RhbnRzXG52YXIgX2sgPSBudWxsO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDY0KTtcblxuICAvLyBjcmVhdGUgSyB0YWJsZSBmb3IgU0hBLTI1NlxuICBfayA9IFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAgIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcbiAgICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gICAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAgIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcbiAgICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gICAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAgIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXTtcblxuICAvLyBub3cgaW5pdGlhbGl6ZWRcbiAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgU0hBLTI1NiBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTI1NiBzdGF0ZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdyB0aGUgYXJyYXkgdG8gdXNlIHRvIHN0b3JlIHdvcmRzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byB1cGRhdGUgd2l0aC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAvLyBjb25zdW1lIDUxMiBiaXQgKDY0IGJ5dGUpIGNodW5rc1xuICB2YXIgdDEsIHQyLCBzMCwgczEsIGNoLCBtYWosIGksIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGg7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA2NCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0yNTZcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB3W2ldID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFhPUiB3b3JkIDIgd29yZHMgYWdvIHJvdCByaWdodCAxNywgcm90IHJpZ2h0IDE5LCBzaGZ0IHJpZ2h0IDEwXG4gICAgICB0MSA9IHdbaSAtIDJdO1xuICAgICAgdDEgPVxuICAgICAgICAoKHQxID4+PiAxNykgfCAodDEgPDwgMTUpKSBeXG4gICAgICAgICgodDEgPj4+IDE5KSB8ICh0MSA8PCAxMykpIF5cbiAgICAgICAgKHQxID4+PiAxMCk7XG4gICAgICAvLyBYT1Igd29yZCAxNSB3b3JkcyBhZ28gcm90IHJpZ2h0IDcsIHJvdCByaWdodCAxOCwgc2hmdCByaWdodCAzXG4gICAgICB0MiA9IHdbaSAtIDE1XTtcbiAgICAgIHQyID1cbiAgICAgICAgKCh0MiA+Pj4gNykgfCAodDIgPDwgMjUpKSBeXG4gICAgICAgICgodDIgPj4+IDE4KSB8ICh0MiA8PCAxNCkpIF5cbiAgICAgICAgKHQyID4+PiAzKTtcbiAgICAgIC8vIHN1bSh0MSwgd29yZCA3IGFnbywgdDIsIHdvcmQgMTYgYWdvKSBtb2R1bG8gMl4zMlxuICAgICAgd1tpXSA9ICh0MSArIHdbaSAtIDddICsgdDIgKyB3W2kgLSAxNl0pIHwgMDtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcbiAgICBmID0gcy5oNTtcbiAgICBnID0gcy5oNjtcbiAgICBoID0gcy5oNztcblxuICAgIC8vIHJvdW5kIGZ1bmN0aW9uXG4gICAgZm9yKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgLy8gU3VtMShlKVxuICAgICAgczEgPVxuICAgICAgICAoKGUgPj4+IDYpIHwgKGUgPDwgMjYpKSBeXG4gICAgICAgICgoZSA+Pj4gMTEpIHwgKGUgPDwgMjEpKSBeXG4gICAgICAgICgoZSA+Pj4gMjUpIHwgKGUgPDwgNykpO1xuICAgICAgLy8gQ2goZSwgZiwgZykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBjaCA9IGcgXiAoZSAmIChmIF4gZykpO1xuICAgICAgLy8gU3VtMChhKVxuICAgICAgczAgPVxuICAgICAgICAoKGEgPj4+IDIpIHwgKGEgPDwgMzApKSBeXG4gICAgICAgICgoYSA+Pj4gMTMpIHwgKGEgPDwgMTkpKSBeXG4gICAgICAgICgoYSA+Pj4gMjIpIHwgKGEgPDwgMTApKTtcbiAgICAgIC8vIE1haihhLCBiLCBjKSAob3B0aW1pemVkIHRoZSBzYW1lIHdheSBhcyBTSEEtMSlcbiAgICAgIG1haiA9IChhICYgYikgfCAoYyAmIChhIF4gYikpO1xuXG4gICAgICAvLyBtYWluIGFsZ29yaXRobVxuICAgICAgdDEgPSBoICsgczEgKyBjaCArIF9rW2ldICsgd1tpXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBoID0gZztcbiAgICAgIGcgPSBmO1xuICAgICAgZiA9IGU7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGUgPSAoZCArIHQxKSA+Pj4gMDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGI7XG4gICAgICBiID0gYTtcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgLy8gY2FuJ3QgdHJ1bmNhdGUgd2l0aCBgfCAwYFxuICAgICAgYSA9ICh0MSArIHQyKSA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZVxuICAgIHMuaDAgPSAocy5oMCArIGEpIHwgMDtcbiAgICBzLmgxID0gKHMuaDEgKyBiKSB8IDA7XG4gICAgcy5oMiA9IChzLmgyICsgYykgfCAwO1xuICAgIHMuaDMgPSAocy5oMyArIGQpIHwgMDtcbiAgICBzLmg0ID0gKHMuaDQgKyBlKSB8IDA7XG4gICAgcy5oNSA9IChzLmg1ICsgZikgfCAwO1xuICAgIHMuaDYgPSAocy5oNiArIGcpIHwgMDtcbiAgICBzLmg3ID0gKHMuaDcgKyBoKSB8IDA7XG4gICAgbGVuIC09IDY0O1xuICB9XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwic2hhMjU2IiwibW9kdWxlIiwiZXhwb3J0cyIsIm1kIiwiYWxnb3JpdGhtcyIsImNyZWF0ZSIsIl9pbml0aWFsaXplZCIsIl9pbml0IiwiX3N0YXRlIiwiX2lucHV0IiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsIl93IiwiQXJyYXkiLCJhbGdvcml0aG0iLCJibG9ja0xlbmd0aCIsImRpZ2VzdExlbmd0aCIsIm1lc3NhZ2VMZW5ndGgiLCJmdWxsTWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VMZW5ndGhTaXplIiwic3RhcnQiLCJtZXNzYWdlTGVuZ3RoNjQiLCJpbnQzMnMiLCJpIiwicHVzaCIsImgwIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaDciLCJ1cGRhdGUiLCJtc2ciLCJlbmNvZGluZyIsImVuY29kZVV0ZjgiLCJsZW4iLCJsZW5ndGgiLCJwdXRCeXRlcyIsIl91cGRhdGUiLCJyZWFkIiwiY29tcGFjdCIsImRpZ2VzdCIsImZpbmFsQmxvY2siLCJieXRlcyIsInJlbWFpbmluZyIsIm92ZXJmbG93IiwiX3BhZGRpbmciLCJzdWJzdHIiLCJuZXh0IiwiY2FycnkiLCJiaXRzIiwicHV0SW50MzIiLCJzMiIsInJ2YWwiLCJfayIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImZpbGxTdHJpbmciLCJzIiwidyIsInQxIiwidDIiLCJzMCIsInMxIiwiY2giLCJtYWoiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImdldEludDMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/sha512.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/sha512.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Secure Hash Algorithm with a 1024-bit block size implementation.\n *\n * This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For\n * SHA-256 (block size 512 bits), see sha256.js.\n *\n * See FIPS 180-4 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014-2015 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(ssr)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\nvar sha512 = module.exports = forge.sha512 = forge.sha512 || {};\n// SHA-512\nforge.md.sha512 = forge.md.algorithms.sha512 = sha512;\n// SHA-384\nvar sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};\nsha384.create = function() {\n    return sha512.create(\"SHA-384\");\n};\nforge.md.sha384 = forge.md.algorithms.sha384 = sha384;\n// SHA-512/256\nforge.sha512.sha256 = forge.sha512.sha256 || {\n    create: function() {\n        return sha512.create(\"SHA-512/256\");\n    }\n};\nforge.md[\"sha512/256\"] = forge.md.algorithms[\"sha512/256\"] = forge.sha512.sha256;\n// SHA-512/224\nforge.sha512.sha224 = forge.sha512.sha224 || {\n    create: function() {\n        return sha512.create(\"SHA-512/224\");\n    }\n};\nforge.md[\"sha512/224\"] = forge.md.algorithms[\"sha512/224\"] = forge.sha512.sha224;\n/**\n * Creates a SHA-2 message digest object.\n *\n * @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,\n *          SHA-512/256).\n *\n * @return a message digest object.\n */ sha512.create = function(algorithm) {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    if (typeof algorithm === \"undefined\") {\n        algorithm = \"SHA-512\";\n    }\n    if (!(algorithm in _states)) {\n        throw new Error(\"Invalid SHA-512 algorithm: \" + algorithm);\n    }\n    // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)\n    var _state = _states[algorithm];\n    var _h = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for 64-bit word storage\n    var _w = new Array(80);\n    for(var wi = 0; wi < 80; ++wi){\n        _w[wi] = new Array(2);\n    }\n    // determine digest length by algorithm name (default)\n    var digestLength = 64;\n    switch(algorithm){\n        case \"SHA-384\":\n            digestLength = 48;\n            break;\n        case \"SHA-512/256\":\n            digestLength = 32;\n            break;\n        case \"SHA-512/224\":\n            digestLength = 28;\n            break;\n    }\n    // message digest object\n    var md = {\n        // SHA-512 => sha512\n        algorithm: algorithm.replace(\"-\", \"\").toLowerCase(),\n        blockLength: 128,\n        digestLength: digestLength,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 16\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength128 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength128 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _h = new Array(_state.length);\n        for(var i = 0; i < _state.length; ++i){\n            _h[i] = _state[i].slice(0);\n        }\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_h, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-512 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 896 mod 1024. In other words,\n    the data to be digested must be a multiple of 1024 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 16 bytes (128\n    bits), that means that the last segment of the data must have 112 bytes\n    (896 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 896 mod 1024 because\n    1024 - 128 = 896.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 896 mod 1024, then 1024 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in big-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry from next int\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for(var i = 0; i < md.fullMessageLength.length - 1; ++i){\n            next = md.fullMessageLength[i + 1] * 8;\n            carry = next / 0x100000000 >>> 0;\n            bits += carry;\n            finalBlock.putInt32(bits >>> 0);\n            bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var h = new Array(_h.length);\n        for(var i = 0; i < _h.length; ++i){\n            h[i] = _h[i].slice(0);\n        }\n        _update(h, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        var hlen;\n        if (algorithm === \"SHA-512\") {\n            hlen = h.length;\n        } else if (algorithm === \"SHA-384\") {\n            hlen = h.length - 2;\n        } else {\n            hlen = h.length - 4;\n        }\n        for(var i = 0; i < hlen; ++i){\n            rval.putInt32(h[i][0]);\n            if (i !== hlen - 1 || algorithm !== \"SHA-512/224\") {\n                rval.putInt32(h[i][1]);\n            }\n        }\n        return rval;\n    };\n    return md;\n};\n// sha-512 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n// table of constants\nvar _k = null;\n// initial hash states\nvar _states = null;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 128);\n    // create K table for SHA-512\n    _k = [\n        [\n            0x428a2f98,\n            0xd728ae22\n        ],\n        [\n            0x71374491,\n            0x23ef65cd\n        ],\n        [\n            0xb5c0fbcf,\n            0xec4d3b2f\n        ],\n        [\n            0xe9b5dba5,\n            0x8189dbbc\n        ],\n        [\n            0x3956c25b,\n            0xf348b538\n        ],\n        [\n            0x59f111f1,\n            0xb605d019\n        ],\n        [\n            0x923f82a4,\n            0xaf194f9b\n        ],\n        [\n            0xab1c5ed5,\n            0xda6d8118\n        ],\n        [\n            0xd807aa98,\n            0xa3030242\n        ],\n        [\n            0x12835b01,\n            0x45706fbe\n        ],\n        [\n            0x243185be,\n            0x4ee4b28c\n        ],\n        [\n            0x550c7dc3,\n            0xd5ffb4e2\n        ],\n        [\n            0x72be5d74,\n            0xf27b896f\n        ],\n        [\n            0x80deb1fe,\n            0x3b1696b1\n        ],\n        [\n            0x9bdc06a7,\n            0x25c71235\n        ],\n        [\n            0xc19bf174,\n            0xcf692694\n        ],\n        [\n            0xe49b69c1,\n            0x9ef14ad2\n        ],\n        [\n            0xefbe4786,\n            0x384f25e3\n        ],\n        [\n            0x0fc19dc6,\n            0x8b8cd5b5\n        ],\n        [\n            0x240ca1cc,\n            0x77ac9c65\n        ],\n        [\n            0x2de92c6f,\n            0x592b0275\n        ],\n        [\n            0x4a7484aa,\n            0x6ea6e483\n        ],\n        [\n            0x5cb0a9dc,\n            0xbd41fbd4\n        ],\n        [\n            0x76f988da,\n            0x831153b5\n        ],\n        [\n            0x983e5152,\n            0xee66dfab\n        ],\n        [\n            0xa831c66d,\n            0x2db43210\n        ],\n        [\n            0xb00327c8,\n            0x98fb213f\n        ],\n        [\n            0xbf597fc7,\n            0xbeef0ee4\n        ],\n        [\n            0xc6e00bf3,\n            0x3da88fc2\n        ],\n        [\n            0xd5a79147,\n            0x930aa725\n        ],\n        [\n            0x06ca6351,\n            0xe003826f\n        ],\n        [\n            0x14292967,\n            0x0a0e6e70\n        ],\n        [\n            0x27b70a85,\n            0x46d22ffc\n        ],\n        [\n            0x2e1b2138,\n            0x5c26c926\n        ],\n        [\n            0x4d2c6dfc,\n            0x5ac42aed\n        ],\n        [\n            0x53380d13,\n            0x9d95b3df\n        ],\n        [\n            0x650a7354,\n            0x8baf63de\n        ],\n        [\n            0x766a0abb,\n            0x3c77b2a8\n        ],\n        [\n            0x81c2c92e,\n            0x47edaee6\n        ],\n        [\n            0x92722c85,\n            0x1482353b\n        ],\n        [\n            0xa2bfe8a1,\n            0x4cf10364\n        ],\n        [\n            0xa81a664b,\n            0xbc423001\n        ],\n        [\n            0xc24b8b70,\n            0xd0f89791\n        ],\n        [\n            0xc76c51a3,\n            0x0654be30\n        ],\n        [\n            0xd192e819,\n            0xd6ef5218\n        ],\n        [\n            0xd6990624,\n            0x5565a910\n        ],\n        [\n            0xf40e3585,\n            0x5771202a\n        ],\n        [\n            0x106aa070,\n            0x32bbd1b8\n        ],\n        [\n            0x19a4c116,\n            0xb8d2d0c8\n        ],\n        [\n            0x1e376c08,\n            0x5141ab53\n        ],\n        [\n            0x2748774c,\n            0xdf8eeb99\n        ],\n        [\n            0x34b0bcb5,\n            0xe19b48a8\n        ],\n        [\n            0x391c0cb3,\n            0xc5c95a63\n        ],\n        [\n            0x4ed8aa4a,\n            0xe3418acb\n        ],\n        [\n            0x5b9cca4f,\n            0x7763e373\n        ],\n        [\n            0x682e6ff3,\n            0xd6b2b8a3\n        ],\n        [\n            0x748f82ee,\n            0x5defb2fc\n        ],\n        [\n            0x78a5636f,\n            0x43172f60\n        ],\n        [\n            0x84c87814,\n            0xa1f0ab72\n        ],\n        [\n            0x8cc70208,\n            0x1a6439ec\n        ],\n        [\n            0x90befffa,\n            0x23631e28\n        ],\n        [\n            0xa4506ceb,\n            0xde82bde9\n        ],\n        [\n            0xbef9a3f7,\n            0xb2c67915\n        ],\n        [\n            0xc67178f2,\n            0xe372532b\n        ],\n        [\n            0xca273ece,\n            0xea26619c\n        ],\n        [\n            0xd186b8c7,\n            0x21c0c207\n        ],\n        [\n            0xeada7dd6,\n            0xcde0eb1e\n        ],\n        [\n            0xf57d4f7f,\n            0xee6ed178\n        ],\n        [\n            0x06f067aa,\n            0x72176fba\n        ],\n        [\n            0x0a637dc5,\n            0xa2c898a6\n        ],\n        [\n            0x113f9804,\n            0xbef90dae\n        ],\n        [\n            0x1b710b35,\n            0x131c471b\n        ],\n        [\n            0x28db77f5,\n            0x23047d84\n        ],\n        [\n            0x32caab7b,\n            0x40c72493\n        ],\n        [\n            0x3c9ebe0a,\n            0x15c9bebc\n        ],\n        [\n            0x431d67c4,\n            0x9c100d4c\n        ],\n        [\n            0x4cc5d4be,\n            0xcb3e42b6\n        ],\n        [\n            0x597f299c,\n            0xfc657e2a\n        ],\n        [\n            0x5fcb6fab,\n            0x3ad6faec\n        ],\n        [\n            0x6c44198c,\n            0x4a475817\n        ]\n    ];\n    // initial hash states\n    _states = {};\n    _states[\"SHA-512\"] = [\n        [\n            0x6a09e667,\n            0xf3bcc908\n        ],\n        [\n            0xbb67ae85,\n            0x84caa73b\n        ],\n        [\n            0x3c6ef372,\n            0xfe94f82b\n        ],\n        [\n            0xa54ff53a,\n            0x5f1d36f1\n        ],\n        [\n            0x510e527f,\n            0xade682d1\n        ],\n        [\n            0x9b05688c,\n            0x2b3e6c1f\n        ],\n        [\n            0x1f83d9ab,\n            0xfb41bd6b\n        ],\n        [\n            0x5be0cd19,\n            0x137e2179\n        ]\n    ];\n    _states[\"SHA-384\"] = [\n        [\n            0xcbbb9d5d,\n            0xc1059ed8\n        ],\n        [\n            0x629a292a,\n            0x367cd507\n        ],\n        [\n            0x9159015a,\n            0x3070dd17\n        ],\n        [\n            0x152fecd8,\n            0xf70e5939\n        ],\n        [\n            0x67332667,\n            0xffc00b31\n        ],\n        [\n            0x8eb44a87,\n            0x68581511\n        ],\n        [\n            0xdb0c2e0d,\n            0x64f98fa7\n        ],\n        [\n            0x47b5481d,\n            0xbefa4fa4\n        ]\n    ];\n    _states[\"SHA-512/256\"] = [\n        [\n            0x22312194,\n            0xFC2BF72C\n        ],\n        [\n            0x9F555FA3,\n            0xC84C64C2\n        ],\n        [\n            0x2393B86B,\n            0x6F53B151\n        ],\n        [\n            0x96387719,\n            0x5940EABD\n        ],\n        [\n            0x96283EE2,\n            0xA88EFFE3\n        ],\n        [\n            0xBE5E1E25,\n            0x53863992\n        ],\n        [\n            0x2B0199FC,\n            0x2C85B8AA\n        ],\n        [\n            0x0EB72DDC,\n            0x81C52CA2\n        ]\n    ];\n    _states[\"SHA-512/224\"] = [\n        [\n            0x8C3D37C8,\n            0x19544DA2\n        ],\n        [\n            0x73E19966,\n            0x89DCD4D6\n        ],\n        [\n            0x1DFAB7AE,\n            0x32FF9C82\n        ],\n        [\n            0x679DD514,\n            0x582F9FCF\n        ],\n        [\n            0x0F6D2B69,\n            0x7BD44DA8\n        ],\n        [\n            0x77E36F73,\n            0x04C48942\n        ],\n        [\n            0x3F9D85A8,\n            0x6A1D36C8\n        ],\n        [\n            0x1112E6AD,\n            0x91D692A1\n        ]\n    ];\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates a SHA-512 state with the given byte buffer.\n *\n * @param s the SHA-512 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (128 byte) chunks\n    var t1_hi, t1_lo;\n    var t2_hi, t2_lo;\n    var s0_hi, s0_lo;\n    var s1_hi, s1_lo;\n    var ch_hi, ch_lo;\n    var maj_hi, maj_lo;\n    var a_hi, a_lo;\n    var b_hi, b_lo;\n    var c_hi, c_lo;\n    var d_hi, d_lo;\n    var e_hi, e_lo;\n    var f_hi, f_lo;\n    var g_hi, g_lo;\n    var h_hi, h_lo;\n    var i, hi, lo, w2, w7, w15, w16;\n    var len = bytes.length();\n    while(len >= 128){\n        // the w array will be populated with sixteen 64-bit big-endian words\n        // and then extended into 64 64-bit words according to SHA-512\n        for(i = 0; i < 16; ++i){\n            w[i][0] = bytes.getInt32() >>> 0;\n            w[i][1] = bytes.getInt32() >>> 0;\n        }\n        for(; i < 80; ++i){\n            // for word 2 words ago: ROTR 19(x) ^ ROTR 61(x) ^ SHR 6(x)\n            w2 = w[i - 2];\n            hi = w2[0];\n            lo = w2[1];\n            // high bits\n            t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19\n            (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)\n            hi >>> 6) >>> 0; // SHR 6\n            // low bits\n            t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19\n            (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)\n            (hi << 26 | lo >>> 6)) >>> 0; // SHR 6\n            // for word 15 words ago: ROTR 1(x) ^ ROTR 8(x) ^ SHR 7(x)\n            w15 = w[i - 15];\n            hi = w15[0];\n            lo = w15[1];\n            // high bits\n            t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1\n            (hi >>> 8 | lo << 24) ^ // ROTR 8\n            hi >>> 7) >>> 0; // SHR 7\n            // low bits\n            t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1\n            (hi << 24 | lo >>> 8) ^ // ROTR 8\n            (hi << 25 | lo >>> 7)) >>> 0; // SHR 7\n            // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^64 (carry lo overflow)\n            w7 = w[i - 7];\n            w16 = w[i - 16];\n            lo = t1_lo + w7[1] + t2_lo + w16[1];\n            w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 0x100000000 >>> 0) >>> 0;\n            w[i][1] = lo >>> 0;\n        }\n        // initialize hash value for this chunk\n        a_hi = s[0][0];\n        a_lo = s[0][1];\n        b_hi = s[1][0];\n        b_lo = s[1][1];\n        c_hi = s[2][0];\n        c_lo = s[2][1];\n        d_hi = s[3][0];\n        d_lo = s[3][1];\n        e_hi = s[4][0];\n        e_lo = s[4][1];\n        f_hi = s[5][0];\n        f_lo = s[5][1];\n        g_hi = s[6][0];\n        g_lo = s[6][1];\n        h_hi = s[7][0];\n        h_lo = s[7][1];\n        // round function\n        for(i = 0; i < 80; ++i){\n            // Sum1(e) = ROTR 14(e) ^ ROTR 18(e) ^ ROTR 41(e)\n            s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14\n            (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18\n            (e_lo >>> 9 | e_hi << 23)) >>> 0; // ROTR 41/(swap + ROTR 9)\n            s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14\n            (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18\n            (e_lo << 23 | e_hi >>> 9)) >>> 0; // ROTR 41/(swap + ROTR 9)\n            // Ch(e, f, g) (optimized the same way as SHA-1)\n            ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;\n            ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;\n            // Sum0(a) = ROTR 28(a) ^ ROTR 34(a) ^ ROTR 39(a)\n            s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28\n            (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)\n            (a_lo >>> 7 | a_hi << 25)) >>> 0; // ROTR 39/(swap + ROTR 7)\n            s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28\n            (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)\n            (a_lo << 25 | a_hi >>> 7)) >>> 0; // ROTR 39/(swap + ROTR 7)\n            // Maj(a, b, c) (optimized the same way as SHA-1)\n            maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;\n            maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;\n            // main algorithm\n            // t1 = (h + s1 + ch + _k[i] + _w[i]) modulo 2^64 (carry lo overflow)\n            lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];\n            t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 0x100000000 >>> 0) >>> 0;\n            t1_lo = lo >>> 0;\n            // t2 = s0 + maj modulo 2^64 (carry lo overflow)\n            lo = s0_lo + maj_lo;\n            t2_hi = s0_hi + maj_hi + (lo / 0x100000000 >>> 0) >>> 0;\n            t2_lo = lo >>> 0;\n            h_hi = g_hi;\n            h_lo = g_lo;\n            g_hi = f_hi;\n            g_lo = f_lo;\n            f_hi = e_hi;\n            f_lo = e_lo;\n            // e = (d + t1) modulo 2^64 (carry lo overflow)\n            lo = d_lo + t1_lo;\n            e_hi = d_hi + t1_hi + (lo / 0x100000000 >>> 0) >>> 0;\n            e_lo = lo >>> 0;\n            d_hi = c_hi;\n            d_lo = c_lo;\n            c_hi = b_hi;\n            c_lo = b_lo;\n            b_hi = a_hi;\n            b_lo = a_lo;\n            // a = (t1 + t2) modulo 2^64 (carry lo overflow)\n            lo = t1_lo + t2_lo;\n            a_hi = t1_hi + t2_hi + (lo / 0x100000000 >>> 0) >>> 0;\n            a_lo = lo >>> 0;\n        }\n        // update hash state (additional modulo 2^64)\n        lo = s[0][1] + a_lo;\n        s[0][0] = s[0][0] + a_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[0][1] = lo >>> 0;\n        lo = s[1][1] + b_lo;\n        s[1][0] = s[1][0] + b_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[1][1] = lo >>> 0;\n        lo = s[2][1] + c_lo;\n        s[2][0] = s[2][0] + c_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[2][1] = lo >>> 0;\n        lo = s[3][1] + d_lo;\n        s[3][0] = s[3][0] + d_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[3][1] = lo >>> 0;\n        lo = s[4][1] + e_lo;\n        s[4][0] = s[4][0] + e_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[4][1] = lo >>> 0;\n        lo = s[5][1] + f_lo;\n        s[5][0] = s[5][0] + f_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[5][1] = lo >>> 0;\n        lo = s[6][1] + g_lo;\n        s[6][0] = s[6][0] + g_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[6][1] = lo >>> 0;\n        lo = s[7][1] + h_lo;\n        s[7][0] = s[7][0] + h_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[7][1] = lo >>> 0;\n        len -= 128;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztDQVdDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsU0FBU0MsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxNQUFNLEdBQUdGLE1BQU1FLE1BQU0sSUFBSSxDQUFDO0FBRTlELFVBQVU7QUFDVkYsTUFBTUssRUFBRSxDQUFDSCxNQUFNLEdBQUdGLE1BQU1LLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDSixNQUFNLEdBQUdBO0FBRS9DLFVBQVU7QUFDVixJQUFJSyxTQUFTUCxNQUFNTyxNQUFNLEdBQUdQLE1BQU1FLE1BQU0sQ0FBQ0ssTUFBTSxHQUFHUCxNQUFNRSxNQUFNLENBQUNLLE1BQU0sSUFBSSxDQUFDO0FBQzFFQSxPQUFPQyxNQUFNLEdBQUc7SUFDZCxPQUFPTixPQUFPTSxNQUFNLENBQUM7QUFDdkI7QUFDQVIsTUFBTUssRUFBRSxDQUFDRSxNQUFNLEdBQUdQLE1BQU1LLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDQyxNQUFNLEdBQUdBO0FBRS9DLGNBQWM7QUFDZFAsTUFBTUUsTUFBTSxDQUFDTyxNQUFNLEdBQUdULE1BQU1FLE1BQU0sQ0FBQ08sTUFBTSxJQUFJO0lBQzNDRCxRQUFRO1FBQ04sT0FBT04sT0FBT00sTUFBTSxDQUFDO0lBQ3ZCO0FBQ0Y7QUFDQVIsTUFBTUssRUFBRSxDQUFDLGFBQWEsR0FBR0wsTUFBTUssRUFBRSxDQUFDQyxVQUFVLENBQUMsYUFBYSxHQUN4RE4sTUFBTUUsTUFBTSxDQUFDTyxNQUFNO0FBRXJCLGNBQWM7QUFDZFQsTUFBTUUsTUFBTSxDQUFDUSxNQUFNLEdBQUdWLE1BQU1FLE1BQU0sQ0FBQ1EsTUFBTSxJQUFJO0lBQzNDRixRQUFRO1FBQ04sT0FBT04sT0FBT00sTUFBTSxDQUFDO0lBQ3ZCO0FBQ0Y7QUFDQVIs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QVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7S0FDbkQ7SUFFRCxzQkFBc0I7SUFDdEIvQyxVQUFVLENBQUM7SUFDWEEsT0FBTyxDQUFDLFVBQVUsR0FBRztRQUNuQjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztLQUN6QjtJQUNEQSxPQUFPLENBQUMsVUFBVSxHQUFHO1FBQ25CO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO1FBQ3hCO1lBQUM7WUFBWTtTQUFXO0tBQ3pCO0lBQ0RBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7UUFDdkI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7UUFDeEI7WUFBQztZQUFZO1NBQVc7S0FDekI7SUFDREEsT0FBTyxDQUFDLGNBQWMsR0FBRztRQUN2QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztRQUN4QjtZQUFDO1lBQVk7U0FBVztLQUN6QjtJQUVELGtCQUFrQjtJQUNsQkYsZUFBZTtBQUNqQjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNnQyxRQUFRcUIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVqQixLQUFLO0lBQzFCLG9DQUFvQztJQUNwQyxJQUFJa0IsT0FBT0M7SUFDWCxJQUFJQyxPQUFPQztJQUNYLElBQUlDLE9BQU9DO0lBQ1gsSUFBSUMsT0FBT0M7SUFDWCxJQUFJQyxPQUFPQztJQUNYLElBQUlDLFFBQVFDO0lBQ1osSUFBSUMsTUFBTUM7SUFDVixJQUFJQyxNQUFNQztJQUNWLElBQUlDLE1BQU1DO0lBQ1YsSUFBSUMsTUFBTUM7SUFDVixJQUFJQyxNQUFNQztJQUNWLElBQUlDLE1BQU1DO0lBQ1YsSUFBSUMsTUFBTUM7SUFDVixJQUFJQyxNQUFNQztJQUNWLElBQUk1RCxHQUFHNkQsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsS0FBS0M7SUFDNUIsSUFBSTFELE1BQU1PLE1BQU1iLE1BQU07SUFDdEIsTUFBTU0sT0FBTyxJQUFLO1FBQ2hCLHFFQUFxRTtRQUNyRSw4REFBOEQ7UUFDOUQsSUFBSVIsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBRztZQUN0QmdDLENBQUMsQ0FBQ2hDLEVBQUUsQ0FBQyxFQUFFLEdBQUdlLE1BQU1vRCxRQUFRLE9BQU87WUFDL0JuQyxDQUFDLENBQUNoQyxFQUFFLENBQUMsRUFBRSxHQUFHZSxNQUFNb0QsUUFBUSxPQUFPO1FBQ2pDO1FBQ0EsTUFBTW5FLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQ2pCLDJEQUEyRDtZQUMzRCtELEtBQUsvQixDQUFDLENBQUNoQyxJQUFJLEVBQUU7WUFDYjZELEtBQUtFLEVBQUUsQ0FBQyxFQUFFO1lBQ1ZELEtBQUtDLEVBQUUsQ0FBQyxFQUFFO1lBRVYsWUFBWTtZQUNaOUIsUUFBUSxDQUNOLENBQUMsT0FBUSxLQUFPNkIsTUFBTSxFQUFFLElBQUssVUFBVTtZQUN0QyxRQUFRLEtBQU9ELE1BQU0sQ0FBQyxJQUFLLDJCQUEyQjtZQUN0REEsT0FBTyxDQUFDLE1BQU8sR0FBRyxRQUFRO1lBQzdCLFdBQVc7WUFDWDNCLFFBQVEsQ0FDTixDQUFDLE1BQU8sS0FBTzRCLE9BQU8sRUFBRSxJQUFLLFVBQVU7WUFDdEMsT0FBTyxJQUFNRCxPQUFPLEVBQUUsSUFBSywyQkFBMkI7WUFDdEQsT0FBTyxLQUFPQyxPQUFPLENBQUMsQ0FBQyxNQUFPLEdBQUcsUUFBUTtZQUU1QywwREFBMEQ7WUFDMURHLE1BQU1qQyxDQUFDLENBQUNoQyxJQUFJLEdBQUc7WUFDZjZELEtBQUtJLEdBQUcsQ0FBQyxFQUFFO1lBQ1hILEtBQUtHLEdBQUcsQ0FBQyxFQUFFO1lBRVgsWUFBWTtZQUNaOUIsUUFBUSxDQUNOLENBQUMsT0FBUSxJQUFNMkIsTUFBTSxFQUFFLElBQUssU0FBUztZQUNwQyxRQUFRLElBQU1BLE1BQU0sRUFBRSxJQUFLLFNBQVM7WUFDcENELE9BQU8sQ0FBQyxNQUFPLEdBQUcsUUFBUTtZQUM3QixXQUFXO1lBQ1h6QixRQUFRLENBQ04sQ0FBQyxNQUFPLEtBQU8wQixPQUFPLENBQUMsSUFBSyxTQUFTO1lBQ3BDLE9BQU8sS0FBT0EsT0FBTyxDQUFDLElBQUssU0FBUztZQUNwQyxPQUFPLEtBQU9BLE9BQU8sQ0FBQyxDQUFDLE1BQU8sR0FBRyxRQUFRO1lBRTVDLHVFQUF1RTtZQUN2RUUsS0FBS2hDLENBQUMsQ0FBQ2hDLElBQUksRUFBRTtZQUNia0UsTUFBTWxDLENBQUMsQ0FBQ2hDLElBQUksR0FBRztZQUNmOEQsS0FBTTVCLFFBQVE4QixFQUFFLENBQUMsRUFBRSxHQUFHNUIsUUFBUThCLEdBQUcsQ0FBQyxFQUFFO1lBQ3BDbEMsQ0FBQyxDQUFDaEMsRUFBRSxDQUFDLEVBQUUsR0FBRyxRQUFTZ0UsRUFBRSxDQUFDLEVBQUUsR0FBRzdCLFFBQVErQixHQUFHLENBQUMsRUFBRSxHQUN0QyxNQUFNLGdCQUFpQixPQUFRO1lBQ2xDbEMsQ0FBQyxDQUFDaEMsRUFBRSxDQUFDLEVBQUUsR0FBRzhELE9BQU87UUFDbkI7UUFFQSx1Q0FBdUM7UUFDdkNqQixPQUFPZCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDZGUsT0FBT2YsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RnQixPQUFPaEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RpQixPQUFPakIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RrQixPQUFPbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RtQixPQUFPbkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RvQixPQUFPcEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RxQixPQUFPckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2RzQixPQUFPdEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2R1QixPQUFPdkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2R3QixPQUFPeEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2R5QixPQUFPekIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2QwQixPQUFPMUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2QyQixPQUFPM0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2Q0QixPQUFPNUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2Q2QixPQUFPN0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBRWQsaUJBQWlCO1FBQ2pCLElBQUkvQixJQUFJLEdBQUdBLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQ3RCLGlEQUFpRDtZQUNqRHVDLFFBQVEsQ0FDTixDQUFDLFNBQVUsS0FBT2UsUUFBUSxFQUFFLElBQUssVUFBVTtZQUMxQyxVQUFVLEtBQU9BLFFBQVEsRUFBRSxJQUFLLFVBQVU7WUFDMUMsVUFBVSxJQUFNRCxRQUFRLEVBQUUsQ0FBQyxNQUFPLEdBQUcsMEJBQTBCO1lBQ2xFYixRQUFRLENBQ04sQ0FBQyxRQUFTLEtBQU9jLFNBQVMsRUFBRSxJQUFLLFVBQVU7WUFDMUMsU0FBUyxLQUFPQSxTQUFTLEVBQUUsSUFBSyxVQUFVO1lBQzFDLFNBQVMsS0FBT0QsU0FBUyxDQUFDLENBQUMsTUFBTyxHQUFHLDBCQUEwQjtZQUVsRSxnREFBZ0Q7WUFDaERaLFFBQVEsQ0FBQ2dCLE9BQVFKLE9BQVFFLENBQUFBLE9BQU9FLElBQUcsQ0FBRSxNQUFPO1lBQzVDZixRQUFRLENBQUNnQixPQUFRSixPQUFRRSxDQUFBQSxPQUFPRSxJQUFHLENBQUUsTUFBTztZQUU1QyxpREFBaUQ7WUFDakRyQixRQUFRLENBQ04sQ0FBQyxTQUFVLEtBQU9TLFFBQVEsQ0FBQyxJQUFLLFVBQVU7WUFDekMsVUFBVSxJQUFNRCxRQUFRLEVBQUUsSUFBSywwQkFBMEI7WUFDekQsVUFBVSxJQUFNQSxRQUFRLEVBQUUsQ0FBQyxNQUFPLEdBQUcsMEJBQTBCO1lBQ2xFUCxRQUFRLENBQ04sQ0FBQyxRQUFTLElBQU1RLFNBQVMsRUFBRSxJQUFLLFVBQVU7WUFDekMsU0FBUyxLQUFPRCxTQUFTLENBQUMsSUFBSywwQkFBMEI7WUFDekQsU0FBUyxLQUFPQSxTQUFTLENBQUMsQ0FBQyxNQUFPLEdBQUcsMEJBQTBCO1lBRWxFLGlEQUFpRDtZQUNqREYsU0FBUyxDQUFDLE9BQVFJLE9BQVNFLE9BQVFKLENBQUFBLE9BQU9FLElBQUcsQ0FBRSxNQUFPO1lBQ3RESCxTQUFTLENBQUMsT0FBUUksT0FBU0UsT0FBUUosQ0FBQUEsT0FBT0UsSUFBRyxDQUFFLE1BQU87WUFFdEQsaUJBQWlCO1lBQ2pCLHFFQUFxRTtZQUNyRWMsS0FBTUYsT0FBT3BCLFFBQVFFLFFBQVFmLEVBQUUsQ0FBQzNCLEVBQUUsQ0FBQyxFQUFFLEdBQUdnQyxDQUFDLENBQUNoQyxFQUFFLENBQUMsRUFBRTtZQUMvQ2lDLFFBQVEsT0FBUU0sUUFBUUUsUUFBUWQsRUFBRSxDQUFDM0IsRUFBRSxDQUFDLEVBQUUsR0FBR2dDLENBQUMsQ0FBQ2hDLEVBQUUsQ0FBQyxFQUFFLEdBQy9DLE1BQU0sZ0JBQWlCLE9BQVE7WUFDbENrQyxRQUFRNEIsT0FBTztZQUVmLGdEQUFnRDtZQUNoREEsS0FBS3hCLFFBQVFNO1lBQ2JULFFBQVEsUUFBU1EsU0FBVSxNQUFNLGdCQUFpQixPQUFRO1lBQzFEUCxRQUFRMEIsT0FBTztZQUVmSCxPQUFPRjtZQUNQRyxPQUFPRjtZQUVQRCxPQUFPRjtZQUNQRyxPQUFPRjtZQUVQRCxPQUFPRjtZQUNQRyxPQUFPRjtZQUVQLCtDQUErQztZQUMvQ1EsS0FBS1YsT0FBT2xCO1lBQ1ptQixPQUFPLE9BQVFwQixRQUFTLE1BQU0sZ0JBQWlCLE9BQVE7WUFDdkRxQixPQUFPUSxPQUFPO1lBRWRYLE9BQU9GO1lBQ1BHLE9BQU9GO1lBRVBELE9BQU9GO1lBQ1BHLE9BQU9GO1lBRVBELE9BQU9GO1lBQ1BHLE9BQU9GO1lBRVAsZ0RBQWdEO1lBQ2hEZ0IsS0FBSzVCLFFBQVFFO1lBQ2JTLE9BQU8sUUFBU1YsUUFBUyxNQUFNLGdCQUFpQixPQUFRO1lBQ3hEVyxPQUFPZ0IsT0FBTztRQUNoQjtRQUVBLDZDQUE2QztRQUM3Q0EsS0FBSy9CLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHZTtRQUNmZixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR2MsT0FBUSxNQUFNLGdCQUFpQixPQUFRO1FBQzVEZCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRytCLE9BQU87UUFFakJBLEtBQUsvQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR2lCO1FBQ2ZqQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR2dCLE9BQVEsTUFBTSxnQkFBaUIsT0FBUTtRQUM1RGhCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHK0IsT0FBTztRQUVqQkEsS0FBSy9CLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHbUI7UUFDZm5CLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHa0IsT0FBUSxNQUFNLGdCQUFpQixPQUFRO1FBQzVEbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcrQixPQUFPO1FBRWpCQSxLQUFLL0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdxQjtRQUNmckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdvQixPQUFRLE1BQU0sZ0JBQWlCLE9BQVE7UUFDNURwQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRytCLE9BQU87UUFFakJBLEtBQUsvQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR3VCO1FBQ2Z2QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR3NCLE9BQVEsTUFBTSxnQkFBaUIsT0FBUTtRQUM1RHRCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHK0IsT0FBTztRQUVqQkEsS0FBSy9CLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHeUI7UUFDZnpCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHd0IsT0FBUSxNQUFNLGdCQUFpQixPQUFRO1FBQzVEeEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcrQixPQUFPO1FBRWpCQSxLQUFLL0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcyQjtRQUNmM0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcwQixPQUFRLE1BQU0sZ0JBQWlCLE9BQVE7UUFDNUQxQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRytCLE9BQU87UUFFakJBLEtBQUsvQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRzZCO1FBQ2Y3QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRzRCLE9BQVEsTUFBTSxnQkFBaUIsT0FBUTtRQUM1RDVCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHK0IsT0FBTztRQUVqQnRELE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhNTEyLmpzP2EyMzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZWN1cmUgSGFzaCBBbGdvcml0aG0gd2l0aCBhIDEwMjQtYml0IGJsb2NrIHNpemUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBpbmNsdWRlczogU0hBLTUxMiwgU0hBLTM4NCwgU0hBLTUxMi8yMjQsIGFuZCBTSEEtNTEyLzI1Ni4gRm9yXG4gKiBTSEEtMjU2IChibG9jayBzaXplIDUxMiBiaXRzKSwgc2VlIHNoYTI1Ni5qcy5cbiAqXG4gKiBTZWUgRklQUyAxODAtNCBmb3IgZGV0YWlscy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgc2hhNTEyID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGE1MTIgPSBmb3JnZS5zaGE1MTIgfHwge307XG5cbi8vIFNIQS01MTJcbmZvcmdlLm1kLnNoYTUxMiA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhNTEyID0gc2hhNTEyO1xuXG4vLyBTSEEtMzg0XG52YXIgc2hhMzg0ID0gZm9yZ2Uuc2hhMzg0ID0gZm9yZ2Uuc2hhNTEyLnNoYTM4NCA9IGZvcmdlLnNoYTUxMi5zaGEzODQgfHwge307XG5zaGEzODQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBzaGE1MTIuY3JlYXRlKCdTSEEtMzg0Jyk7XG59O1xuZm9yZ2UubWQuc2hhMzg0ID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGEzODQgPSBzaGEzODQ7XG5cbi8vIFNIQS01MTIvMjU2XG5mb3JnZS5zaGE1MTIuc2hhMjU2ID0gZm9yZ2Uuc2hhNTEyLnNoYTI1NiB8fCB7XG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYTUxMi5jcmVhdGUoJ1NIQS01MTIvMjU2Jyk7XG4gIH1cbn07XG5mb3JnZS5tZFsnc2hhNTEyLzI1NiddID0gZm9yZ2UubWQuYWxnb3JpdGhtc1snc2hhNTEyLzI1NiddID1cbiAgZm9yZ2Uuc2hhNTEyLnNoYTI1NjtcblxuLy8gU0hBLTUxMi8yMjRcbmZvcmdlLnNoYTUxMi5zaGEyMjQgPSBmb3JnZS5zaGE1MTIuc2hhMjI0IHx8IHtcbiAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2hhNTEyLmNyZWF0ZSgnU0hBLTUxMi8yMjQnKTtcbiAgfVxufTtcbmZvcmdlLm1kWydzaGE1MTIvMjI0J10gPSBmb3JnZS5tZC5hbGdvcml0aG1zWydzaGE1MTIvMjI0J10gPVxuICBmb3JnZS5zaGE1MTIuc2hhMjI0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTSEEtMiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoU0hBLTUxMiwgU0hBLTM4NCwgU0hBLTUxMi8yMjQsXG4gKiAgICAgICAgICBTSEEtNTEyLzI1NikuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhNTEyLmNyZWF0ZSA9IGZ1bmN0aW9uKGFsZ29yaXRobSkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICBpZih0eXBlb2YgYWxnb3JpdGhtID09PSAndW5kZWZpbmVkJykge1xuICAgIGFsZ29yaXRobSA9ICdTSEEtNTEyJztcbiAgfVxuXG4gIGlmKCEoYWxnb3JpdGhtIGluIF9zdGF0ZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNIQS01MTIgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIFNIQS01MTIgc3RhdGUgY29udGFpbnMgZWlnaHQgNjQtYml0IGludGVnZXJzIChlYWNoIGFzIHR3byAzMi1iaXQgaW50cylcbiAgdmFyIF9zdGF0ZSA9IF9zdGF0ZXNbYWxnb3JpdGhtXTtcbiAgdmFyIF9oID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3IgNjQtYml0IHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoODApO1xuICBmb3IodmFyIHdpID0gMDsgd2kgPCA4MDsgKyt3aSkge1xuICAgIF93W3dpXSA9IG5ldyBBcnJheSgyKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBkaWdlc3QgbGVuZ3RoIGJ5IGFsZ29yaXRobSBuYW1lIChkZWZhdWx0KVxuICB2YXIgZGlnZXN0TGVuZ3RoID0gNjQ7XG4gIHN3aXRjaChhbGdvcml0aG0pIHtcbiAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgIGRpZ2VzdExlbmd0aCA9IDQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU0hBLTUxMi8yNTYnOlxuICAgICAgZGlnZXN0TGVuZ3RoID0gMzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdTSEEtNTEyLzIyNCc6XG4gICAgICBkaWdlc3RMZW5ndGggPSAyODtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICAvLyBTSEEtNTEyID0+IHNoYTUxMlxuICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLnJlcGxhY2UoJy0nLCAnJykudG9Mb3dlckNhc2UoKSxcbiAgICBibG9ja0xlbmd0aDogMTI4LFxuICAgIGRpZ2VzdExlbmd0aDogZGlnZXN0TGVuZ3RoLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogMTZcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDEyOCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoMTI4ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX2ggPSBuZXcgQXJyYXkoX3N0YXRlLmxlbmd0aCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IF9zdGF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgX2hbaV0gPSBfc3RhdGVbaV0uc2xpY2UoMCk7XG4gICAgfVxuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX2gsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtNTEyIHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA4OTYgbW9kIDEwMjQuIEluIG90aGVyIHdvcmRzLFxuICAgIHRoZSBkYXRhIHRvIGJlIGRpZ2VzdGVkIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxMDI0IGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDE2IGJ5dGVzICgxMjhcbiAgICBiaXRzKSwgdGhhdCBtZWFucyB0aGF0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGRhdGEgbXVzdCBoYXZlIDExMiBieXRlc1xuICAgICg4OTYgYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA4OTYgbW9kIDEwMjQgYmVjYXVzZVxuICAgIDEwMjQgLSAxMjggPSA4OTYuXG5cbiAgICBJbiBvcmRlciB0byBmaWxsIHVwIHRoZSBtZXNzYWdlIGxlbmd0aCBpdCBtdXN0IGJlIGZpbGxlZCB3aXRoXG4gICAgcGFkZGluZyB0aGF0IGJlZ2lucyB3aXRoIDEgYml0IGZvbGxvd2VkIGJ5IGFsbCAwIGJpdHMuIFBhZGRpbmdcbiAgICBtdXN0ICphbHdheXMqIGJlIHByZXNlbnQsIHNvIGlmIHRoZSBtZXNzYWdlIGxlbmd0aCBpcyBhbHJlYWR5XG4gICAgY29uZ3J1ZW50IHRvIDg5NiBtb2QgMTAyNCwgdGhlbiAxMDI0IHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIGggPSBuZXcgQXJyYXkoX2gubGVuZ3RoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgX2gubGVuZ3RoOyArK2kpIHtcbiAgICAgIGhbaV0gPSBfaFtpXS5zbGljZSgwKTtcbiAgICB9XG4gICAgX3VwZGF0ZShoLCBfdywgZmluYWxCbG9jayk7XG4gICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHZhciBobGVuO1xuICAgIGlmKGFsZ29yaXRobSA9PT0gJ1NIQS01MTInKSB7XG4gICAgICBobGVuID0gaC5sZW5ndGg7XG4gICAgfSBlbHNlIGlmKGFsZ29yaXRobSA9PT0gJ1NIQS0zODQnKSB7XG4gICAgICBobGVuID0gaC5sZW5ndGggLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBobGVuID0gaC5sZW5ndGggLSA0O1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaGxlbjsgKytpKSB7XG4gICAgICBydmFsLnB1dEludDMyKGhbaV1bMF0pO1xuICAgICAgaWYoaSAhPT0gaGxlbiAtIDEgfHwgYWxnb3JpdGhtICE9PSAnU0hBLTUxMi8yMjQnKSB7XG4gICAgICAgIHJ2YWwucHV0SW50MzIoaFtpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIHJldHVybiBtZDtcbn07XG5cbi8vIHNoYS01MTIgcGFkZGluZyBieXRlcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vLyB0YWJsZSBvZiBjb25zdGFudHNcbnZhciBfayA9IG51bGw7XG5cbi8vIGluaXRpYWwgaGFzaCBzdGF0ZXNcbnZhciBfc3RhdGVzID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCAxMjgpO1xuXG4gIC8vIGNyZWF0ZSBLIHRhYmxlIGZvciBTSEEtNTEyXG4gIF9rID0gW1xuICAgIFsweDQyOGEyZjk4LCAweGQ3MjhhZTIyXSwgWzB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2RdLFxuICAgIFsweGI1YzBmYmNmLCAweGVjNGQzYjJmXSwgWzB4ZTliNWRiYTUsIDB4ODE4OWRiYmNdLFxuICAgIFsweDM5NTZjMjViLCAweGYzNDhiNTM4XSwgWzB4NTlmMTExZjEsIDB4YjYwNWQwMTldLFxuICAgIFsweDkyM2Y4MmE0LCAweGFmMTk0ZjliXSwgWzB4YWIxYzVlZDUsIDB4ZGE2ZDgxMThdLFxuICAgIFsweGQ4MDdhYTk4LCAweGEzMDMwMjQyXSwgWzB4MTI4MzViMDEsIDB4NDU3MDZmYmVdLFxuICAgIFsweDI0MzE4NWJlLCAweDRlZTRiMjhjXSwgWzB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTJdLFxuICAgIFsweDcyYmU1ZDc0LCAweGYyN2I4OTZmXSwgWzB4ODBkZWIxZmUsIDB4M2IxNjk2YjFdLFxuICAgIFsweDliZGMwNmE3LCAweDI1YzcxMjM1XSwgWzB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTRdLFxuICAgIFsweGU0OWI2OWMxLCAweDllZjE0YWQyXSwgWzB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTNdLFxuICAgIFsweDBmYzE5ZGM2LCAweDhiOGNkNWI1XSwgWzB4MjQwY2ExY2MsIDB4NzdhYzljNjVdLFxuICAgIFsweDJkZTkyYzZmLCAweDU5MmIwMjc1XSwgWzB4NGE3NDg0YWEsIDB4NmVhNmU0ODNdLFxuICAgIFsweDVjYjBhOWRjLCAweGJkNDFmYmQ0XSwgWzB4NzZmOTg4ZGEsIDB4ODMxMTUzYjVdLFxuICAgIFsweDk4M2U1MTUyLCAweGVlNjZkZmFiXSwgWzB4YTgzMWM2NmQsIDB4MmRiNDMyMTBdLFxuICAgIFsweGIwMDMyN2M4LCAweDk4ZmIyMTNmXSwgWzB4YmY1OTdmYzcsIDB4YmVlZjBlZTRdLFxuICAgIFsweGM2ZTAwYmYzLCAweDNkYTg4ZmMyXSwgWzB4ZDVhNzkxNDcsIDB4OTMwYWE3MjVdLFxuICAgIFsweDA2Y2E2MzUxLCAweGUwMDM4MjZmXSwgWzB4MTQyOTI5NjcsIDB4MGEwZTZlNzBdLFxuICAgIFsweDI3YjcwYTg1LCAweDQ2ZDIyZmZjXSwgWzB4MmUxYjIxMzgsIDB4NWMyNmM5MjZdLFxuICAgIFsweDRkMmM2ZGZjLCAweDVhYzQyYWVkXSwgWzB4NTMzODBkMTMsIDB4OWQ5NWIzZGZdLFxuICAgIFsweDY1MGE3MzU0LCAweDhiYWY2M2RlXSwgWzB4NzY2YTBhYmIsIDB4M2M3N2IyYThdLFxuICAgIFsweDgxYzJjOTJlLCAweDQ3ZWRhZWU2XSwgWzB4OTI3MjJjODUsIDB4MTQ4MjM1M2JdLFxuICAgIFsweGEyYmZlOGExLCAweDRjZjEwMzY0XSwgWzB4YTgxYTY2NGIsIDB4YmM0MjMwMDFdLFxuICAgIFsweGMyNGI4YjcwLCAweGQwZjg5NzkxXSwgWzB4Yzc2YzUxYTMsIDB4MDY1NGJlMzBdLFxuICAgIFsweGQxOTJlODE5LCAweGQ2ZWY1MjE4XSwgWzB4ZDY5OTA2MjQsIDB4NTU2NWE5MTBdLFxuICAgIFsweGY0MGUzNTg1LCAweDU3NzEyMDJhXSwgWzB4MTA2YWEwNzAsIDB4MzJiYmQxYjhdLFxuICAgIFsweDE5YTRjMTE2LCAweGI4ZDJkMGM4XSwgWzB4MWUzNzZjMDgsIDB4NTE0MWFiNTNdLFxuICAgIFsweDI3NDg3NzRjLCAweGRmOGVlYjk5XSwgWzB4MzRiMGJjYjUsIDB4ZTE5YjQ4YThdLFxuICAgIFsweDM5MWMwY2IzLCAweGM1Yzk1YTYzXSwgWzB4NGVkOGFhNGEsIDB4ZTM0MThhY2JdLFxuICAgIFsweDViOWNjYTRmLCAweDc3NjNlMzczXSwgWzB4NjgyZTZmZjMsIDB4ZDZiMmI4YTNdLFxuICAgIFsweDc0OGY4MmVlLCAweDVkZWZiMmZjXSwgWzB4NzhhNTYzNmYsIDB4NDMxNzJmNjBdLFxuICAgIFsweDg0Yzg3ODE0LCAweGExZjBhYjcyXSwgWzB4OGNjNzAyMDgsIDB4MWE2NDM5ZWNdLFxuICAgIFsweDkwYmVmZmZhLCAweDIzNjMxZTI4XSwgWzB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTldLFxuICAgIFsweGJlZjlhM2Y3LCAweGIyYzY3OTE1XSwgWzB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmJdLFxuICAgIFsweGNhMjczZWNlLCAweGVhMjY2MTljXSwgWzB4ZDE4NmI4YzcsIDB4MjFjMGMyMDddLFxuICAgIFsweGVhZGE3ZGQ2LCAweGNkZTBlYjFlXSwgWzB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzhdLFxuICAgIFsweDA2ZjA2N2FhLCAweDcyMTc2ZmJhXSwgWzB4MGE2MzdkYzUsIDB4YTJjODk4YTZdLFxuICAgIFsweDExM2Y5ODA0LCAweGJlZjkwZGFlXSwgWzB4MWI3MTBiMzUsIDB4MTMxYzQ3MWJdLFxuICAgIFsweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0XSwgWzB4MzJjYWFiN2IsIDB4NDBjNzI0OTNdLFxuICAgIFsweDNjOWViZTBhLCAweDE1YzliZWJjXSwgWzB4NDMxZDY3YzQsIDB4OWMxMDBkNGNdLFxuICAgIFsweDRjYzVkNGJlLCAweGNiM2U0MmI2XSwgWzB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmFdLFxuICAgIFsweDVmY2I2ZmFiLCAweDNhZDZmYWVjXSwgWzB4NmM0NDE5OGMsIDB4NGE0NzU4MTddXG4gIF07XG5cbiAgLy8gaW5pdGlhbCBoYXNoIHN0YXRlc1xuICBfc3RhdGVzID0ge307XG4gIF9zdGF0ZXNbJ1NIQS01MTInXSA9IFtcbiAgICBbMHg2YTA5ZTY2NywgMHhmM2JjYzkwOF0sXG4gICAgWzB4YmI2N2FlODUsIDB4ODRjYWE3M2JdLFxuICAgIFsweDNjNmVmMzcyLCAweGZlOTRmODJiXSxcbiAgICBbMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMV0sXG4gICAgWzB4NTEwZTUyN2YsIDB4YWRlNjgyZDFdLFxuICAgIFsweDliMDU2ODhjLCAweDJiM2U2YzFmXSxcbiAgICBbMHgxZjgzZDlhYiwgMHhmYjQxYmQ2Yl0sXG4gICAgWzB4NWJlMGNkMTksIDB4MTM3ZTIxNzldXG4gIF07XG4gIF9zdGF0ZXNbJ1NIQS0zODQnXSA9IFtcbiAgICBbMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOF0sXG4gICAgWzB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDddLFxuICAgIFsweDkxNTkwMTVhLCAweDMwNzBkZDE3XSxcbiAgICBbMHgxNTJmZWNkOCwgMHhmNzBlNTkzOV0sXG4gICAgWzB4NjczMzI2NjcsIDB4ZmZjMDBiMzFdLFxuICAgIFsweDhlYjQ0YTg3LCAweDY4NTgxNTExXSxcbiAgICBbMHhkYjBjMmUwZCwgMHg2NGY5OGZhN10sXG4gICAgWzB4NDdiNTQ4MWQsIDB4YmVmYTRmYTRdXG4gIF07XG4gIF9zdGF0ZXNbJ1NIQS01MTIvMjU2J10gPSBbXG4gICAgWzB4MjIzMTIxOTQsIDB4RkMyQkY3MkNdLFxuICAgIFsweDlGNTU1RkEzLCAweEM4NEM2NEMyXSxcbiAgICBbMHgyMzkzQjg2QiwgMHg2RjUzQjE1MV0sXG4gICAgWzB4OTYzODc3MTksIDB4NTk0MEVBQkRdLFxuICAgIFsweDk2MjgzRUUyLCAweEE4OEVGRkUzXSxcbiAgICBbMHhCRTVFMUUyNSwgMHg1Mzg2Mzk5Ml0sXG4gICAgWzB4MkIwMTk5RkMsIDB4MkM4NUI4QUFdLFxuICAgIFsweDBFQjcyRERDLCAweDgxQzUyQ0EyXVxuICBdO1xuICBfc3RhdGVzWydTSEEtNTEyLzIyNCddID0gW1xuICAgIFsweDhDM0QzN0M4LCAweDE5NTQ0REEyXSxcbiAgICBbMHg3M0UxOTk2NiwgMHg4OURDRDRENl0sXG4gICAgWzB4MURGQUI3QUUsIDB4MzJGRjlDODJdLFxuICAgIFsweDY3OURENTE0LCAweDU4MkY5RkNGXSxcbiAgICBbMHgwRjZEMkI2OSwgMHg3QkQ0NERBOF0sXG4gICAgWzB4NzdFMzZGNzMsIDB4MDRDNDg5NDJdLFxuICAgIFsweDNGOUQ4NUE4LCAweDZBMUQzNkM4XSxcbiAgICBbMHgxMTEyRTZBRCwgMHg5MUQ2OTJBMV1cbiAgXTtcblxuICAvLyBub3cgaW5pdGlhbGl6ZWRcbiAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgU0hBLTUxMiBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTUxMiBzdGF0ZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdyB0aGUgYXJyYXkgdG8gdXNlIHRvIHN0b3JlIHdvcmRzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byB1cGRhdGUgd2l0aC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAvLyBjb25zdW1lIDUxMiBiaXQgKDEyOCBieXRlKSBjaHVua3NcbiAgdmFyIHQxX2hpLCB0MV9sbztcbiAgdmFyIHQyX2hpLCB0Ml9sbztcbiAgdmFyIHMwX2hpLCBzMF9sbztcbiAgdmFyIHMxX2hpLCBzMV9sbztcbiAgdmFyIGNoX2hpLCBjaF9sbztcbiAgdmFyIG1hal9oaSwgbWFqX2xvO1xuICB2YXIgYV9oaSwgYV9sbztcbiAgdmFyIGJfaGksIGJfbG87XG4gIHZhciBjX2hpLCBjX2xvO1xuICB2YXIgZF9oaSwgZF9sbztcbiAgdmFyIGVfaGksIGVfbG87XG4gIHZhciBmX2hpLCBmX2xvO1xuICB2YXIgZ19oaSwgZ19sbztcbiAgdmFyIGhfaGksIGhfbG87XG4gIHZhciBpLCBoaSwgbG8sIHcyLCB3NywgdzE1LCB3MTY7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDEyOCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiA2NC1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgNjQtYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtNTEyXG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXVswXSA9IGJ5dGVzLmdldEludDMyKCkgPj4+IDA7XG4gICAgICB3W2ldWzFdID0gYnl0ZXMuZ2V0SW50MzIoKSA+Pj4gMDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDgwOyArK2kpIHtcbiAgICAgIC8vIGZvciB3b3JkIDIgd29yZHMgYWdvOiBST1RSIDE5KHgpIF4gUk9UUiA2MSh4KSBeIFNIUiA2KHgpXG4gICAgICB3MiA9IHdbaSAtIDJdO1xuICAgICAgaGkgPSB3MlswXTtcbiAgICAgIGxvID0gdzJbMV07XG5cbiAgICAgIC8vIGhpZ2ggYml0c1xuICAgICAgdDFfaGkgPSAoXG4gICAgICAgICgoaGkgPj4+IDE5KSB8IChsbyA8PCAxMykpIF4gLy8gUk9UUiAxOVxuICAgICAgICAoKGxvID4+PiAyOSkgfCAoaGkgPDwgMykpIF4gLy8gUk9UUiA2MS8oc3dhcCArIFJPVFIgMjkpXG4gICAgICAgIChoaSA+Pj4gNikpID4+PiAwOyAvLyBTSFIgNlxuICAgICAgLy8gbG93IGJpdHNcbiAgICAgIHQxX2xvID0gKFxuICAgICAgICAoKGhpIDw8IDEzKSB8IChsbyA+Pj4gMTkpKSBeIC8vIFJPVFIgMTlcbiAgICAgICAgKChsbyA8PCAzKSB8IChoaSA+Pj4gMjkpKSBeIC8vIFJPVFIgNjEvKHN3YXAgKyBST1RSIDI5KVxuICAgICAgICAoKGhpIDw8IDI2KSB8IChsbyA+Pj4gNikpKSA+Pj4gMDsgLy8gU0hSIDZcblxuICAgICAgLy8gZm9yIHdvcmQgMTUgd29yZHMgYWdvOiBST1RSIDEoeCkgXiBST1RSIDgoeCkgXiBTSFIgNyh4KVxuICAgICAgdzE1ID0gd1tpIC0gMTVdO1xuICAgICAgaGkgPSB3MTVbMF07XG4gICAgICBsbyA9IHcxNVsxXTtcblxuICAgICAgLy8gaGlnaCBiaXRzXG4gICAgICB0Ml9oaSA9IChcbiAgICAgICAgKChoaSA+Pj4gMSkgfCAobG8gPDwgMzEpKSBeIC8vIFJPVFIgMVxuICAgICAgICAoKGhpID4+PiA4KSB8IChsbyA8PCAyNCkpIF4gLy8gUk9UUiA4XG4gICAgICAgIChoaSA+Pj4gNykpID4+PiAwOyAvLyBTSFIgN1xuICAgICAgLy8gbG93IGJpdHNcbiAgICAgIHQyX2xvID0gKFxuICAgICAgICAoKGhpIDw8IDMxKSB8IChsbyA+Pj4gMSkpIF4gLy8gUk9UUiAxXG4gICAgICAgICgoaGkgPDwgMjQpIHwgKGxvID4+PiA4KSkgXiAvLyBST1RSIDhcbiAgICAgICAgKChoaSA8PCAyNSkgfCAobG8gPj4+IDcpKSkgPj4+IDA7IC8vIFNIUiA3XG5cbiAgICAgIC8vIHN1bSh0MSwgd29yZCA3IGFnbywgdDIsIHdvcmQgMTYgYWdvKSBtb2R1bG8gMl42NCAoY2FycnkgbG8gb3ZlcmZsb3cpXG4gICAgICB3NyA9IHdbaSAtIDddO1xuICAgICAgdzE2ID0gd1tpIC0gMTZdO1xuICAgICAgbG8gPSAodDFfbG8gKyB3N1sxXSArIHQyX2xvICsgdzE2WzFdKTtcbiAgICAgIHdbaV1bMF0gPSAodDFfaGkgKyB3N1swXSArIHQyX2hpICsgdzE2WzBdICtcbiAgICAgICAgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgICAgd1tpXVsxXSA9IGxvID4+PiAwO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgaGFzaCB2YWx1ZSBmb3IgdGhpcyBjaHVua1xuICAgIGFfaGkgPSBzWzBdWzBdO1xuICAgIGFfbG8gPSBzWzBdWzFdO1xuICAgIGJfaGkgPSBzWzFdWzBdO1xuICAgIGJfbG8gPSBzWzFdWzFdO1xuICAgIGNfaGkgPSBzWzJdWzBdO1xuICAgIGNfbG8gPSBzWzJdWzFdO1xuICAgIGRfaGkgPSBzWzNdWzBdO1xuICAgIGRfbG8gPSBzWzNdWzFdO1xuICAgIGVfaGkgPSBzWzRdWzBdO1xuICAgIGVfbG8gPSBzWzRdWzFdO1xuICAgIGZfaGkgPSBzWzVdWzBdO1xuICAgIGZfbG8gPSBzWzVdWzFdO1xuICAgIGdfaGkgPSBzWzZdWzBdO1xuICAgIGdfbG8gPSBzWzZdWzFdO1xuICAgIGhfaGkgPSBzWzddWzBdO1xuICAgIGhfbG8gPSBzWzddWzFdO1xuXG4gICAgLy8gcm91bmQgZnVuY3Rpb25cbiAgICBmb3IoaSA9IDA7IGkgPCA4MDsgKytpKSB7XG4gICAgICAvLyBTdW0xKGUpID0gUk9UUiAxNChlKSBeIFJPVFIgMTgoZSkgXiBST1RSIDQxKGUpXG4gICAgICBzMV9oaSA9IChcbiAgICAgICAgKChlX2hpID4+PiAxNCkgfCAoZV9sbyA8PCAxOCkpIF4gLy8gUk9UUiAxNFxuICAgICAgICAoKGVfaGkgPj4+IDE4KSB8IChlX2xvIDw8IDE0KSkgXiAvLyBST1RSIDE4XG4gICAgICAgICgoZV9sbyA+Pj4gOSkgfCAoZV9oaSA8PCAyMykpKSA+Pj4gMDsgLy8gUk9UUiA0MS8oc3dhcCArIFJPVFIgOSlcbiAgICAgIHMxX2xvID0gKFxuICAgICAgICAoKGVfaGkgPDwgMTgpIHwgKGVfbG8gPj4+IDE0KSkgXiAvLyBST1RSIDE0XG4gICAgICAgICgoZV9oaSA8PCAxNCkgfCAoZV9sbyA+Pj4gMTgpKSBeIC8vIFJPVFIgMThcbiAgICAgICAgKChlX2xvIDw8IDIzKSB8IChlX2hpID4+PiA5KSkpID4+PiAwOyAvLyBST1RSIDQxLyhzd2FwICsgUk9UUiA5KVxuXG4gICAgICAvLyBDaChlLCBmLCBnKSAob3B0aW1pemVkIHRoZSBzYW1lIHdheSBhcyBTSEEtMSlcbiAgICAgIGNoX2hpID0gKGdfaGkgXiAoZV9oaSAmIChmX2hpIF4gZ19oaSkpKSA+Pj4gMDtcbiAgICAgIGNoX2xvID0gKGdfbG8gXiAoZV9sbyAmIChmX2xvIF4gZ19sbykpKSA+Pj4gMDtcblxuICAgICAgLy8gU3VtMChhKSA9IFJPVFIgMjgoYSkgXiBST1RSIDM0KGEpIF4gUk9UUiAzOShhKVxuICAgICAgczBfaGkgPSAoXG4gICAgICAgICgoYV9oaSA+Pj4gMjgpIHwgKGFfbG8gPDwgNCkpIF4gLy8gUk9UUiAyOFxuICAgICAgICAoKGFfbG8gPj4+IDIpIHwgKGFfaGkgPDwgMzApKSBeIC8vIFJPVFIgMzQvKHN3YXAgKyBST1RSIDIpXG4gICAgICAgICgoYV9sbyA+Pj4gNykgfCAoYV9oaSA8PCAyNSkpKSA+Pj4gMDsgLy8gUk9UUiAzOS8oc3dhcCArIFJPVFIgNylcbiAgICAgIHMwX2xvID0gKFxuICAgICAgICAoKGFfaGkgPDwgNCkgfCAoYV9sbyA+Pj4gMjgpKSBeIC8vIFJPVFIgMjhcbiAgICAgICAgKChhX2xvIDw8IDMwKSB8IChhX2hpID4+PiAyKSkgXiAvLyBST1RSIDM0Lyhzd2FwICsgUk9UUiAyKVxuICAgICAgICAoKGFfbG8gPDwgMjUpIHwgKGFfaGkgPj4+IDcpKSkgPj4+IDA7IC8vIFJPVFIgMzkvKHN3YXAgKyBST1RSIDcpXG5cbiAgICAgIC8vIE1haihhLCBiLCBjKSAob3B0aW1pemVkIHRoZSBzYW1lIHdheSBhcyBTSEEtMSlcbiAgICAgIG1hal9oaSA9ICgoYV9oaSAmIGJfaGkpIHwgKGNfaGkgJiAoYV9oaSBeIGJfaGkpKSkgPj4+IDA7XG4gICAgICBtYWpfbG8gPSAoKGFfbG8gJiBiX2xvKSB8IChjX2xvICYgKGFfbG8gXiBiX2xvKSkpID4+PiAwO1xuXG4gICAgICAvLyBtYWluIGFsZ29yaXRobVxuICAgICAgLy8gdDEgPSAoaCArIHMxICsgY2ggKyBfa1tpXSArIF93W2ldKSBtb2R1bG8gMl42NCAoY2FycnkgbG8gb3ZlcmZsb3cpXG4gICAgICBsbyA9IChoX2xvICsgczFfbG8gKyBjaF9sbyArIF9rW2ldWzFdICsgd1tpXVsxXSk7XG4gICAgICB0MV9oaSA9IChoX2hpICsgczFfaGkgKyBjaF9oaSArIF9rW2ldWzBdICsgd1tpXVswXSArXG4gICAgICAgICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIHQxX2xvID0gbG8gPj4+IDA7XG5cbiAgICAgIC8vIHQyID0gczAgKyBtYWogbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgbG8gPSBzMF9sbyArIG1hal9sbztcbiAgICAgIHQyX2hpID0gKHMwX2hpICsgbWFqX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgICAgdDJfbG8gPSBsbyA+Pj4gMDtcblxuICAgICAgaF9oaSA9IGdfaGk7XG4gICAgICBoX2xvID0gZ19sbztcblxuICAgICAgZ19oaSA9IGZfaGk7XG4gICAgICBnX2xvID0gZl9sbztcblxuICAgICAgZl9oaSA9IGVfaGk7XG4gICAgICBmX2xvID0gZV9sbztcblxuICAgICAgLy8gZSA9IChkICsgdDEpIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIGxvID0gZF9sbyArIHQxX2xvO1xuICAgICAgZV9oaSA9IChkX2hpICsgdDFfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgICBlX2xvID0gbG8gPj4+IDA7XG5cbiAgICAgIGRfaGkgPSBjX2hpO1xuICAgICAgZF9sbyA9IGNfbG87XG5cbiAgICAgIGNfaGkgPSBiX2hpO1xuICAgICAgY19sbyA9IGJfbG87XG5cbiAgICAgIGJfaGkgPSBhX2hpO1xuICAgICAgYl9sbyA9IGFfbG87XG5cbiAgICAgIC8vIGEgPSAodDEgKyB0MikgbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgbG8gPSB0MV9sbyArIHQyX2xvO1xuICAgICAgYV9oaSA9ICh0MV9oaSArIHQyX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgICAgYV9sbyA9IGxvID4+PiAwO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlIChhZGRpdGlvbmFsIG1vZHVsbyAyXjY0KVxuICAgIGxvID0gc1swXVsxXSArIGFfbG87XG4gICAgc1swXVswXSA9IChzWzBdWzBdICsgYV9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzBdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbMV1bMV0gKyBiX2xvO1xuICAgIHNbMV1bMF0gPSAoc1sxXVswXSArIGJfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1sxXVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzJdWzFdICsgY19sbztcbiAgICBzWzJdWzBdID0gKHNbMl1bMF0gKyBjX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbMl1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1szXVsxXSArIGRfbG87XG4gICAgc1szXVswXSA9IChzWzNdWzBdICsgZF9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzNdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbNF1bMV0gKyBlX2xvO1xuICAgIHNbNF1bMF0gPSAoc1s0XVswXSArIGVfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1s0XVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzVdWzFdICsgZl9sbztcbiAgICBzWzVdWzBdID0gKHNbNV1bMF0gKyBmX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbNV1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1s2XVsxXSArIGdfbG87XG4gICAgc1s2XVswXSA9IChzWzZdWzBdICsgZ19oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzZdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbN11bMV0gKyBoX2xvO1xuICAgIHNbN11bMF0gPSAoc1s3XVswXSArIGhfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1s3XVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbGVuIC09IDEyODtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInNoYTUxMiIsIm1vZHVsZSIsImV4cG9ydHMiLCJtZCIsImFsZ29yaXRobXMiLCJzaGEzODQiLCJjcmVhdGUiLCJzaGEyNTYiLCJzaGEyMjQiLCJhbGdvcml0aG0iLCJfaW5pdGlhbGl6ZWQiLCJfaW5pdCIsIl9zdGF0ZXMiLCJFcnJvciIsIl9zdGF0ZSIsIl9oIiwiX2lucHV0IiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsIl93IiwiQXJyYXkiLCJ3aSIsImRpZ2VzdExlbmd0aCIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImJsb2NrTGVuZ3RoIiwibWVzc2FnZUxlbmd0aCIsImZ1bGxNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZUxlbmd0aFNpemUiLCJzdGFydCIsIm1lc3NhZ2VMZW5ndGgxMjgiLCJpbnQzMnMiLCJpIiwicHVzaCIsImxlbmd0aCIsInNsaWNlIiwidXBkYXRlIiwibXNnIiwiZW5jb2RpbmciLCJlbmNvZGVVdGY4IiwibGVuIiwicHV0Qnl0ZXMiLCJfdXBkYXRlIiwicmVhZCIsImNvbXBhY3QiLCJkaWdlc3QiLCJmaW5hbEJsb2NrIiwiYnl0ZXMiLCJyZW1haW5pbmciLCJvdmVyZmxvdyIsIl9wYWRkaW5nIiwic3Vic3RyIiwibmV4dCIsImNhcnJ5IiwiYml0cyIsInB1dEludDMyIiwiaCIsInJ2YWwiLCJobGVuIiwiX2siLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJmaWxsU3RyaW5nIiwicyIsInciLCJ0MV9oaSIsInQxX2xvIiwidDJfaGkiLCJ0Ml9sbyIsInMwX2hpIiwiczBfbG8iLCJzMV9oaSIsInMxX2xvIiwiY2hfaGkiLCJjaF9sbyIsIm1hal9oaSIsIm1hal9sbyIsImFfaGkiLCJhX2xvIiwiYl9oaSIsImJfbG8iLCJjX2hpIiwiY19sbyIsImRfaGkiLCJkX2xvIiwiZV9oaSIsImVfbG8iLCJmX2hpIiwiZl9sbyIsImdfaGkiLCJnX2xvIiwiaF9oaSIsImhfbG8iLCJoaSIsImxvIiwidzIiLCJ3NyIsIncxNSIsIncxNiIsImdldEludDMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-forge/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Utility functions for web applications.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2018 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\nvar baseN = __webpack_require__(/*! ./baseN */ \"(ssr)/./node_modules/node-forge/lib/baseN.js\");\n/* Utilities API */ var util = module.exports = forge.util = forge.util || {};\n// define setImmediate and nextTick\n(function() {\n    // use native nextTick (unless we're in webpack)\n    // webpack (or better node-libs-browser polyfill) sets process.browser.\n    // this way we can detect webpack properly\n    if (typeof process !== \"undefined\" && process.nextTick && !false) {\n        util.nextTick = process.nextTick;\n        if (typeof setImmediate === \"function\") {\n            util.setImmediate = setImmediate;\n        } else {\n            // polyfill setImmediate with nextTick, older versions of node\n            // (those w/o setImmediate) won't totally starve IO\n            util.setImmediate = util.nextTick;\n        }\n        return;\n    }\n    // polyfill nextTick with native setImmediate\n    if (typeof setImmediate === \"function\") {\n        util.setImmediate = function() {\n            return setImmediate.apply(undefined, arguments);\n        };\n        util.nextTick = function(callback) {\n            return setImmediate(callback);\n        };\n        return;\n    }\n    /* Note: A polyfill upgrade pattern is used here to allow combining\n  polyfills. For example, MutationObserver is fast, but blocks UI updates,\n  so it needs to allow UI updates periodically, so it falls back on\n  postMessage or setTimeout. */ // polyfill with setTimeout\n    util.setImmediate = function(callback) {\n        setTimeout(callback, 0);\n    };\n    // upgrade polyfill to use postMessage\n    if (false) { var callbacks, msg; }\n    // upgrade polyfill to use MutationObserver\n    if (typeof MutationObserver !== \"undefined\") {\n        // polyfill with MutationObserver\n        var now = Date.now();\n        var attr = true;\n        var div = document.createElement(\"div\");\n        var callbacks = [];\n        new MutationObserver(function() {\n            var copy = callbacks.slice();\n            callbacks.length = 0;\n            copy.forEach(function(callback) {\n                callback();\n            });\n        }).observe(div, {\n            attributes: true\n        });\n        var oldSetImmediate = util.setImmediate;\n        util.setImmediate = function(callback) {\n            if (Date.now() - now > 15) {\n                now = Date.now();\n                oldSetImmediate(callback);\n            } else {\n                callbacks.push(callback);\n                // only trigger observer when it hasn't been triggered in\n                // the current turn of the event loop\n                if (callbacks.length === 1) {\n                    div.setAttribute(\"a\", attr = !attr);\n                }\n            }\n        };\n    }\n    util.nextTick = util.setImmediate;\n})();\n// check if running under Node.js\nutil.isNodejs = typeof process !== \"undefined\" && process.versions && process.versions.node;\n// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while\n// it will point to `window` in the main thread.\n// To remain compatible with older browsers, we fall back to 'window' if 'self'\n// is not available.\nutil.globalScope = function() {\n    if (util.isNodejs) {\n        return global;\n    }\n    return typeof self === \"undefined\" ? window : self;\n}();\n// define isArray\nutil.isArray = Array.isArray || function(x) {\n    return Object.prototype.toString.call(x) === \"[object Array]\";\n};\n// define isArrayBuffer\nutil.isArrayBuffer = function(x) {\n    return typeof ArrayBuffer !== \"undefined\" && x instanceof ArrayBuffer;\n};\n// define isArrayBufferView\nutil.isArrayBufferView = function(x) {\n    return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\n};\n/**\n * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\n * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\n * design only allow for byte operations of a limited size.\n *\n * @param n number of bits.\n *\n * Throw Error if n invalid.\n */ function _checkBitsParam(n) {\n    if (!(n === 8 || n === 16 || n === 24 || n === 32)) {\n        throw new Error(\"Only 8, 16, 24, or 32 bits supported: \" + n);\n    }\n}\n// TODO: set ByteBuffer to best available backing\nutil.ByteBuffer = ByteStringBuffer;\n/** Buffer w/BinaryString backing */ /**\n * Constructor for a binary string backed byte buffer.\n *\n * @param [b] the bytes to wrap (either encoded as string, one byte per\n *          character, or as an ArrayBuffer or Typed Array).\n */ function ByteStringBuffer(b) {\n    // TODO: update to match DataBuffer API\n    // the data in this buffer\n    this.data = \"\";\n    // the pointer for reading from this buffer\n    this.read = 0;\n    if (typeof b === \"string\") {\n        this.data = b;\n    } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\n        if (typeof Buffer !== \"undefined\" && b instanceof Buffer) {\n            this.data = b.toString(\"binary\");\n        } else {\n            // convert native buffer to forge buffer\n            // FIXME: support native buffers internally instead\n            var arr = new Uint8Array(b);\n            try {\n                this.data = String.fromCharCode.apply(null, arr);\n            } catch (e) {\n                for(var i = 0; i < arr.length; ++i){\n                    this.putByte(arr[i]);\n                }\n            }\n        }\n    } else if (b instanceof ByteStringBuffer || typeof b === \"object\" && typeof b.data === \"string\" && typeof b.read === \"number\") {\n        // copy existing buffer\n        this.data = b.data;\n        this.read = b.read;\n    }\n    // used for v8 optimization\n    this._constructedStringLength = 0;\n}\nutil.ByteStringBuffer = ByteStringBuffer;\n/* Note: This is an optimization for V8-based browsers. When V8 concatenates\n  a string, the strings are only joined logically using a \"cons string\" or\n  \"constructed/concatenated string\". These containers keep references to one\n  another and can result in very large memory usage. For example, if a 2MB\n  string is constructed by concatenating 4 bytes together at a time, the\n  memory usage will be ~44MB; so ~22x increase. The strings are only joined\n  together when an operation requiring their joining takes place, such as\n  substr(). This function is called when adding data to this buffer to ensure\n  these types of strings are periodically joined to reduce the memory\n  footprint. */ var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\nutil.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\n    this._constructedStringLength += x;\n    if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\n        // this substr() should cause the constructed string to join\n        this.data.substr(0, 1);\n        this._constructedStringLength = 0;\n    }\n};\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */ util.ByteStringBuffer.prototype.length = function() {\n    return this.data.length - this.read;\n};\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */ util.ByteStringBuffer.prototype.isEmpty = function() {\n    return this.length() <= 0;\n};\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putByte = function(b) {\n    return this.putBytes(String.fromCharCode(b));\n};\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\n    b = String.fromCharCode(b);\n    var d = this.data;\n    while(n > 0){\n        if (n & 1) {\n            d += b;\n        }\n        n >>>= 1;\n        if (n > 0) {\n            b += b;\n        }\n    }\n    this.data = d;\n    this._optimizeConstructedString(n);\n    return this;\n};\n/**\n * Puts bytes in this buffer.\n *\n * @param bytes the bytes (as a binary encoded string) to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putBytes = function(bytes) {\n    this.data += bytes;\n    this._optimizeConstructedString(bytes.length);\n    return this;\n};\n/**\n * Puts a UTF-16 encoded string into this buffer.\n *\n * @param str the string to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putString = function(str) {\n    return this.putBytes(util.encodeUtf8(str));\n};\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt16 = function(i) {\n    return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));\n};\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt24 = function(i) {\n    return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));\n};\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt32 = function(i) {\n    return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));\n};\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt16Le = function(i) {\n    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));\n};\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt24Le = function(i) {\n    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));\n};\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt32Le = function(i) {\n    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));\n};\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt = function(i, n) {\n    _checkBitsParam(n);\n    var bytes = \"\";\n    do {\n        n -= 8;\n        bytes += String.fromCharCode(i >> n & 0xFF);\n    }while (n > 0);\n    return this.putBytes(bytes);\n};\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\n    // putInt checks n\n    if (i < 0) {\n        i += 2 << n - 1;\n    }\n    return this.putInt(i, n);\n};\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putBuffer = function(buffer) {\n    return this.putBytes(buffer.getBytes());\n};\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */ util.ByteStringBuffer.prototype.getByte = function() {\n    return this.data.charCodeAt(this.read++);\n};\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.ByteStringBuffer.prototype.getInt16 = function() {\n    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.ByteStringBuffer.prototype.getInt24 = function() {\n    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.ByteStringBuffer.prototype.getInt32 = function() {\n    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.ByteStringBuffer.prototype.getInt16Le = function() {\n    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.ByteStringBuffer.prototype.getInt24Le = function() {\n    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.ByteStringBuffer.prototype.getInt32Le = function() {\n    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by ceil(n/8).\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.ByteStringBuffer.prototype.getInt = function(n) {\n    _checkBitsParam(n);\n    var rval = 0;\n    do {\n        // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n        rval = (rval << 8) + this.data.charCodeAt(this.read++);\n        n -= 8;\n    }while (n > 0);\n    return rval;\n};\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.ByteStringBuffer.prototype.getSignedInt = function(n) {\n    // getInt checks n\n    var x = this.getInt(n);\n    var max = 2 << n - 2;\n    if (x >= max) {\n        x -= max << 1;\n    }\n    return x;\n};\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer. Note that the resulting string is binary encoded (in node.js this\n * encoding is referred to as `binary`, it is *not* `utf8`).\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */ util.ByteStringBuffer.prototype.getBytes = function(count) {\n    var rval;\n    if (count) {\n        // read count bytes\n        count = Math.min(this.length(), count);\n        rval = this.data.slice(this.read, this.read + count);\n        this.read += count;\n    } else if (count === 0) {\n        rval = \"\";\n    } else {\n        // read all bytes, optimize to only copy when needed\n        rval = this.read === 0 ? this.data : this.data.slice(this.read);\n        this.clear();\n    }\n    return rval;\n};\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */ util.ByteStringBuffer.prototype.bytes = function(count) {\n    return typeof count === \"undefined\" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n};\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */ util.ByteStringBuffer.prototype.at = function(i) {\n    return this.data.charCodeAt(this.read + i);\n};\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.setAt = function(i, b) {\n    this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);\n    return this;\n};\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */ util.ByteStringBuffer.prototype.last = function() {\n    return this.data.charCodeAt(this.data.length - 1);\n};\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */ util.ByteStringBuffer.prototype.copy = function() {\n    var c = util.createBuffer(this.data);\n    c.read = this.read;\n    return c;\n};\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.compact = function() {\n    if (this.read > 0) {\n        this.data = this.data.slice(this.read);\n        this.read = 0;\n    }\n    return this;\n};\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.clear = function() {\n    this.data = \"\";\n    this.read = 0;\n    return this;\n};\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.truncate = function(count) {\n    var len = Math.max(0, this.length() - count);\n    this.data = this.data.substr(this.read, len);\n    this.read = 0;\n    return this;\n};\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */ util.ByteStringBuffer.prototype.toHex = function() {\n    var rval = \"\";\n    for(var i = this.read; i < this.data.length; ++i){\n        var b = this.data.charCodeAt(i);\n        if (b < 16) {\n            rval += \"0\";\n        }\n        rval += b.toString(16);\n    }\n    return rval;\n};\n/**\n * Converts this buffer to a UTF-16 string (standard JavaScript string).\n *\n * @return a UTF-16 string.\n */ util.ByteStringBuffer.prototype.toString = function() {\n    return util.decodeUtf8(this.bytes());\n};\n/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**\n * FIXME: Experimental. Do not use yet.\n *\n * Constructor for an ArrayBuffer-backed byte buffer.\n *\n * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\n * TypedArray.\n *\n * If a string is given, its encoding should be provided as an option,\n * otherwise it will default to 'binary'. A 'binary' string is encoded such\n * that each character is one byte in length and size.\n *\n * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\n * *directly* without any copying. Note that, if a write to the buffer requires\n * more space, the buffer will allocate a new backing ArrayBuffer to\n * accommodate. The starting read and write offsets for the buffer may be\n * given as options.\n *\n * @param [b] the initial bytes for this buffer.\n * @param options the options to use:\n *          [readOffset] the starting read offset to use (default: 0).\n *          [writeOffset] the starting write offset to use (default: the\n *            length of the first parameter).\n *          [growSize] the minimum amount, in bytes, to grow the buffer by to\n *            accommodate writes (default: 1024).\n *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\n *            first parameter, if it is a string (default: 'binary').\n */ function DataBuffer(b, options) {\n    // default options\n    options = options || {};\n    // pointers for read from/write to buffer\n    this.read = options.readOffset || 0;\n    this.growSize = options.growSize || 1024;\n    var isArrayBuffer = util.isArrayBuffer(b);\n    var isArrayBufferView = util.isArrayBufferView(b);\n    if (isArrayBuffer || isArrayBufferView) {\n        // use ArrayBuffer directly\n        if (isArrayBuffer) {\n            this.data = new DataView(b);\n        } else {\n            // TODO: adjust read/write offset based on the type of view\n            // or specify that this must be done in the options ... that the\n            // offsets are byte-based\n            this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\n        }\n        this.write = \"writeOffset\" in options ? options.writeOffset : this.data.byteLength;\n        return;\n    }\n    // initialize to empty array buffer and add any given bytes using putBytes\n    this.data = new DataView(new ArrayBuffer(0));\n    this.write = 0;\n    if (b !== null && b !== undefined) {\n        this.putBytes(b);\n    }\n    if (\"writeOffset\" in options) {\n        this.write = options.writeOffset;\n    }\n}\nutil.DataBuffer = DataBuffer;\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */ util.DataBuffer.prototype.length = function() {\n    return this.write - this.read;\n};\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */ util.DataBuffer.prototype.isEmpty = function() {\n    return this.length() <= 0;\n};\n/**\n * Ensures this buffer has enough empty space to accommodate the given number\n * of bytes. An optional parameter may be given that indicates a minimum\n * amount to grow the buffer if necessary. If the parameter is not given,\n * the buffer will be grown by some previously-specified default amount\n * or heuristic.\n *\n * @param amount the number of bytes to accommodate.\n * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\n *          necessary.\n */ util.DataBuffer.prototype.accommodate = function(amount, growSize) {\n    if (this.length() >= amount) {\n        return this;\n    }\n    growSize = Math.max(growSize || this.growSize, amount);\n    // grow buffer\n    var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);\n    var dst = new Uint8Array(this.length() + growSize);\n    dst.set(src);\n    this.data = new DataView(dst.buffer);\n    return this;\n};\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putByte = function(b) {\n    this.accommodate(1);\n    this.data.setUint8(this.write++, b);\n    return this;\n};\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.fillWithByte = function(b, n) {\n    this.accommodate(n);\n    for(var i = 0; i < n; ++i){\n        this.data.setUint8(b);\n    }\n    return this;\n};\n/**\n * Puts bytes in this buffer. The bytes may be given as a string, an\n * ArrayBuffer, a DataView, or a TypedArray.\n *\n * @param bytes the bytes to put.\n * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\n *          'utf16', 'hex'), if it is a string (default: 'binary').\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putBytes = function(bytes, encoding) {\n    if (util.isArrayBufferView(bytes)) {\n        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        var len = src.byteLength - src.byteOffset;\n        this.accommodate(len);\n        var dst = new Uint8Array(this.data.buffer, this.write);\n        dst.set(src);\n        this.write += len;\n        return this;\n    }\n    if (util.isArrayBuffer(bytes)) {\n        var src = new Uint8Array(bytes);\n        this.accommodate(src.byteLength);\n        var dst = new Uint8Array(this.data.buffer);\n        dst.set(src, this.write);\n        this.write += src.byteLength;\n        return this;\n    }\n    // bytes is a util.DataBuffer or equivalent\n    if (bytes instanceof util.DataBuffer || typeof bytes === \"object\" && typeof bytes.read === \"number\" && typeof bytes.write === \"number\" && util.isArrayBufferView(bytes.data)) {\n        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\n        this.accommodate(src.byteLength);\n        var dst = new Uint8Array(bytes.data.byteLength, this.write);\n        dst.set(src);\n        this.write += src.byteLength;\n        return this;\n    }\n    if (bytes instanceof util.ByteStringBuffer) {\n        // copy binary string and process as the same as a string parameter below\n        bytes = bytes.data;\n        encoding = \"binary\";\n    }\n    // string conversion\n    encoding = encoding || \"binary\";\n    if (typeof bytes === \"string\") {\n        var view;\n        // decode from string\n        if (encoding === \"hex\") {\n            this.accommodate(Math.ceil(bytes.length / 2));\n            view = new Uint8Array(this.data.buffer, this.write);\n            this.write += util.binary.hex.decode(bytes, view, this.write);\n            return this;\n        }\n        if (encoding === \"base64\") {\n            this.accommodate(Math.ceil(bytes.length / 4) * 3);\n            view = new Uint8Array(this.data.buffer, this.write);\n            this.write += util.binary.base64.decode(bytes, view, this.write);\n            return this;\n        }\n        // encode text as UTF-8 bytes\n        if (encoding === \"utf8\") {\n            // encode as UTF-8 then decode string as raw binary\n            bytes = util.encodeUtf8(bytes);\n            encoding = \"binary\";\n        }\n        // decode string as raw binary\n        if (encoding === \"binary\" || encoding === \"raw\") {\n            // one byte per character\n            this.accommodate(bytes.length);\n            view = new Uint8Array(this.data.buffer, this.write);\n            this.write += util.binary.raw.decode(view);\n            return this;\n        }\n        // encode text as UTF-16 bytes\n        if (encoding === \"utf16\") {\n            // two bytes per character\n            this.accommodate(bytes.length * 2);\n            view = new Uint16Array(this.data.buffer, this.write);\n            this.write += util.text.utf16.encode(view);\n            return this;\n        }\n        throw new Error(\"Invalid encoding: \" + encoding);\n    }\n    throw Error(\"Invalid parameter: \" + bytes);\n};\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putBuffer = function(buffer) {\n    this.putBytes(buffer);\n    buffer.clear();\n    return this;\n};\n/**\n * Puts a string into this buffer.\n *\n * @param str the string to put.\n * @param [encoding] the encoding for the string (default: 'utf16').\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putString = function(str) {\n    return this.putBytes(str, \"utf16\");\n};\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt16 = function(i) {\n    this.accommodate(2);\n    this.data.setInt16(this.write, i);\n    this.write += 2;\n    return this;\n};\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt24 = function(i) {\n    this.accommodate(3);\n    this.data.setInt16(this.write, i >> 8 & 0xFFFF);\n    this.data.setInt8(this.write, i >> 16 & 0xFF);\n    this.write += 3;\n    return this;\n};\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt32 = function(i) {\n    this.accommodate(4);\n    this.data.setInt32(this.write, i);\n    this.write += 4;\n    return this;\n};\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt16Le = function(i) {\n    this.accommodate(2);\n    this.data.setInt16(this.write, i, true);\n    this.write += 2;\n    return this;\n};\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt24Le = function(i) {\n    this.accommodate(3);\n    this.data.setInt8(this.write, i >> 16 & 0xFF);\n    this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\n    this.write += 3;\n    return this;\n};\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt32Le = function(i) {\n    this.accommodate(4);\n    this.data.setInt32(this.write, i, true);\n    this.write += 4;\n    return this;\n};\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt = function(i, n) {\n    _checkBitsParam(n);\n    this.accommodate(n / 8);\n    do {\n        n -= 8;\n        this.data.setInt8(this.write++, i >> n & 0xFF);\n    }while (n > 0);\n    return this;\n};\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putSignedInt = function(i, n) {\n    _checkBitsParam(n);\n    this.accommodate(n / 8);\n    if (i < 0) {\n        i += 2 << n - 1;\n    }\n    return this.putInt(i, n);\n};\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */ util.DataBuffer.prototype.getByte = function() {\n    return this.data.getInt8(this.read++);\n};\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.DataBuffer.prototype.getInt16 = function() {\n    var rval = this.data.getInt16(this.read);\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.DataBuffer.prototype.getInt24 = function() {\n    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.DataBuffer.prototype.getInt32 = function() {\n    var rval = this.data.getInt32(this.read);\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.DataBuffer.prototype.getInt16Le = function() {\n    var rval = this.data.getInt16(this.read, true);\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.DataBuffer.prototype.getInt24Le = function() {\n    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.DataBuffer.prototype.getInt32Le = function() {\n    var rval = this.data.getInt32(this.read, true);\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.DataBuffer.prototype.getInt = function(n) {\n    _checkBitsParam(n);\n    var rval = 0;\n    do {\n        // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n        rval = (rval << 8) + this.data.getInt8(this.read++);\n        n -= 8;\n    }while (n > 0);\n    return rval;\n};\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.DataBuffer.prototype.getSignedInt = function(n) {\n    // getInt checks n\n    var x = this.getInt(n);\n    var max = 2 << n - 2;\n    if (x >= max) {\n        x -= max << 1;\n    }\n    return x;\n};\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer.\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */ util.DataBuffer.prototype.getBytes = function(count) {\n    // TODO: deprecate this method, it is poorly named and\n    // this.toString('binary') replaces it\n    // add a toTypedArray()/toArrayBuffer() function\n    var rval;\n    if (count) {\n        // read count bytes\n        count = Math.min(this.length(), count);\n        rval = this.data.slice(this.read, this.read + count);\n        this.read += count;\n    } else if (count === 0) {\n        rval = \"\";\n    } else {\n        // read all bytes, optimize to only copy when needed\n        rval = this.read === 0 ? this.data : this.data.slice(this.read);\n        this.clear();\n    }\n    return rval;\n};\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */ util.DataBuffer.prototype.bytes = function(count) {\n    // TODO: deprecate this method, it is poorly named, add \"getString()\"\n    return typeof count === \"undefined\" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n};\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */ util.DataBuffer.prototype.at = function(i) {\n    return this.data.getUint8(this.read + i);\n};\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.setAt = function(i, b) {\n    this.data.setUint8(i, b);\n    return this;\n};\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */ util.DataBuffer.prototype.last = function() {\n    return this.data.getUint8(this.write - 1);\n};\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */ util.DataBuffer.prototype.copy = function() {\n    return new util.DataBuffer(this);\n};\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.compact = function() {\n    if (this.read > 0) {\n        var src = new Uint8Array(this.data.buffer, this.read);\n        var dst = new Uint8Array(src.byteLength);\n        dst.set(src);\n        this.data = new DataView(dst);\n        this.write -= this.read;\n        this.read = 0;\n    }\n    return this;\n};\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.clear = function() {\n    this.data = new DataView(new ArrayBuffer(0));\n    this.read = this.write = 0;\n    return this;\n};\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.truncate = function(count) {\n    this.write = Math.max(0, this.length() - count);\n    this.read = Math.min(this.read, this.write);\n    return this;\n};\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */ util.DataBuffer.prototype.toHex = function() {\n    var rval = \"\";\n    for(var i = this.read; i < this.data.byteLength; ++i){\n        var b = this.data.getUint8(i);\n        if (b < 16) {\n            rval += \"0\";\n        }\n        rval += b.toString(16);\n    }\n    return rval;\n};\n/**\n * Converts this buffer to a string, using the given encoding. If no\n * encoding is given, 'utf8' (UTF-8) is used.\n *\n * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\n *          'base64' (default: 'utf8').\n *\n * @return a string representation of the bytes in this buffer.\n */ util.DataBuffer.prototype.toString = function(encoding) {\n    var view = new Uint8Array(this.data, this.read, this.length());\n    encoding = encoding || \"utf8\";\n    // encode to string\n    if (encoding === \"binary\" || encoding === \"raw\") {\n        return util.binary.raw.encode(view);\n    }\n    if (encoding === \"hex\") {\n        return util.binary.hex.encode(view);\n    }\n    if (encoding === \"base64\") {\n        return util.binary.base64.encode(view);\n    }\n    // decode to text\n    if (encoding === \"utf8\") {\n        return util.text.utf8.decode(view);\n    }\n    if (encoding === \"utf16\") {\n        return util.text.utf16.decode(view);\n    }\n    throw new Error(\"Invalid encoding: \" + encoding);\n};\n/** End Buffer w/UInt8Array backing */ /**\n * Creates a buffer that stores bytes. A value may be given to populate the\n * buffer with data. This value can either be string of encoded bytes or a\n * regular string of characters. When passing a string of binary encoded\n * bytes, the encoding `raw` should be given. This is also the default. When\n * passing a string of characters, the encoding `utf8` should be given.\n *\n * @param [input] a string with encoded bytes to store in the buffer.\n * @param [encoding] (default: 'raw', other: 'utf8').\n */ util.createBuffer = function(input, encoding) {\n    // TODO: deprecate, use new ByteBuffer() instead\n    encoding = encoding || \"raw\";\n    if (input !== undefined && encoding === \"utf8\") {\n        input = util.encodeUtf8(input);\n    }\n    return new util.ByteBuffer(input);\n};\n/**\n * Fills a string with a particular value. If you want the string to be a byte\n * string, pass in String.fromCharCode(theByte).\n *\n * @param c the character to fill the string with, use String.fromCharCode\n *          to fill the string with a byte value.\n * @param n the number of characters of value c to fill with.\n *\n * @return the filled string.\n */ util.fillString = function(c, n) {\n    var s = \"\";\n    while(n > 0){\n        if (n & 1) {\n            s += c;\n        }\n        n >>>= 1;\n        if (n > 0) {\n            c += c;\n        }\n    }\n    return s;\n};\n/**\n * Performs a per byte XOR between two byte strings and returns the result as a\n * string of bytes.\n *\n * @param s1 first string of bytes.\n * @param s2 second string of bytes.\n * @param n the number of bytes to XOR.\n *\n * @return the XOR'd result.\n */ util.xorBytes = function(s1, s2, n) {\n    var s3 = \"\";\n    var b = \"\";\n    var t = \"\";\n    var i = 0;\n    var c = 0;\n    for(; n > 0; --n, ++i){\n        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n        if (c >= 10) {\n            s3 += t;\n            t = \"\";\n            c = 0;\n        }\n        t += String.fromCharCode(b);\n        ++c;\n    }\n    s3 += t;\n    return s3;\n};\n/**\n * Converts a hex string into a 'binary' encoded string of bytes.\n *\n * @param hex the hexadecimal string to convert.\n *\n * @return the binary-encoded string of bytes.\n */ util.hexToBytes = function(hex) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\n    var rval = \"\";\n    var i = 0;\n    if (hex.length & 1 == 1) {\n        // odd number of characters, convert first character alone\n        i = 1;\n        rval += String.fromCharCode(parseInt(hex[0], 16));\n    }\n    // convert 2 characters (1 byte) at a time\n    for(; i < hex.length; i += 2){\n        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n    }\n    return rval;\n};\n/**\n * Converts a 'binary' encoded string of bytes to hex.\n *\n * @param bytes the byte string to convert.\n *\n * @return the string of hexadecimal characters.\n */ util.bytesToHex = function(bytes) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\n    return util.createBuffer(bytes).toHex();\n};\n/**\n * Converts an 32-bit integer to 4-big-endian byte string.\n *\n * @param i the integer.\n *\n * @return the byte string.\n */ util.int32ToBytes = function(i) {\n    return String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);\n};\n// base64 characters, reverse mapping\nvar _base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar _base64Idx = [\n    /*43 -43 = 0*/ /*'+',  1,  2,  3,'/' */ 62,\n    -1,\n    -1,\n    -1,\n    63,\n    /*'0','1','2','3','4','5','6','7','8','9' */ 52,\n    53,\n    54,\n    55,\n    56,\n    57,\n    58,\n    59,\n    60,\n    61,\n    /*15, 16, 17,'=', 19, 20, 21 */ -1,\n    -1,\n    -1,\n    64,\n    -1,\n    -1,\n    -1,\n    /*65 - 43 = 22*/ /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */ 0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */ 13,\n    14,\n    15,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    22,\n    23,\n    24,\n    25,\n    /*91 - 43 = 48 */ /*48, 49, 50, 51, 52, 53 */ -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    /*97 - 43 = 54*/ /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */ 26,\n    27,\n    28,\n    29,\n    30,\n    31,\n    32,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */ 39,\n    40,\n    41,\n    42,\n    43,\n    44,\n    45,\n    46,\n    47,\n    48,\n    49,\n    50,\n    51\n];\n// base58 characters (Bitcoin alphabet)\nvar _base58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n/**\n * Base64 encodes a 'binary' encoded string of bytes.\n *\n * @param input the binary encoded string of bytes to base64-encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output.\n */ util.encode64 = function(input, maxline) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\n    var line = \"\";\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var i = 0;\n    while(i < input.length){\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n        // encode 4 character group\n        line += _base64.charAt(chr1 >> 2);\n        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n        if (isNaN(chr2)) {\n            line += \"==\";\n        } else {\n            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n            line += isNaN(chr3) ? \"=\" : _base64.charAt(chr3 & 63);\n        }\n        if (maxline && line.length > maxline) {\n            output += line.substr(0, maxline) + \"\\r\\n\";\n            line = line.substr(maxline);\n        }\n    }\n    output += line;\n    return output;\n};\n/**\n * Base64 decodes a string into a 'binary' encoded string of bytes.\n *\n * @param input the base64-encoded input.\n *\n * @return the binary encoded string.\n */ util.decode64 = function(input) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\n    // remove all non-base64 characters\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    var output = \"\";\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n    while(i < input.length){\n        enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);\n        if (enc3 !== 64) {\n            // decoded at least 2 bytes\n            output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);\n            if (enc4 !== 64) {\n                // decoded 3 bytes\n                output += String.fromCharCode((enc3 & 3) << 6 | enc4);\n            }\n        }\n    }\n    return output;\n};\n/**\n * Encodes the given string of characters (a standard JavaScript\n * string) as a binary encoded string where the bytes represent\n * a UTF-8 encoded string of characters. Non-ASCII characters will be\n * encoded as multiple bytes according to UTF-8.\n *\n * @param str a standard string of characters to encode.\n *\n * @return the binary encoded string.\n */ util.encodeUtf8 = function(str) {\n    return unescape(encodeURIComponent(str));\n};\n/**\n * Decodes a binary encoded string that contains bytes that\n * represent a UTF-8 encoded string of characters -- into a\n * string of characters (a standard JavaScript string).\n *\n * @param str the binary encoded string to decode.\n *\n * @return the resulting standard string of characters.\n */ util.decodeUtf8 = function(str) {\n    return decodeURIComponent(escape(str));\n};\n// binary encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.binary = {\n    raw: {},\n    hex: {},\n    base64: {},\n    base58: {},\n    baseN: {\n        encode: baseN.encode,\n        decode: baseN.decode\n    }\n};\n/**\n * Encodes a Uint8Array as a binary-encoded string. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param bytes the Uint8Array to encode.\n *\n * @return the binary-encoded string.\n */ util.binary.raw.encode = function(bytes) {\n    return String.fromCharCode.apply(null, bytes);\n};\n/**\n * Decodes a binary-encoded string to a Uint8Array. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param str the binary-encoded string to decode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.binary.raw.decode = function(str, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(str.length);\n    }\n    offset = offset || 0;\n    var j = offset;\n    for(var i = 0; i < str.length; ++i){\n        out[j++] = str.charCodeAt(i);\n    }\n    return output ? j - offset : out;\n};\n/**\n * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\n * ByteBuffer as a string of hexadecimal characters.\n *\n * @param bytes the bytes to convert.\n *\n * @return the string of hexadecimal characters.\n */ util.binary.hex.encode = util.bytesToHex;\n/**\n * Decodes a hex-encoded string to a Uint8Array.\n *\n * @param hex the hexadecimal string to convert.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.binary.hex.decode = function(hex, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(Math.ceil(hex.length / 2));\n    }\n    offset = offset || 0;\n    var i = 0, j = offset;\n    if (hex.length & 1) {\n        // odd number of characters, convert first character alone\n        i = 1;\n        out[j++] = parseInt(hex[0], 16);\n    }\n    // convert 2 characters (1 byte) at a time\n    for(; i < hex.length; i += 2){\n        out[j++] = parseInt(hex.substr(i, 2), 16);\n    }\n    return output ? j - offset : out;\n};\n/**\n * Base64-encodes a Uint8Array.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output string.\n */ util.binary.base64.encode = function(input, maxline) {\n    var line = \"\";\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var i = 0;\n    while(i < input.byteLength){\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        // encode 4 character group\n        line += _base64.charAt(chr1 >> 2);\n        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n        if (isNaN(chr2)) {\n            line += \"==\";\n        } else {\n            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n            line += isNaN(chr3) ? \"=\" : _base64.charAt(chr3 & 63);\n        }\n        if (maxline && line.length > maxline) {\n            output += line.substr(0, maxline) + \"\\r\\n\";\n            line = line.substr(maxline);\n        }\n    }\n    output += line;\n    return output;\n};\n/**\n * Decodes a base64-encoded string to a Uint8Array.\n *\n * @param input the base64-encoded input string.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.binary.base64.decode = function(input, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(Math.ceil(input.length / 4) * 3);\n    }\n    // remove all non-base64 characters\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    offset = offset || 0;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, j = offset;\n    while(i < input.length){\n        enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n        out[j++] = enc1 << 2 | enc2 >> 4;\n        if (enc3 !== 64) {\n            // decoded at least 2 bytes\n            out[j++] = (enc2 & 15) << 4 | enc3 >> 2;\n            if (enc4 !== 64) {\n                // decoded 3 bytes\n                out[j++] = (enc3 & 3) << 6 | enc4;\n            }\n        }\n    }\n    // make sure result is the exact decoded length\n    return output ? j - offset : out.subarray(0, j);\n};\n// add support for base58 encoding/decoding with Bitcoin alphabet\nutil.binary.base58.encode = function(input, maxline) {\n    return util.binary.baseN.encode(input, _base58, maxline);\n};\nutil.binary.base58.decode = function(input, maxline) {\n    return util.binary.baseN.decode(input, _base58, maxline);\n};\n// text encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.text = {\n    utf8: {},\n    utf16: {}\n};\n/**\n * Encodes the given string as UTF-8 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.text.utf8.encode = function(str, output, offset) {\n    str = util.encodeUtf8(str);\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(str.length);\n    }\n    offset = offset || 0;\n    var j = offset;\n    for(var i = 0; i < str.length; ++i){\n        out[j++] = str.charCodeAt(i);\n    }\n    return output ? j - offset : out;\n};\n/**\n * Decodes the UTF-8 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */ util.text.utf8.decode = function(bytes) {\n    return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\n};\n/**\n * Encodes the given string as UTF-16 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.text.utf16.encode = function(str, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(str.length * 2);\n    }\n    var view = new Uint16Array(out.buffer);\n    offset = offset || 0;\n    var j = offset;\n    var k = offset;\n    for(var i = 0; i < str.length; ++i){\n        view[k++] = str.charCodeAt(i);\n        j += 2;\n    }\n    return output ? j - offset : out;\n};\n/**\n * Decodes the UTF-16 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */ util.text.utf16.decode = function(bytes) {\n    return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n};\n/**\n * Deflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true to return only raw deflate data, false to include zlib\n *          header and trailer.\n *\n * @return the deflated data as a string.\n */ util.deflate = function(api, bytes, raw) {\n    bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\n    // strip zlib header and trailer if necessary\n    if (raw) {\n        // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\n        // there is a 4-byte DICT (alder-32) block before the data if\n        // its 5th bit is set\n        var start = 2;\n        var flg = bytes.charCodeAt(1);\n        if (flg & 0x20) {\n            start = 6;\n        }\n        // zlib trailer is 4 bytes of adler-32\n        bytes = bytes.substring(start, bytes.length - 4);\n    }\n    return bytes;\n};\n/**\n * Inflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true if the incoming data has no zlib header or trailer and is\n *          raw DEFLATE data.\n *\n * @return the inflated data as a string, null on error.\n */ util.inflate = function(api, bytes, raw) {\n    // TODO: add zlib header and trailer if necessary/possible\n    var rval = api.inflate(util.encode64(bytes)).rval;\n    return rval === null ? null : util.decode64(rval);\n};\n/**\n * Sets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param obj the storage object, null to remove.\n */ var _setStorageObject = function(api, id, obj) {\n    if (!api) {\n        throw new Error(\"WebStorage not available.\");\n    }\n    var rval;\n    if (obj === null) {\n        rval = api.removeItem(id);\n    } else {\n        // json-encode and base64-encode object\n        obj = util.encode64(JSON.stringify(obj));\n        rval = api.setItem(id, obj);\n    }\n    // handle potential flash error\n    if (typeof rval !== \"undefined\" && rval.rval !== true) {\n        var error = new Error(rval.error.message);\n        error.id = rval.error.id;\n        error.name = rval.error.name;\n        throw error;\n    }\n};\n/**\n * Gets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n *\n * @return the storage object entry or null if none exists.\n */ var _getStorageObject = function(api, id) {\n    if (!api) {\n        throw new Error(\"WebStorage not available.\");\n    }\n    // get the existing entry\n    var rval = api.getItem(id);\n    /* Note: We check api.init because we can't do (api == localStorage)\n    on IE because of \"Class doesn't support Automation\" exception. Only\n    the flash api has an init method so this works too, but we need a\n    better solution in the future. */ // flash returns item wrapped in an object, handle special case\n    if (api.init) {\n        if (rval.rval === null) {\n            if (rval.error) {\n                var error = new Error(rval.error.message);\n                error.id = rval.error.id;\n                error.name = rval.error.name;\n                throw error;\n            }\n            // no error, but also no item\n            rval = null;\n        } else {\n            rval = rval.rval;\n        }\n    }\n    // handle decoding\n    if (rval !== null) {\n        // base64-decode and json-decode data\n        rval = JSON.parse(util.decode64(rval));\n    }\n    return rval;\n};\n/**\n * Stores an item in local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n */ var _setItem = function(api, id, key, data) {\n    // get storage object\n    var obj = _getStorageObject(api, id);\n    if (obj === null) {\n        // create a new storage object\n        obj = {};\n    }\n    // update key\n    obj[key] = data;\n    // set storage object\n    _setStorageObject(api, id, obj);\n};\n/**\n * Gets an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n *\n * @return the item.\n */ var _getItem = function(api, id, key) {\n    // get storage object\n    var rval = _getStorageObject(api, id);\n    if (rval !== null) {\n        // return data at key\n        rval = key in rval ? rval[key] : null;\n    }\n    return rval;\n};\n/**\n * Removes an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n */ var _removeItem = function(api, id, key) {\n    // get storage object\n    var obj = _getStorageObject(api, id);\n    if (obj !== null && key in obj) {\n        // remove key\n        delete obj[key];\n        // see if entry has no keys remaining\n        var empty = true;\n        for(var prop in obj){\n            empty = false;\n            break;\n        }\n        if (empty) {\n            // remove entry entirely if no keys are left\n            obj = null;\n        }\n        // set storage object\n        _setStorageObject(api, id, obj);\n    }\n};\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n */ var _clearItems = function(api, id) {\n    _setStorageObject(api, id, null);\n};\n/**\n * Calls a storage function.\n *\n * @param func the function to call.\n * @param args the arguments for the function.\n * @param location the location argument.\n *\n * @return the return value from the function.\n */ var _callStorageFunction = function(func, args, location) {\n    var rval = null;\n    // default storage types\n    if (typeof location === \"undefined\") {\n        location = [\n            \"web\",\n            \"flash\"\n        ];\n    }\n    // apply storage types in order of preference\n    var type;\n    var done = false;\n    var exception = null;\n    for(var idx in location){\n        type = location[idx];\n        try {\n            if (type === \"flash\" || type === \"both\") {\n                if (args[0] === null) {\n                    throw new Error(\"Flash local storage not available.\");\n                }\n                rval = func.apply(this, args);\n                done = type === \"flash\";\n            }\n            if (type === \"web\" || type === \"both\") {\n                args[0] = localStorage;\n                rval = func.apply(this, args);\n                done = true;\n            }\n        } catch (ex) {\n            exception = ex;\n        }\n        if (done) {\n            break;\n        }\n    }\n    if (!done) {\n        throw exception;\n    }\n    return rval;\n};\n/**\n * Stores an item on local disk.\n *\n * The available types of local storage include 'flash', 'web', and 'both'.\n *\n * The type 'flash' refers to flash local storage (SharedObject). In order\n * to use flash local storage, the 'api' parameter must be valid. The type\n * 'web' refers to WebStorage, if supported by the browser. The type 'both'\n * refers to storing using both 'flash' and 'web', not just one or the\n * other.\n *\n * The location array should list the storage types to use in order of\n * preference:\n *\n * ['flash']: flash only storage\n * ['web']: web only storage\n * ['both']: try to store in both\n * ['flash','web']: store in flash first, but if not available, 'web'\n * ['web','flash']: store in web first, but if not available, 'flash'\n *\n * The location array defaults to: ['web', 'flash']\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n * @param location an array with the preferred types of storage to use.\n */ util.setItem = function(api, id, key, data, location) {\n    _callStorageFunction(_setItem, arguments, location);\n};\n/**\n * Gets an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n *\n * @return the item.\n */ util.getItem = function(api, id, key, location) {\n    return _callStorageFunction(_getItem, arguments, location);\n};\n/**\n * Removes an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n */ util.removeItem = function(api, id, key, location) {\n    _callStorageFunction(_removeItem, arguments, location);\n};\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface if flash is available.\n * @param id the storage ID to use.\n * @param location an array with the preferred types of storage to use.\n */ util.clearItems = function(api, id, location) {\n    _callStorageFunction(_clearItems, arguments, location);\n};\n/**\n * Check if an object is empty.\n *\n * Taken from:\n * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\n *\n * @param object the object to check.\n */ util.isEmpty = function(obj) {\n    for(var prop in obj){\n        if (obj.hasOwnProperty(prop)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Format with simple printf-style interpolation.\n *\n * %%: literal '%'\n * %s,%o: convert next argument into a string.\n *\n * @param format the string to format.\n * @param ... arguments to interpolate into the format string.\n */ util.format = function(format) {\n    var re = /%./g;\n    // current match\n    var match;\n    // current part\n    var part;\n    // current arg index\n    var argi = 0;\n    // collected parts to recombine later\n    var parts = [];\n    // last index found\n    var last = 0;\n    // loop while matches remain\n    while(match = re.exec(format)){\n        part = format.substring(last, re.lastIndex - 2);\n        // don't add empty strings (ie, parts between %s%s)\n        if (part.length > 0) {\n            parts.push(part);\n        }\n        last = re.lastIndex;\n        // switch on % code\n        var code = match[0][1];\n        switch(code){\n            case \"s\":\n            case \"o\":\n                // check if enough arguments were given\n                if (argi < arguments.length) {\n                    parts.push(arguments[argi++ + 1]);\n                } else {\n                    parts.push(\"<?>\");\n                }\n                break;\n            // FIXME: do proper formating for numbers, etc\n            //case 'f':\n            //case 'd':\n            case \"%\":\n                parts.push(\"%\");\n                break;\n            default:\n                parts.push(\"<%\" + code + \"?>\");\n        }\n    }\n    // add trailing part of format string\n    parts.push(format.substring(last));\n    return parts.join(\"\");\n};\n/**\n * Formats a number.\n *\n * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\n */ util.formatNumber = function(number, decimals, dec_point, thousands_sep) {\n    // http://kevin.vanzonneveld.net\n    // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +     bugfix by: Michael White (http://crestidg.com)\n    // +     bugfix by: Benjamin Lupton\n    // +     bugfix by: Allan Jensen (http://www.winternet.no)\n    // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n    // *     example 1: number_format(1234.5678, 2, '.', '');\n    // *     returns 1: 1234.57\n    var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n    var d = dec_point === undefined ? \",\" : dec_point;\n    var t = thousands_sep === undefined ? \".\" : thousands_sep, s = n < 0 ? \"-\" : \"\";\n    var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + \"\";\n    var j = i.length > 3 ? i.length % 3 : 0;\n    return s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : \"\");\n};\n/**\n * Formats a byte size.\n *\n * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\n */ util.formatSize = function(size) {\n    if (size >= 1073741824) {\n        size = util.formatNumber(size / 1073741824, 2, \".\", \"\") + \" GiB\";\n    } else if (size >= 1048576) {\n        size = util.formatNumber(size / 1048576, 2, \".\", \"\") + \" MiB\";\n    } else if (size >= 1024) {\n        size = util.formatNumber(size / 1024, 0) + \" KiB\";\n    } else {\n        size = util.formatNumber(size, 0) + \" bytes\";\n    }\n    return size;\n};\n/**\n * Converts an IPv4 or IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv4 or IPv6 address to convert.\n *\n * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\n *         be parsed.\n */ util.bytesFromIP = function(ip) {\n    if (ip.indexOf(\".\") !== -1) {\n        return util.bytesFromIPv4(ip);\n    }\n    if (ip.indexOf(\":\") !== -1) {\n        return util.bytesFromIPv6(ip);\n    }\n    return null;\n};\n/**\n * Converts an IPv4 string representation into bytes (in network order).\n *\n * @param ip the IPv4 address to convert.\n *\n * @return the 4-byte address or null if the address can't be parsed.\n */ util.bytesFromIPv4 = function(ip) {\n    ip = ip.split(\".\");\n    if (ip.length !== 4) {\n        return null;\n    }\n    var b = util.createBuffer();\n    for(var i = 0; i < ip.length; ++i){\n        var num = parseInt(ip[i], 10);\n        if (isNaN(num)) {\n            return null;\n        }\n        b.putByte(num);\n    }\n    return b.getBytes();\n};\n/**\n * Converts an IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv6 address to convert.\n *\n * @return the 16-byte address or null if the address can't be parsed.\n */ util.bytesFromIPv6 = function(ip) {\n    var blanks = 0;\n    ip = ip.split(\":\").filter(function(e) {\n        if (e.length === 0) ++blanks;\n        return true;\n    });\n    var zeros = (8 - ip.length + blanks) * 2;\n    var b = util.createBuffer();\n    for(var i = 0; i < 8; ++i){\n        if (!ip[i] || ip[i].length === 0) {\n            b.fillWithByte(0, zeros);\n            zeros = 0;\n            continue;\n        }\n        var bytes = util.hexToBytes(ip[i]);\n        if (bytes.length < 2) {\n            b.putByte(0);\n        }\n        b.putBytes(bytes);\n    }\n    return b.getBytes();\n};\n/**\n * Converts 4-bytes into an IPv4 string representation or 16-bytes into\n * an IPv6 string representation. The bytes must be in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\n *         respectively, are given, otherwise null.\n */ util.bytesToIP = function(bytes) {\n    if (bytes.length === 4) {\n        return util.bytesToIPv4(bytes);\n    }\n    if (bytes.length === 16) {\n        return util.bytesToIPv6(bytes);\n    }\n    return null;\n};\n/**\n * Converts 4-bytes into an IPv4 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 string representation or null for an invalid # of bytes.\n */ util.bytesToIPv4 = function(bytes) {\n    if (bytes.length !== 4) {\n        return null;\n    }\n    var ip = [];\n    for(var i = 0; i < bytes.length; ++i){\n        ip.push(bytes.charCodeAt(i));\n    }\n    return ip.join(\".\");\n};\n/**\n * Converts 16-bytes into an IPv16 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv16 string representation or null for an invalid # of bytes.\n */ util.bytesToIPv6 = function(bytes) {\n    if (bytes.length !== 16) {\n        return null;\n    }\n    var ip = [];\n    var zeroGroups = [];\n    var zeroMaxGroup = 0;\n    for(var i = 0; i < bytes.length; i += 2){\n        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\n        // canonicalize zero representation\n        while(hex[0] === \"0\" && hex !== \"0\"){\n            hex = hex.substr(1);\n        }\n        if (hex === \"0\") {\n            var last = zeroGroups[zeroGroups.length - 1];\n            var idx = ip.length;\n            if (!last || idx !== last.end + 1) {\n                zeroGroups.push({\n                    start: idx,\n                    end: idx\n                });\n            } else {\n                last.end = idx;\n                if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {\n                    zeroMaxGroup = zeroGroups.length - 1;\n                }\n            }\n        }\n        ip.push(hex);\n    }\n    if (zeroGroups.length > 0) {\n        var group = zeroGroups[zeroMaxGroup];\n        // only shorten group of length > 0\n        if (group.end - group.start > 0) {\n            ip.splice(group.start, group.end - group.start + 1, \"\");\n            if (group.start === 0) {\n                ip.unshift(\"\");\n            }\n            if (group.end === 7) {\n                ip.push(\"\");\n            }\n        }\n    }\n    return ip.join(\":\");\n};\n/**\n * Estimates the number of processes that can be run concurrently. If\n * creating Web Workers, keep in mind that the main JavaScript process needs\n * its own core.\n *\n * @param options the options to use:\n *          update true to force an update (not use the cached value).\n * @param callback(err, max) called once the operation completes.\n */ util.estimateCores = function(options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = options || {};\n    if (\"cores\" in util && !options.update) {\n        return callback(null, util.cores);\n    }\n    if (typeof navigator !== \"undefined\" && \"hardwareConcurrency\" in navigator && navigator.hardwareConcurrency > 0) {\n        util.cores = navigator.hardwareConcurrency;\n        return callback(null, util.cores);\n    }\n    if (typeof Worker === \"undefined\") {\n        // workers not available\n        util.cores = 1;\n        return callback(null, util.cores);\n    }\n    if (typeof Blob === \"undefined\") {\n        // can't estimate, default to 2\n        util.cores = 2;\n        return callback(null, util.cores);\n    }\n    // create worker concurrency estimation code as blob\n    var blobUrl = URL.createObjectURL(new Blob([\n        \"(\",\n        (function() {\n            self.addEventListener(\"message\", function(e) {\n                // run worker for 4 ms\n                var st = Date.now();\n                var et = st + 4;\n                while(Date.now() < et);\n                self.postMessage({\n                    st: st,\n                    et: et\n                });\n            });\n        }).toString(),\n        \")()\"\n    ], {\n        type: \"application/javascript\"\n    }));\n    // take 5 samples using 16 workers\n    sample([], 5, 16);\n    function sample(max, samples, numWorkers) {\n        if (samples === 0) {\n            // get overlap average\n            var avg = Math.floor(max.reduce(function(avg, x) {\n                return avg + x;\n            }, 0) / max.length);\n            util.cores = Math.max(1, avg);\n            URL.revokeObjectURL(blobUrl);\n            return callback(null, util.cores);\n        }\n        map(numWorkers, function(err, results) {\n            max.push(reduce(numWorkers, results));\n            sample(max, samples - 1, numWorkers);\n        });\n    }\n    function map(numWorkers, callback) {\n        var workers = [];\n        var results = [];\n        for(var i = 0; i < numWorkers; ++i){\n            var worker = new Worker(blobUrl);\n            worker.addEventListener(\"message\", function(e) {\n                results.push(e.data);\n                if (results.length === numWorkers) {\n                    for(var i = 0; i < numWorkers; ++i){\n                        workers[i].terminate();\n                    }\n                    callback(null, results);\n                }\n            });\n            workers.push(worker);\n        }\n        for(var i = 0; i < numWorkers; ++i){\n            workers[i].postMessage(i);\n        }\n    }\n    function reduce(numWorkers, results) {\n        // find overlapping time windows\n        var overlaps = [];\n        for(var n = 0; n < numWorkers; ++n){\n            var r1 = results[n];\n            var overlap = overlaps[n] = [];\n            for(var i = 0; i < numWorkers; ++i){\n                if (n === i) {\n                    continue;\n                }\n                var r2 = results[i];\n                if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {\n                    overlap.push(i);\n                }\n            }\n        }\n        // get maximum overlaps ... don't include overlapping worker itself\n        // as the main JS process was also being scheduled during the work and\n        // would have to be subtracted from the estimate anyway\n        return overlaps.reduce(function(max, overlap) {\n            return Math.max(max, overlap.length);\n        }, 0);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUVwQixpQkFBaUIsR0FDakIsSUFBSUUsT0FBT0MsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRyxJQUFJLEdBQUdILE1BQU1HLElBQUksSUFBSSxDQUFDO0FBRXhELG1DQUFtQztBQUNsQztJQUNDLGdEQUFnRDtJQUNoRCx1RUFBdUU7SUFDdkUsMENBQTBDO0lBQzFDLElBQUcsT0FBT0csWUFBWSxlQUFlQSxRQUFRQyxRQUFRLElBQUksQ0FBQ0QsS0FBZSxFQUFFO1FBQ3pFSCxLQUFLSSxRQUFRLEdBQUdELFFBQVFDLFFBQVE7UUFDaEMsSUFBRyxPQUFPRSxpQkFBaUIsWUFBWTtZQUNyQ04sS0FBS00sWUFBWSxHQUFHQTtRQUN0QixPQUFPO1lBQ0wsOERBQThEO1lBQzlELG1EQUFtRDtZQUNuRE4sS0FBS00sWUFBWSxHQUFHTixLQUFLSSxRQUFRO1FBQ25DO1FBQ0E7SUFDRjtJQUVBLDZDQUE2QztJQUM3QyxJQUFHLE9BQU9FLGlCQUFpQixZQUFZO1FBQ3JDTixLQUFLTSxZQUFZLEdBQUc7WUFBYSxPQUFPQSxhQUFhQyxLQUFLLENBQUNDLFdBQVdDO1FBQVk7UUFDbEZULEtBQUtJLFFBQVEsR0FBRyxTQUFTTSxRQUFRO1lBQy9CLE9BQU9KLGFBQWFJO1FBQ3RCO1FBQ0E7SUFDRjtJQUVBOzs7NkJBRzJCLEdBRTNCLDJCQUEyQjtJQUMzQlYsS0FBS00sWUFBWSxHQUFHLFNBQVNJLFFBQVE7UUFDbkNDLFdBQVdELFVBQVU7SUFDdkI7SUFFQSxzQ0FBc0M7SUFDdEMsSUFBRyxLQUM2QixFQUFZLHVCQXNCM0M7SUFFRCwyQ0FBMkM7SUFDM0MsSUFBRyxPQUFPaUIscUJBQXFCLGFBQWE7UUFDMUMsaUNBQWlDO1FBQ2pDLElBQUlDLE1BQU1D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UXRSLE1BQU07UUFDckMsR0FBRztJQUNMO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi91dGlsLmpzPzM3NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnZhciBiYXNlTiA9IHJlcXVpcmUoJy4vYmFzZU4nKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuXG4vLyAnc2VsZicgd2lsbCBhbHNvIHdvcmsgaW4gV2ViIFdvcmtlcnMgKGluc3RhbmNlIG9mIFdvcmtlckdsb2JhbFNjb3BlKSB3aGlsZVxuLy8gaXQgd2lsbCBwb2ludCB0byBgd2luZG93YCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4vLyBUbyByZW1haW4gY29tcGF0aWJsZSB3aXRoIG9sZGVyIGJyb3dzZXJzLCB3ZSBmYWxsIGJhY2sgdG8gJ3dpbmRvdycgaWYgJ3NlbGYnXG4vLyBpcyBub3QgYXZhaWxhYmxlLlxudXRpbC5nbG9iYWxTY29wZSA9IChmdW5jdGlvbigpIHtcbiAgaWYodXRpbC5pc05vZGVqcykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gd2luZG93IDogc2VsZjtcbn0pKCk7XG5cbi8vIGRlZmluZSBpc0FycmF5XG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyXG51dGlsLmlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyVmlld1xudXRpbC5pc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggJiYgdXRpbC5pc0FycmF5QnVmZmVyKHguYnVmZmVyKSAmJiB4LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRW5zdXJlIGEgYml0cyBwYXJhbSBpcyA4LCAxNiwgMjQsIG9yIDMyLiBVc2VkIHRvIHZhbGlkYXRlIGlucHV0IGZvclxuICogYWxnb3JpdGhtcyB3aGVyZSBiaXQgbWFuaXB1bGF0aW9uLCBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCBhbmQvb3IgYWxnb3JpdGhtXG4gKiBkZXNpZ24gb25seSBhbGxvdyBmb3IgYnl0ZSBvcGVyYXRpb25zIG9mIGEgbGltaXRlZCBzaXplLlxuICpcbiAqIEBwYXJhbSBuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIFRocm93IEVycm9yIGlmIG4gaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQml0c1BhcmFtKG4pIHtcbiAgaWYoIShuID09PSA4IHx8IG4gPT09IDE2IHx8IG4gPT09IDI0IHx8IG4gPT09IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSA4LCAxNiwgMjQsIG9yIDMyIGJpdHMgc3VwcG9ydGVkOiAnICsgbik7XG4gIH1cbn1cblxuLy8gVE9ETzogc2V0IEJ5dGVCdWZmZXIgdG8gYmVzdCBhdmFpbGFibGUgYmFja2luZ1xudXRpbC5CeXRlQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyoqIEJ1ZmZlciB3L0JpbmFyeVN0cmluZyBiYWNraW5nICovXG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgYmluYXJ5IHN0cmluZyBiYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgYnl0ZXMgdG8gd3JhcCAoZWl0aGVyIGVuY29kZWQgYXMgc3RyaW5nLCBvbmUgYnl0ZSBwZXJcbiAqICAgICAgICAgIGNoYXJhY3Rlciwgb3IgYXMgYW4gQXJyYXlCdWZmZXIgb3IgVHlwZWQgQXJyYXkpLlxuICovXG5mdW5jdGlvbiBCeXRlU3RyaW5nQnVmZmVyKGIpIHtcbiAgLy8gVE9ETzogdXBkYXRlIHRvIG1hdGNoIERhdGFCdWZmZXIgQVBJXG5cbiAgLy8gdGhlIGRhdGEgaW4gdGhpcyBidWZmZXJcbiAgdGhpcy5kYXRhID0gJyc7XG4gIC8vIHRoZSBwb2ludGVyIGZvciByZWFkaW5nIGZyb20gdGhpcyBidWZmZXJcbiAgdGhpcy5yZWFkID0gMDtcblxuICBpZih0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmRhdGEgPSBiO1xuICB9IGVsc2UgaWYodXRpbC5pc0FycmF5QnVmZmVyKGIpIHx8IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYikpIHtcbiAgICBpZih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBiIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBiLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29udmVydCBuYXRpdmUgYnVmZmVyIHRvIGZvcmdlIGJ1ZmZlclxuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgbmF0aXZlIGJ1ZmZlcnMgaW50ZXJuYWxseSBpbnN0ZWFkXG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMucHV0Qnl0ZShhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYiBpbnN0YW5jZW9mIEJ5dGVTdHJpbmdCdWZmZXIgfHxcbiAgICAodHlwZW9mIGIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiLmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGIucmVhZCA9PT0gJ251bWJlcicpKSB7XG4gICAgLy8gY29weSBleGlzdGluZyBidWZmZXJcbiAgICB0aGlzLmRhdGEgPSBiLmRhdGE7XG4gICAgdGhpcy5yZWFkID0gYi5yZWFkO1xuICB9XG5cbiAgLy8gdXNlZCBmb3Igdjggb3B0aW1pemF0aW9uXG4gIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbn1cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG5cbi8qIE5vdGU6IFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBWOC1iYXNlZCBicm93c2Vycy4gV2hlbiBWOCBjb25jYXRlbmF0ZXNcbiAgYSBzdHJpbmcsIHRoZSBzdHJpbmdzIGFyZSBvbmx5IGpvaW5lZCBsb2dpY2FsbHkgdXNpbmcgYSBcImNvbnMgc3RyaW5nXCIgb3JcbiAgXCJjb25zdHJ1Y3RlZC9jb25jYXRlbmF0ZWQgc3RyaW5nXCIuIFRoZXNlIGNvbnRhaW5lcnMga2VlcCByZWZlcmVuY2VzIHRvIG9uZVxuICBhbm90aGVyIGFuZCBjYW4gcmVzdWx0IGluIHZlcnkgbGFyZ2UgbWVtb3J5IHVzYWdlLiBGb3IgZXhhbXBsZSwgaWYgYSAyTUJcbiAgc3RyaW5nIGlzIGNvbnN0cnVjdGVkIGJ5IGNvbmNhdGVuYXRpbmcgNCBieXRlcyB0b2dldGhlciBhdCBhIHRpbWUsIHRoZVxuICBtZW1vcnkgdXNhZ2Ugd2lsbCBiZSB+NDRNQjsgc28gfjIyeCBpbmNyZWFzZS4gVGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkXG4gIHRvZ2V0aGVyIHdoZW4gYW4gb3BlcmF0aW9uIHJlcXVpcmluZyB0aGVpciBqb2luaW5nIHRha2VzIHBsYWNlLCBzdWNoIGFzXG4gIHN1YnN0cigpLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGFkZGluZyBkYXRhIHRvIHRoaXMgYnVmZmVyIHRvIGVuc3VyZVxuICB0aGVzZSB0eXBlcyBvZiBzdHJpbmdzIGFyZSBwZXJpb2RpY2FsbHkgam9pbmVkIHRvIHJlZHVjZSB0aGUgbWVtb3J5XG4gIGZvb3RwcmludC4gKi9cbnZhciBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEggPSA0MDk2O1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggKz0geDtcbiAgaWYodGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPiBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgpIHtcbiAgICAvLyB0aGlzIHN1YnN0cigpIHNob3VsZCBjYXVzZSB0aGUgY29uc3RydWN0ZWQgc3RyaW5nIHRvIGpvaW5cbiAgICB0aGlzLmRhdGEuc3Vic3RyKDAsIDEpO1xuICAgIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMucmVhZDtcbn07XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1ZmZlciBpcyBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBidWZmZXIgaXMgZW1wdHksIGZhbHNlIGlmIG5vdC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIGIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgZCArPSBiO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYiArPSBiO1xuICAgIH1cbiAgfVxuICB0aGlzLmRhdGEgPSBkO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKG4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIChhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZykgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuICB0aGlzLmRhdGEgKz0gYnl0ZXM7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcoYnl0ZXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBVVEYtMTYgZW5jb2RlZCBzdHJpbmcgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKHV0aWwuZW5jb2RlVXRmOChzdHIpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhbiBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBieXRlcyA9ICcnO1xuICBkbyB7XG4gICAgbiAtPSA4O1xuICAgIGJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGkgPj4gbikgJiAweEZGKTtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuIFR3bydzXG4gKiBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICAvLyBwdXRJbnQgY2hlY2tzIG5cbiAgaWYoaSA8IDApIHtcbiAgICBpICs9IDIgPDwgKG4gLSAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wdXRJbnQoaSwgbik7XG59O1xuXG4vKipcbiAqIFB1dHMgdGhlIGdpdmVuIGJ1ZmZlciBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgdGhlIGJ1ZmZlciB0byBwdXQgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhidWZmZXIuZ2V0Qnl0ZXMoKSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGZyb20gdGhpcyBidWZmZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDI0IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMykpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDgpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpIDw8IDI0KTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBjZWlsKG4vOCkuXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGVcbiAqIGJ1ZmZlci4gTm90ZSB0aGF0IHRoZSByZXN1bHRpbmcgc3RyaW5nIGlzIGJpbmFyeSBlbmNvZGVkIChpbiBub2RlLmpzIHRoaXNcbiAqIGVuY29kaW5nIGlzIHJlZmVycmVkIHRvIGFzIGBiaW5hcnlgLCBpdCBpcyAqbm90KiBgdXRmOGApLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dFxuICogbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIGJpbmFyeSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICByZXR1cm4gKHR5cGVvZihjb3VudCkgPT09ICd1bmRlZmluZWQnID9cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyKDAsIHRoaXMucmVhZCArIGkpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpICtcbiAgICB0aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCArIGkgKyAxKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxhc3QgYnl0ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGxhc3QgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLmRhdGEubGVuZ3RoIC0gMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvcHkuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYyA9IHV0aWwuY3JlYXRlQnVmZmVyKHRoaXMuZGF0YSk7XG4gIGMucmVhZCA9IHRoaXMucmVhZDtcbiAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENvbXBhY3RzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLnJlYWQgPiAwKSB7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5yZWFkID0gMDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kYXRhID0gJyc7XG4gIHRoaXMucmVhZCA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG9ydGVucyB0aGlzIGJ1ZmZlciBieSB0cmltaW5nIGJ5dGVzIG9mZiBvZiB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHRyaW0gb2ZmLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQsIGxlbik7XG4gIHRoaXMucmVhZCA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gJyc7XG4gIGZvcih2YXIgaSA9IHRoaXMucmVhZDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBiID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBVVEYtMTYgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKlxuICogQHJldHVybiBhIFVURi0xNiBzdHJpbmcuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOCh0aGlzLmJ5dGVzKCkpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9CaW5hcnlTdHJpbmcgYmFja2luZyAqL1xuXG4vKiogQnVmZmVyIHcvVUludDhBcnJheSBiYWNraW5nICovXG5cbi8qKlxuICogRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG4gKlxuICogQ29uc3RydWN0b3IgZm9yIGFuIEFycmF5QnVmZmVyLWJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUaGUgYnVmZmVyIG1heSBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgc3RyaW5nLCBhbiBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIG9yIGFcbiAqIFR5cGVkQXJyYXkuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgZ2l2ZW4sIGl0cyBlbmNvZGluZyBzaG91bGQgYmUgcHJvdmlkZWQgYXMgYW4gb3B0aW9uLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byAnYmluYXJ5Jy4gQSAnYmluYXJ5JyBzdHJpbmcgaXMgZW5jb2RlZCBzdWNoXG4gKiB0aGF0IGVhY2ggY2hhcmFjdGVyIGlzIG9uZSBieXRlIGluIGxlbmd0aCBhbmQgc2l6ZS5cbiAqXG4gKiBJZiBhbiBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIG9yIFR5cGVkQXJyYXkgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgdXNlZFxuICogKmRpcmVjdGx5KiB3aXRob3V0IGFueSBjb3B5aW5nLiBOb3RlIHRoYXQsIGlmIGEgd3JpdGUgdG8gdGhlIGJ1ZmZlciByZXF1aXJlc1xuICogbW9yZSBzcGFjZSwgdGhlIGJ1ZmZlciB3aWxsIGFsbG9jYXRlIGEgbmV3IGJhY2tpbmcgQXJyYXlCdWZmZXIgdG9cbiAqIGFjY29tbW9kYXRlLiBUaGUgc3RhcnRpbmcgcmVhZCBhbmQgd3JpdGUgb2Zmc2V0cyBmb3IgdGhlIGJ1ZmZlciBtYXkgYmVcbiAqIGdpdmVuIGFzIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgaW5pdGlhbCBieXRlcyBmb3IgdGhpcyBidWZmZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbcmVhZE9mZnNldF0gdGhlIHN0YXJ0aW5nIHJlYWQgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogMCkuXG4gKiAgICAgICAgICBbd3JpdGVPZmZzZXRdIHRoZSBzdGFydGluZyB3cml0ZSBvZmZzZXQgdG8gdXNlIChkZWZhdWx0OiB0aGVcbiAqICAgICAgICAgICAgbGVuZ3RoIG9mIHRoZSBmaXJzdCBwYXJhbWV0ZXIpLlxuICogICAgICAgICAgW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgdG9cbiAqICAgICAgICAgICAgYWNjb21tb2RhdGUgd3JpdGVzIChkZWZhdWx0OiAxMDI0KS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nICgnYmluYXJ5JywgJ3V0ZjgnLCAndXRmMTYnLCAnaGV4JykgZm9yIHRoZVxuICogICAgICAgICAgICBmaXJzdCBwYXJhbWV0ZXIsIGlmIGl0IGlzIGEgc3RyaW5nIChkZWZhdWx0OiAnYmluYXJ5JykuXG4gKi9cbmZ1bmN0aW9uIERhdGFCdWZmZXIoYiwgb3B0aW9ucykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9pbnRlcnMgZm9yIHJlYWQgZnJvbS93cml0ZSB0byBidWZmZXJcbiAgdGhpcy5yZWFkID0gb3B0aW9ucy5yZWFkT2Zmc2V0IHx8IDA7XG4gIHRoaXMuZ3Jvd1NpemUgPSBvcHRpb25zLmdyb3dTaXplIHx8IDEwMjQ7XG5cbiAgdmFyIGlzQXJyYXlCdWZmZXIgPSB1dGlsLmlzQXJyYXlCdWZmZXIoYik7XG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYik7XG4gIGlmKGlzQXJyYXlCdWZmZXIgfHwgaXNBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAvLyB1c2UgQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgICBpZihpc0FycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkanVzdCByZWFkL3dyaXRlIG9mZnNldCBiYXNlZCBvbiB0aGUgdHlwZSBvZiB2aWV3XG4gICAgICAvLyBvciBzcGVjaWZ5IHRoYXQgdGhpcyBtdXN0IGJlIGRvbmUgaW4gdGhlIG9wdGlvbnMgLi4uIHRoYXQgdGhlXG4gICAgICAvLyBvZmZzZXRzIGFyZSBieXRlLWJhc2VkXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy53cml0ZSA9ICgnd3JpdGVPZmZzZXQnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy53cml0ZU9mZnNldCA6IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHRvIGVtcHR5IGFycmF5IGJ1ZmZlciBhbmQgYWRkIGFueSBnaXZlbiBieXRlcyB1c2luZyBwdXRCeXRlc1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgdGhpcy53cml0ZSA9IDA7XG5cbiAgaWYoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnB1dEJ5dGVzKGIpO1xuICB9XG5cbiAgaWYoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy53cml0ZSA9IG9wdGlvbnMud3JpdGVPZmZzZXQ7XG4gIH1cbn1cbnV0aWwuRGF0YUJ1ZmZlciA9IERhdGFCdWZmZXI7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUgLSB0aGlzLnJlYWQ7XG59O1xuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3QgdGhpcyBidWZmZXIgaXMgZW1wdHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgYnVmZmVyIGlzIGVtcHR5LCBmYWxzZSBpZiBub3QuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGgoKSA8PSAwO1xufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoaXMgYnVmZmVyIGhhcyBlbm91Z2ggZW1wdHkgc3BhY2UgdG8gYWNjb21tb2RhdGUgdGhlIGdpdmVuIG51bWJlclxuICogb2YgYnl0ZXMuIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBtYXkgYmUgZ2l2ZW4gdGhhdCBpbmRpY2F0ZXMgYSBtaW5pbXVtXG4gKiBhbW91bnQgdG8gZ3JvdyB0aGUgYnVmZmVyIGlmIG5lY2Vzc2FyeS4gSWYgdGhlIHBhcmFtZXRlciBpcyBub3QgZ2l2ZW4sXG4gKiB0aGUgYnVmZmVyIHdpbGwgYmUgZ3Jvd24gYnkgc29tZSBwcmV2aW91c2x5LXNwZWNpZmllZCBkZWZhdWx0IGFtb3VudFxuICogb3IgaGV1cmlzdGljLlxuICpcbiAqIEBwYXJhbSBhbW91bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBhY2NvbW1vZGF0ZS5cbiAqIEBwYXJhbSBbZ3Jvd1NpemVdIHRoZSBtaW5pbXVtIGFtb3VudCwgaW4gYnl0ZXMsIHRvIGdyb3cgdGhlIGJ1ZmZlciBieSBpZlxuICogICAgICAgICAgbmVjZXNzYXJ5LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmFjY29tbW9kYXRlID0gZnVuY3Rpb24oYW1vdW50LCBncm93U2l6ZSkge1xuICBpZih0aGlzLmxlbmd0aCgpID49IGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyb3dTaXplID0gTWF0aC5tYXgoZ3Jvd1NpemUgfHwgdGhpcy5ncm93U2l6ZSwgYW1vdW50KTtcblxuICAvLyBncm93IGJ1ZmZlclxuICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgdGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLmJ5dGVPZmZzZXQsIHRoaXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKyBncm93U2l6ZSk7XG4gIGRzdC5zZXQoc3JjKTtcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGRzdC5idWZmZXIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICB0aGlzLmFjY29tbW9kYXRlKDEpO1xuICB0aGlzLmRhdGEuc2V0VWludDgodGhpcy53cml0ZSsrLCBiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHRoaXMuZGF0YS5zZXRVaW50OChiKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci4gVGhlIGJ5dGVzIG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZywgYW5cbiAqIEFycmF5QnVmZmVyLCBhIERhdGFWaWV3LCBvciBhIFR5cGVkQXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBwdXQuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXIgKCdiaW5hcnknLCAndXRmOCcsXG4gKiAgICAgICAgICAndXRmMTYnLCAnaGV4JyksIGlmIGl0IGlzIGEgc3RyaW5nIChkZWZhdWx0OiAnYmluYXJ5JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzLCBlbmNvZGluZykge1xuICBpZih1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBsZW4gPSBzcmMuYnl0ZUxlbmd0aCAtIHNyYy5ieXRlT2Zmc2V0O1xuICAgIHRoaXMuYWNjb21tb2RhdGUobGVuKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyKGJ5dGVzKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpO1xuICAgIGRzdC5zZXQoc3JjLCB0aGlzLndyaXRlKTtcbiAgICB0aGlzLndyaXRlICs9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gYnl0ZXMgaXMgYSB1dGlsLkRhdGFCdWZmZXIgb3IgZXF1aXZhbGVudFxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuRGF0YUJ1ZmZlciB8fFxuICAgICh0eXBlb2YgYnl0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGJ5dGVzLnJlYWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBieXRlcy53cml0ZSA9PT0gJ251bWJlcicgJiZcbiAgICB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzLmRhdGEpKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIGJ5dGVzLnJlYWQsIGJ5dGVzLmxlbmd0aCgpKTtcbiAgICB0aGlzLmFjY29tbW9kYXRlKHNyYy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCB0aGlzLndyaXRlKTtcbiAgICBkc3Quc2V0KHNyYyk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKGJ5dGVzIGluc3RhbmNlb2YgdXRpbC5CeXRlU3RyaW5nQnVmZmVyKSB7XG4gICAgLy8gY29weSBiaW5hcnkgc3RyaW5nIGFuZCBwcm9jZXNzIGFzIHRoZSBzYW1lIGFzIGEgc3RyaW5nIHBhcmFtZXRlciBiZWxvd1xuICAgIGJ5dGVzID0gYnl0ZXMuZGF0YTtcbiAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICB9XG5cbiAgLy8gc3RyaW5nIGNvbnZlcnNpb25cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2aWV3O1xuXG4gICAgLy8gZGVjb2RlIGZyb20gc3RyaW5nXG4gICAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChieXRlcy5sZW5ndGggLyAyKSk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmhleC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gNCkgKiAzKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZShieXRlcywgdmlldywgdGhpcy53cml0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdGV4dCBhcyBVVEYtOCBieXRlc1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIC8vIGVuY29kZSBhcyBVVEYtOCB0aGVuIGRlY29kZSBzdHJpbmcgYXMgcmF3IGJpbmFyeVxuICAgICAgYnl0ZXMgPSB1dGlsLmVuY29kZVV0ZjgoYnl0ZXMpO1xuICAgICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB9XG5cbiAgICAvLyBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgICAvLyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LnJhdy5kZWNvZGUodmlldyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdGV4dCBhcyBVVEYtMTYgYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgICAgLy8gdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXJcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoYnl0ZXMubGVuZ3RoICogMik7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLnRleHQudXRmMTYuZW5jb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG5cbiAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5wdXRCeXRlcyhidWZmZXIpO1xuICBidWZmZXIuY2xlYXIoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzdHJpbmcgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgc3RyaW5nIChkZWZhdWx0OiAndXRmMTYnKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhzdHIsICd1dGYxNicpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNiA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkpO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkgPj4gOCAmIDB4RkZGRik7XG4gIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUsIGkgPj4gMTYgJiAweEZGKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YS5zZXRJbnQzMih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYsIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB0aGlzLmFjY29tbW9kYXRlKG4gLyA4KTtcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlKyssIChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuIFR3bydzXG4gKiBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQgKyAyKSk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCwgdHJ1ZSk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCArIDEsIHRydWUpIDw8IDgpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZVxuICogcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBydmFsID0gMDtcbiAgZG8ge1xuICAgIC8vIFRPRE86IFVzZSAocnZhbCAqIDB4MTAwKSBpZiBhZGRpbmcgc3VwcG9ydCBmb3IgMzMgdG8gNTMgYml0cy5cbiAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG4gICAgbiAtPSA4O1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIsIHVzaW5nXG4gKiB0d28ncyBjb21wbGVtZW50LCBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgLy8gZ2V0SW50IGNoZWNrcyBuXG4gIHZhciB4ID0gdGhpcy5nZXRJbnQobik7XG4gIHZhciBtYXggPSAyIDw8IChuIC0gMik7XG4gIGlmKHggPj0gbWF4KSB7XG4gICAgeCAtPSBtYXggPDwgMTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZXMgb3V0IGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZVxuICogYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkIGFuZFxuICAvLyB0aGlzLnRvU3RyaW5nKCdiaW5hcnknKSByZXBsYWNlcyBpdFxuICAvLyBhZGQgYSB0b1R5cGVkQXJyYXkoKS90b0FycmF5QnVmZmVyKCkgZnVuY3Rpb25cbiAgdmFyIHJ2YWw7XG4gIGlmKGNvdW50KSB7XG4gICAgLy8gcmVhZCBjb3VudCBieXRlc1xuICAgIGNvdW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgoKSwgY291bnQpO1xuICAgIHJ2YWwgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCk7XG4gICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICB9IGVsc2UgaWYoY291bnQgPT09IDApIHtcbiAgICBydmFsID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBhbGwgYnl0ZXMsIG9wdGltaXplIHRvIG9ubHkgY29weSB3aGVuIG5lZWRlZFxuICAgIHJ2YWwgPSAodGhpcy5yZWFkID09PSAwKSA/IHRoaXMuZGF0YSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0XG4gKiBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgYmluYXJ5IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwb3B1bGF0ZSB0aGVcbiAqIGJ1ZmZlciB3aXRoIGRhdGEuIFRoaXMgdmFsdWUgY2FuIGVpdGhlciBiZSBzdHJpbmcgb2YgZW5jb2RlZCBieXRlcyBvciBhXG4gKiByZWd1bGFyIHN0cmluZyBvZiBjaGFyYWN0ZXJzLiBXaGVuIHBhc3NpbmcgYSBzdHJpbmcgb2YgYmluYXJ5IGVuY29kZWRcbiAqIGJ5dGVzLCB0aGUgZW5jb2RpbmcgYHJhd2Agc2hvdWxkIGJlIGdpdmVuLiBUaGlzIGlzIGFsc28gdGhlIGRlZmF1bHQuIFdoZW5cbiAqIHBhc3NpbmcgYSBzdHJpbmcgb2YgY2hhcmFjdGVycywgdGhlIGVuY29kaW5nIGB1dGY4YCBzaG91bGQgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIFtpbnB1dF0gYSBzdHJpbmcgd2l0aCBlbmNvZGVkIGJ5dGVzIHRvIHN0b3JlIGluIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBvZiBjaGFyYWN0ZXJzIChhIHN0YW5kYXJkIEphdmFTY3JpcHRcbiAqIHN0cmluZykgYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgd2hlcmUgdGhlIGJ5dGVzIHJlcHJlc2VudFxuICogYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiBjaGFyYWN0ZXJzLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlXG4gKiBlbmNvZGVkIGFzIG11bHRpcGxlIGJ5dGVzIGFjY29yZGluZyB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIGEgc3RhbmRhcmQgc3RyaW5nIG9mIGNoYXJhY3RlcnMgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5lbmNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgdGhhdCBjb250YWlucyBieXRlcyB0aGF0XG4gKiByZXByZXNlbnQgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIC0tIGludG8gYVxuICogc3RyaW5nIG9mIGNoYXJhY3RlcnMgKGEgc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0YW5kYXJkIHN0cmluZyBvZiBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmRlY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59O1xuXG4vLyBiaW5hcnkgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC5iaW5hcnkgPSB7XG4gIHJhdzoge30sXG4gIGhleDoge30sXG4gIGJhc2U2NDoge30sXG4gIGJhc2U1ODoge30sXG4gIGJhc2VOIDoge1xuICAgIGVuY29kZTogYmFzZU4uZW5jb2RlLFxuICAgIGRlY29kZTogYmFzZU4uZGVjb2RlXG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIFVpbnQ4QXJyYXkgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5lbmNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LiBUaGlzIGVuY29kaW5nIHVzZXNcbiAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5yYXcuZGVjb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgJ2JpbmFyeScgc3RyaW5nLCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIFR5cGVkQXJyYXksIG9yXG4gKiBCeXRlQnVmZmVyIGFzIGEgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmJpbmFyeS5oZXguZW5jb2RlID0gdXRpbC5ieXRlc1RvSGV4O1xuXG4vKipcbiAqIERlY29kZXMgYSBoZXgtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuaGV4LmRlY29kZSA9IGZ1bmN0aW9uKGhleCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMikpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG4gIGlmKGhleC5sZW5ndGggJiAxKSB7XG4gICAgLy8gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBjb252ZXJ0IGZpcnN0IGNoYXJhY3RlciBhbG9uZVxuICAgIGkgPSAxO1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4WzBdLCAxNik7XG4gIH1cbiAgLy8gY29udmVydCAyIGNoYXJhY3RlcnMgKDEgYnl0ZSkgYXQgYSB0aW1lXG4gIGZvcig7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQtZW5jb2RlcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQgc3RyaW5nLlxuICovXG51dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZShpIDwgaW5wdXQuYnl0ZUxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgIGNocjMgPSBpbnB1dFtpKytdO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2U2NC1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA0KSAqIDMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFsbCBub24tYmFzZTY0IGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRbaisrXSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgaWYoZW5jMyAhPT0gNjQpIHtcbiAgICAgIC8vIGRlY29kZWQgYXQgbGVhc3QgMiBieXRlc1xuICAgICAgb3V0W2orK10gPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRbaisrXSA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgcmVzdWx0IGlzIHRoZSBleGFjdCBkZWNvZGVkIGxlbmd0aFxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0LnN1YmFycmF5KDAsIGopO1xufTtcblxuLy8gYWRkIHN1cHBvcnQgZm9yIGJhc2U1OCBlbmNvZGluZy9kZWNvZGluZyB3aXRoIEJpdGNvaW4gYWxwaGFiZXRcbnV0aWwuYmluYXJ5LmJhc2U1OC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZW5jb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG51dGlsLmJpbmFyeS5iYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmRlY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG59O1xuXG4vLyB0ZXh0IGVuY29kaW5nL2RlY29kaW5nIHRvb2xzXG4vLyBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbnV0aWwudGV4dCA9IHtcbiAgdXRmODoge30sXG4gIHV0ZjE2OiB7fVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTggaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmOC5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHN0ciA9IHV0aWwuZW5jb2RlVXRmOChzdHIpO1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtOCBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGY4LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcykpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTE2IGluIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC50ZXh0LnV0ZjE2LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGggKiAyKTtcbiAgfVxuICB2YXIgdmlldyA9IG5ldyBVaW50MTZBcnJheShvdXQuYnVmZmVyKTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICB2YXIgayA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIHZpZXdbaysrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGogKz0gMjtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtMTYgY29udGVudHMgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICovXG51dGlsLnRleHQudXRmMTYuZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpO1xufTtcblxuLyoqXG4gKiBEZWZsYXRlcyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyBhIGZsYXNoIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGRhdGEuXG4gKiBAcGFyYW0gcmF3IHRydWUgdG8gcmV0dXJuIG9ubHkgcmF3IGRlZmxhdGUgZGF0YSwgZmFsc2UgdG8gaW5jbHVkZSB6bGliXG4gKiAgICAgICAgICBoZWFkZXIgYW5kIHRyYWlsZXIuXG4gKlxuICogQHJldHVybiB0aGUgZGVmbGF0ZWQgZGF0YSBhcyBhIHN0cmluZy5cbiAqL1xudXRpbC5kZWZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIGJ5dGVzID0gdXRpbC5kZWNvZGU2NChhcGkuZGVmbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbCk7XG5cbiAgLy8gc3RyaXAgemxpYiBoZWFkZXIgYW5kIHRyYWlsZXIgaWYgbmVjZXNzYXJ5XG4gIGlmKHJhdykge1xuICAgIC8vIHpsaWIgaGVhZGVyIGlzIDIgYnl0ZXMgKENNRixGTEcpIHdoZXJlIEZMRyBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vIHRoZXJlIGlzIGEgNC1ieXRlIERJQ1QgKGFsZGVyLTMyKSBibG9jayBiZWZvcmUgdGhlIGRhdGEgaWZcbiAgICAvLyBpdHMgNXRoIGJpdCBpcyBzZXRcbiAgICB2YXIgc3RhcnQgPSAyO1xuICAgIHZhciBmbGcgPSBieXRlcy5jaGFyQ29kZUF0KDEpO1xuICAgIGlmKGZsZyAmIDB4MjApIHtcbiAgICAgIHN0YXJ0ID0gNjtcbiAgICB9XG4gICAgLy8gemxpYiB0cmFpbGVyIGlzIDQgYnl0ZXMgb2YgYWRsZXItMzJcbiAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZyhzdGFydCwgYnl0ZXMubGVuZ3RoIC0gNCk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIEluZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSBpZiB0aGUgaW5jb21pbmcgZGF0YSBoYXMgbm8gemxpYiBoZWFkZXIgb3IgdHJhaWxlciBhbmQgaXNcbiAqICAgICAgICAgIHJhdyBERUZMQVRFIGRhdGEuXG4gKlxuICogQHJldHVybiB0aGUgaW5mbGF0ZWQgZGF0YSBhcyBhIHN0cmluZywgbnVsbCBvbiBlcnJvci5cbiAqL1xudXRpbC5pbmZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIC8vIFRPRE86IGFkZCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnkvcG9zc2libGVcbiAgdmFyIHJ2YWwgPSBhcGkuaW5mbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbDtcbiAgcmV0dXJuIChydmFsID09PSBudWxsKSA/IG51bGwgOiB1dGlsLmRlY29kZTY0KHJ2YWwpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIG9iaiB0aGUgc3RvcmFnZSBvYmplY3QsIG51bGwgdG8gcmVtb3ZlLlxuICovXG52YXIgX3NldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkLCBvYmopIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgdmFyIHJ2YWw7XG4gIGlmKG9iaiA9PT0gbnVsbCkge1xuICAgIHJ2YWwgPSBhcGkucmVtb3ZlSXRlbShpZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8ganNvbi1lbmNvZGUgYW5kIGJhc2U2NC1lbmNvZGUgb2JqZWN0XG4gICAgb2JqID0gdXRpbC5lbmNvZGU2NChKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICBydmFsID0gYXBpLnNldEl0ZW0oaWQsIG9iaik7XG4gIH1cblxuICAvLyBoYW5kbGUgcG90ZW50aWFsIGZsYXNoIGVycm9yXG4gIGlmKHR5cGVvZihydmFsKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcnZhbC5ydmFsICE9PSB0cnVlKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIHN0b3JhZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdG9yYWdlIG9iamVjdCBlbnRyeSBvciBudWxsIGlmIG5vbmUgZXhpc3RzLlxuICovXG52YXIgX2dldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkKSB7XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgZXhpc3RpbmcgZW50cnlcbiAgdmFyIHJ2YWwgPSBhcGkuZ2V0SXRlbShpZCk7XG5cbiAgLyogTm90ZTogV2UgY2hlY2sgYXBpLmluaXQgYmVjYXVzZSB3ZSBjYW4ndCBkbyAoYXBpID09IGxvY2FsU3RvcmFnZSlcbiAgICBvbiBJRSBiZWNhdXNlIG9mIFwiQ2xhc3MgZG9lc24ndCBzdXBwb3J0IEF1dG9tYXRpb25cIiBleGNlcHRpb24uIE9ubHlcbiAgICB0aGUgZmxhc2ggYXBpIGhhcyBhbiBpbml0IG1ldGhvZCBzbyB0aGlzIHdvcmtzIHRvbywgYnV0IHdlIG5lZWQgYVxuICAgIGJldHRlciBzb2x1dGlvbiBpbiB0aGUgZnV0dXJlLiAqL1xuXG4gIC8vIGZsYXNoIHJldHVybnMgaXRlbSB3cmFwcGVkIGluIGFuIG9iamVjdCwgaGFuZGxlIHNwZWNpYWwgY2FzZVxuICBpZihhcGkuaW5pdCkge1xuICAgIGlmKHJ2YWwucnZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYocnZhbC5lcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgICAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIG5vIGVycm9yLCBidXQgYWxzbyBubyBpdGVtXG4gICAgICBydmFsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCA9IHJ2YWwucnZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZGVjb2RpbmdcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIGJhc2U2NC1kZWNvZGUgYW5kIGpzb24tZGVjb2RlIGRhdGFcbiAgICBydmFsID0gSlNPTi5wYXJzZSh1dGlsLmRlY29kZTY0KHJ2YWwpKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBpbiBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICovXG52YXIgX3NldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHN0b3JhZ2Ugb2JqZWN0XG4gICAgb2JqID0ge307XG4gIH1cbiAgLy8gdXBkYXRlIGtleVxuICBvYmpba2V5XSA9IGRhdGE7XG5cbiAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG9iaik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG52YXIgX2dldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBydmFsID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKHJ2YWwgIT09IG51bGwpIHtcbiAgICAvLyByZXR1cm4gZGF0YSBhdCBrZXlcbiAgICBydmFsID0gKGtleSBpbiBydmFsKSA/IHJ2YWxba2V5XSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICovXG52YXIgX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqICE9PSBudWxsICYmIGtleSBpbiBvYmopIHtcbiAgICAvLyByZW1vdmUga2V5XG4gICAgZGVsZXRlIG9ialtrZXldO1xuXG4gICAgLy8gc2VlIGlmIGVudHJ5IGhhcyBubyBrZXlzIHJlbWFpbmluZ1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZihlbXB0eSkge1xuICAgICAgLy8gcmVtb3ZlIGVudHJ5IGVudGlyZWx5IGlmIG5vIGtleXMgYXJlIGxlZnRcbiAgICAgIG9iaiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gICAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKi9cbnZhciBfY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgc3RvcmFnZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBsb2NhdGlvbiB0aGUgbG9jYXRpb24gYXJndW1lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uLlxuICovXG52YXIgX2NhbGxTdG9yYWdlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzLCBsb2NhdGlvbikge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZGVmYXVsdCBzdG9yYWdlIHR5cGVzXG4gIGlmKHR5cGVvZihsb2NhdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYXRpb24gPSBbJ3dlYicsICdmbGFzaCddO1xuICB9XG5cbiAgLy8gYXBwbHkgc3RvcmFnZSB0eXBlcyBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gIHZhciB0eXBlO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgZXhjZXB0aW9uID0gbnVsbDtcbiAgZm9yKHZhciBpZHggaW4gbG9jYXRpb24pIHtcbiAgICB0eXBlID0gbG9jYXRpb25baWR4XTtcbiAgICB0cnkge1xuICAgICAgaWYodHlwZSA9PT0gJ2ZsYXNoJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYoYXJnc1swXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhc2ggbG9jYWwgc3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gKHR5cGUgPT09ICdmbGFzaCcpO1xuICAgICAgfVxuICAgICAgaWYodHlwZSA9PT0gJ3dlYicgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBsb2NhbFN0b3JhZ2U7XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGV4KSB7XG4gICAgICBleGNlcHRpb24gPSBleDtcbiAgICB9XG4gICAgaWYoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoIWRvbmUpIHtcbiAgICB0aHJvdyBleGNlcHRpb247XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU3RvcmVzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIHR5cGVzIG9mIGxvY2FsIHN0b3JhZ2UgaW5jbHVkZSAnZmxhc2gnLCAnd2ViJywgYW5kICdib3RoJy5cbiAqXG4gKiBUaGUgdHlwZSAnZmxhc2gnIHJlZmVycyB0byBmbGFzaCBsb2NhbCBzdG9yYWdlIChTaGFyZWRPYmplY3QpLiBJbiBvcmRlclxuICogdG8gdXNlIGZsYXNoIGxvY2FsIHN0b3JhZ2UsIHRoZSAnYXBpJyBwYXJhbWV0ZXIgbXVzdCBiZSB2YWxpZC4gVGhlIHR5cGVcbiAqICd3ZWInIHJlZmVycyB0byBXZWJTdG9yYWdlLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSB0eXBlICdib3RoJ1xuICogcmVmZXJzIHRvIHN0b3JpbmcgdXNpbmcgYm90aCAnZmxhc2gnIGFuZCAnd2ViJywgbm90IGp1c3Qgb25lIG9yIHRoZVxuICogb3RoZXIuXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IHNob3VsZCBsaXN0IHRoZSBzdG9yYWdlIHR5cGVzIHRvIHVzZSBpbiBvcmRlciBvZlxuICogcHJlZmVyZW5jZTpcbiAqXG4gKiBbJ2ZsYXNoJ106IGZsYXNoIG9ubHkgc3RvcmFnZVxuICogWyd3ZWInXTogd2ViIG9ubHkgc3RvcmFnZVxuICogWydib3RoJ106IHRyeSB0byBzdG9yZSBpbiBib3RoXG4gKiBbJ2ZsYXNoJywnd2ViJ106IHN0b3JlIGluIGZsYXNoIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ3dlYidcbiAqIFsnd2ViJywnZmxhc2gnXTogc3RvcmUgaW4gd2ViIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ2ZsYXNoJ1xuICpcbiAqIFRoZSBsb2NhdGlvbiBhcnJheSBkZWZhdWx0cyB0bzogWyd3ZWInLCAnZmxhc2gnXVxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5zZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBkYXRhLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfc2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UsIG51bGwgdG8gdXNlIG9ubHkgV2ViU3RvcmFnZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG51dGlsLmdldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gIHJldHVybiBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfZ2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3JlbW92ZUl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlIGlmIGZsYXNoIGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLmNsZWFySXRlbXMgPSBmdW5jdGlvbihhcGksIGlkLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfY2xlYXJJdGVtcywgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJiYXNlTiIsInV0aWwiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiYnJvd3NlciIsInNldEltbWVkaWF0ZSIsImFwcGx5IiwidW5kZWZpbmVkIiwiYXJndW1lbnRzIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0Iiwid2luZG93IiwicG9zdE1lc3NhZ2UiLCJtc2ciLCJjYWxsYmFja3MiLCJwdXNoIiwibGVuZ3RoIiwiaGFuZGxlciIsImV2ZW50Iiwic291cmNlIiwiZGF0YSIsInN0b3BQcm9wYWdhdGlvbiIsImNvcHkiLCJzbGljZSIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm5vdyIsIkRhdGUiLCJhdHRyIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJvbGRTZXRJbW1lZGlhdGUiLCJzZXRBdHRyaWJ1dGUiLCJpc05vZGVqcyIsInZlcnNpb25zIiwibm9kZSIsImdsb2JhbFNjb3BlIiwiZ2xvYmFsIiwic2VsZiIsImlzQXJyYXkiLCJBcnJheSIsIngiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc0FycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyVmlldyIsImJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJfY2hlY2tCaXRzUGFyYW0iLCJuIiwiRXJyb3IiLCJCeXRlQnVmZmVyIiwiQnl0ZVN0cmluZ0J1ZmZlciIsImIiLCJyZWFkIiwiQnVmZmVyIiwiYXJyIiwiVWludDhBcnJheSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImUiLCJpIiwicHV0Qnl0ZSIsIl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCIsIl9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCIsIl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nIiwic3Vic3RyIiwiaXNFbXB0eSIsInB1dEJ5dGVzIiwiZmlsbFdpdGhCeXRlIiwiZCIsImJ5dGVzIiwicHV0U3RyaW5nIiwic3RyIiwiZW5jb2RlVXRmOCIsInB1dEludDE2IiwicHV0SW50MjQiLCJwdXRJbnQzMiIsInB1dEludDE2TGUiLCJwdXRJbnQyNExlIiwicHV0SW50MzJMZSIsInB1dEludCIsInB1dFNpZ25lZEludCIsInB1dEJ1ZmZlciIsImdldEJ5dGVzIiwiZ2V0Qnl0ZSIsImNoYXJDb2RlQXQiLCJnZXRJbnQxNiIsInJ2YWwiLCJnZXRJbnQyNCIsImdldEludDMyIiwiZ2V0SW50MTZMZSIsImdldEludDI0TGUiLCJnZXRJbnQzMkxlIiwiZ2V0SW50IiwiZ2V0U2lnbmVkSW50IiwibWF4IiwiY291bnQiLCJNYXRoIiwibWluIiwiY2xlYXIiLCJhdCIsInNldEF0IiwibGFzdCIsImMiLCJjcmVhdGVCdWZmZXIiLCJjb21wYWN0IiwidHJ1bmNhdGUiLCJsZW4iLCJ0b0hleCIsImRlY29kZVV0ZjgiLCJEYXRhQnVmZmVyIiwib3B0aW9ucyIsInJlYWRPZmZzZXQiLCJncm93U2l6ZSIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsIndyaXRlIiwid3JpdGVPZmZzZXQiLCJhY2NvbW1vZGF0ZSIsImFtb3VudCIsInNyYyIsImRzdCIsInNldCIsInNldFVpbnQ4IiwiZW5jb2RpbmciLCJ2aWV3IiwiY2VpbCIsImJpbmFyeSIsImhleCIsImRlY29kZSIsImJhc2U2NCIsInJhdyIsIlVpbnQxNkFycmF5IiwidGV4dCIsInV0ZjE2IiwiZW5jb2RlIiwic2V0SW50MTYiLCJzZXRJbnQ4Iiwic2V0SW50MzIiLCJnZXRJbnQ4IiwiZ2V0VWludDgiLCJ1dGY4IiwiaW5wdXQiLCJmaWxsU3RyaW5nIiwicyIsInhvckJ5dGVzIiwiczEiLCJzMiIsInMzIiwidCIsImhleFRvQnl0ZXMiLCJwYXJzZUludCIsImJ5dGVzVG9IZXgiLCJpbnQzMlRvQnl0ZXMiLCJfYmFzZTY0IiwiX2Jhc2U2NElkeCIsIl9iYXNlNTgiLCJlbmNvZGU2NCIsIm1heGxpbmUiLCJsaW5lIiwib3V0cHV0IiwiY2hyMSIsImNocjIiLCJjaHIzIiwiY2hhckF0IiwiaXNOYU4iLCJkZWNvZGU2NCIsInJlcGxhY2UiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJiYXNlNTgiLCJvZmZzZXQiLCJvdXQiLCJqIiwic3ViYXJyYXkiLCJrIiwiZGVmbGF0ZSIsImFwaSIsInN0YXJ0IiwiZmxnIiwic3Vic3RyaW5nIiwiaW5mbGF0ZSIsIl9zZXRTdG9yYWdlT2JqZWN0IiwiaWQiLCJvYmoiLCJyZW1vdmVJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldEl0ZW0iLCJlcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwiX2dldFN0b3JhZ2VPYmplY3QiLCJnZXRJdGVtIiwiaW5pdCIsInBhcnNlIiwiX3NldEl0ZW0iLCJrZXkiLCJfZ2V0SXRlbSIsIl9yZW1vdmVJdGVtIiwiZW1wdHkiLCJwcm9wIiwiX2NsZWFySXRlbXMiLCJfY2FsbFN0b3JhZ2VGdW5jdGlvbiIsImZ1bmMiLCJhcmdzIiwibG9jYXRpb24iLCJ0eXBlIiwiZG9uZSIsImV4Y2VwdGlvbiIsImlkeCIsImxvY2FsU3RvcmFnZSIsImV4IiwiY2xlYXJJdGVtcyIsImhhc093blByb3BlcnR5IiwiZm9ybWF0IiwicmUiLCJtYXRjaCIsInBhcnQiLCJhcmdpIiwicGFydHMiLCJleGVjIiwibGFzdEluZGV4IiwiY29kZSIsImpvaW4iLCJmb3JtYXROdW1iZXIiLCJudW1iZXIiLCJkZWNpbWFscyIsImRlY19wb2ludCIsInRob3VzYW5kc19zZXAiLCJhYnMiLCJ0b0ZpeGVkIiwiZm9ybWF0U2l6ZSIsInNpemUiLCJieXRlc0Zyb21JUCIsImlwIiwiaW5kZXhPZiIsImJ5dGVzRnJvbUlQdjQiLCJieXRlc0Zyb21JUHY2Iiwic3BsaXQiLCJudW0iLCJibGFua3MiLCJmaWx0ZXIiLCJ6ZXJvcyIsImJ5dGVzVG9JUCIsImJ5dGVzVG9JUHY0IiwiYnl0ZXNUb0lQdjYiLCJ6ZXJvR3JvdXBzIiwiemVyb01heEdyb3VwIiwiZW5kIiwiZ3JvdXAiLCJzcGxpY2UiLCJ1bnNoaWZ0IiwiZXN0aW1hdGVDb3JlcyIsInVwZGF0ZSIsImNvcmVzIiwibmF2aWdhdG9yIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsIldvcmtlciIsIkJsb2IiLCJibG9iVXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic3QiLCJldCIsInNhbXBsZSIsInNhbXBsZXMiLCJudW1Xb3JrZXJzIiwiYXZnIiwiZmxvb3IiLCJyZWR1Y2UiLCJyZXZva2VPYmplY3RVUkwiLCJtYXAiLCJlcnIiLCJyZXN1bHRzIiwid29ya2VycyIsIndvcmtlciIsInRlcm1pbmF0ZSIsIm92ZXJsYXBzIiwicjEiLCJvdmVybGFwIiwicjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-forge/lib/util.js\n");

/***/ })

};
;