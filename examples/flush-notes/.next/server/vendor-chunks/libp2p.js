"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/libp2p";
exports.ids = ["vendor-chunks/libp2p"];
exports.modules = {

/***/ "(ssr)/./node_modules/libp2p/dist/src/address-manager/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/address-manager/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultAddressManager: () => (/* binding */ DefaultAddressManager)\n/* harmony export */ });\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/peer-id */ \"(ssr)/./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/libp2p/dist/src/address-manager/utils.js\");\n\n\n\nconst defaultAddressFilter = (addrs)=>addrs;\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */ function stripPeerId(ma, peerId) {\n    const observedPeerIdStr = ma.getPeerId();\n    // strip our peer id if it has been passed\n    if (observedPeerIdStr != null) {\n        const observedPeerId = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(observedPeerIdStr);\n        // use same encoding for comparison\n        if (observedPeerId.equals(peerId)) {\n            ma = ma.decapsulate((0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(`/p2p/${peerId.toString()}`));\n        }\n    }\n    return ma;\n}\nclass DefaultAddressManager {\n    /**\n     * Responsible for managing the peer addresses.\n     * Peers can specify their listen and announce addresses.\n     * The listen addresses will be used by the libp2p transports to listen for new connections,\n     * while the announce addresses will be used for the peer addresses' to other peers in the network.\n     */ constructor(components, init = {}){\n        const { listen = [], announce = [] } = init;\n        this.components = components;\n        this.log = components.logger.forComponent(\"libp2p:address-manager\");\n        this.listen = listen.map((ma)=>ma.toString());\n        this.announce = new Set(announce.map((ma)=>ma.toString()));\n        this.observed = new Map();\n        this.announceFilter = init.announceFilter ?? defaultAddressFilter;\n        // this method gets called repeatedly on startup when transports start listening so\n        // debounce it so we don't cause multiple self:peer:update events to be emitted\n        this._updatePeerStoreAddresses = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.debounce)(this._updatePeerStoreAddresses.bind(this), 1000);\n        // update our stored addresses when new transports listen\n        components.events.addEventListener(\"transport:listening\", ()=>{\n            this._updatePeerStoreAddresses();\n        });\n        // update our stored addresses when existing transports stop listening\n        components.events.addEventListener(\"transport:close\", ()=>{\n            this._updatePeerStoreAddresses();\n        });\n    }\n    _updatePeerStoreAddresses() {\n        // if announce addresses have been configured, ensure they make it into our peer\n        // record for things like identify\n        const addrs = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([\n            ...this.observed.entries()\n        ].filter(([_, metadata])=>metadata.confident).map(([str])=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(str))).map((ma)=>{\n            // strip our peer id if it is present\n            if (ma.getPeerId() === this.components.peerId.toString()) {\n                return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);\n            }\n            return ma;\n        });\n        this.components.peerStore.patch(this.components.peerId, {\n            multiaddrs: addrs\n        }).catch((err)=>{\n            this.log.error(\"error updating addresses\", err);\n        });\n    }\n    /**\n     * Get peer listen multiaddrs\n     */ getListenAddrs() {\n        return Array.from(this.listen).map((a)=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a));\n    }\n    /**\n     * Get peer announcing multiaddrs\n     */ getAnnounceAddrs() {\n        return Array.from(this.announce).map((a)=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a));\n    }\n    /**\n     * Get observed multiaddrs\n     */ getObservedAddrs() {\n        return Array.from(this.observed).map(([a])=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a));\n    }\n    /**\n     * Add peer observed addresses\n     */ addObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        // do not trigger the change:addresses event if we already know about this address\n        if (this.observed.has(addrString)) {\n            return;\n        }\n        this.observed.set(addrString, {\n            confident: false\n        });\n    }\n    confirmObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        const metadata = this.observed.get(addrString) ?? {\n            confident: false\n        };\n        const startingConfidence = metadata.confident;\n        this.observed.set(addrString, {\n            confident: true\n        });\n        // only trigger the 'self:peer:update' event if our confidence in an address has changed\n        if (!startingConfidence) {\n            this._updatePeerStoreAddresses();\n        }\n    }\n    removeObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        this.observed.delete(addrString);\n    }\n    getAddresses() {\n        let addrs = this.getAnnounceAddrs().map((ma)=>ma.toString());\n        if (addrs.length === 0) {\n            // no configured announce addrs, add configured listen addresses\n            addrs = this.components.transportManager.getAddrs().map((ma)=>ma.toString());\n        }\n        // add observed addresses we are confident in\n        addrs = addrs.concat(Array.from(this.observed).filter(([ma, metadata])=>metadata.confident).map(([ma])=>ma));\n        // dedupe multiaddrs\n        const addrSet = new Set(addrs);\n        // Create advertising list\n        return this.announceFilter(Array.from(addrSet).map((str)=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(str))).map((ma)=>{\n            // do not append our peer id to a path multiaddr as it will become invalid\n            if (ma.protos().pop()?.path === true) {\n                return ma;\n            }\n            if (ma.getPeerId() === this.components.peerId.toString()) {\n                return ma;\n            }\n            return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);\n        });\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2FkZHJlc3MtbWFuYWdlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBQ0M7QUFDZDtBQUN0QyxNQUFNRyx1QkFBdUIsQ0FBQ0MsUUFBVUE7QUFDeEM7O0NBRUMsR0FDRCxTQUFTQyxZQUFZQyxFQUFFLEVBQUVDLE1BQU07SUFDM0IsTUFBTUMsb0JBQW9CRixHQUFHRyxTQUFTO0lBQ3RDLDBDQUEwQztJQUMxQyxJQUFJRCxxQkFBcUIsTUFBTTtRQUMzQixNQUFNRSxpQkFBaUJWLGlFQUFnQkEsQ0FBQ1E7UUFDeEMsbUNBQW1DO1FBQ25DLElBQUlFLGVBQWVDLE1BQU0sQ0FBQ0osU0FBUztZQUMvQkQsS0FBS0EsR0FBR00sV0FBVyxDQUFDWCxrRUFBU0EsQ0FBQyxDQUFDLEtBQUssRUFBRU0sT0FBT00sUUFBUSxHQUFHLENBQUM7UUFDN0Q7SUFDSjtJQUNBLE9BQU9QO0FBQ1g7QUFDTyxNQUFNUTtJQVFUOzs7OztLQUtDLEdBQ0RDLFlBQVlDLFVBQVUsRUFBRUMsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUMvQixNQUFNLEVBQUVDLFNBQVMsRUFBRSxFQUFFQyxXQUFXLEVBQUUsRUFBRSxHQUFHRjtRQUN2QyxJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDSSxHQUFHLEdBQUdKLFdBQVdLLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDO1FBQzFDLElBQUksQ0FBQ0osTUFBTSxHQUFHQSxPQUFPSyxHQUFHLENBQUNqQixDQUFBQSxLQUFNQSxHQUFHTyxRQUFRO1FBQzFDLElBQUksQ0FBQ00sUUFBUSxHQUFHLElBQUlLLElBQUlMLFNBQVNJLEdBQUcsQ0FBQ2pCLENBQUFBLEtBQU1BLEdBQUdPLFFBQVE7UUFDdEQsSUFBSSxDQUFDWSxRQUFRLEdBQUcsSUFBSUM7UUFDcEIsSUFBSSxDQUFDQyxjQUFjLEdBQUdWLEtBQUtVLGNBQWMsSUFBSXhCO1FBQzdDLG1GQUFtRjtRQUNuRiwrRUFBK0U7UUFDL0UsSUFBSSxDQUFDeUIseUJBQXlCLEdBQUcxQixtREFBUUEsQ0FBQyxJQUFJLENBQUMwQix5QkFBeUIsQ0FBQ0MsSUFBSSxDQUFDLElBQUksR0FBRztRQUNyRix5REFBeUQ7UUFDekRiLFdBQVdjLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsdUJBQXVCO1lBQ3RELElBQUksQ0FBQ0gseUJBQXlCO1FBQ2xDO1FBQ0Esc0VBQXNFO1FBQ3RFWixXQUFXYyxNQUFNLENBQUNDLGdCQUFnQixDQUFDLG1CQUFtQjtZQUNsRCxJQUFJLENBQUNILHlCQUF5QjtRQUNsQztJQUNKO0lBQ0FBLDRCQUE0QjtRQUN4QixnRkFBZ0Y7UUFDaEYsa0NBQWtDO1FBQ2xDLE1BQU14QixRQUFRLElBQUksQ0FBQzRCLGdCQUFnQixHQUM5QkMsTUFBTSxDQUFDLElBQUksQ0FBQ2pCLFVBQVUsQ0FBQ2tCLGdCQUFnQixDQUFDQyxRQUFRLElBQ2hERixNQUFNLENBQUM7ZUFBSSxJQUFJLENBQUNSLFFBQVEsQ0FBQ1csT0FBTztTQUFHLENBQ25DQyxNQUFNLENBQUMsQ0FBQyxDQUFDQyxHQUFHQyxTQUFTLEdBQUtBLFNBQVNDLFNBQVMsRUFDNUNqQixHQUFHLENBQUMsQ0FBQyxDQUFDa0IsSUFBSSxHQUFLeEMsa0VBQVNBLENBQUN3QyxPQUFPbEIsR0FBRyxDQUFDakIsQ0FBQUE7WUFDckMscUNBQXFDO1lBQ3JDLElBQUlBLEdBQUdHLFNBQVMsT0FBTyxJQUFJLENBQUNPLFVBQVUsQ0FBQ1QsTUFBTSxDQUFDTSxRQUFRLElBQUk7Z0JBQ3RELE9BQU9QLEdBQUdNLFdBQVcsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUNJLFVBQVUsQ0FBQ1QsTUFBTSxDQUFDTSxRQUFRLEdBQUcsQ0FBQztZQUNyRTtZQUNBLE9BQU9QO1FBQ1g7UUFDQSxJQUFJLENBQUNVLFVBQVUsQ0FBQzBCLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQzNCLFVBQVUsQ0FBQ1QsTUFBTSxFQUFFO1lBQ3BEcUMsWUFBWXhDO1FBQ2hCLEdBQ0t5QyxLQUFLLENBQUNDLENBQUFBO1lBQVMsSUFBSSxDQUFDMUIsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDRCQUE0QkQ7UUFBTTtJQUN6RTtJQUNBOztLQUVDLEdBQ0RFLGlCQUFpQjtRQUNiLE9BQU9DLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNoQyxNQUFNLEVBQUVLLEdBQUcsQ0FBQyxDQUFDNEIsSUFBTWxELGtFQUFTQSxDQUFDa0Q7SUFDeEQ7SUFDQTs7S0FFQyxHQUNEbkIsbUJBQW1CO1FBQ2YsT0FBT2lCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUMvQixRQUFRLEVBQUVJLEdBQUcsQ0FBQyxDQUFDNEIsSUFBTWxELGtFQUFTQSxDQUFDa0Q7SUFDMUQ7SUFDQTs7S0FFQyxHQUNEQyxtQkFBbUI7UUFDZixPQUFPSCxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDekIsUUFBUSxFQUFFRixHQUFHLENBQUMsQ0FBQyxDQUFDNEIsRUFBRSxHQUFLbEQsa0VBQVNBLENBQUNrRDtJQUM1RDtJQUNBOztLQUVDLEdBQ0RFLGdCQUFnQkMsSUFBSSxFQUFFO1FBQ2xCQSxPQUFPakQsWUFBWWlELE1BQU0sSUFBSSxDQUFDdEMsVUFBVSxDQUFDVCxNQUFNO1FBQy9DLE1BQU1nRCxhQUFhRCxLQUFLekMsUUFBUTtRQUNoQyxrRkFBa0Y7UUFDbEYsSUFBSSxJQUFJLENBQUNZLFFBQVEsQ0FBQytCLEdBQUcsQ0FBQ0QsYUFBYTtZQUMvQjtRQUNKO1FBQ0EsSUFBSSxDQUFDOUIsUUFBUSxDQUFDZ0MsR0FBRyxDQUFDRixZQUFZO1lBQzFCZixXQUFXO1FBQ2Y7SUFDSjtJQUNBa0Isb0JBQW9CSixJQUFJLEVBQUU7UUFDdEJBLE9BQU9qRCxZQUFZaUQsTUFBTSxJQUFJLENBQUN0QyxVQUFVLENBQUNULE1BQU07UUFDL0MsTUFBTWdELGFBQWFELEtBQUt6QyxRQUFRO1FBQ2hDLE1BQU0wQixXQUFXLElBQUksQ0FBQ2QsUUFBUSxDQUFDa0MsR0FBRyxDQUFDSixlQUFlO1lBQzlDZixXQUFXO1FBQ2Y7UUFDQSxNQUFNb0IscUJBQXFCckIsU0FBU0MsU0FBUztRQUM3QyxJQUFJLENBQUNmLFFBQVEsQ0FBQ2dDLEdBQUcsQ0FBQ0YsWUFBWTtZQUMxQmYsV0FBVztRQUNmO1FBQ0Esd0ZBQXdGO1FBQ3hGLElBQUksQ0FBQ29CLG9CQUFvQjtZQUNyQixJQUFJLENBQUNoQyx5QkFBeUI7UUFDbEM7SUFDSjtJQUNBaUMsbUJBQW1CUCxJQUFJLEVBQUU7UUFDckJBLE9BQU9qRCxZQUFZaUQsTUFBTSxJQUFJLENBQUN0QyxVQUFVLENBQUNULE1BQU07UUFDL0MsTUFBTWdELGFBQWFELEtBQUt6QyxRQUFRO1FBQ2hDLElBQUksQ0FBQ1ksUUFBUSxDQUFDcUMsTUFBTSxDQUFDUDtJQUN6QjtJQUNBUSxlQUFlO1FBQ1gsSUFBSTNELFFBQVEsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUdULEdBQUcsQ0FBQ2pCLENBQUFBLEtBQU1BLEdBQUdPLFFBQVE7UUFDekQsSUFBSVQsTUFBTTRELE1BQU0sS0FBSyxHQUFHO1lBQ3BCLGdFQUFnRTtZQUNoRTVELFFBQVEsSUFBSSxDQUFDWSxVQUFVLENBQUNrQixnQkFBZ0IsQ0FBQ0MsUUFBUSxHQUFHWixHQUFHLENBQUNqQixDQUFBQSxLQUFNQSxHQUFHTyxRQUFRO1FBQzdFO1FBQ0EsNkNBQTZDO1FBQzdDVCxRQUFRQSxNQUFNNkIsTUFBTSxDQUFDZ0IsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ3pCLFFBQVEsRUFDeENZLE1BQU0sQ0FBQyxDQUFDLENBQUMvQixJQUFJaUMsU0FBUyxHQUFLQSxTQUFTQyxTQUFTLEVBQzdDakIsR0FBRyxDQUFDLENBQUMsQ0FBQ2pCLEdBQUcsR0FBS0E7UUFDbkIsb0JBQW9CO1FBQ3BCLE1BQU0yRCxVQUFVLElBQUl6QyxJQUFJcEI7UUFDeEIsMEJBQTBCO1FBQzFCLE9BQU8sSUFBSSxDQUFDdUIsY0FBYyxDQUFDc0IsTUFBTUMsSUFBSSxDQUFDZSxTQUNqQzFDLEdBQUcsQ0FBQ2tCLENBQUFBLE1BQU94QyxrRUFBU0EsQ0FBQ3dDLE9BQ3JCbEIsR0FBRyxDQUFDakIsQ0FBQUE7WUFDTCwwRUFBMEU7WUFDMUUsSUFBSUEsR0FBRzRELE1BQU0sR0FBR0MsR0FBRyxJQUFJQyxTQUFTLE1BQU07Z0JBQ2xDLE9BQU85RDtZQUNYO1lBQ0EsSUFBSUEsR0FBR0csU0FBUyxPQUFPLElBQUksQ0FBQ08sVUFBVSxDQUFDVCxNQUFNLENBQUNNLFFBQVEsSUFBSTtnQkFDdEQsT0FBT1A7WUFDWDtZQUNBLE9BQU9BLEdBQUcrRCxXQUFXLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDckQsVUFBVSxDQUFDVCxNQUFNLENBQUNNLFFBQVEsR0FBRyxDQUFDO1FBQ3JFO0lBQ0o7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9hZGRyZXNzLW1hbmFnZXIvaW5kZXguanM/YTJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwZWVySWRGcm9tU3RyaW5nIH0gZnJvbSAnQGxpYnAycC9wZWVyLWlkJztcbmltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBkZWZhdWx0QWRkcmVzc0ZpbHRlciA9IChhZGRycykgPT4gYWRkcnM7XG4vKipcbiAqIElmIHRoZSBwYXNzZWQgbXVsdGlhZGRyIGNvbnRhaW5zIHRoZSBwYXNzZWQgcGVlciBpZCwgcmVtb3ZlIGl0XG4gKi9cbmZ1bmN0aW9uIHN0cmlwUGVlcklkKG1hLCBwZWVySWQpIHtcbiAgICBjb25zdCBvYnNlcnZlZFBlZXJJZFN0ciA9IG1hLmdldFBlZXJJZCgpO1xuICAgIC8vIHN0cmlwIG91ciBwZWVyIGlkIGlmIGl0IGhhcyBiZWVuIHBhc3NlZFxuICAgIGlmIChvYnNlcnZlZFBlZXJJZFN0ciAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVkUGVlcklkID0gcGVlcklkRnJvbVN0cmluZyhvYnNlcnZlZFBlZXJJZFN0cik7XG4gICAgICAgIC8vIHVzZSBzYW1lIGVuY29kaW5nIGZvciBjb21wYXJpc29uXG4gICAgICAgIGlmIChvYnNlcnZlZFBlZXJJZC5lcXVhbHMocGVlcklkKSkge1xuICAgICAgICAgICAgbWEgPSBtYS5kZWNhcHN1bGF0ZShtdWx0aWFkZHIoYC9wMnAvJHtwZWVySWQudG9TdHJpbmcoKX1gKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hO1xufVxuZXhwb3J0IGNsYXNzIERlZmF1bHRBZGRyZXNzTWFuYWdlciB7XG4gICAgbG9nO1xuICAgIGNvbXBvbmVudHM7XG4gICAgLy8gdGhpcyBpcyBhbiBhcnJheSB0byBhbGxvdyBmb3IgZHVwbGljYXRlcywgZS5nLiBtdWx0aXBsZXMgb2YgYC9pcDQvMC4wLjAuMC90Y3AvMGBcbiAgICBsaXN0ZW47XG4gICAgYW5ub3VuY2U7XG4gICAgb2JzZXJ2ZWQ7XG4gICAgYW5ub3VuY2VGaWx0ZXI7XG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHRoZSBwZWVyIGFkZHJlc3Nlcy5cbiAgICAgKiBQZWVycyBjYW4gc3BlY2lmeSB0aGVpciBsaXN0ZW4gYW5kIGFubm91bmNlIGFkZHJlc3Nlcy5cbiAgICAgKiBUaGUgbGlzdGVuIGFkZHJlc3NlcyB3aWxsIGJlIHVzZWQgYnkgdGhlIGxpYnAycCB0cmFuc3BvcnRzIHRvIGxpc3RlbiBmb3IgbmV3IGNvbm5lY3Rpb25zLFxuICAgICAqIHdoaWxlIHRoZSBhbm5vdW5jZSBhZGRyZXNzZXMgd2lsbCBiZSB1c2VkIGZvciB0aGUgcGVlciBhZGRyZXNzZXMnIHRvIG90aGVyIHBlZXJzIGluIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMsIGluaXQgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGxpc3RlbiA9IFtdLCBhbm5vdW5jZSA9IFtdIH0gPSBpbml0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLmxvZyA9IGNvbXBvbmVudHMubG9nZ2VyLmZvckNvbXBvbmVudCgnbGlicDJwOmFkZHJlc3MtbWFuYWdlcicpO1xuICAgICAgICB0aGlzLmxpc3RlbiA9IGxpc3Rlbi5tYXAobWEgPT4gbWEudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2UgPSBuZXcgU2V0KGFubm91bmNlLm1hcChtYSA9PiBtYS50b1N0cmluZygpKSk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VGaWx0ZXIgPSBpbml0LmFubm91bmNlRmlsdGVyID8/IGRlZmF1bHRBZGRyZXNzRmlsdGVyO1xuICAgICAgICAvLyB0aGlzIG1ldGhvZCBnZXRzIGNhbGxlZCByZXBlYXRlZGx5IG9uIHN0YXJ0dXAgd2hlbiB0cmFuc3BvcnRzIHN0YXJ0IGxpc3RlbmluZyBzb1xuICAgICAgICAvLyBkZWJvdW5jZSBpdCBzbyB3ZSBkb24ndCBjYXVzZSBtdWx0aXBsZSBzZWxmOnBlZXI6dXBkYXRlIGV2ZW50cyB0byBiZSBlbWl0dGVkXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBlZXJTdG9yZUFkZHJlc3NlcyA9IGRlYm91bmNlKHRoaXMuX3VwZGF0ZVBlZXJTdG9yZUFkZHJlc3Nlcy5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgLy8gdXBkYXRlIG91ciBzdG9yZWQgYWRkcmVzc2VzIHdoZW4gbmV3IHRyYW5zcG9ydHMgbGlzdGVuXG4gICAgICAgIGNvbXBvbmVudHMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zcG9ydDpsaXN0ZW5pbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQZWVyU3RvcmVBZGRyZXNzZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVwZGF0ZSBvdXIgc3RvcmVkIGFkZHJlc3NlcyB3aGVuIGV4aXN0aW5nIHRyYW5zcG9ydHMgc3RvcCBsaXN0ZW5pbmdcbiAgICAgICAgY29tcG9uZW50cy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNwb3J0OmNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGVlclN0b3JlQWRkcmVzc2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfdXBkYXRlUGVlclN0b3JlQWRkcmVzc2VzKCkge1xuICAgICAgICAvLyBpZiBhbm5vdW5jZSBhZGRyZXNzZXMgaGF2ZSBiZWVuIGNvbmZpZ3VyZWQsIGVuc3VyZSB0aGV5IG1ha2UgaXQgaW50byBvdXIgcGVlclxuICAgICAgICAvLyByZWNvcmQgZm9yIHRoaW5ncyBsaWtlIGlkZW50aWZ5XG4gICAgICAgIGNvbnN0IGFkZHJzID0gdGhpcy5nZXRBbm5vdW5jZUFkZHJzKClcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5jb21wb25lbnRzLnRyYW5zcG9ydE1hbmFnZXIuZ2V0QWRkcnMoKSlcbiAgICAgICAgICAgIC5jb25jYXQoWy4uLnRoaXMub2JzZXJ2ZWQuZW50cmllcygpXVxuICAgICAgICAgICAgLmZpbHRlcigoW18sIG1ldGFkYXRhXSkgPT4gbWV0YWRhdGEuY29uZmlkZW50KVxuICAgICAgICAgICAgLm1hcCgoW3N0cl0pID0+IG11bHRpYWRkcihzdHIpKSkubWFwKG1hID0+IHtcbiAgICAgICAgICAgIC8vIHN0cmlwIG91ciBwZWVyIGlkIGlmIGl0IGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChtYS5nZXRQZWVySWQoKSA9PT0gdGhpcy5jb21wb25lbnRzLnBlZXJJZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hLmRlY2Fwc3VsYXRlKGAvcDJwLyR7dGhpcy5jb21wb25lbnRzLnBlZXJJZC50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnBlZXJTdG9yZS5wYXRjaCh0aGlzLmNvbXBvbmVudHMucGVlcklkLCB7XG4gICAgICAgICAgICBtdWx0aWFkZHJzOiBhZGRyc1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7IHRoaXMubG9nLmVycm9yKCdlcnJvciB1cGRhdGluZyBhZGRyZXNzZXMnLCBlcnIpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHBlZXIgbGlzdGVuIG11bHRpYWRkcnNcbiAgICAgKi9cbiAgICBnZXRMaXN0ZW5BZGRycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5saXN0ZW4pLm1hcCgoYSkgPT4gbXVsdGlhZGRyKGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHBlZXIgYW5ub3VuY2luZyBtdWx0aWFkZHJzXG4gICAgICovXG4gICAgZ2V0QW5ub3VuY2VBZGRycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5hbm5vdW5jZSkubWFwKChhKSA9PiBtdWx0aWFkZHIoYSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb2JzZXJ2ZWQgbXVsdGlhZGRyc1xuICAgICAqL1xuICAgIGdldE9ic2VydmVkQWRkcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZWQpLm1hcCgoW2FdKSA9PiBtdWx0aWFkZHIoYSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcGVlciBvYnNlcnZlZCBhZGRyZXNzZXNcbiAgICAgKi9cbiAgICBhZGRPYnNlcnZlZEFkZHIoYWRkcikge1xuICAgICAgICBhZGRyID0gc3RyaXBQZWVySWQoYWRkciwgdGhpcy5jb21wb25lbnRzLnBlZXJJZCk7XG4gICAgICAgIGNvbnN0IGFkZHJTdHJpbmcgPSBhZGRyLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGRvIG5vdCB0cmlnZ2VyIHRoZSBjaGFuZ2U6YWRkcmVzc2VzIGV2ZW50IGlmIHdlIGFscmVhZHkga25vdyBhYm91dCB0aGlzIGFkZHJlc3NcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZWQuaGFzKGFkZHJTdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlZC5zZXQoYWRkclN0cmluZywge1xuICAgICAgICAgICAgY29uZmlkZW50OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uZmlybU9ic2VydmVkQWRkcihhZGRyKSB7XG4gICAgICAgIGFkZHIgPSBzdHJpcFBlZXJJZChhZGRyLCB0aGlzLmNvbXBvbmVudHMucGVlcklkKTtcbiAgICAgICAgY29uc3QgYWRkclN0cmluZyA9IGFkZHIudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm9ic2VydmVkLmdldChhZGRyU3RyaW5nKSA/PyB7XG4gICAgICAgICAgICBjb25maWRlbnQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nQ29uZmlkZW5jZSA9IG1ldGFkYXRhLmNvbmZpZGVudDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZC5zZXQoYWRkclN0cmluZywge1xuICAgICAgICAgICAgY29uZmlkZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBvbmx5IHRyaWdnZXIgdGhlICdzZWxmOnBlZXI6dXBkYXRlJyBldmVudCBpZiBvdXIgY29uZmlkZW5jZSBpbiBhbiBhZGRyZXNzIGhhcyBjaGFuZ2VkXG4gICAgICAgIGlmICghc3RhcnRpbmdDb25maWRlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQZWVyU3RvcmVBZGRyZXNzZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVPYnNlcnZlZEFkZHIoYWRkcikge1xuICAgICAgICBhZGRyID0gc3RyaXBQZWVySWQoYWRkciwgdGhpcy5jb21wb25lbnRzLnBlZXJJZCk7XG4gICAgICAgIGNvbnN0IGFkZHJTdHJpbmcgPSBhZGRyLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZWQuZGVsZXRlKGFkZHJTdHJpbmcpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzZXMoKSB7XG4gICAgICAgIGxldCBhZGRycyA9IHRoaXMuZ2V0QW5ub3VuY2VBZGRycygpLm1hcChtYSA9PiBtYS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGFkZHJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gbm8gY29uZmlndXJlZCBhbm5vdW5jZSBhZGRycywgYWRkIGNvbmZpZ3VyZWQgbGlzdGVuIGFkZHJlc3Nlc1xuICAgICAgICAgICAgYWRkcnMgPSB0aGlzLmNvbXBvbmVudHMudHJhbnNwb3J0TWFuYWdlci5nZXRBZGRycygpLm1hcChtYSA9PiBtYS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgb2JzZXJ2ZWQgYWRkcmVzc2VzIHdlIGFyZSBjb25maWRlbnQgaW5cbiAgICAgICAgYWRkcnMgPSBhZGRycy5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLm9ic2VydmVkKVxuICAgICAgICAgICAgLmZpbHRlcigoW21hLCBtZXRhZGF0YV0pID0+IG1ldGFkYXRhLmNvbmZpZGVudClcbiAgICAgICAgICAgIC5tYXAoKFttYV0pID0+IG1hKSk7XG4gICAgICAgIC8vIGRlZHVwZSBtdWx0aWFkZHJzXG4gICAgICAgIGNvbnN0IGFkZHJTZXQgPSBuZXcgU2V0KGFkZHJzKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFkdmVydGlzaW5nIGxpc3RcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5ub3VuY2VGaWx0ZXIoQXJyYXkuZnJvbShhZGRyU2V0KVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gbXVsdGlhZGRyKHN0cikpKVxuICAgICAgICAgICAgLm1hcChtYSA9PiB7XG4gICAgICAgICAgICAvLyBkbyBub3QgYXBwZW5kIG91ciBwZWVyIGlkIHRvIGEgcGF0aCBtdWx0aWFkZHIgYXMgaXQgd2lsbCBiZWNvbWUgaW52YWxpZFxuICAgICAgICAgICAgaWYgKG1hLnByb3RvcygpLnBvcCgpPy5wYXRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hLmdldFBlZXJJZCgpID09PSB0aGlzLmNvbXBvbmVudHMucGVlcklkLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWEuZW5jYXBzdWxhdGUoYC9wMnAvJHt0aGlzLmNvbXBvbmVudHMucGVlcklkLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJwZWVySWRGcm9tU3RyaW5nIiwibXVsdGlhZGRyIiwiZGVib3VuY2UiLCJkZWZhdWx0QWRkcmVzc0ZpbHRlciIsImFkZHJzIiwic3RyaXBQZWVySWQiLCJtYSIsInBlZXJJZCIsIm9ic2VydmVkUGVlcklkU3RyIiwiZ2V0UGVlcklkIiwib2JzZXJ2ZWRQZWVySWQiLCJlcXVhbHMiLCJkZWNhcHN1bGF0ZSIsInRvU3RyaW5nIiwiRGVmYXVsdEFkZHJlc3NNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRzIiwiaW5pdCIsImxpc3RlbiIsImFubm91bmNlIiwibG9nIiwibG9nZ2VyIiwiZm9yQ29tcG9uZW50IiwibWFwIiwiU2V0Iiwib2JzZXJ2ZWQiLCJNYXAiLCJhbm5vdW5jZUZpbHRlciIsIl91cGRhdGVQZWVyU3RvcmVBZGRyZXNzZXMiLCJiaW5kIiwiZXZlbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldEFubm91bmNlQWRkcnMiLCJjb25jYXQiLCJ0cmFuc3BvcnRNYW5hZ2VyIiwiZ2V0QWRkcnMiLCJlbnRyaWVzIiwiZmlsdGVyIiwiXyIsIm1ldGFkYXRhIiwiY29uZmlkZW50Iiwic3RyIiwicGVlclN0b3JlIiwicGF0Y2giLCJtdWx0aWFkZHJzIiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsImdldExpc3RlbkFkZHJzIiwiQXJyYXkiLCJmcm9tIiwiYSIsImdldE9ic2VydmVkQWRkcnMiLCJhZGRPYnNlcnZlZEFkZHIiLCJhZGRyIiwiYWRkclN0cmluZyIsImhhcyIsInNldCIsImNvbmZpcm1PYnNlcnZlZEFkZHIiLCJnZXQiLCJzdGFydGluZ0NvbmZpZGVuY2UiLCJyZW1vdmVPYnNlcnZlZEFkZHIiLCJkZWxldGUiLCJnZXRBZGRyZXNzZXMiLCJsZW5ndGgiLCJhZGRyU2V0IiwicHJvdG9zIiwicG9wIiwicGF0aCIsImVuY2Fwc3VsYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/address-manager/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/address-manager/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/address-manager/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debounce: () => (/* binding */ debounce)\n/* harmony export */ });\nfunction debounce(func, wait) {\n    let timeout;\n    return function() {\n        const later = function() {\n            timeout = undefined;\n            func();\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2FkZHJlc3MtbWFuYWdlci91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQy9CLElBQUlDO0lBQ0osT0FBTztRQUNILE1BQU1DLFFBQVE7WUFDVkQsVUFBVUU7WUFDVko7UUFDSjtRQUNBSyxhQUFhSDtRQUNiQSxVQUFVSSxXQUFXSCxPQUFPRjtJQUNoQztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2FkZHJlc3MtbWFuYWdlci91dGlscy5qcz80NTU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwibGF0ZXIiLCJ1bmRlZmluZWQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/address-manager/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/components.js":
/*!****************************************************!*\
  !*** ./node_modules/libp2p/dist/src/components.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libp2p/logger */ \"(ssr)/./node_modules/@libp2p/logger/dist/src/index.js\");\n\n\n\nclass DefaultComponents {\n    constructor(init = {}){\n        this.components = {};\n        this._started = false;\n        this.components = {};\n        for (const [key, value] of Object.entries(init)){\n            this.components[key] = value;\n        }\n        if (this.components.logger == null) {\n            this.components.logger = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_0__.defaultLogger)();\n        }\n    }\n    isStarted() {\n        return this._started;\n    }\n    async _invokeStartableMethod(methodName) {\n        await Promise.all(Object.values(this.components).filter((obj)=>(0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.isStartable)(obj)).map(async (startable)=>{\n            await startable[methodName]?.();\n        }));\n    }\n    async beforeStart() {\n        await this._invokeStartableMethod(\"beforeStart\");\n    }\n    async start() {\n        await this._invokeStartableMethod(\"start\");\n        this._started = true;\n    }\n    async afterStart() {\n        await this._invokeStartableMethod(\"afterStart\");\n    }\n    async beforeStop() {\n        await this._invokeStartableMethod(\"beforeStop\");\n    }\n    async stop() {\n        await this._invokeStartableMethod(\"stop\");\n        this._started = false;\n    }\n    async afterStop() {\n        await this._invokeStartableMethod(\"afterStop\");\n    }\n}\nconst OPTIONAL_SERVICES = [\n    \"metrics\",\n    \"connectionProtector\",\n    \"dns\"\n];\nconst NON_SERVICE_PROPERTIES = [\n    \"components\",\n    \"isStarted\",\n    \"beforeStart\",\n    \"start\",\n    \"afterStart\",\n    \"beforeStop\",\n    \"stop\",\n    \"afterStop\",\n    \"then\",\n    \"_invokeStartableMethod\"\n];\nfunction defaultComponents(init = {}) {\n    const components = new DefaultComponents(init);\n    const proxy = new Proxy(components, {\n        get (target, prop, receiver) {\n            if (typeof prop === \"string\" && !NON_SERVICE_PROPERTIES.includes(prop)) {\n                const service = components.components[prop];\n                if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(`${prop} not set`, \"ERR_SERVICE_MISSING\");\n                }\n                return service;\n            }\n            return Reflect.get(target, prop, receiver);\n        },\n        set (target, prop, value) {\n            if (typeof prop === \"string\") {\n                components.components[prop] = value;\n            } else {\n                Reflect.set(target, prop, value);\n            }\n            return true;\n        }\n    });\n    // @ts-expect-error component keys are proxied\n    return proxy;\n} //# sourceMappingURL=components.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2NvbXBvbmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUNFO0FBQ0Q7QUFDL0MsTUFBTUc7SUFHRkMsWUFBWUMsT0FBTyxDQUFDLENBQUMsQ0FBRTthQUZ2QkMsYUFBYSxDQUFDO2FBQ2RDLFdBQVc7UUFFUCxJQUFJLENBQUNELFVBQVUsR0FBRyxDQUFDO1FBQ25CLEtBQUssTUFBTSxDQUFDRSxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ04sTUFBTztZQUM3QyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0UsSUFBSSxHQUFHQztRQUMzQjtRQUNBLElBQUksSUFBSSxDQUFDSCxVQUFVLENBQUNNLE1BQU0sSUFBSSxNQUFNO1lBQ2hDLElBQUksQ0FBQ04sVUFBVSxDQUFDTSxNQUFNLEdBQUdWLDZEQUFhQTtRQUMxQztJQUNKO0lBQ0FXLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ04sUUFBUTtJQUN4QjtJQUNBLE1BQU1PLHVCQUF1QkMsVUFBVSxFQUFFO1FBQ3JDLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ1AsT0FBT1EsTUFBTSxDQUFDLElBQUksQ0FBQ1osVUFBVSxFQUMxQ2EsTUFBTSxDQUFDQyxDQUFBQSxNQUFPbkIsOERBQVdBLENBQUNtQixNQUMxQkMsR0FBRyxDQUFDLE9BQU9DO1lBQ1osTUFBTUEsU0FBUyxDQUFDUCxXQUFXO1FBQy9CO0lBQ0o7SUFDQSxNQUFNUSxjQUFjO1FBQ2hCLE1BQU0sSUFBSSxDQUFDVCxzQkFBc0IsQ0FBQztJQUN0QztJQUNBLE1BQU1VLFFBQVE7UUFDVixNQUFNLElBQUksQ0FBQ1Ysc0JBQXNCLENBQUM7UUFDbEMsSUFBSSxDQUFDUCxRQUFRLEdBQUc7SUFDcEI7SUFDQSxNQUFNa0IsYUFBYTtRQUNmLE1BQU0sSUFBSSxDQUFDWCxzQkFBc0IsQ0FBQztJQUN0QztJQUNBLE1BQU1ZLGFBQWE7UUFDZixNQUFNLElBQUksQ0FBQ1osc0JBQXNCLENBQUM7SUFDdEM7SUFDQSxNQUFNYSxPQUFPO1FBQ1QsTUFBTSxJQUFJLENBQUNiLHNCQUFzQixDQUFDO1FBQ2xDLElBQUksQ0FBQ1AsUUFBUSxHQUFHO0lBQ3BCO0lBQ0EsTUFBTXFCLFlBQVk7UUFDZCxNQUFNLElBQUksQ0FBQ2Qsc0JBQXNCLENBQUM7SUFDdEM7QUFDSjtBQUNBLE1BQU1lLG9CQUFvQjtJQUN0QjtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1DLHlCQUF5QjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ00sU0FBU0Msa0JBQWtCMUIsT0FBTyxDQUFDLENBQUM7SUFDdkMsTUFBTUMsYUFBYSxJQUFJSCxrQkFBa0JFO0lBQ3pDLE1BQU0yQixRQUFRLElBQUlDLE1BQU0zQixZQUFZO1FBQ2hDNEIsS0FBSUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7WUFDdEIsSUFBSSxPQUFPRCxTQUFTLFlBQVksQ0FBQ04sdUJBQXVCUSxRQUFRLENBQUNGLE9BQU87Z0JBQ3BFLE1BQU1HLFVBQVVqQyxXQUFXQSxVQUFVLENBQUM4QixLQUFLO2dCQUMzQyxJQUFJRyxXQUFXLFFBQVEsQ0FBQ1Ysa0JBQWtCUyxRQUFRLENBQUNGLE9BQU87b0JBQ3RELE1BQU0sSUFBSXBDLHdEQUFTQSxDQUFDLENBQUMsRUFBRW9DLEtBQUssUUFBUSxDQUFDLEVBQUU7Z0JBQzNDO2dCQUNBLE9BQU9HO1lBQ1g7WUFDQSxPQUFPQyxRQUFRTixHQUFHLENBQUNDLFFBQVFDLE1BQU1DO1FBQ3JDO1FBQ0FJLEtBQUlOLE1BQU0sRUFBRUMsSUFBSSxFQUFFM0IsS0FBSztZQUNuQixJQUFJLE9BQU8yQixTQUFTLFVBQVU7Z0JBQzFCOUIsV0FBV0EsVUFBVSxDQUFDOEIsS0FBSyxHQUFHM0I7WUFDbEMsT0FDSztnQkFDRCtCLFFBQVFDLEdBQUcsQ0FBQ04sUUFBUUMsTUFBTTNCO1lBQzlCO1lBQ0EsT0FBTztRQUNYO0lBQ0o7SUFDQSw4Q0FBOEM7SUFDOUMsT0FBT3VCO0FBQ1gsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvY29tcG9uZW50cy5qcz9mZDRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVFcnJvciB9IGZyb20gJ0BsaWJwMnAvaW50ZXJmYWNlJztcbmltcG9ydCB7IGlzU3RhcnRhYmxlIH0gZnJvbSAnQGxpYnAycC9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgZGVmYXVsdExvZ2dlciB9IGZyb20gJ0BsaWJwMnAvbG9nZ2VyJztcbmNsYXNzIERlZmF1bHRDb21wb25lbnRzIHtcbiAgICBjb21wb25lbnRzID0ge307XG4gICAgX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcihpbml0ID0ge30pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGluaXQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMubG9nZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5sb2dnZXIgPSBkZWZhdWx0TG9nZ2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgICB9XG4gICAgYXN5bmMgX2ludm9rZVN0YXJ0YWJsZU1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXModGhpcy5jb21wb25lbnRzKVxuICAgICAgICAgICAgLmZpbHRlcihvYmogPT4gaXNTdGFydGFibGUob2JqKSlcbiAgICAgICAgICAgIC5tYXAoYXN5bmMgKHN0YXJ0YWJsZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgc3RhcnRhYmxlW21ldGhvZE5hbWVdPy4oKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBiZWZvcmVTdGFydCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW52b2tlU3RhcnRhYmxlTWV0aG9kKCdiZWZvcmVTdGFydCcpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW52b2tlU3RhcnRhYmxlTWV0aG9kKCdzdGFydCcpO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgYWZ0ZXJTdGFydCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW52b2tlU3RhcnRhYmxlTWV0aG9kKCdhZnRlclN0YXJ0Jyk7XG4gICAgfVxuICAgIGFzeW5jIGJlZm9yZVN0b3AoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2ludm9rZVN0YXJ0YWJsZU1ldGhvZCgnYmVmb3JlU3RvcCcpO1xuICAgIH1cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9pbnZva2VTdGFydGFibGVNZXRob2QoJ3N0b3AnKTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBhZnRlclN0b3AoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2ludm9rZVN0YXJ0YWJsZU1ldGhvZCgnYWZ0ZXJTdG9wJyk7XG4gICAgfVxufVxuY29uc3QgT1BUSU9OQUxfU0VSVklDRVMgPSBbXG4gICAgJ21ldHJpY3MnLFxuICAgICdjb25uZWN0aW9uUHJvdGVjdG9yJyxcbiAgICAnZG5zJ1xuXTtcbmNvbnN0IE5PTl9TRVJWSUNFX1BST1BFUlRJRVMgPSBbXG4gICAgJ2NvbXBvbmVudHMnLFxuICAgICdpc1N0YXJ0ZWQnLFxuICAgICdiZWZvcmVTdGFydCcsXG4gICAgJ3N0YXJ0JyxcbiAgICAnYWZ0ZXJTdGFydCcsXG4gICAgJ2JlZm9yZVN0b3AnLFxuICAgICdzdG9wJyxcbiAgICAnYWZ0ZXJTdG9wJyxcbiAgICAndGhlbicsXG4gICAgJ19pbnZva2VTdGFydGFibGVNZXRob2QnXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRDb21wb25lbnRzKGluaXQgPSB7fSkge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBuZXcgRGVmYXVsdENvbXBvbmVudHMoaW5pdCk7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoY29tcG9uZW50cywge1xuICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiAhTk9OX1NFUlZJQ0VfUFJPUEVSVElFUy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBjb21wb25lbnRzLmNvbXBvbmVudHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UgPT0gbnVsbCAmJiAhT1BUSU9OQUxfU0VSVklDRVMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihgJHtwcm9wfSBub3Qgc2V0YCwgJ0VSUl9TRVJWSUNFX01JU1NJTkcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5jb21wb25lbnRzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjb21wb25lbnQga2V5cyBhcmUgcHJveGllZFxuICAgIHJldHVybiBwcm94eTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHMuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVFcnJvciIsImlzU3RhcnRhYmxlIiwiZGVmYXVsdExvZ2dlciIsIkRlZmF1bHRDb21wb25lbnRzIiwiY29uc3RydWN0b3IiLCJpbml0IiwiY29tcG9uZW50cyIsIl9zdGFydGVkIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwibG9nZ2VyIiwiaXNTdGFydGVkIiwiX2ludm9rZVN0YXJ0YWJsZU1ldGhvZCIsIm1ldGhvZE5hbWUiLCJQcm9taXNlIiwiYWxsIiwidmFsdWVzIiwiZmlsdGVyIiwib2JqIiwibWFwIiwic3RhcnRhYmxlIiwiYmVmb3JlU3RhcnQiLCJzdGFydCIsImFmdGVyU3RhcnQiLCJiZWZvcmVTdG9wIiwic3RvcCIsImFmdGVyU3RvcCIsIk9QVElPTkFMX1NFUlZJQ0VTIiwiTk9OX1NFUlZJQ0VfUFJPUEVSVElFUyIsImRlZmF1bHRDb21wb25lbnRzIiwicHJveHkiLCJQcm94eSIsImdldCIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsImluY2x1ZGVzIiwic2VydmljZSIsIlJlZmxlY3QiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/components.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/config.js":
/*!************************************************!*\
  !*** ./node_modules/libp2p/dist/src/config.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateConfig: () => (/* binding */ validateConfig)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/transport/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/peer-id */ \"(ssr)/./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _libp2p_utils_address_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/utils/address-sort */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/address-sort.js\");\n/* harmony import */ var _multiformats_multiaddr_resolvers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr/resolvers */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! merge-options */ \"(ssr)/./node_modules/merge-options/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n\n\n\n\n\n\nconst DefaultConfig = {\n    addresses: {\n        listen: [],\n        announce: [],\n        noAnnounce: [],\n        announceFilter: (multiaddrs)=>multiaddrs\n    },\n    connectionManager: {\n        resolvers: {\n            dnsaddr: _multiformats_multiaddr_resolvers__WEBPACK_IMPORTED_MODULE_0__.dnsaddrResolver\n        },\n        addressSorter: _libp2p_utils_address_sort__WEBPACK_IMPORTED_MODULE_2__.defaultAddressSort\n    },\n    transportManager: {\n        faultTolerance: _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.FaultTolerance.FATAL_ALL\n    }\n};\nasync function validateConfig(opts) {\n    const resultingOptions = (0,merge_options__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(DefaultConfig, opts);\n    if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError(_errors_js__WEBPACK_IMPORTED_MODULE_5__.messages.ERR_PROTECTOR_REQUIRED, _errors_js__WEBPACK_IMPORTED_MODULE_5__.codes.ERR_PROTECTOR_REQUIRED);\n    }\n    if (!(await (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_6__.peerIdFromKeys)(resultingOptions.privateKey.public.bytes, resultingOptions.privateKey.bytes)).equals(resultingOptions.peerId)) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError(\"Private key doesn't match peer id\", _errors_js__WEBPACK_IMPORTED_MODULE_5__.codes.ERR_INVALID_KEY);\n    }\n    return resultingOptions;\n} //# sourceMappingURL=config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RDtBQUNiO0FBQ2U7QUFDSTtBQUMzQjtBQUNLO0FBQzlDLE1BQU1RLGdCQUFnQjtJQUNsQkMsV0FBVztRQUNQQyxRQUFRLEVBQUU7UUFDVkMsVUFBVSxFQUFFO1FBQ1pDLFlBQVksRUFBRTtRQUNkQyxnQkFBZ0IsQ0FBQ0MsYUFBZUE7SUFDcEM7SUFDQUMsbUJBQW1CO1FBQ2ZDLFdBQVc7WUFDUEMsU0FBU2IsOEVBQWVBO1FBQzVCO1FBQ0FjLGVBQWVmLDBFQUFrQkE7SUFDckM7SUFDQWdCLGtCQUFrQjtRQUNkQyxnQkFBZ0JuQiw2REFBY0EsQ0FBQ29CLFNBQVM7SUFDNUM7QUFDSjtBQUNPLGVBQWVDLGVBQWVDLElBQUk7SUFDckMsTUFBTUMsbUJBQW1CbkIseURBQVlBLENBQUNHLGVBQWVlO0lBQ3JELElBQUlDLGlCQUFpQkMsbUJBQW1CLEtBQUssUUFBUUMsV0FBV0MsT0FBTyxFQUFFQyxLQUFLQyxxQkFBcUIsTUFBTTtRQUNyRyxNQUFNLElBQUk3Qix3REFBU0EsQ0FBQ08sZ0RBQVFBLENBQUN1QixzQkFBc0IsRUFBRXhCLDZDQUFLQSxDQUFDd0Isc0JBQXNCO0lBQ3JGO0lBQ0EsSUFBSSxDQUFDLENBQUMsTUFBTTVCLCtEQUFjQSxDQUFDc0IsaUJBQWlCTyxVQUFVLENBQUNDLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFVCxpQkFBaUJPLFVBQVUsQ0FBQ0UsS0FBSyxHQUFHQyxNQUFNLENBQUNWLGlCQUFpQlcsTUFBTSxHQUFHO1FBQ3RJLE1BQU0sSUFBSW5DLHdEQUFTQSxDQUFDLHFDQUFzQ00sNkNBQUtBLENBQUM4QixlQUFlO0lBQ25GO0lBQ0EsT0FBT1o7QUFDWCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9jb25maWcuanM/MTM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRXJyb3IsIEZhdWx0VG9sZXJhbmNlIH0gZnJvbSAnQGxpYnAycC9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgcGVlcklkRnJvbUtleXMgfSBmcm9tICdAbGlicDJwL3BlZXItaWQnO1xuaW1wb3J0IHsgZGVmYXVsdEFkZHJlc3NTb3J0IH0gZnJvbSAnQGxpYnAycC91dGlscy9hZGRyZXNzLXNvcnQnO1xuaW1wb3J0IHsgZG5zYWRkclJlc29sdmVyIH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvcmVzb2x2ZXJzJztcbmltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnbWVyZ2Utb3B0aW9ucyc7XG5pbXBvcnQgeyBjb2RlcywgbWVzc2FnZXMgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5jb25zdCBEZWZhdWx0Q29uZmlnID0ge1xuICAgIGFkZHJlc3Nlczoge1xuICAgICAgICBsaXN0ZW46IFtdLFxuICAgICAgICBhbm5vdW5jZTogW10sXG4gICAgICAgIG5vQW5ub3VuY2U6IFtdLFxuICAgICAgICBhbm5vdW5jZUZpbHRlcjogKG11bHRpYWRkcnMpID0+IG11bHRpYWRkcnNcbiAgICB9LFxuICAgIGNvbm5lY3Rpb25NYW5hZ2VyOiB7XG4gICAgICAgIHJlc29sdmVyczoge1xuICAgICAgICAgICAgZG5zYWRkcjogZG5zYWRkclJlc29sdmVyXG4gICAgICAgIH0sXG4gICAgICAgIGFkZHJlc3NTb3J0ZXI6IGRlZmF1bHRBZGRyZXNzU29ydFxuICAgIH0sXG4gICAgdHJhbnNwb3J0TWFuYWdlcjoge1xuICAgICAgICBmYXVsdFRvbGVyYW5jZTogRmF1bHRUb2xlcmFuY2UuRkFUQUxfQUxMXG4gICAgfVxufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZyhvcHRzKSB7XG4gICAgY29uc3QgcmVzdWx0aW5nT3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhEZWZhdWx0Q29uZmlnLCBvcHRzKTtcbiAgICBpZiAocmVzdWx0aW5nT3B0aW9ucy5jb25uZWN0aW9uUHJvdGVjdG9yID09PSBudWxsICYmIGdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5MSUJQMlBfRk9SQ0VfUE5FVCAhPSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihtZXNzYWdlcy5FUlJfUFJPVEVDVE9SX1JFUVVJUkVELCBjb2Rlcy5FUlJfUFJPVEVDVE9SX1JFUVVJUkVEKTtcbiAgICB9XG4gICAgaWYgKCEoYXdhaXQgcGVlcklkRnJvbUtleXMocmVzdWx0aW5nT3B0aW9ucy5wcml2YXRlS2V5LnB1YmxpYy5ieXRlcywgcmVzdWx0aW5nT3B0aW9ucy5wcml2YXRlS2V5LmJ5dGVzKSkuZXF1YWxzKHJlc3VsdGluZ09wdGlvbnMucGVlcklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdQcml2YXRlIGtleSBkb2VzblxcJ3QgbWF0Y2ggcGVlciBpZCcsIGNvZGVzLkVSUl9JTlZBTElEX0tFWSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRpbmdPcHRpb25zO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlRXJyb3IiLCJGYXVsdFRvbGVyYW5jZSIsInBlZXJJZEZyb21LZXlzIiwiZGVmYXVsdEFkZHJlc3NTb3J0IiwiZG5zYWRkclJlc29sdmVyIiwibWVyZ2VPcHRpb25zIiwiY29kZXMiLCJtZXNzYWdlcyIsIkRlZmF1bHRDb25maWciLCJhZGRyZXNzZXMiLCJsaXN0ZW4iLCJhbm5vdW5jZSIsIm5vQW5ub3VuY2UiLCJhbm5vdW5jZUZpbHRlciIsIm11bHRpYWRkcnMiLCJjb25uZWN0aW9uTWFuYWdlciIsInJlc29sdmVycyIsImRuc2FkZHIiLCJhZGRyZXNzU29ydGVyIiwidHJhbnNwb3J0TWFuYWdlciIsImZhdWx0VG9sZXJhbmNlIiwiRkFUQUxfQUxMIiwidmFsaWRhdGVDb25maWciLCJvcHRzIiwicmVzdWx0aW5nT3B0aW9ucyIsImNvbm5lY3Rpb25Qcm90ZWN0b3IiLCJnbG9iYWxUaGlzIiwicHJvY2VzcyIsImVudiIsIkxJQlAyUF9GT1JDRV9QTkVUIiwiRVJSX1BST1RFQ1RPUl9SRVFVSVJFRCIsInByaXZhdGVLZXkiLCJwdWJsaWMiLCJieXRlcyIsImVxdWFscyIsInBlZXJJZCIsIkVSUl9JTlZBTElEX0tFWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/config/connection-gater.js":
/*!*****************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/config/connection-gater.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectionGater: () => (/* binding */ connectionGater)\n/* harmony export */ });\n/**\n * Returns a default connection gater implementation that allows everything\n */ function connectionGater(gater = {}) {\n    return {\n        denyDialPeer: async ()=>false,\n        denyDialMultiaddr: async ()=>false,\n        denyInboundConnection: async ()=>false,\n        denyOutboundConnection: async ()=>false,\n        denyInboundEncryptedConnection: async ()=>false,\n        denyOutboundEncryptedConnection: async ()=>false,\n        denyInboundUpgradedConnection: async ()=>false,\n        denyOutboundUpgradedConnection: async ()=>false,\n        filterMultiaddrForPeer: async ()=>true,\n        ...gater\n    };\n} //# sourceMappingURL=connection-gater.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2NvbmZpZy9jb25uZWN0aW9uLWdhdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNNLFNBQVNBLGdCQUFnQkMsUUFBUSxDQUFDLENBQUM7SUFDdEMsT0FBTztRQUNIQyxjQUFjLFVBQVk7UUFDMUJDLG1CQUFtQixVQUFZO1FBQy9CQyx1QkFBdUIsVUFBWTtRQUNuQ0Msd0JBQXdCLFVBQVk7UUFDcENDLGdDQUFnQyxVQUFZO1FBQzVDQyxpQ0FBaUMsVUFBWTtRQUM3Q0MsK0JBQStCLFVBQVk7UUFDM0NDLGdDQUFnQyxVQUFZO1FBQzVDQyx3QkFBd0IsVUFBWTtRQUNwQyxHQUFHVCxLQUFLO0lBQ1o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9jb25maWcvY29ubmVjdGlvbi1nYXRlci5qcz84MWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0dXJucyBhIGRlZmF1bHQgY29ubmVjdGlvbiBnYXRlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGFsbG93cyBldmVyeXRoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25uZWN0aW9uR2F0ZXIoZ2F0ZXIgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbnlEaWFsUGVlcjogYXN5bmMgKCkgPT4gZmFsc2UsXG4gICAgICAgIGRlbnlEaWFsTXVsdGlhZGRyOiBhc3luYyAoKSA9PiBmYWxzZSxcbiAgICAgICAgZGVueUluYm91bmRDb25uZWN0aW9uOiBhc3luYyAoKSA9PiBmYWxzZSxcbiAgICAgICAgZGVueU91dGJvdW5kQ29ubmVjdGlvbjogYXN5bmMgKCkgPT4gZmFsc2UsXG4gICAgICAgIGRlbnlJbmJvdW5kRW5jcnlwdGVkQ29ubmVjdGlvbjogYXN5bmMgKCkgPT4gZmFsc2UsXG4gICAgICAgIGRlbnlPdXRib3VuZEVuY3J5cHRlZENvbm5lY3Rpb246IGFzeW5jICgpID0+IGZhbHNlLFxuICAgICAgICBkZW55SW5ib3VuZFVwZ3JhZGVkQ29ubmVjdGlvbjogYXN5bmMgKCkgPT4gZmFsc2UsXG4gICAgICAgIGRlbnlPdXRib3VuZFVwZ3JhZGVkQ29ubmVjdGlvbjogYXN5bmMgKCkgPT4gZmFsc2UsXG4gICAgICAgIGZpbHRlck11bHRpYWRkckZvclBlZXI6IGFzeW5jICgpID0+IHRydWUsXG4gICAgICAgIC4uLmdhdGVyXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tZ2F0ZXIuanMubWFwIl0sIm5hbWVzIjpbImNvbm5lY3Rpb25HYXRlciIsImdhdGVyIiwiZGVueURpYWxQZWVyIiwiZGVueURpYWxNdWx0aWFkZHIiLCJkZW55SW5ib3VuZENvbm5lY3Rpb24iLCJkZW55T3V0Ym91bmRDb25uZWN0aW9uIiwiZGVueUluYm91bmRFbmNyeXB0ZWRDb25uZWN0aW9uIiwiZGVueU91dGJvdW5kRW5jcnlwdGVkQ29ubmVjdGlvbiIsImRlbnlJbmJvdW5kVXBncmFkZWRDb25uZWN0aW9uIiwiZGVueU91dGJvdW5kVXBncmFkZWRDb25uZWN0aW9uIiwiZmlsdGVyTXVsdGlhZGRyRm9yUGVlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/config/connection-gater.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/auto-dial.js":
/*!**********************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/auto-dial.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoDial: () => (/* binding */ AutoDial)\n/* harmony export */ });\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/set.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/map.js\");\n/* harmony import */ var _libp2p_utils_peer_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/utils/peer-queue */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/peer-queue.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/uint8arrays/dist/src/to-string.node.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js\");\n\n\n\n\nconst defaultOptions = {\n    minConnections: _constants_js__WEBPACK_IMPORTED_MODULE_1__.MIN_CONNECTIONS,\n    maxQueueLength: _constants_js__WEBPACK_IMPORTED_MODULE_2__.AUTO_DIAL_MAX_QUEUE_LENGTH,\n    autoDialConcurrency: _constants_js__WEBPACK_IMPORTED_MODULE_2__.AUTO_DIAL_CONCURRENCY,\n    autoDialPriority: _constants_js__WEBPACK_IMPORTED_MODULE_2__.AUTO_DIAL_PRIORITY,\n    autoDialInterval: _constants_js__WEBPACK_IMPORTED_MODULE_2__.AUTO_DIAL_INTERVAL,\n    autoDialPeerRetryThreshold: _constants_js__WEBPACK_IMPORTED_MODULE_1__.AUTO_DIAL_PEER_RETRY_THRESHOLD,\n    autoDialDiscoveredPeersDebounce: _constants_js__WEBPACK_IMPORTED_MODULE_2__.AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE\n};\nclass AutoDial {\n    /**\n     * Proactively tries to connect to known peers stored in the PeerStore.\n     * It will keep the number of connections below the upper limit and sort\n     * the peers to connect based on whether we know their keys and protocols.\n     */ constructor(components, init){\n        this.connectionManager = components.connectionManager;\n        this.peerStore = components.peerStore;\n        this.minConnections = init.minConnections ?? defaultOptions.minConnections;\n        this.autoDialPriority = init.autoDialPriority ?? defaultOptions.autoDialPriority;\n        this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions.autoDialInterval;\n        this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions.maxQueueLength;\n        this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold;\n        this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce;\n        this.log = components.logger.forComponent(\"libp2p:connection-manager:auto-dial\");\n        this.started = false;\n        this.running = false;\n        this.queue = new _libp2p_utils_peer_queue__WEBPACK_IMPORTED_MODULE_3__.PeerQueue({\n            concurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n            metricName: \"libp2p_autodial_queue\",\n            metrics: components.metrics\n        });\n        this.queue.addEventListener(\"error\", (evt)=>{\n            this.log.error(\"error during auto-dial\", evt.detail);\n        });\n        // check the min connection limit whenever a peer disconnects\n        components.events.addEventListener(\"connection:close\", ()=>{\n            this.autoDial().catch((err)=>{\n                this.log.error(err);\n            });\n        });\n        // sometimes peers are discovered in quick succession so add a small\n        // debounce to ensure all eligible peers are autodialed\n        let debounce;\n        // when new peers are discovered, dial them if we don't have\n        // enough connections\n        components.events.addEventListener(\"peer:discovery\", ()=>{\n            clearTimeout(debounce);\n            debounce = setTimeout(()=>{\n                this.autoDial().catch((err)=>{\n                    this.log.error(err);\n                });\n            }, this.autoDialDiscoveredPeersDebounce);\n        });\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    afterStart() {\n        this.autoDial().catch((err)=>{\n            this.log.error(\"error while autodialing\", err);\n        });\n    }\n    stop() {\n        // clear the queue\n        this.queue.clear();\n        clearTimeout(this.autoDialInterval);\n        this.started = false;\n        this.running = false;\n    }\n    async autoDial() {\n        if (!this.started || this.running) {\n            return;\n        }\n        const connections = this.connectionManager.getConnectionsMap();\n        const numConnections = connections.size;\n        // already have enough connections\n        if (numConnections >= this.minConnections) {\n            if (this.minConnections > 0) {\n                this.log.trace(\"have enough connections %d/%d\", numConnections, this.minConnections);\n            }\n            // no need to schedule next autodial as it will be run when on\n            // connection:close event\n            return;\n        }\n        if (this.queue.size > this.autoDialMaxQueueLength) {\n            this.log(\"not enough connections %d/%d but auto dial queue is full\", numConnections, this.minConnections);\n            this.sheduleNextAutodial();\n            return;\n        }\n        this.running = true;\n        this.log(\"not enough connections %d/%d - will dial peers to increase the number of connections\", numConnections, this.minConnections);\n        const dialQueue = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_4__.PeerSet(// @ts-expect-error boolean filter removes falsy peer IDs\n        this.connectionManager.getDialQueue().map((queue)=>queue.peerId).filter(Boolean));\n        // sort peers on whether we know protocols or public keys for them\n        const peers = await this.peerStore.all({\n            filters: [\n                // remove some peers\n                (peer)=>{\n                    // remove peers without addresses\n                    if (peer.addresses.length === 0) {\n                        this.log.trace(\"not autodialing %p because they have no addresses\", peer.id);\n                        return false;\n                    }\n                    // remove peers we are already connected to\n                    if (connections.has(peer.id)) {\n                        this.log.trace(\"not autodialing %p because they are already connected\", peer.id);\n                        return false;\n                    }\n                    // remove peers we are already dialling\n                    if (dialQueue.has(peer.id)) {\n                        this.log.trace(\"not autodialing %p because they are already being dialed\", peer.id);\n                        return false;\n                    }\n                    // remove peers already in the autodial queue\n                    if (this.queue.has(peer.id)) {\n                        this.log.trace(\"not autodialing %p because they are already being autodialed\", peer.id);\n                        return false;\n                    }\n                    return true;\n                }\n            ]\n        });\n        // shuffle the peers - this is so peers with the same tag values will be\n        // dialled in a different order each time\n        const shuffledPeers = peers.sort(()=>Math.random() > 0.5 ? 1 : -1);\n        // sort shuffled peers by tag value\n        const peerValues = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_5__.PeerMap();\n        for (const peer of shuffledPeers){\n            if (peerValues.has(peer.id)) {\n                continue;\n            }\n            // sum all tag values\n            peerValues.set(peer.id, [\n                ...peer.tags.values()\n            ].reduce((acc, curr)=>{\n                return acc + curr.value;\n            }, 0));\n        }\n        // sort by value, highest to lowest\n        const sortedPeers = shuffledPeers.sort((a, b)=>{\n            const peerAValue = peerValues.get(a.id) ?? 0;\n            const peerBValue = peerValues.get(b.id) ?? 0;\n            if (peerAValue > peerBValue) {\n                return -1;\n            }\n            if (peerAValue < peerBValue) {\n                return 1;\n            }\n            return 0;\n        });\n        const peersThatHaveNotFailed = sortedPeers.filter((peer)=>{\n            const lastDialFailure = peer.metadata.get(_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAST_DIAL_FAILURE_KEY);\n            if (lastDialFailure == null) {\n                return true;\n            }\n            const lastDialFailureTimestamp = parseInt((0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_0__.toString)(lastDialFailure));\n            if (isNaN(lastDialFailureTimestamp)) {\n                return true;\n            }\n            // only dial if the time since the last failure is above the retry threshold\n            return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;\n        });\n        this.log(\"selected %d/%d peers to dial\", peersThatHaveNotFailed.length, peers.length);\n        for (const peer of peersThatHaveNotFailed){\n            this.queue.add(async ()=>{\n                const numConnections = this.connectionManager.getConnectionsMap().size;\n                // Check to see if we still need to auto dial\n                if (numConnections >= this.minConnections) {\n                    this.log(\"got enough connections now %d/%d\", numConnections, this.minConnections);\n                    this.queue.clear();\n                    return;\n                }\n                this.log(\"connecting to a peerStore stored peer %p\", peer.id);\n                await this.connectionManager.openConnection(peer.id, {\n                    priority: this.autoDialPriority\n                });\n            }, {\n                peerId: peer.id\n            }).catch((err)=>{\n                this.log.error(\"could not connect to peerStore stored peer\", err);\n            });\n        }\n        this.running = false;\n        this.sheduleNextAutodial();\n    }\n    sheduleNextAutodial() {\n        if (!this.started) {\n            return;\n        }\n        this.autoDialInterval = setTimeout(()=>{\n            this.autoDial().catch((err)=>{\n                this.log.error(\"error while autodialing\", err);\n            });\n        }, this.autoDialIntervalMs);\n    }\n} //# sourceMappingURL=auto-dial.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9hdXRvLWRpYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0RDtBQUNQO0FBQ2tCO0FBQ2lLO0FBQ3hPLE1BQU1hLGlCQUFpQjtJQUNuQkMsZ0JBQWdCRiwwREFBZUE7SUFDL0JHLGdCQUFnQlAscUVBQTBCQTtJQUMxQ1EscUJBQXFCWCxnRUFBcUJBO0lBQzFDWSxrQkFBa0JQLDZEQUFrQkE7SUFDcENRLGtCQUFrQlgsNkRBQWtCQTtJQUNwQ1ksNEJBQTRCVix5RUFBOEJBO0lBQzFEVyxpQ0FBaUNkLDhFQUFtQ0E7QUFDeEU7QUFDTyxNQUFNZTtJQWNUOzs7O0tBSUMsR0FDREMsWUFBWUMsVUFBVSxFQUFFQyxJQUFJLENBQUU7UUFDMUIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0YsV0FBV0UsaUJBQWlCO1FBQ3JELElBQUksQ0FBQ0MsU0FBUyxHQUFHSCxXQUFXRyxTQUFTO1FBQ3JDLElBQUksQ0FBQ1osY0FBYyxHQUFHVSxLQUFLVixjQUFjLElBQUlELGVBQWVDLGNBQWM7UUFDMUUsSUFBSSxDQUFDRyxnQkFBZ0IsR0FBR08sS0FBS1AsZ0JBQWdCLElBQUlKLGVBQWVJLGdCQUFnQjtRQUNoRixJQUFJLENBQUNVLGtCQUFrQixHQUFHSCxLQUFLTixnQkFBZ0IsSUFBSUwsZUFBZUssZ0JBQWdCO1FBQ2xGLElBQUksQ0FBQ1Usc0JBQXNCLEdBQUdKLEtBQUtULGNBQWMsSUFBSUYsZUFBZUUsY0FBYztRQUNsRixJQUFJLENBQUNjLDRCQUE0QixHQUFHTCxLQUFLTCwwQkFBMEIsSUFBSU4sZUFBZU0sMEJBQTBCO1FBQ2hILElBQUksQ0FBQ0MsK0JBQStCLEdBQUdJLEtBQUtKLCtCQUErQixJQUFJUCxlQUFlTywrQkFBK0I7UUFDN0gsSUFBSSxDQUFDVSxHQUFHLEdBQUdQLFdBQVdRLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDO1FBQzFDLElBQUksQ0FBQ0MsT0FBTyxH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O2dCQUNYLE1BQU01QyxpQkFBaUIsSUFBSSxDQUFDaEMsaUJBQWlCLENBQUMrQixpQkFBaUIsR0FBR0UsSUFBSTtnQkFDdEUsNkNBQTZDO2dCQUM3QyxJQUFJRCxrQkFBa0IsSUFBSSxDQUFDM0MsY0FBYyxFQUFFO29CQUN2QyxJQUFJLENBQUNnQixHQUFHLENBQUMsb0NBQW9DMkIsZ0JBQWdCLElBQUksQ0FBQzNDLGNBQWM7b0JBQ2hGLElBQUksQ0FBQ3FCLEtBQUssQ0FBQ21CLEtBQUs7b0JBQ2hCO2dCQUNKO2dCQUNBLElBQUksQ0FBQ3hCLEdBQUcsQ0FBQyw0Q0FBNEN3QyxLQUFLRyxFQUFFO2dCQUM1RCxNQUFNLElBQUksQ0FBQ2hELGlCQUFpQixDQUFDNkUsY0FBYyxDQUFDaEMsS0FBS0csRUFBRSxFQUFFO29CQUNqRDhCLFVBQVUsSUFBSSxDQUFDdEYsZ0JBQWdCO2dCQUNuQztZQUNKLEdBQUc7Z0JBQ0MrQyxRQUFRTSxLQUFLRyxFQUFFO1lBQ25CLEdBQUc1QixLQUFLLENBQUNDLENBQUFBO2dCQUNMLElBQUksQ0FBQ2hCLEdBQUcsQ0FBQ1csS0FBSyxDQUFDLDhDQUE4Q0s7WUFDakU7UUFDSjtRQUNBLElBQUksQ0FBQ1osT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDMEIsbUJBQW1CO0lBQzVCO0lBQ0FBLHNCQUFzQjtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDM0IsT0FBTyxFQUFFO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQ2YsZ0JBQWdCLEdBQUcrQixXQUFXO1lBQy9CLElBQUksQ0FBQ0wsUUFBUSxHQUNSQyxLQUFLLENBQUNDLENBQUFBO2dCQUNQLElBQUksQ0FBQ2hCLEdBQUcsQ0FBQ1csS0FBSyxDQUFDLDJCQUEyQks7WUFDOUM7UUFDSixHQUFHLElBQUksQ0FBQ25CLGtCQUFrQjtJQUM5QjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9hdXRvLWRpYWwuanM/MzAzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQZWVyTWFwLCBQZWVyU2V0IH0gZnJvbSAnQGxpYnAycC9wZWVyLWNvbGxlY3Rpb25zJztcbmltcG9ydCB7IFBlZXJRdWV1ZSB9IGZyb20gJ0BsaWJwMnAvdXRpbHMvcGVlci1xdWV1ZSc7XG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnO1xuaW1wb3J0IHsgQVVUT19ESUFMX0NPTkNVUlJFTkNZLCBBVVRPX0RJQUxfRElTQ09WRVJFRF9QRUVSU19ERUJPVU5DRSwgQVVUT19ESUFMX0lOVEVSVkFMLCBBVVRPX0RJQUxfTUFYX1FVRVVFX0xFTkdUSCwgQVVUT19ESUFMX1BFRVJfUkVUUllfVEhSRVNIT0xELCBBVVRPX0RJQUxfUFJJT1JJVFksIExBU1RfRElBTF9GQUlMVVJFX0tFWSwgTUlOX0NPTk5FQ1RJT05TIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbWluQ29ubmVjdGlvbnM6IE1JTl9DT05ORUNUSU9OUyxcbiAgICBtYXhRdWV1ZUxlbmd0aDogQVVUT19ESUFMX01BWF9RVUVVRV9MRU5HVEgsXG4gICAgYXV0b0RpYWxDb25jdXJyZW5jeTogQVVUT19ESUFMX0NPTkNVUlJFTkNZLFxuICAgIGF1dG9EaWFsUHJpb3JpdHk6IEFVVE9fRElBTF9QUklPUklUWSxcbiAgICBhdXRvRGlhbEludGVydmFsOiBBVVRPX0RJQUxfSU5URVJWQUwsXG4gICAgYXV0b0RpYWxQZWVyUmV0cnlUaHJlc2hvbGQ6IEFVVE9fRElBTF9QRUVSX1JFVFJZX1RIUkVTSE9MRCxcbiAgICBhdXRvRGlhbERpc2NvdmVyZWRQZWVyc0RlYm91bmNlOiBBVVRPX0RJQUxfRElTQ09WRVJFRF9QRUVSU19ERUJPVU5DRVxufTtcbmV4cG9ydCBjbGFzcyBBdXRvRGlhbCB7XG4gICAgY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgcGVlclN0b3JlO1xuICAgIHF1ZXVlO1xuICAgIG1pbkNvbm5lY3Rpb25zO1xuICAgIGF1dG9EaWFsUHJpb3JpdHk7XG4gICAgYXV0b0RpYWxJbnRlcnZhbE1zO1xuICAgIGF1dG9EaWFsTWF4UXVldWVMZW5ndGg7XG4gICAgYXV0b0RpYWxQZWVyUmV0cnlUaHJlc2hvbGRNcztcbiAgICBhdXRvRGlhbERpc2NvdmVyZWRQZWVyc0RlYm91bmNlO1xuICAgIGF1dG9EaWFsSW50ZXJ2YWw7XG4gICAgc3RhcnRlZDtcbiAgICBydW5uaW5nO1xuICAgIGxvZztcbiAgICAvKipcbiAgICAgKiBQcm9hY3RpdmVseSB0cmllcyB0byBjb25uZWN0IHRvIGtub3duIHBlZXJzIHN0b3JlZCBpbiB0aGUgUGVlclN0b3JlLlxuICAgICAqIEl0IHdpbGwga2VlcCB0aGUgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGJlbG93IHRoZSB1cHBlciBsaW1pdCBhbmQgc29ydFxuICAgICAqIHRoZSBwZWVycyB0byBjb25uZWN0IGJhc2VkIG9uIHdoZXRoZXIgd2Uga25vdyB0aGVpciBrZXlzIGFuZCBwcm90b2NvbHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cywgaW5pdCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29tcG9uZW50cy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgdGhpcy5wZWVyU3RvcmUgPSBjb21wb25lbnRzLnBlZXJTdG9yZTtcbiAgICAgICAgdGhpcy5taW5Db25uZWN0aW9ucyA9IGluaXQubWluQ29ubmVjdGlvbnMgPz8gZGVmYXVsdE9wdGlvbnMubWluQ29ubmVjdGlvbnM7XG4gICAgICAgIHRoaXMuYXV0b0RpYWxQcmlvcml0eSA9IGluaXQuYXV0b0RpYWxQcmlvcml0eSA/PyBkZWZhdWx0T3B0aW9ucy5hdXRvRGlhbFByaW9yaXR5O1xuICAgICAgICB0aGlzLmF1dG9EaWFsSW50ZXJ2YWxNcyA9IGluaXQuYXV0b0RpYWxJbnRlcnZhbCA/PyBkZWZhdWx0T3B0aW9ucy5hdXRvRGlhbEludGVydmFsO1xuICAgICAgICB0aGlzLmF1dG9EaWFsTWF4UXVldWVMZW5ndGggPSBpbml0Lm1heFF1ZXVlTGVuZ3RoID8/IGRlZmF1bHRPcHRpb25zLm1heFF1ZXVlTGVuZ3RoO1xuICAgICAgICB0aGlzLmF1dG9EaWFsUGVlclJldHJ5VGhyZXNob2xkTXMgPSBpbml0LmF1dG9EaWFsUGVlclJldHJ5VGhyZXNob2xkID8/IGRlZmF1bHRPcHRpb25zLmF1dG9EaWFsUGVlclJldHJ5VGhyZXNob2xkO1xuICAgICAgICB0aGlzLmF1dG9EaWFsRGlzY292ZXJlZFBlZXJzRGVib3VuY2UgPSBpbml0LmF1dG9EaWFsRGlzY292ZXJlZFBlZXJzRGVib3VuY2UgPz8gZGVmYXVsdE9wdGlvbnMuYXV0b0RpYWxEaXNjb3ZlcmVkUGVlcnNEZWJvdW5jZTtcbiAgICAgICAgdGhpcy5sb2cgPSBjb21wb25lbnRzLmxvZ2dlci5mb3JDb21wb25lbnQoJ2xpYnAycDpjb25uZWN0aW9uLW1hbmFnZXI6YXV0by1kaWFsJyk7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQZWVyUXVldWUoe1xuICAgICAgICAgICAgY29uY3VycmVuY3k6IGluaXQuYXV0b0RpYWxDb25jdXJyZW5jeSA/PyBkZWZhdWx0T3B0aW9ucy5hdXRvRGlhbENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgbWV0cmljTmFtZTogJ2xpYnAycF9hdXRvZGlhbF9xdWV1ZScsXG4gICAgICAgICAgICBtZXRyaWNzOiBjb21wb25lbnRzLm1ldHJpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVldWUuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3IgZHVyaW5nIGF1dG8tZGlhbCcsIGV2dC5kZXRhaWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgdGhlIG1pbiBjb25uZWN0aW9uIGxpbWl0IHdoZW5ldmVyIGEgcGVlciBkaXNjb25uZWN0c1xuICAgICAgICBjb21wb25lbnRzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uOmNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdXRvRGlhbCgpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc29tZXRpbWVzIHBlZXJzIGFyZSBkaXNjb3ZlcmVkIGluIHF1aWNrIHN1Y2Nlc3Npb24gc28gYWRkIGEgc21hbGxcbiAgICAgICAgLy8gZGVib3VuY2UgdG8gZW5zdXJlIGFsbCBlbGlnaWJsZSBwZWVycyBhcmUgYXV0b2RpYWxlZFxuICAgICAgICBsZXQgZGVib3VuY2U7XG4gICAgICAgIC8vIHdoZW4gbmV3IHBlZXJzIGFyZSBkaXNjb3ZlcmVkLCBkaWFsIHRoZW0gaWYgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBlbm91Z2ggY29ubmVjdGlvbnNcbiAgICAgICAgY29tcG9uZW50cy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcigncGVlcjpkaXNjb3ZlcnknLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2UpO1xuICAgICAgICAgICAgZGVib3VuY2UgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9EaWFsKClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLmF1dG9EaWFsRGlzY292ZXJlZFBlZXJzRGVib3VuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydGVkO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYWZ0ZXJTdGFydCgpIHtcbiAgICAgICAgdGhpcy5hdXRvRGlhbCgpXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB3aGlsZSBhdXRvZGlhbGluZycsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICAvLyBjbGVhciB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvRGlhbEludGVydmFsKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBhdXRvRGlhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQgfHwgdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb25zTWFwKCk7XG4gICAgICAgIGNvbnN0IG51bUNvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMuc2l6ZTtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXZlIGVub3VnaCBjb25uZWN0aW9uc1xuICAgICAgICBpZiAobnVtQ29ubmVjdGlvbnMgPj0gdGhpcy5taW5Db25uZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWluQ29ubmVjdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cudHJhY2UoJ2hhdmUgZW5vdWdoIGNvbm5lY3Rpb25zICVkLyVkJywgbnVtQ29ubmVjdGlvbnMsIHRoaXMubWluQ29ubmVjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBzY2hlZHVsZSBuZXh0IGF1dG9kaWFsIGFzIGl0IHdpbGwgYmUgcnVuIHdoZW4gb25cbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb246Y2xvc2UgZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5zaXplID4gdGhpcy5hdXRvRGlhbE1heFF1ZXVlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnbm90IGVub3VnaCBjb25uZWN0aW9ucyAlZC8lZCBidXQgYXV0byBkaWFsIHF1ZXVlIGlzIGZ1bGwnLCBudW1Db25uZWN0aW9ucywgdGhpcy5taW5Db25uZWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNoZWR1bGVOZXh0QXV0b2RpYWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvZygnbm90IGVub3VnaCBjb25uZWN0aW9ucyAlZC8lZCAtIHdpbGwgZGlhbCBwZWVycyB0byBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIGNvbm5lY3Rpb25zJywgbnVtQ29ubmVjdGlvbnMsIHRoaXMubWluQ29ubmVjdGlvbnMpO1xuICAgICAgICBjb25zdCBkaWFsUXVldWUgPSBuZXcgUGVlclNldChcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBib29sZWFuIGZpbHRlciByZW1vdmVzIGZhbHN5IHBlZXIgSURzXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RGlhbFF1ZXVlKClcbiAgICAgICAgICAgIC5tYXAocXVldWUgPT4gcXVldWUucGVlcklkKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIC8vIHNvcnQgcGVlcnMgb24gd2hldGhlciB3ZSBrbm93IHByb3RvY29scyBvciBwdWJsaWMga2V5cyBmb3IgdGhlbVxuICAgICAgICBjb25zdCBwZWVycyA9IGF3YWl0IHRoaXMucGVlclN0b3JlLmFsbCh7XG4gICAgICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNvbWUgcGVlcnNcbiAgICAgICAgICAgICAgICAocGVlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcGVlcnMgd2l0aG91dCBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZXIuYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cudHJhY2UoJ25vdCBhdXRvZGlhbGluZyAlcCBiZWNhdXNlIHRoZXkgaGF2ZSBubyBhZGRyZXNzZXMnLCBwZWVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcGVlcnMgd2UgYXJlIGFscmVhZHkgY29ubmVjdGVkIHRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9ucy5oYXMocGVlci5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLnRyYWNlKCdub3QgYXV0b2RpYWxpbmcgJXAgYmVjYXVzZSB0aGV5IGFyZSBhbHJlYWR5IGNvbm5lY3RlZCcsIHBlZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwZWVycyB3ZSBhcmUgYWxyZWFkeSBkaWFsbGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlhbFF1ZXVlLmhhcyhwZWVyLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cudHJhY2UoJ25vdCBhdXRvZGlhbGluZyAlcCBiZWNhdXNlIHRoZXkgYXJlIGFscmVhZHkgYmVpbmcgZGlhbGVkJywgcGVlci5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBlZXJzIGFscmVhZHkgaW4gdGhlIGF1dG9kaWFsIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlLmhhcyhwZWVyLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cudHJhY2UoJ25vdCBhdXRvZGlhbGluZyAlcCBiZWNhdXNlIHRoZXkgYXJlIGFscmVhZHkgYmVpbmcgYXV0b2RpYWxlZCcsIHBlZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNodWZmbGUgdGhlIHBlZXJzIC0gdGhpcyBpcyBzbyBwZWVycyB3aXRoIHRoZSBzYW1lIHRhZyB2YWx1ZXMgd2lsbCBiZVxuICAgICAgICAvLyBkaWFsbGVkIGluIGEgZGlmZmVyZW50IG9yZGVyIGVhY2ggdGltZVxuICAgICAgICBjb25zdCBzaHVmZmxlZFBlZXJzID0gcGVlcnMuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xKTtcbiAgICAgICAgLy8gc29ydCBzaHVmZmxlZCBwZWVycyBieSB0YWcgdmFsdWVcbiAgICAgICAgY29uc3QgcGVlclZhbHVlcyA9IG5ldyBQZWVyTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBzaHVmZmxlZFBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlclZhbHVlcy5oYXMocGVlci5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN1bSBhbGwgdGFnIHZhbHVlc1xuICAgICAgICAgICAgcGVlclZhbHVlcy5zZXQocGVlci5pZCwgWy4uLnBlZXIudGFncy52YWx1ZXMoKV0ucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgY3Vyci52YWx1ZTtcbiAgICAgICAgICAgIH0sIDApKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3J0IGJ5IHZhbHVlLCBoaWdoZXN0IHRvIGxvd2VzdFxuICAgICAgICBjb25zdCBzb3J0ZWRQZWVycyA9IHNodWZmbGVkUGVlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVlckFWYWx1ZSA9IHBlZXJWYWx1ZXMuZ2V0KGEuaWQpID8/IDA7XG4gICAgICAgICAgICBjb25zdCBwZWVyQlZhbHVlID0gcGVlclZhbHVlcy5nZXQoYi5pZCkgPz8gMDtcbiAgICAgICAgICAgIGlmIChwZWVyQVZhbHVlID4gcGVlckJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZWVyQVZhbHVlIDwgcGVlckJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwZWVyc1RoYXRIYXZlTm90RmFpbGVkID0gc29ydGVkUGVlcnMuZmlsdGVyKHBlZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFzdERpYWxGYWlsdXJlID0gcGVlci5tZXRhZGF0YS5nZXQoTEFTVF9ESUFMX0ZBSUxVUkVfS0VZKTtcbiAgICAgICAgICAgIGlmIChsYXN0RGlhbEZhaWx1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdERpYWxGYWlsdXJlVGltZXN0YW1wID0gcGFyc2VJbnQodWludDhBcnJheVRvU3RyaW5nKGxhc3REaWFsRmFpbHVyZSkpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGxhc3REaWFsRmFpbHVyZVRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgZGlhbCBpZiB0aGUgdGltZSBzaW5jZSB0aGUgbGFzdCBmYWlsdXJlIGlzIGFib3ZlIHRoZSByZXRyeSB0aHJlc2hvbGRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbGFzdERpYWxGYWlsdXJlVGltZXN0YW1wID4gdGhpcy5hdXRvRGlhbFBlZXJSZXRyeVRocmVzaG9sZE1zO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb2coJ3NlbGVjdGVkICVkLyVkIHBlZXJzIHRvIGRpYWwnLCBwZWVyc1RoYXRIYXZlTm90RmFpbGVkLmxlbmd0aCwgcGVlcnMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIHBlZXJzVGhhdEhhdmVOb3RGYWlsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUuYWRkKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Db25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbnNNYXAoKS5zaXplO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzdGlsbCBuZWVkIHRvIGF1dG8gZGlhbFxuICAgICAgICAgICAgICAgIGlmIChudW1Db25uZWN0aW9ucyA+PSB0aGlzLm1pbkNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdnb3QgZW5vdWdoIGNvbm5lY3Rpb25zIG5vdyAlZC8lZCcsIG51bUNvbm5lY3Rpb25zLCB0aGlzLm1pbkNvbm5lY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdjb25uZWN0aW5nIHRvIGEgcGVlclN0b3JlIHN0b3JlZCBwZWVyICVwJywgcGVlci5pZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vcGVuQ29ubmVjdGlvbihwZWVyLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0aGlzLmF1dG9EaWFsUHJpb3JpdHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBwZWVySWQ6IHBlZXIuaWRcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBjb25uZWN0IHRvIHBlZXJTdG9yZSBzdG9yZWQgcGVlcicsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaGVkdWxlTmV4dEF1dG9kaWFsKCk7XG4gICAgfVxuICAgIHNoZWR1bGVOZXh0QXV0b2RpYWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvRGlhbEludGVydmFsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF1dG9EaWFsKClcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igd2hpbGUgYXV0b2RpYWxpbmcnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMuYXV0b0RpYWxJbnRlcnZhbE1zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvLWRpYWwuanMubWFwIl0sIm5hbWVzIjpbIlBlZXJNYXAiLCJQZWVyU2V0IiwiUGVlclF1ZXVlIiwidG9TdHJpbmciLCJ1aW50OEFycmF5VG9TdHJpbmciLCJBVVRPX0RJQUxfQ09OQ1VSUkVOQ1kiLCJBVVRPX0RJQUxfRElTQ09WRVJFRF9QRUVSU19ERUJPVU5DRSIsIkFVVE9fRElBTF9JTlRFUlZBTCIsIkFVVE9fRElBTF9NQVhfUVVFVUVfTEVOR1RIIiwiQVVUT19ESUFMX1BFRVJfUkVUUllfVEhSRVNIT0xEIiwiQVVUT19ESUFMX1BSSU9SSVRZIiwiTEFTVF9ESUFMX0ZBSUxVUkVfS0VZIiwiTUlOX0NPTk5FQ1RJT05TIiwiZGVmYXVsdE9wdGlvbnMiLCJtaW5Db25uZWN0aW9ucyIsIm1heFF1ZXVlTGVuZ3RoIiwiYXV0b0RpYWxDb25jdXJyZW5jeSIsImF1dG9EaWFsUHJpb3JpdHkiLCJhdXRvRGlhbEludGVydmFsIiwiYXV0b0RpYWxQZWVyUmV0cnlUaHJlc2hvbGQiLCJhdXRvRGlhbERpc2NvdmVyZWRQZWVyc0RlYm91bmNlIiwiQXV0b0RpYWwiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudHMiLCJpbml0IiwiY29ubmVjdGlvbk1hbmFnZXIiLCJwZWVyU3RvcmUiLCJhdXRvRGlhbEludGVydmFsTXMiLCJhdXRvRGlhbE1heFF1ZXVlTGVuZ3RoIiwiYXV0b0RpYWxQZWVyUmV0cnlUaHJlc2hvbGRNcyIsImxvZyIsImxvZ2dlciIsImZvckNvbXBvbmVudCIsInN0YXJ0ZWQiLCJydW5uaW5nIiwicXVldWUiLCJjb25jdXJyZW5jeSIsIm1ldHJpY05hbWUiLCJtZXRyaWNzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2dCIsImVycm9yIiwiZGV0YWlsIiwiZXZlbnRzIiwiYXV0b0RpYWwiLCJjYXRjaCIsImVyciIsImRlYm91bmNlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImlzU3RhcnRlZCIsInN0YXJ0IiwiYWZ0ZXJTdGFydCIsInN0b3AiLCJjbGVhciIsImNvbm5lY3Rpb25zIiwiZ2V0Q29ubmVjdGlvbnNNYXAiLCJudW1Db25uZWN0aW9ucyIsInNpemUiLCJ0cmFjZSIsInNoZWR1bGVOZXh0QXV0b2RpYWwiLCJkaWFsUXVldWUiLCJnZXREaWFsUXVldWUiLCJtYXAiLCJwZWVySWQiLCJmaWx0ZXIiLCJCb29sZWFuIiwicGVlcnMiLCJhbGwiLCJmaWx0ZXJzIiwicGVlciIsImFkZHJlc3NlcyIsImxlbmd0aCIsImlkIiwiaGFzIiwic2h1ZmZsZWRQZWVycyIsInNvcnQiLCJNYXRoIiwicmFuZG9tIiwicGVlclZhbHVlcyIsInNldCIsInRhZ3MiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwidmFsdWUiLCJzb3J0ZWRQZWVycyIsImEiLCJiIiwicGVlckFWYWx1ZSIsImdldCIsInBlZXJCVmFsdWUiLCJwZWVyc1RoYXRIYXZlTm90RmFpbGVkIiwibGFzdERpYWxGYWlsdXJlIiwibWV0YWRhdGEiLCJsYXN0RGlhbEZhaWx1cmVUaW1lc3RhbXAiLCJwYXJzZUludCIsImlzTmFOIiwiRGF0ZSIsIm5vdyIsImFkZCIsIm9wZW5Db25uZWN0aW9uIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/auto-dial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/connection-pruner.js":
/*!******************************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/connection-pruner.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionPruner: () => (/* binding */ ConnectionPruner)\n/* harmony export */ });\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/map.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.js\");\n\n\nconst defaultOptions = {\n    maxConnections: _constants_js__WEBPACK_IMPORTED_MODULE_0__.MAX_CONNECTIONS,\n    allow: []\n};\n/**\n * If we go over the max connections limit, choose some connections to close\n */ class ConnectionPruner {\n    constructor(components, init = {}){\n        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;\n        this.allow = init.allow ?? defaultOptions.allow;\n        this.connectionManager = components.connectionManager;\n        this.peerStore = components.peerStore;\n        this.events = components.events;\n        this.log = components.logger.forComponent(\"libp2p:connection-manager:connection-pruner\");\n        // check the max connection limit whenever a peer connects\n        components.events.addEventListener(\"connection:open\", ()=>{\n            this.maybePruneConnections().catch((err)=>{\n                this.log.error(err);\n            });\n        });\n    }\n    /**\n     * If we have more connections than our maximum, select some excess connections\n     * to prune based on peer value\n     */ async maybePruneConnections() {\n        const connections = this.connectionManager.getConnections();\n        const numConnections = connections.length;\n        const toPrune = Math.max(numConnections - this.maxConnections, 0);\n        this.log(\"checking max connections limit %d/%d\", numConnections, this.maxConnections);\n        if (numConnections <= this.maxConnections) {\n            return;\n        }\n        this.log(\"max connections limit exceeded %d/%d, pruning %d connection(s)\", numConnections, this.maxConnections, toPrune);\n        const peerValues = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_1__.PeerMap();\n        // work out peer values\n        for (const connection of connections){\n            const remotePeer = connection.remotePeer;\n            if (peerValues.has(remotePeer)) {\n                continue;\n            }\n            peerValues.set(remotePeer, 0);\n            try {\n                const peer = await this.peerStore.get(remotePeer);\n                // sum all tag values\n                peerValues.set(remotePeer, [\n                    ...peer.tags.values()\n                ].reduce((acc, curr)=>{\n                    return acc + curr.value;\n                }, 0));\n            } catch (err) {\n                if (err.code !== \"ERR_NOT_FOUND\") {\n                    this.log.error(\"error loading peer tags\", err);\n                }\n            }\n        }\n        // sort by value, lowest to highest\n        const sortedConnections = connections.sort((a, b)=>{\n            const peerAValue = peerValues.get(a.remotePeer) ?? 0;\n            const peerBValue = peerValues.get(b.remotePeer) ?? 0;\n            if (peerAValue > peerBValue) {\n                return 1;\n            }\n            if (peerAValue < peerBValue) {\n                return -1;\n            }\n            // if the peers have an equal tag value then we want to close short-lived connections first\n            const connectionALifespan = a.timeline.open;\n            const connectionBLifespan = b.timeline.open;\n            if (connectionALifespan < connectionBLifespan) {\n                return 1;\n            }\n            if (connectionALifespan > connectionBLifespan) {\n                return -1;\n            }\n            return 0;\n        });\n        // close some connections\n        const toClose = [];\n        for (const connection of sortedConnections){\n            this.log(\"too many connections open - closing a connection to %p\", connection.remotePeer);\n            // check allow list\n            const connectionInAllowList = this.allow.some((ma)=>{\n                return connection.remoteAddr.toString().startsWith(ma.toString());\n            });\n            // Connections in the allow list should be excluded from pruning\n            if (!connectionInAllowList) {\n                toClose.push(connection);\n            }\n            if (toClose.length === toPrune) {\n                break;\n            }\n        }\n        // close connections\n        await Promise.all(toClose.map(async (connection)=>{\n            try {\n                await connection.close();\n            } catch (err) {\n                this.log.error(err);\n            }\n        }));\n        // despatch prune event\n        this.events.safeDispatchEvent(\"connection:prune\", {\n            detail: toClose\n        });\n    }\n} //# sourceMappingURL=connection-pruner.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9jb25uZWN0aW9uLXBydW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUQ7QUFDRjtBQUNqRCxNQUFNRSxpQkFBaUI7SUFDbkJDLGdCQUFnQkYsMERBQWVBO0lBQy9CRyxPQUFPLEVBQUU7QUFDYjtBQUNBOztDQUVDLEdBQ00sTUFBTUM7SUFPVEMsWUFBWUMsVUFBVSxFQUFFQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQy9CLElBQUksQ0FBQ0wsY0FBYyxHQUFHSyxLQUFLTCxjQUFjLElBQUlELGVBQWVDLGNBQWM7UUFDMUUsSUFBSSxDQUFDQyxLQUFLLEdBQUdJLEtBQUtKLEtBQUssSUFBSUYsZUFBZUUsS0FBSztRQUMvQyxJQUFJLENBQUNLLGlCQUFpQixHQUFHRixXQUFXRSxpQkFBaUI7UUFDckQsSUFBSSxDQUFDQyxTQUFTLEdBQUdILFdBQVdHLFNBQVM7UUFDckMsSUFBSSxDQUFDQyxNQUFNLEdBQUdKLFdBQVdJLE1BQU07UUFDL0IsSUFBSSxDQUFDQyxHQUFHLEdBQUdMLFdBQVdNLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDO1FBQzFDLDBEQUEwRDtRQUMxRFAsV0FBV0ksTUFBTSxDQUFDSSxnQkFBZ0IsQ0FBQyxtQkFBbUI7WUFDbEQsSUFBSSxDQUFDQyxxQkFBcUIsR0FDckJDLEtBQUssQ0FBQ0MsQ0FBQUE7Z0JBQ1AsSUFBSSxDQUFDTixHQUFHLENBQUNPLEtBQUssQ0FBQ0Q7WUFDbkI7UUFDSjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTUYsd0JBQXdCO1FBQzFCLE1BQU1JLGNBQWMsSUFBSSxDQUFDWCxpQkFBaUIsQ0FBQ1ksY0FBYztRQUN6RCxNQUFNQyxpQkFBaUJGLFlBQVlHLE1BQU07UUFDekMsTUFBTUMsVUFBVUMsS0FBS0MsR0FBRyxDQUFDSixpQkFBaUIsSUFBSSxDQUFDbkIsY0FBYyxFQUFFO1FBQy9ELElBQUksQ0FBQ1MsR0FBRyxDQUFD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aC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvY29ubmVjdGlvbi1tYW5hZ2VyL2Nvbm5lY3Rpb24tcHJ1bmVyLmpzP2ZlNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGVlck1hcCB9IGZyb20gJ0BsaWJwMnAvcGVlci1jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBNQVhfQ09OTkVDVElPTlMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtYXhDb25uZWN0aW9uczogTUFYX0NPTk5FQ1RJT05TLFxuICAgIGFsbG93OiBbXVxufTtcbi8qKlxuICogSWYgd2UgZ28gb3ZlciB0aGUgbWF4IGNvbm5lY3Rpb25zIGxpbWl0LCBjaG9vc2Ugc29tZSBjb25uZWN0aW9ucyB0byBjbG9zZVxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvblBydW5lciB7XG4gICAgbWF4Q29ubmVjdGlvbnM7XG4gICAgY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgcGVlclN0b3JlO1xuICAgIGFsbG93O1xuICAgIGV2ZW50cztcbiAgICBsb2c7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cywgaW5pdCA9IHt9KSB7XG4gICAgICAgIHRoaXMubWF4Q29ubmVjdGlvbnMgPSBpbml0Lm1heENvbm5lY3Rpb25zID8/IGRlZmF1bHRPcHRpb25zLm1heENvbm5lY3Rpb25zO1xuICAgICAgICB0aGlzLmFsbG93ID0gaW5pdC5hbGxvdyA/PyBkZWZhdWx0T3B0aW9ucy5hbGxvdztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbXBvbmVudHMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIHRoaXMucGVlclN0b3JlID0gY29tcG9uZW50cy5wZWVyU3RvcmU7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gY29tcG9uZW50cy5ldmVudHM7XG4gICAgICAgIHRoaXMubG9nID0gY29tcG9uZW50cy5sb2dnZXIuZm9yQ29tcG9uZW50KCdsaWJwMnA6Y29ubmVjdGlvbi1tYW5hZ2VyOmNvbm5lY3Rpb24tcHJ1bmVyJyk7XG4gICAgICAgIC8vIGNoZWNrIHRoZSBtYXggY29ubmVjdGlvbiBsaW1pdCB3aGVuZXZlciBhIHBlZXIgY29ubmVjdHNcbiAgICAgICAgY29tcG9uZW50cy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbjpvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZVBydW5lQ29ubmVjdGlvbnMoKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlIGhhdmUgbW9yZSBjb25uZWN0aW9ucyB0aGFuIG91ciBtYXhpbXVtLCBzZWxlY3Qgc29tZSBleGNlc3MgY29ubmVjdGlvbnNcbiAgICAgKiB0byBwcnVuZSBiYXNlZCBvbiBwZWVyIHZhbHVlXG4gICAgICovXG4gICAgYXN5bmMgbWF5YmVQcnVuZUNvbm5lY3Rpb25zKCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbnMoKTtcbiAgICAgICAgY29uc3QgbnVtQ29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHRvUHJ1bmUgPSBNYXRoLm1heChudW1Db25uZWN0aW9ucyAtIHRoaXMubWF4Q29ubmVjdGlvbnMsIDApO1xuICAgICAgICB0aGlzLmxvZygnY2hlY2tpbmcgbWF4IGNvbm5lY3Rpb25zIGxpbWl0ICVkLyVkJywgbnVtQ29ubmVjdGlvbnMsIHRoaXMubWF4Q29ubmVjdGlvbnMpO1xuICAgICAgICBpZiAobnVtQ29ubmVjdGlvbnMgPD0gdGhpcy5tYXhDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKCdtYXggY29ubmVjdGlvbnMgbGltaXQgZXhjZWVkZWQgJWQvJWQsIHBydW5pbmcgJWQgY29ubmVjdGlvbihzKScsIG51bUNvbm5lY3Rpb25zLCB0aGlzLm1heENvbm5lY3Rpb25zLCB0b1BydW5lKTtcbiAgICAgICAgY29uc3QgcGVlclZhbHVlcyA9IG5ldyBQZWVyTWFwKCk7XG4gICAgICAgIC8vIHdvcmsgb3V0IHBlZXIgdmFsdWVzXG4gICAgICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlUGVlciA9IGNvbm5lY3Rpb24ucmVtb3RlUGVlcjtcbiAgICAgICAgICAgIGlmIChwZWVyVmFsdWVzLmhhcyhyZW1vdGVQZWVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVlclZhbHVlcy5zZXQocmVtb3RlUGVlciwgMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlZXIgPSBhd2FpdCB0aGlzLnBlZXJTdG9yZS5nZXQocmVtb3RlUGVlcik7XG4gICAgICAgICAgICAgICAgLy8gc3VtIGFsbCB0YWcgdmFsdWVzXG4gICAgICAgICAgICAgICAgcGVlclZhbHVlcy5zZXQocmVtb3RlUGVlciwgWy4uLnBlZXIudGFncy52YWx1ZXMoKV0ucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGN1cnIudmFsdWU7XG4gICAgICAgICAgICAgICAgfSwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciBsb2FkaW5nIHBlZXIgdGFncycsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNvcnQgYnkgdmFsdWUsIGxvd2VzdCB0byBoaWdoZXN0XG4gICAgICAgIGNvbnN0IHNvcnRlZENvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVlckFWYWx1ZSA9IHBlZXJWYWx1ZXMuZ2V0KGEucmVtb3RlUGVlcikgPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IHBlZXJCVmFsdWUgPSBwZWVyVmFsdWVzLmdldChiLnJlbW90ZVBlZXIpID8/IDA7XG4gICAgICAgICAgICBpZiAocGVlckFWYWx1ZSA+IHBlZXJCVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZWVyQVZhbHVlIDwgcGVlckJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBwZWVycyBoYXZlIGFuIGVxdWFsIHRhZyB2YWx1ZSB0aGVuIHdlIHdhbnQgdG8gY2xvc2Ugc2hvcnQtbGl2ZWQgY29ubmVjdGlvbnMgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25BTGlmZXNwYW4gPSBhLnRpbWVsaW5lLm9wZW47XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uQkxpZmVzcGFuID0gYi50aW1lbGluZS5vcGVuO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25BTGlmZXNwYW4gPCBjb25uZWN0aW9uQkxpZmVzcGFuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbkFMaWZlc3BhbiA+IGNvbm5lY3Rpb25CTGlmZXNwYW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNsb3NlIHNvbWUgY29ubmVjdGlvbnNcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2Ygc29ydGVkQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0b28gbWFueSBjb25uZWN0aW9ucyBvcGVuIC0gY2xvc2luZyBhIGNvbm5lY3Rpb24gdG8gJXAnLCBjb25uZWN0aW9uLnJlbW90ZVBlZXIpO1xuICAgICAgICAgICAgLy8gY2hlY2sgYWxsb3cgbGlzdFxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkluQWxsb3dMaXN0ID0gdGhpcy5hbGxvdy5zb21lKChtYSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnJlbW90ZUFkZHIudG9TdHJpbmcoKS5zdGFydHNXaXRoKG1hLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb25uZWN0aW9ucyBpbiB0aGUgYWxsb3cgbGlzdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBwcnVuaW5nXG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25JbkFsbG93TGlzdCkge1xuICAgICAgICAgICAgICAgIHRvQ2xvc2UucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Nsb3NlLmxlbmd0aCA9PT0gdG9QcnVuZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsb3NlIGNvbm5lY3Rpb25zXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRvQ2xvc2UubWFwKGFzeW5jIChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGRlc3BhdGNoIHBydW5lIGV2ZW50XG4gICAgICAgIHRoaXMuZXZlbnRzLnNhZmVEaXNwYXRjaEV2ZW50KCdjb25uZWN0aW9uOnBydW5lJywgeyBkZXRhaWw6IHRvQ2xvc2UgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1wcnVuZXIuanMubWFwIl0sIm5hbWVzIjpbIlBlZXJNYXAiLCJNQVhfQ09OTkVDVElPTlMiLCJkZWZhdWx0T3B0aW9ucyIsIm1heENvbm5lY3Rpb25zIiwiYWxsb3ciLCJDb25uZWN0aW9uUHJ1bmVyIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRzIiwiaW5pdCIsImNvbm5lY3Rpb25NYW5hZ2VyIiwicGVlclN0b3JlIiwiZXZlbnRzIiwibG9nIiwibG9nZ2VyIiwiZm9yQ29tcG9uZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1heWJlUHJ1bmVDb25uZWN0aW9ucyIsImNhdGNoIiwiZXJyIiwiZXJyb3IiLCJjb25uZWN0aW9ucyIsImdldENvbm5lY3Rpb25zIiwibnVtQ29ubmVjdGlvbnMiLCJsZW5ndGgiLCJ0b1BydW5lIiwiTWF0aCIsIm1heCIsInBlZXJWYWx1ZXMiLCJjb25uZWN0aW9uIiwicmVtb3RlUGVlciIsImhhcyIsInNldCIsInBlZXIiLCJnZXQiLCJ0YWdzIiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwiY3VyciIsInZhbHVlIiwiY29kZSIsInNvcnRlZENvbm5lY3Rpb25zIiwic29ydCIsImEiLCJiIiwicGVlckFWYWx1ZSIsInBlZXJCVmFsdWUiLCJjb25uZWN0aW9uQUxpZmVzcGFuIiwidGltZWxpbmUiLCJvcGVuIiwiY29ubmVjdGlvbkJMaWZlc3BhbiIsInRvQ2xvc2UiLCJjb25uZWN0aW9uSW5BbGxvd0xpc3QiLCJzb21lIiwibWEiLCJyZW1vdGVBZGRyIiwidG9TdHJpbmciLCJzdGFydHNXaXRoIiwicHVzaCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJjbG9zZSIsInNhZmVEaXNwYXRjaEV2ZW50IiwiZGV0YWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/connection-pruner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTO_DIAL_CONCURRENCY: () => (/* binding */ AUTO_DIAL_CONCURRENCY),\n/* harmony export */   AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE: () => (/* binding */ AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE),\n/* harmony export */   AUTO_DIAL_INTERVAL: () => (/* binding */ AUTO_DIAL_INTERVAL),\n/* harmony export */   AUTO_DIAL_MAX_QUEUE_LENGTH: () => (/* binding */ AUTO_DIAL_MAX_QUEUE_LENGTH),\n/* harmony export */   AUTO_DIAL_PRIORITY: () => (/* binding */ AUTO_DIAL_PRIORITY),\n/* harmony export */   DIAL_TIMEOUT: () => (/* binding */ DIAL_TIMEOUT),\n/* harmony export */   INBOUND_CONNECTION_THRESHOLD: () => (/* binding */ INBOUND_CONNECTION_THRESHOLD),\n/* harmony export */   INBOUND_UPGRADE_TIMEOUT: () => (/* binding */ INBOUND_UPGRADE_TIMEOUT),\n/* harmony export */   LAST_DIAL_FAILURE_KEY: () => (/* binding */ LAST_DIAL_FAILURE_KEY),\n/* harmony export */   MAX_DIAL_QUEUE_LENGTH: () => (/* binding */ MAX_DIAL_QUEUE_LENGTH),\n/* harmony export */   MAX_INCOMING_PENDING_CONNECTIONS: () => (/* binding */ MAX_INCOMING_PENDING_CONNECTIONS),\n/* harmony export */   MAX_PEER_ADDRS_TO_DIAL: () => (/* binding */ MAX_PEER_ADDRS_TO_DIAL)\n/* harmony export */ });\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */ const DIAL_TIMEOUT = 5e3;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */ const INBOUND_UPGRADE_TIMEOUT = 2e3;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */ const MAX_PEER_ADDRS_TO_DIAL = 25;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialInterval\n */ const AUTO_DIAL_INTERVAL = 5000;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialConcurrency\n */ const AUTO_DIAL_CONCURRENCY = 25;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialPriority\n */ const AUTO_DIAL_PRIORITY = 0;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialMaxQueueLength\n */ const AUTO_DIAL_MAX_QUEUE_LENGTH = 100;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialDiscoveredPeersDebounce\n */ const AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */ const INBOUND_CONNECTION_THRESHOLD = 5;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */ const MAX_INCOMING_PENDING_CONNECTIONS = 10;\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempted failed with the relevant\n * peer stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */ const LAST_DIAL_FAILURE_KEY = \"last-dial-failure\";\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxDialQueueLength\n */ const MAX_DIAL_QUEUE_LENGTH = 500; //# sourceMappingURL=constants.defaults.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9jb25zdGFudHMuZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDTSxNQUFNQSxlQUFlLElBQUk7QUFDaEM7O0NBRUMsR0FDTSxNQUFNQywwQkFBMEIsSUFBSTtBQUMzQzs7Q0FFQyxHQUNNLE1BQU1DLHlCQUF5QixHQUFHO0FBQ3pDOztDQUVDLEdBQ00sTUFBTUMscUJBQXFCLEtBQUs7QUFDdkM7O0NBRUMsR0FDTSxNQUFNQyx3QkFBd0IsR0FBRztBQUN4Qzs7Q0FFQyxHQUNNLE1BQU1DLHFCQUFxQixFQUFFO0FBQ3BDOztDQUVDLEdBQ00sTUFBTUMsNkJBQTZCLElBQUk7QUFDOUM7O0NBRUMsR0FDTSxNQUFNQyxzQ0FBc0MsR0FBRztBQUN0RDs7Q0FFQyxHQUNNLE1BQU1DLCtCQUErQixFQUFFO0FBQzlDOztDQUVDLEdBQ00sTUFBTUMsbUNBQW1DLEdBQUc7QUFDbkQ7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1DLHdCQUF3QixvQkFBb0I7QUFDekQ7O0NBRUMsR0FDTSxNQUFNQyx3QkFBd0IsSUFBSSxDQUN6Qyw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvY29ubmVjdGlvbi1tYW5hZ2VyL2NvbnN0YW50cy5kZWZhdWx0cy5qcz8wZDg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNlZSBodHRwczovL2xpYnAycC5naXRodWIuaW8vanMtbGlicDJwL2ludGVyZmFjZXMvaW5kZXguX2ludGVybmFsXy5Db25uZWN0aW9uTWFuYWdlckNvbmZpZy5odG1sI2RpYWxUaW1lb3V0XG4gKi9cbmV4cG9ydCBjb25zdCBESUFMX1RJTUVPVVQgPSA1ZTM7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9saWJwMnAuZ2l0aHViLmlvL2pzLWxpYnAycC9pbnRlcmZhY2VzL2luZGV4Ll9pbnRlcm5hbF8uQ29ubmVjdGlvbk1hbmFnZXJDb25maWcuaHRtbCNpbmJvdW5kVXBncmFkZVRpbWVvdXRcbiAqL1xuZXhwb3J0IGNvbnN0IElOQk9VTkRfVVBHUkFERV9USU1FT1VUID0gMmUzO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbGlicDJwLmdpdGh1Yi5pby9qcy1saWJwMnAvaW50ZXJmYWNlcy9pbmRleC5faW50ZXJuYWxfLkNvbm5lY3Rpb25NYW5hZ2VyQ29uZmlnLmh0bWwjbWF4UGVlckFkZHJzVG9EaWFsXG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfUEVFUl9BRERSU19UT19ESUFMID0gMjU7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9saWJwMnAuZ2l0aHViLmlvL2pzLWxpYnAycC9pbnRlcmZhY2VzL2luZGV4Ll9pbnRlcm5hbF8uQ29ubmVjdGlvbk1hbmFnZXJDb25maWcuaHRtbCNhdXRvRGlhbEludGVydmFsXG4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX0RJQUxfSU5URVJWQUwgPSA1MDAwO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbGlicDJwLmdpdGh1Yi5pby9qcy1saWJwMnAvaW50ZXJmYWNlcy9pbmRleC5faW50ZXJuYWxfLkNvbm5lY3Rpb25NYW5hZ2VyQ29uZmlnLmh0bWwjYXV0b0RpYWxDb25jdXJyZW5jeVxuICovXG5leHBvcnQgY29uc3QgQVVUT19ESUFMX0NPTkNVUlJFTkNZID0gMjU7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9saWJwMnAuZ2l0aHViLmlvL2pzLWxpYnAycC9pbnRlcmZhY2VzL2luZGV4Ll9pbnRlcm5hbF8uQ29ubmVjdGlvbk1hbmFnZXJDb25maWcuaHRtbCNhdXRvRGlhbFByaW9yaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX0RJQUxfUFJJT1JJVFkgPSAwO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbGlicDJwLmdpdGh1Yi5pby9qcy1saWJwMnAvaW50ZXJmYWNlcy9pbmRleC5faW50ZXJuYWxfLkNvbm5lY3Rpb25NYW5hZ2VyQ29uZmlnLmh0bWwjYXV0b0RpYWxNYXhRdWV1ZUxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgQVVUT19ESUFMX01BWF9RVUVVRV9MRU5HVEggPSAxMDA7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9saWJwMnAuZ2l0aHViLmlvL2pzLWxpYnAycC9pbnRlcmZhY2VzL2xpYnAycC5pbmRleC51bmtub3duLkNvbm5lY3Rpb25NYW5hZ2VySW5pdC5odG1sI2F1dG9EaWFsRGlzY292ZXJlZFBlZXJzRGVib3VuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fRElBTF9ESVNDT1ZFUkVEX1BFRVJTX0RFQk9VTkNFID0gMTA7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9saWJwMnAuZ2l0aHViLmlvL2pzLWxpYnAycC9pbnRlcmZhY2VzL2luZGV4Ll9pbnRlcm5hbF8uQ29ubmVjdGlvbk1hbmFnZXJDb25maWcuaHRtbCNpbmJvdW5kQ29ubmVjdGlvblRocmVzaG9sZFxuICovXG5leHBvcnQgY29uc3QgSU5CT1VORF9DT05ORUNUSU9OX1RIUkVTSE9MRCA9IDU7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9saWJwMnAuZ2l0aHViLmlvL2pzLWxpYnAycC9pbnRlcmZhY2VzL2luZGV4Ll9pbnRlcm5hbF8uQ29ubmVjdGlvbk1hbmFnZXJDb25maWcuaHRtbCNtYXhJbmNvbWluZ1BlbmRpbmdDb25uZWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgTUFYX0lOQ09NSU5HX1BFTkRJTkdfQ09OTkVDVElPTlMgPSAxMDtcbi8qKlxuICogU3RvcmUgYXMgcGFydCBvZiB0aGUgcGVlciBzdG9yZSBtZXRhZGF0YSBmb3IgYSBnaXZlbiBwZWVyLCB0aGUgdmFsdWUgZm9yIHRoaXNcbiAqIGtleSBpcyBhIHRpbWVzdGFtcCBvZiB0aGUgbGFzdCB0aW1lIGEgZGlhbCBhdHRlbXB0ZWQgZmFpbGVkIHdpdGggdGhlIHJlbGV2YW50XG4gKiBwZWVyIHN0b3JlZCBhcyBhIHN0cmluZy5cbiAqXG4gKiBVc2VkIHRvIGluc3VyZSB3ZSBkbyBub3QgZW5kbGVzc2x5IHRyeSB0byBhdXRvIGRpYWwgcGVlcnMgd2UgaGF2ZSByZWNlbnRseVxuICogZmFpbGVkIHRvIGRpYWwuXG4gKi9cbmV4cG9ydCBjb25zdCBMQVNUX0RJQUxfRkFJTFVSRV9LRVkgPSAnbGFzdC1kaWFsLWZhaWx1cmUnO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbGlicDJwLmdpdGh1Yi5pby9qcy1saWJwMnAvaW50ZXJmYWNlcy9pbmRleC5faW50ZXJuYWxfLkNvbm5lY3Rpb25NYW5hZ2VyQ29uZmlnLmh0bWwjbWF4RGlhbFF1ZXVlTGVuZ3RoXG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfRElBTF9RVUVVRV9MRU5HVEggPSA1MDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuZGVmYXVsdHMuanMubWFwIl0sIm5hbWVzIjpbIkRJQUxfVElNRU9VVCIsIklOQk9VTkRfVVBHUkFERV9USU1FT1VUIiwiTUFYX1BFRVJfQUREUlNfVE9fRElBTCIsIkFVVE9fRElBTF9JTlRFUlZBTCIsIkFVVE9fRElBTF9DT05DVVJSRU5DWSIsIkFVVE9fRElBTF9QUklPUklUWSIsIkFVVE9fRElBTF9NQVhfUVVFVUVfTEVOR1RIIiwiQVVUT19ESUFMX0RJU0NPVkVSRURfUEVFUlNfREVCT1VOQ0UiLCJJTkJPVU5EX0NPTk5FQ1RJT05fVEhSRVNIT0xEIiwiTUFYX0lOQ09NSU5HX1BFTkRJTkdfQ09OTkVDVElPTlMiLCJMQVNUX0RJQUxfRkFJTFVSRV9LRVkiLCJNQVhfRElBTF9RVUVVRV9MRU5HVEgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.js":
/*!**********************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/constants.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTO_DIAL_CONCURRENCY: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.AUTO_DIAL_CONCURRENCY),\n/* harmony export */   AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE),\n/* harmony export */   AUTO_DIAL_INTERVAL: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.AUTO_DIAL_INTERVAL),\n/* harmony export */   AUTO_DIAL_MAX_QUEUE_LENGTH: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.AUTO_DIAL_MAX_QUEUE_LENGTH),\n/* harmony export */   AUTO_DIAL_PEER_RETRY_THRESHOLD: () => (/* binding */ AUTO_DIAL_PEER_RETRY_THRESHOLD),\n/* harmony export */   AUTO_DIAL_PRIORITY: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.AUTO_DIAL_PRIORITY),\n/* harmony export */   DIAL_TIMEOUT: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.DIAL_TIMEOUT),\n/* harmony export */   INBOUND_CONNECTION_THRESHOLD: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.INBOUND_CONNECTION_THRESHOLD),\n/* harmony export */   INBOUND_UPGRADE_TIMEOUT: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.INBOUND_UPGRADE_TIMEOUT),\n/* harmony export */   LAST_DIAL_FAILURE_KEY: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.LAST_DIAL_FAILURE_KEY),\n/* harmony export */   MAX_CONNECTIONS: () => (/* binding */ MAX_CONNECTIONS),\n/* harmony export */   MAX_DIAL_QUEUE_LENGTH: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.MAX_DIAL_QUEUE_LENGTH),\n/* harmony export */   MAX_INCOMING_PENDING_CONNECTIONS: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.MAX_INCOMING_PENDING_CONNECTIONS),\n/* harmony export */   MAX_PARALLEL_DIALS: () => (/* binding */ MAX_PARALLEL_DIALS),\n/* harmony export */   MAX_PEER_ADDRS_TO_DIAL: () => (/* reexport safe */ _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__.MAX_PEER_ADDRS_TO_DIAL),\n/* harmony export */   MIN_CONNECTIONS: () => (/* binding */ MIN_CONNECTIONS)\n/* harmony export */ });\n/* harmony import */ var _constants_defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.defaults.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js\");\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#minConnections\n */ const MIN_CONNECTIONS = 50;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */ const MAX_CONNECTIONS = 300;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */ const MAX_PARALLEL_DIALS = 100;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialPeerRetryThreshold\n */ const AUTO_DIAL_PEER_RETRY_THRESHOLD = 1000 * 60; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDeEM7O0NBRUMsR0FDTSxNQUFNQSxrQkFBa0IsR0FBRztBQUNsQzs7Q0FFQyxHQUNNLE1BQU1DLGtCQUFrQixJQUFJO0FBQ25DOztDQUVDLEdBQ00sTUFBTUMscUJBQXFCLElBQUk7QUFDdEM7O0NBRUMsR0FDTSxNQUFNQyxpQ0FBaUMsT0FBTyxHQUFHLENBQ3hELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9jb25uZWN0aW9uLW1hbmFnZXIvY29uc3RhbnRzLmpzP2Y2NzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9jb25zdGFudHMuZGVmYXVsdHMuanMnO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbGlicDJwLmdpdGh1Yi5pby9qcy1saWJwMnAvaW50ZXJmYWNlcy9pbmRleC5faW50ZXJuYWxfLkNvbm5lY3Rpb25NYW5hZ2VyQ29uZmlnLmh0bWwjbWluQ29ubmVjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IE1JTl9DT05ORUNUSU9OUyA9IDUwO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbGlicDJwLmdpdGh1Yi5pby9qcy1saWJwMnAvaW50ZXJmYWNlcy9pbmRleC5faW50ZXJuYWxfLkNvbm5lY3Rpb25NYW5hZ2VyQ29uZmlnLmh0bWwjbWF4Q29ubmVjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9DT05ORUNUSU9OUyA9IDMwMDtcbi8qKlxuICogQHNlZSBodHRwczovL2xpYnAycC5naXRodWIuaW8vanMtbGlicDJwL2ludGVyZmFjZXMvaW5kZXguX2ludGVybmFsXy5Db25uZWN0aW9uTWFuYWdlckNvbmZpZy5odG1sI21heFBhcmFsbGVsRGlhbHNcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9QQVJBTExFTF9ESUFMUyA9IDEwMDtcbi8qKlxuICogQHNlZSBodHRwczovL2xpYnAycC5naXRodWIuaW8vanMtbGlicDJwL2ludGVyZmFjZXMvbGlicDJwLmluZGV4LnVua25vd24uQ29ubmVjdGlvbk1hbmFnZXJJbml0Lmh0bWwjYXV0b0RpYWxQZWVyUmV0cnlUaHJlc2hvbGRcbiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fRElBTF9QRUVSX1JFVFJZX1RIUkVTSE9MRCA9IDEwMDAgKiA2MDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiTUlOX0NPTk5FQ1RJT05TIiwiTUFYX0NPTk5FQ1RJT05TIiwiTUFYX1BBUkFMTEVMX0RJQUxTIiwiQVVUT19ESUFMX1BFRVJfUkVUUllfVEhSRVNIT0xEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/dial-queue.js":
/*!***********************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/dial-queue.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DialQueue: () => (/* binding */ DialQueue)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/events.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/map.js\");\n/* harmony import */ var _libp2p_utils_address_sort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libp2p/utils/address-sort */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/address-sort.js\");\n/* harmony import */ var _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/utils/queue */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/queue/index.js\");\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/* harmony import */ var _multiformats_multiaddr_resolvers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/multiaddr/resolvers */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js\");\n/* harmony import */ var _multiformats_multiaddr_matcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr-matcher */ \"(ssr)/./node_modules/@multiformats/multiaddr-matcher/dist/src/index.js\");\n/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! any-signal */ \"(ssr)/./node_modules/any-signal/dist/src/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uint8arrays/from-string */ \"(ssr)/./node_modules/uint8arrays/dist/src/from-string.node.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n/* harmony import */ var _get_peer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../get-peer.js */ \"(ssr)/./node_modules/libp2p/dist/src/get-peer.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/utils.js\");\n/* eslint-disable max-depth */ \n\n\n\n\n\n\n\n\n\n\n\n\nconst defaultOptions = {\n    addressSorter: _libp2p_utils_address_sort__WEBPACK_IMPORTED_MODULE_5__.defaultAddressSort,\n    maxParallelDials: _constants_js__WEBPACK_IMPORTED_MODULE_6__.MAX_PARALLEL_DIALS,\n    maxDialQueueLength: _constants_js__WEBPACK_IMPORTED_MODULE_7__.MAX_DIAL_QUEUE_LENGTH,\n    maxPeerAddrsToDial: _constants_js__WEBPACK_IMPORTED_MODULE_7__.MAX_PEER_ADDRS_TO_DIAL,\n    dialTimeout: _constants_js__WEBPACK_IMPORTED_MODULE_7__.DIAL_TIMEOUT,\n    resolvers: {\n        dnsaddr: _multiformats_multiaddr_resolvers__WEBPACK_IMPORTED_MODULE_1__.dnsaddrResolver\n    }\n};\nclass DialQueue {\n    constructor(components, init = {}){\n        this.addressSorter = init.addressSorter ?? defaultOptions.addressSorter;\n        this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial;\n        this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions.maxDialQueueLength;\n        this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout;\n        this.connections = init.connections ?? new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_8__.PeerMap();\n        this.log = components.logger.forComponent(\"libp2p:connection-manager:dial-queue\");\n        this.components = components;\n        this.shutDownController = new AbortController();\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_9__.setMaxListeners)(Infinity, this.shutDownController.signal);\n        for (const [key, value] of Object.entries(init.resolvers ?? {})){\n            _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.resolvers.set(key, value);\n        }\n        // controls dial concurrency\n        this.queue = new _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_10__.Queue({\n            concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,\n            metricName: \"libp2p_dial_queue\",\n            metrics: components.metrics\n        });\n        // a started job errored\n        this.queue.addEventListener(\"error\", (event)=>{\n            this.log.error(\"error in dial queue\", event.detail);\n        });\n    }\n    start() {\n        this.shutDownController = new AbortController();\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_9__.setMaxListeners)(Infinity, this.shutDownController.signal);\n    }\n    /**\n     * Clears any pending dials\n     */ stop() {\n        this.shutDownController.abort();\n        this.queue.abort();\n    }\n    /**\n     * Connects to a given peer, multiaddr or list of multiaddrs.\n     *\n     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n     * multiaddrs are passed only those will be dialled.\n     *\n     * Where a list of multiaddrs is passed, if any contain a peer id then all\n     * multiaddrs in the list must contain the same peer id.\n     *\n     * The dial to the first address that is successfully able to upgrade a\n     * connection will be used, all other dials will be aborted when that happens.\n     */ async dial(peerIdOrMultiaddr, options = {}) {\n        const { peerId, multiaddrs } = (0,_get_peer_js__WEBPACK_IMPORTED_MODULE_11__.getPeerAddress)(peerIdOrMultiaddr);\n        // make sure we don't have an existing connection to any of the addresses we\n        // are about to dial\n        const existingConnection = Array.from(this.connections.values()).flat().find((conn)=>{\n            if (options.force === true) {\n                return false;\n            }\n            if (conn.remotePeer.equals(peerId)) {\n                return true;\n            }\n            return multiaddrs.find((addr)=>{\n                return addr.equals(conn.remoteAddr);\n            });\n        });\n        if (existingConnection != null) {\n            this.log(\"already connected to %a\", existingConnection.remoteAddr);\n            return existingConnection;\n        }\n        // ready to dial, all async work finished - make sure we don't have any\n        // pending dials in progress for this peer or set of multiaddrs\n        const existingDial = this.queue.queue.find((job)=>{\n            if (peerId?.equals(job.options.peerId) === true) {\n                return true;\n            }\n            // does the dial contain any of the target multiaddrs?\n            const addresses = job.options.multiaddrs;\n            if (addresses == null) {\n                return false;\n            }\n            for (const multiaddr of multiaddrs){\n                if (addresses.has(multiaddr.toString())) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        if (existingDial != null) {\n            this.log(\"joining existing dial target for %p\", peerId);\n            // add all multiaddrs to the dial target\n            for (const multiaddr of multiaddrs){\n                existingDial.options.multiaddrs.add(multiaddr.toString());\n            }\n            return existingDial.join(options);\n        }\n        if (this.queue.size >= this.maxDialQueueLength) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(\"Dial queue is full\", \"ERR_DIAL_QUEUE_FULL\");\n        }\n        this.log(\"creating dial target for %p\", peerId, multiaddrs.map((ma)=>ma.toString()));\n        return this.queue.add(async (options)=>{\n            // create abort conditions - need to do this before `calculateMultiaddrs` as\n            // we may be about to resolve a dns addr which can time out\n            const signal = this.createDialAbortController(options?.signal);\n            let addrsToDial;\n            try {\n                // load addresses from address book, resolve and dnsaddrs, filter\n                // undiallables, add peer IDs, etc\n                addrsToDial = await this.calculateMultiaddrs(peerId, options?.multiaddrs, {\n                    ...options,\n                    signal\n                });\n                addrsToDial.map(({ multiaddr })=>multiaddr.toString()).forEach((addr)=>{\n                    options?.multiaddrs.add(addr);\n                });\n            } catch (err) {\n                signal.clear();\n                throw err;\n            }\n            try {\n                let dialed = 0;\n                const errors = [];\n                for (const address of addrsToDial){\n                    if (dialed === this.maxPeerAddrsToDial) {\n                        this.log(\"dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others\", dialed, peerId);\n                        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(\"Peer had more than maxPeerAddrsToDial\", _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_TOO_MANY_ADDRESSES);\n                    }\n                    dialed++;\n                    try {\n                        const conn = await this.components.transportManager.dial(address.multiaddr, {\n                            ...options,\n                            signal\n                        });\n                        this.log(\"dial to %a succeeded\", address.multiaddr);\n                        return conn;\n                    } catch (err) {\n                        this.log.error(\"dial failed to %a\", address.multiaddr, err);\n                        if (peerId != null) {\n                            // record the failed dial\n                            try {\n                                await this.components.peerStore.patch(peerId, {\n                                    metadata: {\n                                        [_constants_js__WEBPACK_IMPORTED_MODULE_7__.LAST_DIAL_FAILURE_KEY]: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_4__.fromString)(Date.now().toString())\n                                    }\n                                });\n                            } catch (err) {\n                                this.log.error(\"could not update last dial failure key for %p\", peerId, err);\n                            }\n                        }\n                        // the user/dial timeout/shutdown controller signal aborted\n                        if (signal.aborted) {\n                            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(err.message, _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.ERR_TIMEOUT);\n                        }\n                        errors.push(err);\n                    }\n                }\n                if (errors.length === 1) {\n                    throw errors[0];\n                }\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.AggregateCodeError(errors, \"All multiaddr dials failed\", _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_TRANSPORT_DIAL_FAILED);\n            } finally{\n                // clean up abort signals/controllers\n                signal.clear();\n            }\n        }, {\n            peerId,\n            priority: options.priority,\n            multiaddrs: new Set(multiaddrs.map((ma)=>ma.toString())),\n            signal: options.signal\n        });\n    }\n    createDialAbortController(userSignal) {\n        // let any signal abort the dial\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_3__.anySignal)([\n            AbortSignal.timeout(this.dialTimeout),\n            this.shutDownController.signal,\n            userSignal\n        ]);\n        // This emitter gets listened to a lot\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_9__.setMaxListeners)(Infinity, signal);\n        return signal;\n    }\n    // eslint-disable-next-line complexity\n    async calculateMultiaddrs(peerId, multiaddrs = new Set(), options = {}) {\n        const addrs = [\n            ...multiaddrs\n        ].map((ma)=>({\n                multiaddr: (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(ma),\n                isCertified: false\n            }));\n        // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n        if (peerId != null) {\n            if (this.components.peerId.equals(peerId)) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(\"Tried to dial self\", _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_DIALED_SELF);\n            }\n            if (await this.components.connectionGater.denyDialPeer?.(peerId) === true) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(\"The dial request is blocked by gater.allowDialPeer\", _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_PEER_DIAL_INTERCEPTED);\n            }\n            // if just a peer id was passed, load available multiaddrs for this peer\n            // from the peer store\n            if (addrs.length === 0) {\n                this.log(\"loading multiaddrs for %p\", peerId);\n                try {\n                    const peer = await this.components.peerStore.get(peerId);\n                    addrs.push(...peer.addresses);\n                    this.log(\"loaded multiaddrs for %p\", peerId, addrs.map(({ multiaddr })=>multiaddr.toString()));\n                } catch (err) {\n                    if (err.code !== _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_NOT_FOUND) {\n                        throw err;\n                    }\n                }\n            }\n            // if we still don't have any addresses for this peer, try a lookup\n            // using the peer routing\n            if (addrs.length === 0) {\n                this.log(\"looking up multiaddrs for %p in the peer routing\", peerId);\n                try {\n                    const peerInfo = await this.components.peerRouting.findPeer(peerId);\n                    this.log(\"found multiaddrs for %p in the peer routing\", peerId, addrs.map(({ multiaddr })=>multiaddr.toString()));\n                    addrs.push(...peerInfo.multiaddrs.map((multiaddr)=>({\n                            multiaddr,\n                            isCertified: false\n                        })));\n                } catch (err) {\n                    if (err.code !== _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_NO_ROUTERS_AVAILABLE) {\n                        this.log.error(\"looking up multiaddrs for %p in the peer routing failed\", peerId, err);\n                    }\n                }\n            }\n        }\n        // resolve addresses - this can result in a one-to-many translation when\n        // dnsaddrs are resolved\n        let resolvedAddresses = (await Promise.all(addrs.map(async (addr)=>{\n            const result = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_14__.resolveMultiaddrs)(addr.multiaddr, {\n                dns: this.components.dns,\n                ...options,\n                log: this.log\n            });\n            if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n                return addr;\n            }\n            return result.map((multiaddr)=>({\n                    multiaddr,\n                    isCertified: false\n                }));\n        }))).flat();\n        // ensure the peer id is appended to the multiaddr\n        if (peerId != null) {\n            const peerIdMultiaddr = `/p2p/${peerId.toString()}`;\n            resolvedAddresses = resolvedAddresses.map((addr)=>{\n                const lastProto = addr.multiaddr.protos().pop();\n                // do not append peer id to path multiaddrs\n                if (lastProto?.path === true) {\n                    return addr;\n                }\n                // append peer id to multiaddr if it is not already present\n                if (addr.multiaddr.getPeerId() == null) {\n                    return {\n                        multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n                        isCertified: addr.isCertified\n                    };\n                }\n                return addr;\n            });\n        }\n        const filteredAddrs = resolvedAddresses.filter((addr)=>{\n            // filter out any multiaddrs that we do not have transports for\n            if (this.components.transportManager.transportForMultiaddr(addr.multiaddr) == null) {\n                return false;\n            }\n            // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n            // - this can happen with addresses like bootstrap.libp2p.io that resolve\n            // to multiple different peers\n            const addrPeerId = addr.multiaddr.getPeerId();\n            if (peerId != null && addrPeerId != null) {\n                return peerId.equals(addrPeerId);\n            }\n            return true;\n        });\n        // deduplicate addresses\n        const dedupedAddrs = new Map();\n        for (const addr of filteredAddrs){\n            const maStr = addr.multiaddr.toString();\n            const existing = dedupedAddrs.get(maStr);\n            if (existing != null) {\n                existing.isCertified = existing.isCertified || addr.isCertified || false;\n                continue;\n            }\n            dedupedAddrs.set(maStr, addr);\n        }\n        const dedupedMultiaddrs = [\n            ...dedupedAddrs.values()\n        ];\n        // make sure we actually have some addresses to dial\n        if (dedupedMultiaddrs.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(\"The dial request has no valid addresses\", _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_NO_VALID_ADDRESSES);\n        }\n        const gatedAdrs = [];\n        for (const addr of dedupedMultiaddrs){\n            if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n                continue;\n            }\n            gatedAdrs.push(addr);\n        }\n        const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);\n        // make sure we actually have some addresses to dial\n        if (sortedGatedAddrs.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.CodeError(\"The connection gater denied all addresses in the dial request\", _errors_js__WEBPACK_IMPORTED_MODULE_13__.codes.ERR_NO_VALID_ADDRESSES);\n        }\n        this.log.trace(\"addresses for %p before filtering\", peerId ?? \"unknown peer\", resolvedAddresses.map(({ multiaddr })=>multiaddr.toString()));\n        this.log.trace(\"addresses for %p after filtering\", peerId ?? \"unknown peer\", sortedGatedAddrs.map(({ multiaddr })=>multiaddr.toString()));\n        return sortedGatedAddrs;\n    }\n    async isDialable(multiaddr, options = {}) {\n        if (!Array.isArray(multiaddr)) {\n            multiaddr = [\n                multiaddr\n            ];\n        }\n        try {\n            const addresses = await this.calculateMultiaddrs(undefined, new Set(multiaddr.map((ma)=>ma.toString())), options);\n            if (options.runOnTransientConnection === false) {\n                // return true if any resolved multiaddrs are not relay addresses\n                return addresses.find((addr)=>{\n                    return !_multiformats_multiaddr_matcher__WEBPACK_IMPORTED_MODULE_2__.Circuit.matches(addr.multiaddr);\n                }) != null;\n            }\n            return true;\n        } catch (err) {\n            this.log.trace(\"error calculating if multiaddr(s) were dialable\", err);\n        }\n        return false;\n    }\n} //# sourceMappingURL=dial-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9kaWFsLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0QkFBNEIsR0FDb0U7QUFDN0M7QUFDYTtBQUNwQjtBQUNtQjtBQUNLO0FBQ1Y7QUFDbkI7QUFDc0M7QUFDeEM7QUFDVztBQUN3RjtBQUN6RjtBQUMvQyxNQUFNc0IsaUJBQWlCO0lBQ25CQyxlQUFlbEIsMEVBQWtCQTtJQUNqQ21CLGtCQUFrQlAsNkRBQWtCQTtJQUNwQ1Esb0JBQW9CTCxnRUFBcUJBO0lBQ3pDTSxvQkFBb0JSLGlFQUFzQkE7SUFDMUNTLGFBQWFYLHVEQUFZQTtJQUN6QlQsV0FBVztRQUNQcUIsU0FBU25CLDhFQUFlQTtJQUM1QjtBQUNKO0FBQ08sTUFBTW9CO0lBVVRDLFlBQVlDLFVBQVUsRUFBRUMsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUMvQixJQUFJLENBQUNULGFBQWEsR0FBR1MsS0FBS1QsYUFBYSxJQUFJRCxlQUFlQyxhQUFhO1FBQ3ZFLElBQUksQ0FBQ0csa0JBQWtCLEdBQUdNLEtBQUtOLGtCQUFrQixJQUFJSixlQUFlSSxrQkFBa0I7UUFDdEYsSUFBSSxDQUFDRCxrQkFBa0IsR0FBR08sS0FBS1Asa0JBQWtCLElBQUlILGVBQWVHLGtCQUFrQjtRQUN0RixJQUFJLENBQUNFLFdBQVcsR0FBR0ssS0FBS0wsV0FBVyxJQUFJTCxlQUFlSyxXQUFXO1FBQ2pFLElBQUksQ0FBQ00sV0FBVyxHQUFHRCxLQUFLQyxXQUFXLElBQUksSUFBSTdCLDZEQUFPQTtRQUNsRCxJQUFJLENBQUM4QixHQUFHLEdBQUdILFdBQVdJLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDO1FBQzFDLElBQUksQ0FBQ0wsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNNLGtCQUFrQixHQUFHLElBQUlDO1FBQzlCbkMsa0VBQWVBLENBQUNvQyxVQUFVLElBQUksQ0FBQ0Ysa0JBQWtCLENB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T0FBTztRQUNYLEVBQ0EsT0FBT2dGLEtBQUs7WUFDUixJQUFJLENBQUN0RCxHQUFHLENBQUNvSCxLQUFLLENBQUMsbURBQW1EOUQ7UUFDdEU7UUFDQSxPQUFPO0lBQ1g7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9jb25uZWN0aW9uLW1hbmFnZXIvZGlhbC1xdWV1ZS5qcz9iZDkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuaW1wb3J0IHsgQ29kZUVycm9yLCBBZ2dyZWdhdGVDb2RlRXJyb3IsIEVSUl9USU1FT1VULCBzZXRNYXhMaXN0ZW5lcnMgfSBmcm9tICdAbGlicDJwL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBQZWVyTWFwIH0gZnJvbSAnQGxpYnAycC9wZWVyLWNvbGxlY3Rpb25zJztcbmltcG9ydCB7IGRlZmF1bHRBZGRyZXNzU29ydCB9IGZyb20gJ0BsaWJwMnAvdXRpbHMvYWRkcmVzcy1zb3J0JztcbmltcG9ydCB7IFF1ZXVlIH0gZnJvbSAnQGxpYnAycC91dGlscy9xdWV1ZSc7XG5pbXBvcnQgeyByZXNvbHZlcnMsIG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJztcbmltcG9ydCB7IGRuc2FkZHJSZXNvbHZlciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL3Jlc29sdmVycyc7XG5pbXBvcnQgeyBDaXJjdWl0IH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHItbWF0Y2hlcic7XG5pbXBvcnQgeyBhbnlTaWduYWwgfSBmcm9tICdhbnktc2lnbmFsJztcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZyc7XG5pbXBvcnQgeyBjb2RlcyB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBnZXRQZWVyQWRkcmVzcyB9IGZyb20gJy4uL2dldC1wZWVyLmpzJztcbmltcG9ydCB7IERJQUxfVElNRU9VVCwgTUFYX1BBUkFMTEVMX0RJQUxTLCBNQVhfUEVFUl9BRERSU19UT19ESUFMLCBMQVNUX0RJQUxfRkFJTFVSRV9LRVksIE1BWF9ESUFMX1FVRVVFX0xFTkdUSCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHJlc29sdmVNdWx0aWFkZHJzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBhZGRyZXNzU29ydGVyOiBkZWZhdWx0QWRkcmVzc1NvcnQsXG4gICAgbWF4UGFyYWxsZWxEaWFsczogTUFYX1BBUkFMTEVMX0RJQUxTLFxuICAgIG1heERpYWxRdWV1ZUxlbmd0aDogTUFYX0RJQUxfUVVFVUVfTEVOR1RILFxuICAgIG1heFBlZXJBZGRyc1RvRGlhbDogTUFYX1BFRVJfQUREUlNfVE9fRElBTCxcbiAgICBkaWFsVGltZW91dDogRElBTF9USU1FT1VULFxuICAgIHJlc29sdmVyczoge1xuICAgICAgICBkbnNhZGRyOiBkbnNhZGRyUmVzb2x2ZXJcbiAgICB9XG59O1xuZXhwb3J0IGNsYXNzIERpYWxRdWV1ZSB7XG4gICAgcXVldWU7XG4gICAgY29tcG9uZW50cztcbiAgICBhZGRyZXNzU29ydGVyO1xuICAgIG1heFBlZXJBZGRyc1RvRGlhbDtcbiAgICBtYXhEaWFsUXVldWVMZW5ndGg7XG4gICAgZGlhbFRpbWVvdXQ7XG4gICAgc2h1dERvd25Db250cm9sbGVyO1xuICAgIGNvbm5lY3Rpb25zO1xuICAgIGxvZztcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzLCBpbml0ID0ge30pIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzU29ydGVyID0gaW5pdC5hZGRyZXNzU29ydGVyID8/IGRlZmF1bHRPcHRpb25zLmFkZHJlc3NTb3J0ZXI7XG4gICAgICAgIHRoaXMubWF4UGVlckFkZHJzVG9EaWFsID0gaW5pdC5tYXhQZWVyQWRkcnNUb0RpYWwgPz8gZGVmYXVsdE9wdGlvbnMubWF4UGVlckFkZHJzVG9EaWFsO1xuICAgICAgICB0aGlzLm1heERpYWxRdWV1ZUxlbmd0aCA9IGluaXQubWF4RGlhbFF1ZXVlTGVuZ3RoID8/IGRlZmF1bHRPcHRpb25zLm1heERpYWxRdWV1ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5kaWFsVGltZW91dCA9IGluaXQuZGlhbFRpbWVvdXQgPz8gZGVmYXVsdE9wdGlvbnMuZGlhbFRpbWVvdXQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBpbml0LmNvbm5lY3Rpb25zID8/IG5ldyBQZWVyTWFwKCk7XG4gICAgICAgIHRoaXMubG9nID0gY29tcG9uZW50cy5sb2dnZXIuZm9yQ29tcG9uZW50KCdsaWJwMnA6Y29ubmVjdGlvbi1tYW5hZ2VyOmRpYWwtcXVldWUnKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5zaHV0RG93bkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHNldE1heExpc3RlbmVycyhJbmZpbml0eSwgdGhpcy5zaHV0RG93bkNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdC5yZXNvbHZlcnMgPz8ge30pKSB7XG4gICAgICAgICAgICByZXNvbHZlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnRyb2xzIGRpYWwgY29uY3VycmVuY3lcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBRdWV1ZSh7XG4gICAgICAgICAgICBjb25jdXJyZW5jeTogaW5pdC5tYXhQYXJhbGxlbERpYWxzID8/IGRlZmF1bHRPcHRpb25zLm1heFBhcmFsbGVsRGlhbHMsXG4gICAgICAgICAgICBtZXRyaWNOYW1lOiAnbGlicDJwX2RpYWxfcXVldWUnLFxuICAgICAgICAgICAgbWV0cmljczogY29tcG9uZW50cy5tZXRyaWNzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhIHN0YXJ0ZWQgam9iIGVycm9yZWRcbiAgICAgICAgdGhpcy5xdWV1ZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIGluIGRpYWwgcXVldWUnLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2h1dERvd25Db250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHksIHRoaXMuc2h1dERvd25Db250cm9sbGVyLnNpZ25hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbnkgcGVuZGluZyBkaWFsc1xuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2h1dERvd25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRoaXMucXVldWUuYWJvcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdG8gYSBnaXZlbiBwZWVyLCBtdWx0aWFkZHIgb3IgbGlzdCBvZiBtdWx0aWFkZHJzLlxuICAgICAqXG4gICAgICogSWYgYSBwZWVyIGlzIHBhc3NlZCwgYWxsIGtub3duIG11bHRpYWRkcnMgd2lsbCBiZSB0cmllZC4gSWYgYSBtdWx0aWFkZHIgb3JcbiAgICAgKiBtdWx0aWFkZHJzIGFyZSBwYXNzZWQgb25seSB0aG9zZSB3aWxsIGJlIGRpYWxsZWQuXG4gICAgICpcbiAgICAgKiBXaGVyZSBhIGxpc3Qgb2YgbXVsdGlhZGRycyBpcyBwYXNzZWQsIGlmIGFueSBjb250YWluIGEgcGVlciBpZCB0aGVuIGFsbFxuICAgICAqIG11bHRpYWRkcnMgaW4gdGhlIGxpc3QgbXVzdCBjb250YWluIHRoZSBzYW1lIHBlZXIgaWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGlhbCB0byB0aGUgZmlyc3QgYWRkcmVzcyB0aGF0IGlzIHN1Y2Nlc3NmdWxseSBhYmxlIHRvIHVwZ3JhZGUgYVxuICAgICAqIGNvbm5lY3Rpb24gd2lsbCBiZSB1c2VkLCBhbGwgb3RoZXIgZGlhbHMgd2lsbCBiZSBhYm9ydGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgICAqL1xuICAgIGFzeW5jIGRpYWwocGVlcklkT3JNdWx0aWFkZHIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHBlZXJJZCwgbXVsdGlhZGRycyB9ID0gZ2V0UGVlckFkZHJlc3MocGVlcklkT3JNdWx0aWFkZHIpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBhbiBleGlzdGluZyBjb25uZWN0aW9uIHRvIGFueSBvZiB0aGUgYWRkcmVzc2VzIHdlXG4gICAgICAgIC8vIGFyZSBhYm91dCB0byBkaWFsXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ29ubmVjdGlvbiA9IEFycmF5LmZyb20odGhpcy5jb25uZWN0aW9ucy52YWx1ZXMoKSkuZmxhdCgpLmZpbmQoY29ubiA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uLnJlbW90ZVBlZXIuZXF1YWxzKHBlZXJJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtdWx0aWFkZHJzLmZpbmQoYWRkciA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHIuZXF1YWxzKGNvbm4ucmVtb3RlQWRkcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChleGlzdGluZ0Nvbm5lY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2FscmVhZHkgY29ubmVjdGVkIHRvICVhJywgZXhpc3RpbmdDb25uZWN0aW9uLnJlbW90ZUFkZHIpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ29ubmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeSB0byBkaWFsLCBhbGwgYXN5bmMgd29yayBmaW5pc2hlZCAtIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIGFueVxuICAgICAgICAvLyBwZW5kaW5nIGRpYWxzIGluIHByb2dyZXNzIGZvciB0aGlzIHBlZXIgb3Igc2V0IG9mIG11bHRpYWRkcnNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEaWFsID0gdGhpcy5xdWV1ZS5xdWV1ZS5maW5kKGpvYiA9PiB7XG4gICAgICAgICAgICBpZiAocGVlcklkPy5lcXVhbHMoam9iLm9wdGlvbnMucGVlcklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9lcyB0aGUgZGlhbCBjb250YWluIGFueSBvZiB0aGUgdGFyZ2V0IG11bHRpYWRkcnM/XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBqb2Iub3B0aW9ucy5tdWx0aWFkZHJzO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtdWx0aWFkZHIgb2YgbXVsdGlhZGRycykge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzZXMuaGFzKG11bHRpYWRkci50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXhpc3RpbmdEaWFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdqb2luaW5nIGV4aXN0aW5nIGRpYWwgdGFyZ2V0IGZvciAlcCcsIHBlZXJJZCk7XG4gICAgICAgICAgICAvLyBhZGQgYWxsIG11bHRpYWRkcnMgdG8gdGhlIGRpYWwgdGFyZ2V0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11bHRpYWRkciBvZiBtdWx0aWFkZHJzKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdEaWFsLm9wdGlvbnMubXVsdGlhZGRycy5hZGQobXVsdGlhZGRyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nRGlhbC5qb2luKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLnNpemUgPj0gdGhpcy5tYXhEaWFsUXVldWVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ0RpYWwgcXVldWUgaXMgZnVsbCcsICdFUlJfRElBTF9RVUVVRV9GVUxMJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coJ2NyZWF0aW5nIGRpYWwgdGFyZ2V0IGZvciAlcCcsIHBlZXJJZCwgbXVsdGlhZGRycy5tYXAobWEgPT4gbWEudG9TdHJpbmcoKSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGQoYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhYm9ydCBjb25kaXRpb25zIC0gbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBgY2FsY3VsYXRlTXVsdGlhZGRyc2AgYXNcbiAgICAgICAgICAgIC8vIHdlIG1heSBiZSBhYm91dCB0byByZXNvbHZlIGEgZG5zIGFkZHIgd2hpY2ggY2FuIHRpbWUgb3V0XG4gICAgICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNyZWF0ZURpYWxBYm9ydENvbnRyb2xsZXIob3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgICAgIGxldCBhZGRyc1RvRGlhbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gbG9hZCBhZGRyZXNzZXMgZnJvbSBhZGRyZXNzIGJvb2ssIHJlc29sdmUgYW5kIGRuc2FkZHJzLCBmaWx0ZXJcbiAgICAgICAgICAgICAgICAvLyB1bmRpYWxsYWJsZXMsIGFkZCBwZWVyIElEcywgZXRjXG4gICAgICAgICAgICAgICAgYWRkcnNUb0RpYWwgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZU11bHRpYWRkcnMocGVlcklkLCBvcHRpb25zPy5tdWx0aWFkZHJzLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkZHJzVG9EaWFsLm1hcCgoeyBtdWx0aWFkZHIgfSkgPT4gbXVsdGlhZGRyLnRvU3RyaW5nKCkpLmZvckVhY2goYWRkciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM/Lm11bHRpYWRkcnMuYWRkKGFkZHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpYWxlZCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJzVG9EaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWFsZWQgPT09IHRoaXMubWF4UGVlckFkZHJzVG9EaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZGlhbGVkIG1heFBlZXJBZGRyc1RvRGlhbCAoJWQpIGFkZHJlc3NlcyBmb3IgJXAsIG5vdCB0cnlpbmcgYW55IG90aGVycycsIGRpYWxlZCwgcGVlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ1BlZXIgaGFkIG1vcmUgdGhhbiBtYXhQZWVyQWRkcnNUb0RpYWwnLCBjb2Rlcy5FUlJfVE9PX01BTllfQUREUkVTU0VTKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWFsZWQrKztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCB0aGlzLmNvbXBvbmVudHMudHJhbnNwb3J0TWFuYWdlci5kaWFsKGFkZHJlc3MubXVsdGlhZGRyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2RpYWwgdG8gJWEgc3VjY2VlZGVkJywgYWRkcmVzcy5tdWx0aWFkZHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2RpYWwgZmFpbGVkIHRvICVhJywgYWRkcmVzcy5tdWx0aWFkZHIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVlcklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGZhaWxlZCBkaWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wb25lbnRzLnBlZXJTdG9yZS5wYXRjaChwZWVySWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0xBU1RfRElBTF9GQUlMVVJFX0tFWV06IHVpbnQ4QXJyYXlGcm9tU3RyaW5nKERhdGUubm93KCkudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCB1cGRhdGUgbGFzdCBkaWFsIGZhaWx1cmUga2V5IGZvciAlcCcsIHBlZXJJZCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXNlci9kaWFsIHRpbWVvdXQvc2h1dGRvd24gY29udHJvbGxlciBzaWduYWwgYWJvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihlcnIubWVzc2FnZSwgRVJSX1RJTUVPVVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVDb2RlRXJyb3IoZXJyb3JzLCAnQWxsIG11bHRpYWRkciBkaWFscyBmYWlsZWQnLCBjb2Rlcy5FUlJfVFJBTlNQT1JUX0RJQUxfRkFJTEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIGFib3J0IHNpZ25hbHMvY29udHJvbGxlcnNcbiAgICAgICAgICAgICAgICBzaWduYWwuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgcGVlcklkLFxuICAgICAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHksXG4gICAgICAgICAgICBtdWx0aWFkZHJzOiBuZXcgU2V0KG11bHRpYWRkcnMubWFwKG1hID0+IG1hLnRvU3RyaW5nKCkpKSxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZURpYWxBYm9ydENvbnRyb2xsZXIodXNlclNpZ25hbCkge1xuICAgICAgICAvLyBsZXQgYW55IHNpZ25hbCBhYm9ydCB0aGUgZGlhbFxuICAgICAgICBjb25zdCBzaWduYWwgPSBhbnlTaWduYWwoW1xuICAgICAgICAgICAgQWJvcnRTaWduYWwudGltZW91dCh0aGlzLmRpYWxUaW1lb3V0KSxcbiAgICAgICAgICAgIHRoaXMuc2h1dERvd25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgIHVzZXJTaWduYWxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIFRoaXMgZW1pdHRlciBnZXRzIGxpc3RlbmVkIHRvIGEgbG90XG4gICAgICAgIHNldE1heExpc3RlbmVycyhJbmZpbml0eSwgc2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hbDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBhc3luYyBjYWxjdWxhdGVNdWx0aWFkZHJzKHBlZXJJZCwgbXVsdGlhZGRycyA9IG5ldyBTZXQoKSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFkZHJzID0gWy4uLm11bHRpYWRkcnNdLm1hcChtYSA9PiAoe1xuICAgICAgICAgICAgbXVsdGlhZGRyOiBtdWx0aWFkZHIobWEpLFxuICAgICAgICAgICAgaXNDZXJ0aWZpZWQ6IGZhbHNlXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gaWYgYSBwZWVyIGlkIG9yIG11bHRpYWRkcihzKSB3aXRoIGEgcGVlciBpZCwgbWFrZSBzdXJlIGl0IGlzbid0IG91ciBwZWVyIGlkIGFuZCB0aGF0IHdlIGFyZSBhbGxvd2VkIHRvIGRpYWwgaXRcbiAgICAgICAgaWYgKHBlZXJJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzLnBlZXJJZC5lcXVhbHMocGVlcklkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ1RyaWVkIHRvIGRpYWwgc2VsZicsIGNvZGVzLkVSUl9ESUFMRURfU0VMRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGF3YWl0IHRoaXMuY29tcG9uZW50cy5jb25uZWN0aW9uR2F0ZXIuZGVueURpYWxQZWVyPy4ocGVlcklkKSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdUaGUgZGlhbCByZXF1ZXN0IGlzIGJsb2NrZWQgYnkgZ2F0ZXIuYWxsb3dEaWFsUGVlcicsIGNvZGVzLkVSUl9QRUVSX0RJQUxfSU5URVJDRVBURUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYganVzdCBhIHBlZXIgaWQgd2FzIHBhc3NlZCwgbG9hZCBhdmFpbGFibGUgbXVsdGlhZGRycyBmb3IgdGhpcyBwZWVyXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBwZWVyIHN0b3JlXG4gICAgICAgICAgICBpZiAoYWRkcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2xvYWRpbmcgbXVsdGlhZGRycyBmb3IgJXAnLCBwZWVySWQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlZXIgPSBhd2FpdCB0aGlzLmNvbXBvbmVudHMucGVlclN0b3JlLmdldChwZWVySWQpO1xuICAgICAgICAgICAgICAgICAgICBhZGRycy5wdXNoKC4uLnBlZXIuYWRkcmVzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2xvYWRlZCBtdWx0aWFkZHJzIGZvciAlcCcsIHBlZXJJZCwgYWRkcnMubWFwKCh7IG11bHRpYWRkciB9KSA9PiBtdWx0aWFkZHIudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gY29kZXMuRVJSX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhbnkgYWRkcmVzc2VzIGZvciB0aGlzIHBlZXIsIHRyeSBhIGxvb2t1cFxuICAgICAgICAgICAgLy8gdXNpbmcgdGhlIHBlZXIgcm91dGluZ1xuICAgICAgICAgICAgaWYgKGFkZHJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdsb29raW5nIHVwIG11bHRpYWRkcnMgZm9yICVwIGluIHRoZSBwZWVyIHJvdXRpbmcnLCBwZWVySWQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlZXJJbmZvID0gYXdhaXQgdGhpcy5jb21wb25lbnRzLnBlZXJSb3V0aW5nLmZpbmRQZWVyKHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdmb3VuZCBtdWx0aWFkZHJzIGZvciAlcCBpbiB0aGUgcGVlciByb3V0aW5nJywgcGVlcklkLCBhZGRycy5tYXAoKHsgbXVsdGlhZGRyIH0pID0+IG11bHRpYWRkci50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJzLnB1c2goLi4ucGVlckluZm8ubXVsdGlhZGRycy5tYXAobXVsdGlhZGRyID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWFkZHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NlcnRpZmllZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IGNvZGVzLkVSUl9OT19ST1VURVJTX0FWQUlMQUJMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2xvb2tpbmcgdXAgbXVsdGlhZGRycyBmb3IgJXAgaW4gdGhlIHBlZXIgcm91dGluZyBmYWlsZWQnLCBwZWVySWQsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhZGRyZXNzZXMgLSB0aGlzIGNhbiByZXN1bHQgaW4gYSBvbmUtdG8tbWFueSB0cmFuc2xhdGlvbiB3aGVuXG4gICAgICAgIC8vIGRuc2FkZHJzIGFyZSByZXNvbHZlZFxuICAgICAgICBsZXQgcmVzb2x2ZWRBZGRyZXNzZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoYWRkcnMubWFwKGFzeW5jIChhZGRyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvbHZlTXVsdGlhZGRycyhhZGRyLm11bHRpYWRkciwge1xuICAgICAgICAgICAgICAgIGRuczogdGhpcy5jb21wb25lbnRzLmRucyxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGxvZzogdGhpcy5sb2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEgJiYgcmVzdWx0WzBdLmVxdWFscyhhZGRyLm11bHRpYWRkcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKG11bHRpYWRkciA9PiAoe1xuICAgICAgICAgICAgICAgIG11bHRpYWRkcixcbiAgICAgICAgICAgICAgICBpc0NlcnRpZmllZDogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpKVxuICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBwZWVyIGlkIGlzIGFwcGVuZGVkIHRvIHRoZSBtdWx0aWFkZHJcbiAgICAgICAgaWYgKHBlZXJJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwZWVySWRNdWx0aWFkZHIgPSBgL3AycC8ke3BlZXJJZC50b1N0cmluZygpfWA7XG4gICAgICAgICAgICByZXNvbHZlZEFkZHJlc3NlcyA9IHJlc29sdmVkQWRkcmVzc2VzLm1hcChhZGRyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UHJvdG8gPSBhZGRyLm11bHRpYWRkci5wcm90b3MoKS5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYXBwZW5kIHBlZXIgaWQgdG8gcGF0aCBtdWx0aWFkZHJzXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQcm90bz8ucGF0aCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIHBlZXIgaWQgdG8gbXVsdGlhZGRyIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoYWRkci5tdWx0aWFkZHIuZ2V0UGVlcklkKCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlhZGRyOiBhZGRyLm11bHRpYWRkci5lbmNhcHN1bGF0ZShwZWVySWRNdWx0aWFkZHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDZXJ0aWZpZWQ6IGFkZHIuaXNDZXJ0aWZpZWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZEFkZHJzID0gcmVzb2x2ZWRBZGRyZXNzZXMuZmlsdGVyKGFkZHIgPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBhbnkgbXVsdGlhZGRycyB0aGF0IHdlIGRvIG5vdCBoYXZlIHRyYW5zcG9ydHMgZm9yXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzLnRyYW5zcG9ydE1hbmFnZXIudHJhbnNwb3J0Rm9yTXVsdGlhZGRyKGFkZHIubXVsdGlhZGRyKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlc29sdmVkIG11bHRpYWRkciBoYXMgYSBQZWVySUQgYnV0IGl0J3MgdGhlIHdyb25nIG9uZSwgaWdub3JlIGl0XG4gICAgICAgICAgICAvLyAtIHRoaXMgY2FuIGhhcHBlbiB3aXRoIGFkZHJlc3NlcyBsaWtlIGJvb3RzdHJhcC5saWJwMnAuaW8gdGhhdCByZXNvbHZlXG4gICAgICAgICAgICAvLyB0byBtdWx0aXBsZSBkaWZmZXJlbnQgcGVlcnNcbiAgICAgICAgICAgIGNvbnN0IGFkZHJQZWVySWQgPSBhZGRyLm11bHRpYWRkci5nZXRQZWVySWQoKTtcbiAgICAgICAgICAgIGlmIChwZWVySWQgIT0gbnVsbCAmJiBhZGRyUGVlcklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVlcklkLmVxdWFscyhhZGRyUGVlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGVkdXBsaWNhdGUgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IGRlZHVwZWRBZGRycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlcmVkQWRkcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hU3RyID0gYWRkci5tdWx0aWFkZHIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gZGVkdXBlZEFkZHJzLmdldChtYVN0cik7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLmlzQ2VydGlmaWVkID0gZXhpc3RpbmcuaXNDZXJ0aWZpZWQgfHwgYWRkci5pc0NlcnRpZmllZCB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZHVwZWRBZGRycy5zZXQobWFTdHIsIGFkZHIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZHVwZWRNdWx0aWFkZHJzID0gWy4uLmRlZHVwZWRBZGRycy52YWx1ZXMoKV07XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIHNvbWUgYWRkcmVzc2VzIHRvIGRpYWxcbiAgICAgICAgaWYgKGRlZHVwZWRNdWx0aWFkZHJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignVGhlIGRpYWwgcmVxdWVzdCBoYXMgbm8gdmFsaWQgYWRkcmVzc2VzJywgY29kZXMuRVJSX05PX1ZBTElEX0FERFJFU1NFUyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2F0ZWRBZHJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBkZWR1cGVkTXVsdGlhZGRycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cy5jb25uZWN0aW9uR2F0ZXIuZGVueURpYWxNdWx0aWFkZHIgIT0gbnVsbCAmJiBhd2FpdCB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbkdhdGVyLmRlbnlEaWFsTXVsdGlhZGRyKGFkZHIubXVsdGlhZGRyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2F0ZWRBZHJzLnB1c2goYWRkcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ydGVkR2F0ZWRBZGRycyA9IGdhdGVkQWRycy5zb3J0KHRoaXMuYWRkcmVzc1NvcnRlcik7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIHNvbWUgYWRkcmVzc2VzIHRvIGRpYWxcbiAgICAgICAgaWYgKHNvcnRlZEdhdGVkQWRkcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdUaGUgY29ubmVjdGlvbiBnYXRlciBkZW5pZWQgYWxsIGFkZHJlc3NlcyBpbiB0aGUgZGlhbCByZXF1ZXN0JywgY29kZXMuRVJSX05PX1ZBTElEX0FERFJFU1NFUyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cudHJhY2UoJ2FkZHJlc3NlcyBmb3IgJXAgYmVmb3JlIGZpbHRlcmluZycsIHBlZXJJZCA/PyAndW5rbm93biBwZWVyJywgcmVzb2x2ZWRBZGRyZXNzZXMubWFwKCh7IG11bHRpYWRkciB9KSA9PiBtdWx0aWFkZHIudG9TdHJpbmcoKSkpO1xuICAgICAgICB0aGlzLmxvZy50cmFjZSgnYWRkcmVzc2VzIGZvciAlcCBhZnRlciBmaWx0ZXJpbmcnLCBwZWVySWQgPz8gJ3Vua25vd24gcGVlcicsIHNvcnRlZEdhdGVkQWRkcnMubWFwKCh7IG11bHRpYWRkciB9KSA9PiBtdWx0aWFkZHIudG9TdHJpbmcoKSkpO1xuICAgICAgICByZXR1cm4gc29ydGVkR2F0ZWRBZGRycztcbiAgICB9XG4gICAgYXN5bmMgaXNEaWFsYWJsZShtdWx0aWFkZHIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobXVsdGlhZGRyKSkge1xuICAgICAgICAgICAgbXVsdGlhZGRyID0gW211bHRpYWRkcl07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlTXVsdGlhZGRycyh1bmRlZmluZWQsIG5ldyBTZXQobXVsdGlhZGRyLm1hcChtYSA9PiBtYS50b1N0cmluZygpKSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucnVuT25UcmFuc2llbnRDb25uZWN0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0cnVlIGlmIGFueSByZXNvbHZlZCBtdWx0aWFkZHJzIGFyZSBub3QgcmVsYXkgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3Nlcy5maW5kKGFkZHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIUNpcmN1aXQubWF0Y2hlcyhhZGRyLm11bHRpYWRkcik7XG4gICAgICAgICAgICAgICAgfSkgIT0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLnRyYWNlKCdlcnJvciBjYWxjdWxhdGluZyBpZiBtdWx0aWFkZHIocykgd2VyZSBkaWFsYWJsZScsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpYWwtcXVldWUuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVFcnJvciIsIkFnZ3JlZ2F0ZUNvZGVFcnJvciIsIkVSUl9USU1FT1VUIiwic2V0TWF4TGlzdGVuZXJzIiwiUGVlck1hcCIsImRlZmF1bHRBZGRyZXNzU29ydCIsIlF1ZXVlIiwicmVzb2x2ZXJzIiwibXVsdGlhZGRyIiwiZG5zYWRkclJlc29sdmVyIiwiQ2lyY3VpdCIsImFueVNpZ25hbCIsImZyb21TdHJpbmciLCJ1aW50OEFycmF5RnJvbVN0cmluZyIsImNvZGVzIiwiZ2V0UGVlckFkZHJlc3MiLCJESUFMX1RJTUVPVVQiLCJNQVhfUEFSQUxMRUxfRElBTFMiLCJNQVhfUEVFUl9BRERSU19UT19ESUFMIiwiTEFTVF9ESUFMX0ZBSUxVUkVfS0VZIiwiTUFYX0RJQUxfUVVFVUVfTEVOR1RIIiwicmVzb2x2ZU11bHRpYWRkcnMiLCJkZWZhdWx0T3B0aW9ucyIsImFkZHJlc3NTb3J0ZXIiLCJtYXhQYXJhbGxlbERpYWxzIiwibWF4RGlhbFF1ZXVlTGVuZ3RoIiwibWF4UGVlckFkZHJzVG9EaWFsIiwiZGlhbFRpbWVvdXQiLCJkbnNhZGRyIiwiRGlhbFF1ZXVlIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRzIiwiaW5pdCIsImNvbm5lY3Rpb25zIiwibG9nIiwibG9nZ2VyIiwiZm9yQ29tcG9uZW50Iiwic2h1dERvd25Db250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiSW5maW5pdHkiLCJzaWduYWwiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzZXQiLCJxdWV1ZSIsImNvbmN1cnJlbmN5IiwibWV0cmljTmFtZSIsIm1ldHJpY3MiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJlcnJvciIsImRldGFpbCIsInN0YXJ0Iiwic3RvcCIsImFib3J0IiwiZGlhbCIsInBlZXJJZE9yTXVsdGlhZGRyIiwib3B0aW9ucyIsInBlZXJJZCIsIm11bHRpYWRkcnMiLCJleGlzdGluZ0Nvbm5lY3Rpb24iLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJmbGF0IiwiZmluZCIsImNvbm4iLCJmb3JjZSIsInJlbW90ZVBlZXIiLCJlcXVhbHMiLCJhZGRyIiwicmVtb3RlQWRkciIsImV4aXN0aW5nRGlhbCIsImpvYiIsImFkZHJlc3NlcyIsImhhcyIsInRvU3RyaW5nIiwiYWRkIiwiam9pbiIsInNpemUiLCJtYXAiLCJtYSIsImNyZWF0ZURpYWxBYm9ydENvbnRyb2xsZXIiLCJhZGRyc1RvRGlhbCIsImNhbGN1bGF0ZU11bHRpYWRkcnMiLCJmb3JFYWNoIiwiZXJyIiwiY2xlYXIiLCJkaWFsZWQiLCJlcnJvcnMiLCJhZGRyZXNzIiwiRVJSX1RPT19NQU5ZX0FERFJFU1NFUyIsInRyYW5zcG9ydE1hbmFnZXIiLCJwZWVyU3RvcmUiLCJwYXRjaCIsIm1ldGFkYXRhIiwiRGF0ZSIsIm5vdyIsImFib3J0ZWQiLCJtZXNzYWdlIiwicHVzaCIsImxlbmd0aCIsIkVSUl9UUkFOU1BPUlRfRElBTF9GQUlMRUQiLCJwcmlvcml0eSIsIlNldCIsInVzZXJTaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJhZGRycyIsImlzQ2VydGlmaWVkIiwiRVJSX0RJQUxFRF9TRUxGIiwiY29ubmVjdGlvbkdhdGVyIiwiZGVueURpYWxQZWVyIiwiRVJSX1BFRVJfRElBTF9JTlRFUkNFUFRFRCIsInBlZXIiLCJnZXQiLCJjb2RlIiwiRVJSX05PVF9GT1VORCIsInBlZXJJbmZvIiwicGVlclJvdXRpbmciLCJmaW5kUGVlciIsIkVSUl9OT19ST1VURVJTX0FWQUlMQUJMRSIsInJlc29sdmVkQWRkcmVzc2VzIiwiUHJvbWlzZSIsImFsbCIsInJlc3VsdCIsImRucyIsInBlZXJJZE11bHRpYWRkciIsImxhc3RQcm90byIsInByb3RvcyIsInBvcCIsInBhdGgiLCJnZXRQZWVySWQiLCJlbmNhcHN1bGF0ZSIsImZpbHRlcmVkQWRkcnMiLCJmaWx0ZXIiLCJ0cmFuc3BvcnRGb3JNdWx0aWFkZHIiLCJhZGRyUGVlcklkIiwiZGVkdXBlZEFkZHJzIiwiTWFwIiwibWFTdHIiLCJleGlzdGluZyIsImRlZHVwZWRNdWx0aWFkZHJzIiwiRVJSX05PX1ZBTElEX0FERFJFU1NFUyIsImdhdGVkQWRycyIsImRlbnlEaWFsTXVsdGlhZGRyIiwic29ydGVkR2F0ZWRBZGRycyIsInNvcnQiLCJ0cmFjZSIsImlzRGlhbGFibGUiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwicnVuT25UcmFuc2llbnRDb25uZWN0aW9uIiwibWF0Y2hlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/dial-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultConnectionManager: () => (/* binding */ DefaultConnectionManager)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/peer-store/tags.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/map.js\");\n/* harmony import */ var _libp2p_utils_address_sort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @libp2p/utils/address-sort */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/address-sort.js\");\n/* harmony import */ var _libp2p_utils_rate_limiter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/utils/rate-limiter */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/rate-limiter.js\");\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/* harmony import */ var _multiformats_multiaddr_resolvers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/multiaddr/resolvers */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n/* harmony import */ var _get_peer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../get-peer.js */ \"(ssr)/./node_modules/libp2p/dist/src/get-peer.js\");\n/* harmony import */ var _auto_dial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./auto-dial.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/auto-dial.js\");\n/* harmony import */ var _connection_pruner_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./connection-pruner.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/connection-pruner.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js\");\n/* harmony import */ var _dial_queue_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dial-queue.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/dial-queue.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_DIAL_PRIORITY = 50;\nconst defaultOptions = {\n    minConnections: _constants_js__WEBPACK_IMPORTED_MODULE_2__.MIN_CONNECTIONS,\n    maxConnections: _constants_js__WEBPACK_IMPORTED_MODULE_2__.MAX_CONNECTIONS,\n    inboundConnectionThreshold: _constants_js__WEBPACK_IMPORTED_MODULE_3__.INBOUND_CONNECTION_THRESHOLD,\n    maxIncomingPendingConnections: _constants_js__WEBPACK_IMPORTED_MODULE_3__.MAX_INCOMING_PENDING_CONNECTIONS,\n    autoDialConcurrency: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTO_DIAL_CONCURRENCY,\n    autoDialPriority: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTO_DIAL_PRIORITY,\n    autoDialMaxQueueLength: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTO_DIAL_MAX_QUEUE_LENGTH\n};\n/**\n * Responsible for managing known connections.\n */ class DefaultConnectionManager {\n    constructor(components, init = {}){\n        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;\n        const minConnections = init.minConnections ?? defaultOptions.minConnections;\n        if (this.maxConnections < minConnections) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError(\"Connection Manager maxConnections must be greater than minConnections\", _errors_js__WEBPACK_IMPORTED_MODULE_5__.codes.ERR_INVALID_PARAMETERS);\n        }\n        /**\n         * Map of connections per peer\n         */ this.connections = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_6__.PeerMap();\n        this.started = false;\n        this.peerStore = components.peerStore;\n        this.metrics = components.metrics;\n        this.events = components.events;\n        this.log = components.logger.forComponent(\"libp2p:connection-manager\");\n        this.onConnect = this.onConnect.bind(this);\n        this.onDisconnect = this.onDisconnect.bind(this);\n        this.events.addEventListener(\"connection:open\", this.onConnect);\n        this.events.addEventListener(\"connection:close\", this.onDisconnect);\n        // allow/deny lists\n        this.allow = (init.allow ?? []).map((ma)=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(ma));\n        this.deny = (init.deny ?? []).map((ma)=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(ma));\n        this.incomingPendingConnections = 0;\n        this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections;\n        // controls individual peers trying to dial us too quickly\n        this.inboundConnectionRateLimiter = new _libp2p_utils_rate_limiter__WEBPACK_IMPORTED_MODULE_7__.RateLimiter({\n            points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n            duration: 1\n        });\n        // controls what happens when we don't have enough connections\n        this.autoDial = new _auto_dial_js__WEBPACK_IMPORTED_MODULE_8__.AutoDial({\n            connectionManager: this,\n            peerStore: components.peerStore,\n            events: components.events,\n            logger: components.logger\n        }, {\n            minConnections,\n            autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n            autoDialPriority: init.autoDialPriority ?? defaultOptions.autoDialPriority,\n            maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength\n        });\n        // controls what happens when we have too many connections\n        this.connectionPruner = new _connection_pruner_js__WEBPACK_IMPORTED_MODULE_9__.ConnectionPruner({\n            connectionManager: this,\n            peerStore: components.peerStore,\n            events: components.events,\n            logger: components.logger\n        }, {\n            maxConnections: this.maxConnections,\n            allow: this.allow\n        });\n        this.dialQueue = new _dial_queue_js__WEBPACK_IMPORTED_MODULE_10__.DialQueue(components, {\n            addressSorter: init.addressSorter ?? _libp2p_utils_address_sort__WEBPACK_IMPORTED_MODULE_11__.defaultAddressSort,\n            maxParallelDials: init.maxParallelDials ?? _constants_js__WEBPACK_IMPORTED_MODULE_2__.MAX_PARALLEL_DIALS,\n            maxDialQueueLength: init.maxDialQueueLength ?? _constants_js__WEBPACK_IMPORTED_MODULE_3__.MAX_DIAL_QUEUE_LENGTH,\n            maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? _constants_js__WEBPACK_IMPORTED_MODULE_3__.MAX_PEER_ADDRS_TO_DIAL,\n            dialTimeout: init.dialTimeout ?? _constants_js__WEBPACK_IMPORTED_MODULE_3__.DIAL_TIMEOUT,\n            resolvers: init.resolvers ?? {\n                dnsaddr: _multiformats_multiaddr_resolvers__WEBPACK_IMPORTED_MODULE_1__.dnsaddrResolver\n            },\n            connections: this.connections\n        });\n    }\n    isStarted() {\n        return this.started;\n    }\n    /**\n     * Starts the Connection Manager. If Metrics are not enabled on libp2p\n     * only event loop and connection limits will be monitored.\n     */ async start() {\n        // track inbound/outbound connections\n        this.metrics?.registerMetricGroup(\"libp2p_connection_manager_connections\", {\n            calculate: ()=>{\n                const metric = {\n                    inbound: 0,\n                    outbound: 0\n                };\n                for (const conns of this.connections.values()){\n                    for (const conn of conns){\n                        if (conn.direction === \"inbound\") {\n                            metric.inbound++;\n                        } else {\n                            metric.outbound++;\n                        }\n                    }\n                }\n                return metric;\n            }\n        });\n        // track total number of streams per protocol\n        this.metrics?.registerMetricGroup(\"libp2p_protocol_streams_total\", {\n            label: \"protocol\",\n            calculate: ()=>{\n                const metric = {};\n                for (const conns of this.connections.values()){\n                    for (const conn of conns){\n                        for (const stream of conn.streams){\n                            const key = `${stream.direction} ${stream.protocol ?? \"unnegotiated\"}`;\n                            metric[key] = (metric[key] ?? 0) + 1;\n                        }\n                    }\n                }\n                return metric;\n            }\n        });\n        // track 90th percentile of streams per protocol\n        this.metrics?.registerMetricGroup(\"libp2p_connection_manager_protocol_streams_per_connection_90th_percentile\", {\n            label: \"protocol\",\n            calculate: ()=>{\n                const allStreams = {};\n                for (const conns of this.connections.values()){\n                    for (const conn of conns){\n                        const streams = {};\n                        for (const stream of conn.streams){\n                            const key = `${stream.direction} ${stream.protocol ?? \"unnegotiated\"}`;\n                            streams[key] = (streams[key] ?? 0) + 1;\n                        }\n                        for (const [protocol, count] of Object.entries(streams)){\n                            allStreams[protocol] = allStreams[protocol] ?? [];\n                            allStreams[protocol].push(count);\n                        }\n                    }\n                }\n                const metric = {};\n                for (let [protocol, counts] of Object.entries(allStreams)){\n                    counts = counts.sort((a, b)=>a - b);\n                    const index = Math.floor(counts.length * 0.9);\n                    metric[protocol] = counts[index];\n                }\n                return metric;\n            }\n        });\n        this.dialQueue.start();\n        this.autoDial.start();\n        this.started = true;\n        this.log(\"started\");\n    }\n    async afterStart() {\n        // re-connect to any peers with the KEEP_ALIVE tag\n        void Promise.resolve().then(async ()=>{\n            const keepAlivePeers = await this.peerStore.all({\n                filters: [\n                    (peer)=>{\n                        return peer.tags.has(_libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.KEEP_ALIVE);\n                    }\n                ]\n            });\n            await Promise.all(keepAlivePeers.map(async (peer)=>{\n                await this.openConnection(peer.id).catch((err)=>{\n                    this.log.error(err);\n                });\n            }));\n        }).catch((err)=>{\n            this.log.error(err);\n        });\n        this.autoDial.afterStart();\n    }\n    /**\n     * Stops the Connection Manager\n     */ async stop() {\n        this.dialQueue.stop();\n        this.autoDial.stop();\n        // Close all connections we're tracking\n        const tasks = [];\n        for (const connectionList of this.connections.values()){\n            for (const connection of connectionList){\n                tasks.push((async ()=>{\n                    try {\n                        await connection.close();\n                    } catch (err) {\n                        this.log.error(err);\n                    }\n                })());\n            }\n        }\n        this.log(\"closing %d connections\", tasks.length);\n        await Promise.all(tasks);\n        this.connections.clear();\n        this.log(\"stopped\");\n    }\n    onConnect(evt) {\n        void this._onConnect(evt).catch((err)=>{\n            this.log.error(err);\n        });\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     */ async _onConnect(evt) {\n        const { detail: connection } = evt;\n        if (!this.started) {\n            // This can happen when we are in the process of shutting down the node\n            await connection.close();\n            return;\n        }\n        const peerId = connection.remotePeer;\n        const storedConns = this.connections.get(peerId);\n        let isNewPeer = false;\n        if (storedConns != null) {\n            storedConns.push(connection);\n        } else {\n            isNewPeer = true;\n            this.connections.set(peerId, [\n                connection\n            ]);\n        }\n        // only need to store RSA public keys, all other types are embedded in the peer id\n        if (peerId.publicKey != null && peerId.type === \"RSA\") {\n            await this.peerStore.patch(peerId, {\n                publicKey: peerId.publicKey\n            });\n        }\n        if (isNewPeer) {\n            this.events.safeDispatchEvent(\"peer:connect\", {\n                detail: connection.remotePeer\n            });\n        }\n    }\n    /**\n     * Removes the connection from tracking\n     */ onDisconnect(evt) {\n        const { detail: connection } = evt;\n        if (!this.started) {\n            // This can happen when we are in the process of shutting down the node\n            return;\n        }\n        const peerId = connection.remotePeer;\n        let storedConn = this.connections.get(peerId);\n        if (storedConn != null && storedConn.length > 1) {\n            storedConn = storedConn.filter((conn)=>conn.id !== connection.id);\n            this.connections.set(peerId, storedConn);\n        } else if (storedConn != null) {\n            this.connections.delete(peerId);\n            this.events.safeDispatchEvent(\"peer:disconnect\", {\n                detail: connection.remotePeer\n            });\n        }\n    }\n    getConnections(peerId) {\n        if (peerId != null) {\n            return this.connections.get(peerId) ?? [];\n        }\n        let conns = [];\n        for (const c of this.connections.values()){\n            conns = conns.concat(c);\n        }\n        return conns;\n    }\n    getConnectionsMap() {\n        return this.connections;\n    }\n    async openConnection(peerIdOrMultiaddr, options = {}) {\n        if (!this.isStarted()) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError(\"Not started\", _errors_js__WEBPACK_IMPORTED_MODULE_5__.codes.ERR_NODE_NOT_STARTED);\n        }\n        options.signal?.throwIfAborted();\n        const { peerId } = (0,_get_peer_js__WEBPACK_IMPORTED_MODULE_13__.getPeerAddress)(peerIdOrMultiaddr);\n        if (peerId != null && options.force !== true) {\n            this.log(\"dial %p\", peerId);\n            const existingConnection = this.getConnections(peerId).find((conn)=>!conn.transient);\n            if (existingConnection != null) {\n                this.log(\"had an existing non-transient connection to %p\", peerId);\n                return existingConnection;\n            }\n        }\n        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n            ...options,\n            priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n        });\n        let peerConnections = this.connections.get(connection.remotePeer);\n        if (peerConnections == null) {\n            peerConnections = [];\n            this.connections.set(connection.remotePeer, peerConnections);\n        }\n        // we get notified of connections via the Upgrader emitting \"connection\"\n        // events, double check we aren't already tracking this connection before\n        // storing it\n        let trackedConnection = false;\n        for (const conn of peerConnections){\n            if (conn.id === connection.id) {\n                trackedConnection = true;\n            }\n        }\n        if (!trackedConnection) {\n            peerConnections.push(connection);\n        }\n        return connection;\n    }\n    async closeConnections(peerId, options = {}) {\n        const connections = this.connections.get(peerId) ?? [];\n        await Promise.all(connections.map(async (connection)=>{\n            try {\n                await connection.close(options);\n            } catch (err) {\n                connection.abort(err);\n            }\n        }));\n    }\n    async acceptIncomingConnection(maConn) {\n        // check deny list\n        const denyConnection = this.deny.some((ma)=>{\n            return maConn.remoteAddr.toString().startsWith(ma.toString());\n        });\n        if (denyConnection) {\n            this.log(\"connection from %a refused - connection remote address was in deny list\", maConn.remoteAddr);\n            return false;\n        }\n        // check allow list\n        const allowConnection = this.allow.some((ma)=>{\n            return maConn.remoteAddr.toString().startsWith(ma.toString());\n        });\n        if (allowConnection) {\n            this.incomingPendingConnections++;\n            return true;\n        }\n        // check pending connections\n        if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n            this.log(\"connection from %a refused - incomingPendingConnections exceeded by host\", maConn.remoteAddr);\n            return false;\n        }\n        if (maConn.remoteAddr.isThinWaistAddress()) {\n            const host = maConn.remoteAddr.nodeAddress().address;\n            try {\n                await this.inboundConnectionRateLimiter.consume(host, 1);\n            } catch  {\n                this.log(\"connection from %a refused - inboundConnectionThreshold exceeded by host %s\", maConn.remoteAddr, host);\n                return false;\n            }\n        }\n        if (this.getConnections().length < this.maxConnections) {\n            this.incomingPendingConnections++;\n            return true;\n        }\n        this.log(\"connection from %a refused - maxConnections exceeded\", maConn.remoteAddr);\n        return false;\n    }\n    afterUpgradeInbound() {\n        this.incomingPendingConnections--;\n    }\n    getDialQueue() {\n        const statusMap = {\n            queued: \"queued\",\n            running: \"active\",\n            errored: \"error\",\n            complete: \"success\"\n        };\n        return this.dialQueue.queue.queue.map((job)=>{\n            return {\n                id: job.id,\n                status: statusMap[job.status],\n                peerId: job.options.peerId,\n                multiaddrs: [\n                    ...job.options.multiaddrs\n                ].map((ma)=>(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(ma))\n            };\n        });\n    }\n    async isDialable(multiaddr, options = {}) {\n        return this.dialQueue.isDialable(multiaddr, options);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDUDtBQUNhO0FBQ1A7QUFDTDtBQUNnQjtBQUMvQjtBQUNXO0FBQ047QUFDZ0I7QUFDZ087QUFDOU87QUFDNUMsTUFBTXVCLHdCQUF3QjtBQUM5QixNQUFNQyxpQkFBaUI7SUFDbkJDLGdCQUFnQkosMERBQWVBO0lBQy9CSyxnQkFBZ0JWLDBEQUFlQTtJQUMvQlcsNEJBQTRCWix1RUFBNEJBO0lBQ3hEYSwrQkFBK0JWLDJFQUFnQ0E7SUFDL0RXLHFCQUFxQmxCLGdFQUFxQkE7SUFDMUNtQixrQkFBa0JqQiw2REFBa0JBO0lBQ3BDa0Isd0JBQXdCbkIscUVBQTBCQTtBQUN0RDtBQUNBOztDQUVDLEdBQ00sTUFBTW9CO0lBZ0JUQyxZQUFZQyxVQUFVLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDL0IsSUFBSSxDQUFDVCxjQUFjLEdBQUdTLEtBQUtULGNBQWMsSUFBSUYsZUFBZUUsY0FBYztRQUMxRSxNQUFNRCxpQkFBaUJVLEtBQUtWLGNBQWMsSUFBSUQsZUFBZUMsY0FBYztRQUMzRSxJQUFJLElBQUksQ0FBQ0MsY0FBYyxHQUFHRCxnQkFBZ0I7WUFDdEMsTUFBTSxJQUFJekIsd0RBQVNBLENBQUMseUVBQXlFTyw2Q0FBS0EsQ0FBQzZCLHNCQUFzQjtRQUM3SDtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSW5DLDZEQUFPQTtRQUM5QixJQUFJLENBQUNvQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFNBQVMsR0FBR0wsV0FBV0ssU0FBUztRQUNyQyxJQUFJLENBQUNDLE9BQU8sR0FBR04sV0FBV00sT0FBTztRQUNqQyxJQUFJLENBQUNDLE1BQU0sR0FBR1AsV0FBV08sTUFBTTtRQUMvQixJQUFJLENBQUNDLEdBQUcsR0FBR1IsV0FBV1MsTUFB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RWlILE9BQU9HLFVBQVUsRUFBRUs7Z0JBQzNHLE9BQU87WUFDWDtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUM1QixjQUFjLEdBQUd0QyxNQUFNLEdBQUcsSUFBSSxDQUFDdkUsY0FBYyxFQUFFO1lBQ3BELElBQUksQ0FBQzJCLDBCQUEwQjtZQUMvQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNYLEdBQUcsQ0FBQyx3REFBd0RpSCxPQUFPRyxVQUFVO1FBQ2xGLE9BQU87SUFDWDtJQUNBUyxzQkFBc0I7UUFDbEIsSUFBSSxDQUFDbEgsMEJBQTBCO0lBQ25DO0lBQ0FtSCxlQUFlO1FBQ1gsTUFBTUMsWUFBWTtZQUNkQyxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsU0FBUztZQUNUQyxVQUFVO1FBQ2Q7UUFDQSxPQUFPLElBQUksQ0FBQ2hILFNBQVMsQ0FBQ2lILEtBQUssQ0FBQ0EsS0FBSyxDQUFDNUgsR0FBRyxDQUFDNkgsQ0FBQUE7WUFDbEMsT0FBTztnQkFDSGxFLElBQUlrRSxJQUFJbEUsRUFBRTtnQkFDVm1FLFFBQVFQLFNBQVMsQ0FBQ00sSUFBSUMsTUFBTSxDQUFDO2dCQUM3QnRELFFBQVFxRCxJQUFJbkMsT0FBTyxDQUFDbEIsTUFBTTtnQkFDMUJ1RCxZQUFZO3VCQUFJRixJQUFJbkMsT0FBTyxDQUFDcUMsVUFBVTtpQkFBQyxDQUFDL0gsR0FBRyxDQUFDQyxDQUFBQSxLQUFNOUMsa0VBQVNBLENBQUM4QztZQUNoRTtRQUNKO0lBQ0o7SUFDQSxNQUFNK0gsV0FBVzdLLFNBQVMsRUFBRXVJLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDdEMsT0FBTyxJQUFJLENBQUMvRSxTQUFTLENBQUNxSCxVQUFVLENBQUM3SyxXQUFXdUk7SUFDaEQ7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9jb25uZWN0aW9uLW1hbmFnZXIvaW5kZXguanM/ZTg2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRXJyb3IsIEtFRVBfQUxJVkUgfSBmcm9tICdAbGlicDJwL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBQZWVyTWFwIH0gZnJvbSAnQGxpYnAycC9wZWVyLWNvbGxlY3Rpb25zJztcbmltcG9ydCB7IGRlZmF1bHRBZGRyZXNzU29ydCB9IGZyb20gJ0BsaWJwMnAvdXRpbHMvYWRkcmVzcy1zb3J0JztcbmltcG9ydCB7IFJhdGVMaW1pdGVyIH0gZnJvbSAnQGxpYnAycC91dGlscy9yYXRlLWxpbWl0ZXInO1xuaW1wb3J0IHsgbXVsdGlhZGRyIH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHInO1xuaW1wb3J0IHsgZG5zYWRkclJlc29sdmVyIH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvcmVzb2x2ZXJzJztcbmltcG9ydCB7IGNvZGVzIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGdldFBlZXJBZGRyZXNzIH0gZnJvbSAnLi4vZ2V0LXBlZXIuanMnO1xuaW1wb3J0IHsgQXV0b0RpYWwgfSBmcm9tICcuL2F1dG8tZGlhbC5qcyc7XG5pbXBvcnQgeyBDb25uZWN0aW9uUHJ1bmVyIH0gZnJvbSAnLi9jb25uZWN0aW9uLXBydW5lci5qcyc7XG5pbXBvcnQgeyBBVVRPX0RJQUxfQ09OQ1VSUkVOQ1ksIEFVVE9fRElBTF9NQVhfUVVFVUVfTEVOR1RILCBBVVRPX0RJQUxfUFJJT1JJVFksIERJQUxfVElNRU9VVCwgSU5CT1VORF9DT05ORUNUSU9OX1RIUkVTSE9MRCwgTUFYX0NPTk5FQ1RJT05TLCBNQVhfRElBTF9RVUVVRV9MRU5HVEgsIE1BWF9JTkNPTUlOR19QRU5ESU5HX0NPTk5FQ1RJT05TLCBNQVhfUEFSQUxMRUxfRElBTFMsIE1BWF9QRUVSX0FERFJTX1RPX0RJQUwsIE1JTl9DT05ORUNUSU9OUyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERpYWxRdWV1ZSB9IGZyb20gJy4vZGlhbC1xdWV1ZS5qcyc7XG5jb25zdCBERUZBVUxUX0RJQUxfUFJJT1JJVFkgPSA1MDtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1pbkNvbm5lY3Rpb25zOiBNSU5fQ09OTkVDVElPTlMsXG4gICAgbWF4Q29ubmVjdGlvbnM6IE1BWF9DT05ORUNUSU9OUyxcbiAgICBpbmJvdW5kQ29ubmVjdGlvblRocmVzaG9sZDogSU5CT1VORF9DT05ORUNUSU9OX1RIUkVTSE9MRCxcbiAgICBtYXhJbmNvbWluZ1BlbmRpbmdDb25uZWN0aW9uczogTUFYX0lOQ09NSU5HX1BFTkRJTkdfQ09OTkVDVElPTlMsXG4gICAgYXV0b0RpYWxDb25jdXJyZW5jeTogQVVUT19ESUFMX0NPTkNVUlJFTkNZLFxuICAgIGF1dG9EaWFsUHJpb3JpdHk6IEFVVE9fRElBTF9QUklPUklUWSxcbiAgICBhdXRvRGlhbE1heFF1ZXVlTGVuZ3RoOiBBVVRPX0RJQUxfTUFYX1FVRVVFX0xFTkdUSFxufTtcbi8qKlxuICogUmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIGtub3duIGNvbm5lY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgICBzdGFydGVkO1xuICAgIGNvbm5lY3Rpb25zO1xuICAgIGFsbG93O1xuICAgIGRlbnk7XG4gICAgbWF4SW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnM7XG4gICAgaW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnM7XG4gICAgbWF4Q29ubmVjdGlvbnM7XG4gICAgZGlhbFF1ZXVlO1xuICAgIGF1dG9EaWFsO1xuICAgIGNvbm5lY3Rpb25QcnVuZXI7XG4gICAgaW5ib3VuZENvbm5lY3Rpb25SYXRlTGltaXRlcjtcbiAgICBwZWVyU3RvcmU7XG4gICAgbWV0cmljcztcbiAgICBldmVudHM7XG4gICAgbG9nO1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMsIGluaXQgPSB7fSkge1xuICAgICAgICB0aGlzLm1heENvbm5lY3Rpb25zID0gaW5pdC5tYXhDb25uZWN0aW9ucyA/PyBkZWZhdWx0T3B0aW9ucy5tYXhDb25uZWN0aW9ucztcbiAgICAgICAgY29uc3QgbWluQ29ubmVjdGlvbnMgPSBpbml0Lm1pbkNvbm5lY3Rpb25zID8/IGRlZmF1bHRPcHRpb25zLm1pbkNvbm5lY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9ucyA8IG1pbkNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdDb25uZWN0aW9uIE1hbmFnZXIgbWF4Q29ubmVjdGlvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gbWluQ29ubmVjdGlvbnMnLCBjb2Rlcy5FUlJfSU5WQUxJRF9QQVJBTUVURVJTKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIGNvbm5lY3Rpb25zIHBlciBwZWVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gbmV3IFBlZXJNYXAoKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVlclN0b3JlID0gY29tcG9uZW50cy5wZWVyU3RvcmU7XG4gICAgICAgIHRoaXMubWV0cmljcyA9IGNvbXBvbmVudHMubWV0cmljcztcbiAgICAgICAgdGhpcy5ldmVudHMgPSBjb21wb25lbnRzLmV2ZW50cztcbiAgICAgICAgdGhpcy5sb2cgPSBjb21wb25lbnRzLmxvZ2dlci5mb3JDb21wb25lbnQoJ2xpYnAycDpjb25uZWN0aW9uLW1hbmFnZXInKTtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IHRoaXMub25EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb246b3BlbicsIHRoaXMub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbjpjbG9zZScsIHRoaXMub25EaXNjb25uZWN0KTtcbiAgICAgICAgLy8gYWxsb3cvZGVueSBsaXN0c1xuICAgICAgICB0aGlzLmFsbG93ID0gKGluaXQuYWxsb3cgPz8gW10pLm1hcChtYSA9PiBtdWx0aWFkZHIobWEpKTtcbiAgICAgICAgdGhpcy5kZW55ID0gKGluaXQuZGVueSA/PyBbXSkubWFwKG1hID0+IG11bHRpYWRkcihtYSkpO1xuICAgICAgICB0aGlzLmluY29taW5nUGVuZGluZ0Nvbm5lY3Rpb25zID0gMDtcbiAgICAgICAgdGhpcy5tYXhJbmNvbWluZ1BlbmRpbmdDb25uZWN0aW9ucyA9IGluaXQubWF4SW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnMgPz8gZGVmYXVsdE9wdGlvbnMubWF4SW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnM7XG4gICAgICAgIC8vIGNvbnRyb2xzIGluZGl2aWR1YWwgcGVlcnMgdHJ5aW5nIHRvIGRpYWwgdXMgdG9vIHF1aWNrbHlcbiAgICAgICAgdGhpcy5pbmJvdW5kQ29ubmVjdGlvblJhdGVMaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyKHtcbiAgICAgICAgICAgIHBvaW50czogaW5pdC5pbmJvdW5kQ29ubmVjdGlvblRocmVzaG9sZCA/PyBkZWZhdWx0T3B0aW9ucy5pbmJvdW5kQ29ubmVjdGlvblRocmVzaG9sZCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb250cm9scyB3aGF0IGhhcHBlbnMgd2hlbiB3ZSBkb24ndCBoYXZlIGVub3VnaCBjb25uZWN0aW9uc1xuICAgICAgICB0aGlzLmF1dG9EaWFsID0gbmV3IEF1dG9EaWFsKHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyOiB0aGlzLFxuICAgICAgICAgICAgcGVlclN0b3JlOiBjb21wb25lbnRzLnBlZXJTdG9yZSxcbiAgICAgICAgICAgIGV2ZW50czogY29tcG9uZW50cy5ldmVudHMsXG4gICAgICAgICAgICBsb2dnZXI6IGNvbXBvbmVudHMubG9nZ2VyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbkNvbm5lY3Rpb25zLFxuICAgICAgICAgICAgYXV0b0RpYWxDb25jdXJyZW5jeTogaW5pdC5hdXRvRGlhbENvbmN1cnJlbmN5ID8/IGRlZmF1bHRPcHRpb25zLmF1dG9EaWFsQ29uY3VycmVuY3ksXG4gICAgICAgICAgICBhdXRvRGlhbFByaW9yaXR5OiBpbml0LmF1dG9EaWFsUHJpb3JpdHkgPz8gZGVmYXVsdE9wdGlvbnMuYXV0b0RpYWxQcmlvcml0eSxcbiAgICAgICAgICAgIG1heFF1ZXVlTGVuZ3RoOiBpbml0LmF1dG9EaWFsTWF4UXVldWVMZW5ndGggPz8gZGVmYXVsdE9wdGlvbnMuYXV0b0RpYWxNYXhRdWV1ZUxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29udHJvbHMgd2hhdCBoYXBwZW5zIHdoZW4gd2UgaGF2ZSB0b28gbWFueSBjb25uZWN0aW9uc1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25QcnVuZXIgPSBuZXcgQ29ubmVjdGlvblBydW5lcih7XG4gICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlcjogdGhpcyxcbiAgICAgICAgICAgIHBlZXJTdG9yZTogY29tcG9uZW50cy5wZWVyU3RvcmUsXG4gICAgICAgICAgICBldmVudHM6IGNvbXBvbmVudHMuZXZlbnRzLFxuICAgICAgICAgICAgbG9nZ2VyOiBjb21wb25lbnRzLmxvZ2dlclxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogdGhpcy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGFsbG93OiB0aGlzLmFsbG93XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpYWxRdWV1ZSA9IG5ldyBEaWFsUXVldWUoY29tcG9uZW50cywge1xuICAgICAgICAgICAgYWRkcmVzc1NvcnRlcjogaW5pdC5hZGRyZXNzU29ydGVyID8/IGRlZmF1bHRBZGRyZXNzU29ydCxcbiAgICAgICAgICAgIG1heFBhcmFsbGVsRGlhbHM6IGluaXQubWF4UGFyYWxsZWxEaWFscyA/PyBNQVhfUEFSQUxMRUxfRElBTFMsXG4gICAgICAgICAgICBtYXhEaWFsUXVldWVMZW5ndGg6IGluaXQubWF4RGlhbFF1ZXVlTGVuZ3RoID8/IE1BWF9ESUFMX1FVRVVFX0xFTkdUSCxcbiAgICAgICAgICAgIG1heFBlZXJBZGRyc1RvRGlhbDogaW5pdC5tYXhQZWVyQWRkcnNUb0RpYWwgPz8gTUFYX1BFRVJfQUREUlNfVE9fRElBTCxcbiAgICAgICAgICAgIGRpYWxUaW1lb3V0OiBpbml0LmRpYWxUaW1lb3V0ID8/IERJQUxfVElNRU9VVCxcbiAgICAgICAgICAgIHJlc29sdmVyczogaW5pdC5yZXNvbHZlcnMgPz8ge1xuICAgICAgICAgICAgICAgIGRuc2FkZHI6IGRuc2FkZHJSZXNvbHZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zOiB0aGlzLmNvbm5lY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc1N0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgQ29ubmVjdGlvbiBNYW5hZ2VyLiBJZiBNZXRyaWNzIGFyZSBub3QgZW5hYmxlZCBvbiBsaWJwMnBcbiAgICAgKiBvbmx5IGV2ZW50IGxvb3AgYW5kIGNvbm5lY3Rpb24gbGltaXRzIHdpbGwgYmUgbW9uaXRvcmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAvLyB0cmFjayBpbmJvdW5kL291dGJvdW5kIGNvbm5lY3Rpb25zXG4gICAgICAgIHRoaXMubWV0cmljcz8ucmVnaXN0ZXJNZXRyaWNHcm91cCgnbGlicDJwX2Nvbm5lY3Rpb25fbWFuYWdlcl9jb25uZWN0aW9ucycsIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldHJpYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5ib3VuZDogMCxcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQ6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29ubnMgb2YgdGhpcy5jb25uZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm4gb2YgY29ubnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uLmRpcmVjdGlvbiA9PT0gJ2luYm91bmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljLmluYm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpYy5vdXRib3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRyaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0cmFjayB0b3RhbCBudW1iZXIgb2Ygc3RyZWFtcyBwZXIgcHJvdG9jb2xcbiAgICAgICAgdGhpcy5tZXRyaWNzPy5yZWdpc3Rlck1ldHJpY0dyb3VwKCdsaWJwMnBfcHJvdG9jb2xfc3RyZWFtc190b3RhbCcsIHtcbiAgICAgICAgICAgIGxhYmVsOiAncHJvdG9jb2wnLFxuICAgICAgICAgICAgY2FsY3VsYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0cmljID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25ucyBvZiB0aGlzLmNvbm5lY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29ubiBvZiBjb25ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdHJlYW0gb2YgY29ubi5zdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7c3RyZWFtLmRpcmVjdGlvbn0gJHtzdHJlYW0ucHJvdG9jb2wgPz8gJ3VubmVnb3RpYXRlZCd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNba2V5XSA9IChtZXRyaWNba2V5XSA/PyAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldHJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRyYWNrIDkwdGggcGVyY2VudGlsZSBvZiBzdHJlYW1zIHBlciBwcm90b2NvbFxuICAgICAgICB0aGlzLm1ldHJpY3M/LnJlZ2lzdGVyTWV0cmljR3JvdXAoJ2xpYnAycF9jb25uZWN0aW9uX21hbmFnZXJfcHJvdG9jb2xfc3RyZWFtc19wZXJfY29ubmVjdGlvbl85MHRoX3BlcmNlbnRpbGUnLCB7XG4gICAgICAgICAgICBsYWJlbDogJ3Byb3RvY29sJyxcbiAgICAgICAgICAgIGNhbGN1bGF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFN0cmVhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm5zIG9mIHRoaXMuY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25uIG9mIGNvbm5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBjb25uLnN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtzdHJlYW0uZGlyZWN0aW9ufSAke3N0cmVhbS5wcm90b2NvbCA/PyAndW5uZWdvdGlhdGVkJ31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNba2V5XSA9IChzdHJlYW1zW2tleV0gPz8gMCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbcHJvdG9jb2wsIGNvdW50XSBvZiBPYmplY3QuZW50cmllcyhzdHJlYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFN0cmVhbXNbcHJvdG9jb2xdID0gYWxsU3RyZWFtc1twcm90b2NvbF0gPz8gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsU3RyZWFtc1twcm90b2NvbF0ucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0cmljID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW3Byb3RvY29sLCBjb3VudHNdIG9mIE9iamVjdC5lbnRyaWVzKGFsbFN0cmVhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50cyA9IGNvdW50cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihjb3VudHMubGVuZ3RoICogMC45KTtcbiAgICAgICAgICAgICAgICAgICAgbWV0cmljW3Byb3RvY29sXSA9IGNvdW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRyaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpYWxRdWV1ZS5zdGFydCgpO1xuICAgICAgICB0aGlzLmF1dG9EaWFsLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nKCdzdGFydGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIGFmdGVyU3RhcnQoKSB7XG4gICAgICAgIC8vIHJlLWNvbm5lY3QgdG8gYW55IHBlZXJzIHdpdGggdGhlIEtFRVBfQUxJVkUgdGFnXG4gICAgICAgIHZvaWQgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtlZXBBbGl2ZVBlZXJzID0gYXdhaXQgdGhpcy5wZWVyU3RvcmUuYWxsKHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBbKHBlZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZWVyLnRhZ3MuaGFzKEtFRVBfQUxJVkUpO1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChrZWVwQWxpdmVQZWVycy5tYXAoYXN5bmMgKHBlZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wZW5Db25uZWN0aW9uKHBlZXIuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvRGlhbC5hZnRlclN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBDb25uZWN0aW9uIE1hbmFnZXJcbiAgICAgKi9cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICB0aGlzLmRpYWxRdWV1ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMuYXV0b0RpYWwuc3RvcCgpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgY29ubmVjdGlvbnMgd2UncmUgdHJhY2tpbmdcbiAgICAgICAgY29uc3QgdGFza3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uTGlzdCBvZiB0aGlzLmNvbm5lY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgY29ubmVjdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKCdjbG9zaW5nICVkIGNvbm5lY3Rpb25zJywgdGFza3MubGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMubG9nKCdzdG9wcGVkJyk7XG4gICAgfVxuICAgIG9uQ29ubmVjdChldnQpIHtcbiAgICAgICAgdm9pZCB0aGlzLl9vbkNvbm5lY3QoZXZ0KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrcyB0aGUgaW5jb21pbmcgY29ubmVjdGlvbiBhbmQgY2hlY2sgdGhlIGNvbm5lY3Rpb24gbGltaXRcbiAgICAgKi9cbiAgICBhc3luYyBfb25Db25uZWN0KGV2dCkge1xuICAgICAgICBjb25zdCB7IGRldGFpbDogY29ubmVjdGlvbiB9ID0gZXZ0O1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYXJlIGluIHRoZSBwcm9jZXNzIG9mIHNodXR0aW5nIGRvd24gdGhlIG5vZGVcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZWVySWQgPSBjb25uZWN0aW9uLnJlbW90ZVBlZXI7XG4gICAgICAgIGNvbnN0IHN0b3JlZENvbm5zID0gdGhpcy5jb25uZWN0aW9ucy5nZXQocGVlcklkKTtcbiAgICAgICAgbGV0IGlzTmV3UGVlciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RvcmVkQ29ubnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcmVkQ29ubnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzTmV3UGVlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNldChwZWVySWQsIFtjb25uZWN0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBuZWVkIHRvIHN0b3JlIFJTQSBwdWJsaWMga2V5cywgYWxsIG90aGVyIHR5cGVzIGFyZSBlbWJlZGRlZCBpbiB0aGUgcGVlciBpZFxuICAgICAgICBpZiAocGVlcklkLnB1YmxpY0tleSAhPSBudWxsICYmIHBlZXJJZC50eXBlID09PSAnUlNBJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wZWVyU3RvcmUucGF0Y2gocGVlcklkLCB7XG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiBwZWVySWQucHVibGljS2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXdQZWVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zYWZlRGlzcGF0Y2hFdmVudCgncGVlcjpjb25uZWN0JywgeyBkZXRhaWw6IGNvbm5lY3Rpb24ucmVtb3RlUGVlciB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb25uZWN0aW9uIGZyb20gdHJhY2tpbmdcbiAgICAgKi9cbiAgICBvbkRpc2Nvbm5lY3QoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsOiBjb25uZWN0aW9uIH0gPSBldnQ7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhcmUgaW4gdGhlIHByb2Nlc3Mgb2Ygc2h1dHRpbmcgZG93biB0aGUgbm9kZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IGNvbm5lY3Rpb24ucmVtb3RlUGVlcjtcbiAgICAgICAgbGV0IHN0b3JlZENvbm4gPSB0aGlzLmNvbm5lY3Rpb25zLmdldChwZWVySWQpO1xuICAgICAgICBpZiAoc3RvcmVkQ29ubiAhPSBudWxsICYmIHN0b3JlZENvbm4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgc3RvcmVkQ29ubiA9IHN0b3JlZENvbm4uZmlsdGVyKChjb25uKSA9PiBjb25uLmlkICE9PSBjb25uZWN0aW9uLmlkKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMuc2V0KHBlZXJJZCwgc3RvcmVkQ29ubik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcmVkQ29ubiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmRlbGV0ZShwZWVySWQpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuc2FmZURpc3BhdGNoRXZlbnQoJ3BlZXI6ZGlzY29ubmVjdCcsIHsgZGV0YWlsOiBjb25uZWN0aW9uLnJlbW90ZVBlZXIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29ubmVjdGlvbnMocGVlcklkKSB7XG4gICAgICAgIGlmIChwZWVySWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnMuZ2V0KHBlZXJJZCkgPz8gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbm5zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLmNvbm5lY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25ucyA9IGNvbm5zLmNvbmNhdChjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubnM7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgb3BlbkNvbm5lY3Rpb24ocGVlcklkT3JNdWx0aWFkZHIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ05vdCBzdGFydGVkJywgY29kZXMuRVJSX05PREVfTk9UX1NUQVJURUQpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICBjb25zdCB7IHBlZXJJZCB9ID0gZ2V0UGVlckFkZHJlc3MocGVlcklkT3JNdWx0aWFkZHIpO1xuICAgICAgICBpZiAocGVlcklkICE9IG51bGwgJiYgb3B0aW9ucy5mb3JjZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2RpYWwgJXAnLCBwZWVySWQpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9ucyhwZWVySWQpXG4gICAgICAgICAgICAgICAgLmZpbmQoY29ubiA9PiAhY29ubi50cmFuc2llbnQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ29ubmVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2hhZCBhbiBleGlzdGluZyBub24tdHJhbnNpZW50IGNvbm5lY3Rpb24gdG8gJXAnLCBwZWVySWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0Nvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZGlhbFF1ZXVlLmRpYWwocGVlcklkT3JNdWx0aWFkZHIsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSA/PyBERUZBVUxUX0RJQUxfUFJJT1JJVFlcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBwZWVyQ29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uLnJlbW90ZVBlZXIpO1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5zZXQoY29ubmVjdGlvbi5yZW1vdGVQZWVyLCBwZWVyQ29ubmVjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGdldCBub3RpZmllZCBvZiBjb25uZWN0aW9ucyB2aWEgdGhlIFVwZ3JhZGVyIGVtaXR0aW5nIFwiY29ubmVjdGlvblwiXG4gICAgICAgIC8vIGV2ZW50cywgZG91YmxlIGNoZWNrIHdlIGFyZW4ndCBhbHJlYWR5IHRyYWNraW5nIHRoaXMgY29ubmVjdGlvbiBiZWZvcmVcbiAgICAgICAgLy8gc3RvcmluZyBpdFxuICAgICAgICBsZXQgdHJhY2tlZENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjb25uIG9mIHBlZXJDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNvbm4uaWQgPT09IGNvbm5lY3Rpb24uaWQpIHtcbiAgICAgICAgICAgICAgICB0cmFja2VkQ29ubmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFja2VkQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlQ29ubmVjdGlvbnMocGVlcklkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zLmdldChwZWVySWQpID8/IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb25uZWN0aW9ucy5tYXAoYXN5bmMgKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5jbG9zZShvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmFib3J0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgYWNjZXB0SW5jb21pbmdDb25uZWN0aW9uKG1hQ29ubikge1xuICAgICAgICAvLyBjaGVjayBkZW55IGxpc3RcbiAgICAgICAgY29uc3QgZGVueUNvbm5lY3Rpb24gPSB0aGlzLmRlbnkuc29tZShtYSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFDb25uLnJlbW90ZUFkZHIudG9TdHJpbmcoKS5zdGFydHNXaXRoKG1hLnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlbnlDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnY29ubmVjdGlvbiBmcm9tICVhIHJlZnVzZWQgLSBjb25uZWN0aW9uIHJlbW90ZSBhZGRyZXNzIHdhcyBpbiBkZW55IGxpc3QnLCBtYUNvbm4ucmVtb3RlQWRkcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYWxsb3cgbGlzdFxuICAgICAgICBjb25zdCBhbGxvd0Nvbm5lY3Rpb24gPSB0aGlzLmFsbG93LnNvbWUobWEgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1hQ29ubi5yZW1vdGVBZGRyLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChtYS50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhbGxvd0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnMrKztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHBlbmRpbmcgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuaW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnMgPT09IHRoaXMubWF4SW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdjb25uZWN0aW9uIGZyb20gJWEgcmVmdXNlZCAtIGluY29taW5nUGVuZGluZ0Nvbm5lY3Rpb25zIGV4Y2VlZGVkIGJ5IGhvc3QnLCBtYUNvbm4ucmVtb3RlQWRkcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hQ29ubi5yZW1vdGVBZGRyLmlzVGhpbldhaXN0QWRkcmVzcygpKSB7XG4gICAgICAgICAgICBjb25zdCBob3N0ID0gbWFDb25uLnJlbW90ZUFkZHIubm9kZUFkZHJlc3MoKS5hZGRyZXNzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluYm91bmRDb25uZWN0aW9uUmF0ZUxpbWl0ZXIuY29uc3VtZShob3N0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnY29ubmVjdGlvbiBmcm9tICVhIHJlZnVzZWQgLSBpbmJvdW5kQ29ubmVjdGlvblRocmVzaG9sZCBleGNlZWRlZCBieSBob3N0ICVzJywgbWFDb25uLnJlbW90ZUFkZHIsIGhvc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRDb25uZWN0aW9ucygpLmxlbmd0aCA8IHRoaXMubWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnMrKztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKCdjb25uZWN0aW9uIGZyb20gJWEgcmVmdXNlZCAtIG1heENvbm5lY3Rpb25zIGV4Y2VlZGVkJywgbWFDb25uLnJlbW90ZUFkZHIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFmdGVyVXBncmFkZUluYm91bmQoKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdQZW5kaW5nQ29ubmVjdGlvbnMtLTtcbiAgICB9XG4gICAgZ2V0RGlhbFF1ZXVlKCkge1xuICAgICAgICBjb25zdCBzdGF0dXNNYXAgPSB7XG4gICAgICAgICAgICBxdWV1ZWQ6ICdxdWV1ZWQnLFxuICAgICAgICAgICAgcnVubmluZzogJ2FjdGl2ZScsXG4gICAgICAgICAgICBlcnJvcmVkOiAnZXJyb3InLFxuICAgICAgICAgICAgY29tcGxldGU6ICdzdWNjZXNzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5kaWFsUXVldWUucXVldWUucXVldWUubWFwKGpvYiA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBqb2IuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNNYXBbam9iLnN0YXR1c10sXG4gICAgICAgICAgICAgICAgcGVlcklkOiBqb2Iub3B0aW9ucy5wZWVySWQsXG4gICAgICAgICAgICAgICAgbXVsdGlhZGRyczogWy4uLmpvYi5vcHRpb25zLm11bHRpYWRkcnNdLm1hcChtYSA9PiBtdWx0aWFkZHIobWEpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGlzRGlhbGFibGUobXVsdGlhZGRyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlhbFF1ZXVlLmlzRGlhbGFibGUobXVsdGlhZGRyLCBvcHRpb25zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZUVycm9yIiwiS0VFUF9BTElWRSIsIlBlZXJNYXAiLCJkZWZhdWx0QWRkcmVzc1NvcnQiLCJSYXRlTGltaXRlciIsIm11bHRpYWRkciIsImRuc2FkZHJSZXNvbHZlciIsImNvZGVzIiwiZ2V0UGVlckFkZHJlc3MiLCJBdXRvRGlhbCIsIkNvbm5lY3Rpb25QcnVuZXIiLCJBVVRPX0RJQUxfQ09OQ1VSUkVOQ1kiLCJBVVRPX0RJQUxfTUFYX1FVRVVFX0xFTkdUSCIsIkFVVE9fRElBTF9QUklPUklUWSIsIkRJQUxfVElNRU9VVCIsIklOQk9VTkRfQ09OTkVDVElPTl9USFJFU0hPTEQiLCJNQVhfQ09OTkVDVElPTlMiLCJNQVhfRElBTF9RVUVVRV9MRU5HVEgiLCJNQVhfSU5DT01JTkdfUEVORElOR19DT05ORUNUSU9OUyIsIk1BWF9QQVJBTExFTF9ESUFMUyIsIk1BWF9QRUVSX0FERFJTX1RPX0RJQUwiLCJNSU5fQ09OTkVDVElPTlMiLCJEaWFsUXVldWUiLCJERUZBVUxUX0RJQUxfUFJJT1JJVFkiLCJkZWZhdWx0T3B0aW9ucyIsIm1pbkNvbm5lY3Rpb25zIiwibWF4Q29ubmVjdGlvbnMiLCJpbmJvdW5kQ29ubmVjdGlvblRocmVzaG9sZCIsIm1heEluY29taW5nUGVuZGluZ0Nvbm5lY3Rpb25zIiwiYXV0b0RpYWxDb25jdXJyZW5jeSIsImF1dG9EaWFsUHJpb3JpdHkiLCJhdXRvRGlhbE1heFF1ZXVlTGVuZ3RoIiwiRGVmYXVsdENvbm5lY3Rpb25NYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRzIiwiaW5pdCIsIkVSUl9JTlZBTElEX1BBUkFNRVRFUlMiLCJjb25uZWN0aW9ucyIsInN0YXJ0ZWQiLCJwZWVyU3RvcmUiLCJtZXRyaWNzIiwiZXZlbnRzIiwibG9nIiwibG9nZ2VyIiwiZm9yQ29tcG9uZW50Iiwib25Db25uZWN0IiwiYmluZCIsIm9uRGlzY29ubmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhbGxvdyIsIm1hcCIsIm1hIiwiZGVueSIsImluY29taW5nUGVuZGluZ0Nvbm5lY3Rpb25zIiwiaW5ib3VuZENvbm5lY3Rpb25SYXRlTGltaXRlciIsInBvaW50cyIsImR1cmF0aW9uIiwiYXV0b0RpYWwiLCJjb25uZWN0aW9uTWFuYWdlciIsIm1heFF1ZXVlTGVuZ3RoIiwiY29ubmVjdGlvblBydW5lciIsImRpYWxRdWV1ZSIsImFkZHJlc3NTb3J0ZXIiLCJtYXhQYXJhbGxlbERpYWxzIiwibWF4RGlhbFF1ZXVlTGVuZ3RoIiwibWF4UGVlckFkZHJzVG9EaWFsIiwiZGlhbFRpbWVvdXQiLCJyZXNvbHZlcnMiLCJkbnNhZGRyIiwiaXNTdGFydGVkIiwic3RhcnQiLCJyZWdpc3Rlck1ldHJpY0dyb3VwIiwiY2FsY3VsYXRlIiwibWV0cmljIiwiaW5ib3VuZCIsIm91dGJvdW5kIiwiY29ubnMiLCJ2YWx1ZXMiLCJjb25uIiwiZGlyZWN0aW9uIiwibGFiZWwiLCJzdHJlYW0iLCJzdHJlYW1zIiwia2V5IiwicHJvdG9jb2wiLCJhbGxTdHJlYW1zIiwiY291bnQiLCJPYmplY3QiLCJlbnRyaWVzIiwicHVzaCIsImNvdW50cyIsInNvcnQiLCJhIiwiYiIsImluZGV4IiwiTWF0aCIsImZsb29yIiwibGVuZ3RoIiwiYWZ0ZXJTdGFydCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImtlZXBBbGl2ZVBlZXJzIiwiYWxsIiwiZmlsdGVycyIsInBlZXIiLCJ0YWdzIiwiaGFzIiwib3BlbkNvbm5lY3Rpb24iLCJpZCIsImNhdGNoIiwiZXJyIiwiZXJyb3IiLCJzdG9wIiwidGFza3MiLCJjb25uZWN0aW9uTGlzdCIsImNvbm5lY3Rpb24iLCJjbG9zZSIsImNsZWFyIiwiZXZ0IiwiX29uQ29ubmVjdCIsImRldGFpbCIsInBlZXJJZCIsInJlbW90ZVBlZXIiLCJzdG9yZWRDb25ucyIsImdldCIsImlzTmV3UGVlciIsInNldCIsInB1YmxpY0tleSIsInR5cGUiLCJwYXRjaCIsInNhZmVEaXNwYXRjaEV2ZW50Iiwic3RvcmVkQ29ubiIsImZpbHRlciIsImRlbGV0ZSIsImdldENvbm5lY3Rpb25zIiwiYyIsImNvbmNhdCIsImdldENvbm5lY3Rpb25zTWFwIiwicGVlcklkT3JNdWx0aWFkZHIiLCJvcHRpb25zIiwiRVJSX05PREVfTk9UX1NUQVJURUQiLCJzaWduYWwiLCJ0aHJvd0lmQWJvcnRlZCIsImZvcmNlIiwiZXhpc3RpbmdDb25uZWN0aW9uIiwiZmluZCIsInRyYW5zaWVudCIsImRpYWwiLCJwcmlvcml0eSIsInBlZXJDb25uZWN0aW9ucyIsInRyYWNrZWRDb25uZWN0aW9uIiwiY2xvc2VDb25uZWN0aW9ucyIsImFib3J0IiwiYWNjZXB0SW5jb21pbmdDb25uZWN0aW9uIiwibWFDb25uIiwiZGVueUNvbm5lY3Rpb24iLCJzb21lIiwicmVtb3RlQWRkciIsInRvU3RyaW5nIiwic3RhcnRzV2l0aCIsImFsbG93Q29ubmVjdGlvbiIsImlzVGhpbldhaXN0QWRkcmVzcyIsImhvc3QiLCJub2RlQWRkcmVzcyIsImFkZHJlc3MiLCJjb25zdW1lIiwiYWZ0ZXJVcGdyYWRlSW5ib3VuZCIsImdldERpYWxRdWV1ZSIsInN0YXR1c01hcCIsInF1ZXVlZCIsInJ1bm5pbmciLCJlcnJvcmVkIiwiY29tcGxldGUiLCJxdWV1ZSIsImpvYiIsInN0YXR1cyIsIm11bHRpYWRkcnMiLCJpc0RpYWxhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection-manager/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection-manager/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveMultiaddrs: () => (/* binding */ resolveMultiaddrs)\n/* harmony export */ });\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n\n/**\n * Recursively resolve DNSADDR multiaddrs\n */ async function resolveMultiaddrs(ma, options) {\n    // check multiaddr resolvers\n    let resolvable = false;\n    for (const key of _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.resolvers.keys()){\n        resolvable = ma.protoNames().includes(key);\n        if (resolvable) {\n            break;\n        }\n    }\n    // return multiaddr if it is not resolvable\n    if (!resolvable) {\n        return [\n            ma\n        ];\n    }\n    const output = await ma.resolve(options);\n    options.log(\"resolved %s to\", ma, output.map((ma)=>ma.toString()));\n    return output;\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUNwRDs7Q0FFQyxHQUNNLGVBQWVDLGtCQUFrQkMsRUFBRSxFQUFFQyxPQUFPO0lBQy9DLDRCQUE0QjtJQUM1QixJQUFJQyxhQUFhO0lBQ2pCLEtBQUssTUFBTUMsT0FBT0wsOERBQVNBLENBQUNNLElBQUksR0FBSTtRQUNoQ0YsYUFBYUYsR0FBR0ssVUFBVSxHQUFHQyxRQUFRLENBQUNIO1FBQ3RDLElBQUlELFlBQVk7WUFDWjtRQUNKO0lBQ0o7SUFDQSwyQ0FBMkM7SUFDM0MsSUFBSSxDQUFDQSxZQUFZO1FBQ2IsT0FBTztZQUFDRjtTQUFHO0lBQ2Y7SUFDQSxNQUFNTyxTQUFTLE1BQU1QLEdBQUdRLE9BQU8sQ0FBQ1A7SUFDaENBLFFBQVFRLEdBQUcsQ0FBQyxrQkFBa0JULElBQUlPLE9BQU9HLEdBQUcsQ0FBQ1YsQ0FBQUEsS0FBTUEsR0FBR1csUUFBUTtJQUM5RCxPQUFPSjtBQUNYLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24tbWFuYWdlci91dGlscy5qcz80ZTZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlc29sdmVycyB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJztcbi8qKlxuICogUmVjdXJzaXZlbHkgcmVzb2x2ZSBETlNBRERSIG11bHRpYWRkcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVNdWx0aWFkZHJzKG1hLCBvcHRpb25zKSB7XG4gICAgLy8gY2hlY2sgbXVsdGlhZGRyIHJlc29sdmVyc1xuICAgIGxldCByZXNvbHZhYmxlID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcmVzb2x2ZXJzLmtleXMoKSkge1xuICAgICAgICByZXNvbHZhYmxlID0gbWEucHJvdG9OYW1lcygpLmluY2x1ZGVzKGtleSk7XG4gICAgICAgIGlmIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gbXVsdGlhZGRyIGlmIGl0IGlzIG5vdCByZXNvbHZhYmxlXG4gICAgaWYgKCFyZXNvbHZhYmxlKSB7XG4gICAgICAgIHJldHVybiBbbWFdO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMubG9nKCdyZXNvbHZlZCAlcyB0bycsIG1hLCBvdXRwdXQubWFwKG1hID0+IG1hLnRvU3RyaW5nKCkpKTtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVycyIsInJlc29sdmVNdWx0aWFkZHJzIiwibWEiLCJvcHRpb25zIiwicmVzb2x2YWJsZSIsImtleSIsImtleXMiLCJwcm90b05hbWVzIiwiaW5jbHVkZXMiLCJvdXRwdXQiLCJyZXNvbHZlIiwibG9nIiwibWFwIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection-manager/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/connection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/libp2p/dist/src/connection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionImpl: () => (/* binding */ ConnectionImpl),\n/* harmony export */   createConnection: () => (/* binding */ createConnection)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/connection/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/events.js\");\n\nconst CLOSE_TIMEOUT = 500;\nlet prop;\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */ class ConnectionImpl {\n    static{\n        prop = Symbol.toStringTag;\n    }\n    /**\n     * An implementation of the js-libp2p connection.\n     * Any libp2p transport should use an upgrader to return this connection.\n     */ constructor(init){\n        this[prop] = \"Connection\";\n        this[_libp2p_interface__WEBPACK_IMPORTED_MODULE_0__.connectionSymbol] = true;\n        const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;\n        this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;\n        this.remoteAddr = remoteAddr;\n        this.remotePeer = remotePeer;\n        this.direction = init.direction;\n        this.status = \"open\";\n        this.timeline = init.timeline;\n        this.multiplexer = init.multiplexer;\n        this.encryption = init.encryption;\n        this.transient = init.transient ?? false;\n        this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);\n        if (this.remoteAddr.getPeerId() == null) {\n            this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);\n        }\n        this._newStream = newStream;\n        this._close = close;\n        this._abort = abort;\n        this._getStreams = getStreams;\n        this.tags = [];\n    }\n    /**\n     * Get all the streams of the muxer\n     */ get streams() {\n        return this._getStreams();\n    }\n    /**\n     * Create a new stream from this connection\n     */ async newStream(protocols, options) {\n        if (this.status === \"closing\") {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(\"the connection is being closed\", \"ERR_CONNECTION_BEING_CLOSED\");\n        }\n        if (this.status === \"closed\") {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(\"the connection is closed\", \"ERR_CONNECTION_CLOSED\");\n        }\n        if (!Array.isArray(protocols)) {\n            protocols = [\n                protocols\n            ];\n        }\n        if (this.transient && options?.runOnTransientConnection !== true) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(\"Cannot open protocol stream on transient connection\", \"ERR_TRANSIENT_CONNECTION\");\n        }\n        const stream = await this._newStream(protocols, options);\n        stream.direction = \"outbound\";\n        return stream;\n    }\n    /**\n     * Close the connection\n     */ async close(options = {}) {\n        if (this.status === \"closed\" || this.status === \"closing\") {\n            return;\n        }\n        this.log(\"closing connection to %a\", this.remoteAddr);\n        this.status = \"closing\";\n        if (options.signal == null) {\n            const signal = AbortSignal.timeout(CLOSE_TIMEOUT);\n            (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.setMaxListeners)(Infinity, signal);\n            options = {\n                ...options,\n                signal\n            };\n        }\n        try {\n            this.log.trace(\"closing all streams\");\n            // close all streams gracefully - this can throw if we're not multiplexed\n            await Promise.all(this.streams.map(async (s)=>s.close(options)));\n            this.log.trace(\"closing underlying transport\");\n            // close raw connection\n            await this._close(options);\n            this.log.trace(\"updating timeline with close time\");\n            this.status = \"closed\";\n            this.timeline.close = Date.now();\n        } catch (err) {\n            this.log.error(\"error encountered during graceful close of connection to %a\", this.remoteAddr, err);\n            this.abort(err);\n        }\n    }\n    abort(err) {\n        this.log.error(\"aborting connection to %a due to error\", this.remoteAddr, err);\n        this.status = \"closing\";\n        this.streams.forEach((s)=>{\n            s.abort(err);\n        });\n        this.log.error(\"all streams aborted\", this.streams.length);\n        // Abort raw connection\n        this._abort(err);\n        this.timeline.close = Date.now();\n        this.status = \"closed\";\n    }\n}\nfunction createConnection(init) {\n    return new ConnectionImpl(init);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Nvbm5lY3Rpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUY7QUFDakYsTUFBTUcsZ0JBQWdCOztBQUN0Qjs7O0NBR0MsR0FDTSxNQUFNQzs7ZUErRFJDLE9BQU9DLFdBQVc7O0lBekJuQjs7O0tBR0MsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1lBcUJsQixNQUFvQixHQUFHO1lBQ3ZCLENBQUNSLCtEQUFnQkEsQ0FBQyxHQUFHO1FBckJqQixNQUFNLEVBQUVTLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQUUsR0FBR047UUFDeEUsSUFBSSxDQUFDTyxFQUFFLEdBQUcsQ0FBQyxFQUFFLFNBQVVFLE9BQU9DLEtBQUtDLE1BQU0sS0FBSyxNQUFPQyxRQUFRLENBQUMsSUFBSSxFQUFFQyxLQUFLQyxHQUFHLEdBQUcsQ0FBQztRQUNoRixJQUFJLENBQUNiLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ2EsU0FBUyxHQUFHZixLQUFLZSxTQUFTO1FBQy9CLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdqQixLQUFLaUIsUUFBUTtRQUM3QixJQUFJLENBQUNDLFdBQVcsR0FBR2xCLEtBQUtrQixXQUFXO1FBQ25DLElBQUksQ0FBQ0MsVUFBVSxHQUFHbkIsS0FBS21CLFVBQVU7UUFDakMsSUFBSSxDQUFDQyxTQUFTLEdBQUdwQixLQUFLb0IsU0FBUyxJQUFJO1FBQ25DLElBQUksQ0FBQ0MsR0FBRyxHQUFHckIsS0FBS3NCLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDUixTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ1IsRUFBRSxDQUFDLENBQUM7UUFDcEYsSUFBSSxJQUFJLENBQUNOLFVB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QUNILENBQUFBO1lBQU9BLEVBQUV6QyxLQUFLLENBQUMwQztRQUFNO1FBQzFDLElBQUksQ0FBQzFCLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyx1QkFBdUIsSUFBSSxDQUFDakIsT0FBTyxDQUFDbUIsTUFBTTtRQUN6RCx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDdEIsTUFBTSxDQUFDbUI7UUFDWixJQUFJLENBQUM5QixRQUFRLENBQUNiLEtBQUssR0FBR1MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNFLE1BQU0sR0FBRztJQUNsQjtBQUNKO0FBQ08sU0FBU21DLGlCQUFpQm5ELElBQUk7SUFDakMsT0FBTyxJQUFJSixlQUFlSTtBQUM5QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9jb25uZWN0aW9uL2luZGV4LmpzPzZmMjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29ubmVjdGlvblN5bWJvbCwgQ29kZUVycm9yLCBzZXRNYXhMaXN0ZW5lcnMgfSBmcm9tICdAbGlicDJwL2ludGVyZmFjZSc7XG5jb25zdCBDTE9TRV9USU1FT1VUID0gNTAwO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUganMtbGlicDJwIGNvbm5lY3Rpb24uXG4gKiBBbnkgbGlicDJwIHRyYW5zcG9ydCBzaG91bGQgdXNlIGFuIHVwZ3JhZGVyIHRvIHJldHVybiB0aGlzIGNvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uSW1wbCB7XG4gICAgLyoqXG4gICAgICogQ29ubmVjdGlvbiBpZGVudGlmaWVyLlxuICAgICAqL1xuICAgIGlkO1xuICAgIC8qKlxuICAgICAqIE9ic2VydmVkIG11bHRpYWRkciBvZiB0aGUgcmVtb3RlIHBlZXJcbiAgICAgKi9cbiAgICByZW1vdGVBZGRyO1xuICAgIC8qKlxuICAgICAqIFJlbW90ZSBwZWVyIGlkXG4gICAgICovXG4gICAgcmVtb3RlUGVlcjtcbiAgICBkaXJlY3Rpb247XG4gICAgdGltZWxpbmU7XG4gICAgbXVsdGlwbGV4ZXI7XG4gICAgZW5jcnlwdGlvbjtcbiAgICBzdGF0dXM7XG4gICAgdHJhbnNpZW50O1xuICAgIGxvZztcbiAgICAvKipcbiAgICAgKiBVc2VyIHByb3ZpZGVkIHRhZ3NcbiAgICAgKlxuICAgICAqL1xuICAgIHRhZ3M7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBuZXcgc3RyZWFtIGZ1bmN0aW9uIG9mIHRoZSBtdWx0aXBsZXhlclxuICAgICAqL1xuICAgIF9uZXdTdHJlYW07XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBjbG9zZSBmdW5jdGlvbiBvZiB0aGUgcmF3IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBfY2xvc2U7XG4gICAgX2Fib3J0O1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgZ2V0U3RyZWFtcyBmdW5jdGlvbiBvZiB0aGUgbXV4ZXJcbiAgICAgKi9cbiAgICBfZ2V0U3RyZWFtcztcbiAgICAvKipcbiAgICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUganMtbGlicDJwIGNvbm5lY3Rpb24uXG4gICAgICogQW55IGxpYnAycCB0cmFuc3BvcnQgc2hvdWxkIHVzZSBhbiB1cGdyYWRlciB0byByZXR1cm4gdGhpcyBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICAgICAgY29uc3QgeyByZW1vdGVBZGRyLCByZW1vdGVQZWVyLCBuZXdTdHJlYW0sIGNsb3NlLCBhYm9ydCwgZ2V0U3RyZWFtcyB9ID0gaW5pdDtcbiAgICAgICAgdGhpcy5pZCA9IGAkeyhwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIDFlOSkpKS50b1N0cmluZygzNil9JHtEYXRlLm5vdygpfWA7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkciA9IHJlbW90ZUFkZHI7XG4gICAgICAgIHRoaXMucmVtb3RlUGVlciA9IHJlbW90ZVBlZXI7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gaW5pdC5kaXJlY3Rpb247XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gaW5pdC50aW1lbGluZTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZXhlciA9IGluaXQubXVsdGlwbGV4ZXI7XG4gICAgICAgIHRoaXMuZW5jcnlwdGlvbiA9IGluaXQuZW5jcnlwdGlvbjtcbiAgICAgICAgdGhpcy50cmFuc2llbnQgPSBpbml0LnRyYW5zaWVudCA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2cgPSBpbml0LmxvZ2dlci5mb3JDb21wb25lbnQoYGxpYnAycDpjb25uZWN0aW9uOiR7dGhpcy5kaXJlY3Rpb259OiR7dGhpcy5pZH1gKTtcbiAgICAgICAgaWYgKHRoaXMucmVtb3RlQWRkci5nZXRQZWVySWQoKSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHIgPSB0aGlzLnJlbW90ZUFkZHIuZW5jYXBzdWxhdGUoYC9wMnAvJHt0aGlzLnJlbW90ZVBlZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmV3U3RyZWFtID0gbmV3U3RyZWFtO1xuICAgICAgICB0aGlzLl9jbG9zZSA9IGNsb3NlO1xuICAgICAgICB0aGlzLl9hYm9ydCA9IGFib3J0O1xuICAgICAgICB0aGlzLl9nZXRTdHJlYW1zID0gZ2V0U3RyZWFtcztcbiAgICAgICAgdGhpcy50YWdzID0gW107XG4gICAgfVxuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0Nvbm5lY3Rpb24nO1xuICAgIFtjb25uZWN0aW9uU3ltYm9sXSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgc3RyZWFtcyBvZiB0aGUgbXV4ZXJcbiAgICAgKi9cbiAgICBnZXQgc3RyZWFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0cmVhbXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cmVhbSBmcm9tIHRoaXMgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIG5ld1N0cmVhbShwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAnY2xvc2luZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ3RoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZCcsICdFUlJfQ09OTkVDVElPTl9CRUlOR19DTE9TRUQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCd0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQnLCAnRVJSX0NPTk5FQ1RJT05fQ0xPU0VEJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaWVudCAmJiBvcHRpb25zPy5ydW5PblRyYW5zaWVudENvbm5lY3Rpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ0Nhbm5vdCBvcGVuIHByb3RvY29sIHN0cmVhbSBvbiB0cmFuc2llbnQgY29ubmVjdGlvbicsICdFUlJfVFJBTlNJRU5UX0NPTk5FQ1RJT04nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLl9uZXdTdHJlYW0ocHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICAgICAgc3RyZWFtLmRpcmVjdGlvbiA9ICdvdXRib3VuZCc7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gJ2Nsb3NlZCcgfHwgdGhpcy5zdGF0dXMgPT09ICdjbG9zaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKCdjbG9zaW5nIGNvbm5lY3Rpb24gdG8gJWEnLCB0aGlzLnJlbW90ZUFkZHIpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdjbG9zaW5nJztcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQoQ0xPU0VfVElNRU9VVCk7XG4gICAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHksIHNpZ25hbCk7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxvZy50cmFjZSgnY2xvc2luZyBhbGwgc3RyZWFtcycpO1xuICAgICAgICAgICAgLy8gY2xvc2UgYWxsIHN0cmVhbXMgZ3JhY2VmdWxseSAtIHRoaXMgY2FuIHRocm93IGlmIHdlJ3JlIG5vdCBtdWx0aXBsZXhlZFxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5zdHJlYW1zLm1hcChhc3luYyAocykgPT4gcy5jbG9zZShvcHRpb25zKSkpO1xuICAgICAgICAgICAgdGhpcy5sb2cudHJhY2UoJ2Nsb3NpbmcgdW5kZXJseWluZyB0cmFuc3BvcnQnKTtcbiAgICAgICAgICAgIC8vIGNsb3NlIHJhdyBjb25uZWN0aW9uXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbG9zZShvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubG9nLnRyYWNlKCd1cGRhdGluZyB0aW1lbGluZSB3aXRoIGNsb3NlIHRpbWUnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gJ2Nsb3NlZCc7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmNsb3NlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIGdyYWNlZnVsIGNsb3NlIG9mIGNvbm5lY3Rpb24gdG8gJWEnLCB0aGlzLnJlbW90ZUFkZHIsIGVycik7XG4gICAgICAgICAgICB0aGlzLmFib3J0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJvcnQoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdhYm9ydGluZyBjb25uZWN0aW9uIHRvICVhIGR1ZSB0byBlcnJvcicsIHRoaXMucmVtb3RlQWRkciwgZXJyKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnY2xvc2luZyc7XG4gICAgICAgIHRoaXMuc3RyZWFtcy5mb3JFYWNoKHMgPT4geyBzLmFib3J0KGVycik7IH0pO1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignYWxsIHN0cmVhbXMgYWJvcnRlZCcsIHRoaXMuc3RyZWFtcy5sZW5ndGgpO1xuICAgICAgICAvLyBBYm9ydCByYXcgY29ubmVjdGlvblxuICAgICAgICB0aGlzLl9hYm9ydChlcnIpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmNsb3NlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnY2xvc2VkJztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbihpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSW1wbChpbml0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJjb25uZWN0aW9uU3ltYm9sIiwiQ29kZUVycm9yIiwic2V0TWF4TGlzdGVuZXJzIiwiQ0xPU0VfVElNRU9VVCIsIkNvbm5lY3Rpb25JbXBsIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJjb25zdHJ1Y3RvciIsImluaXQiLCJyZW1vdGVBZGRyIiwicmVtb3RlUGVlciIsIm5ld1N0cmVhbSIsImNsb3NlIiwiYWJvcnQiLCJnZXRTdHJlYW1zIiwiaWQiLCJwYXJzZUludCIsIlN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsIkRhdGUiLCJub3ciLCJkaXJlY3Rpb24iLCJzdGF0dXMiLCJ0aW1lbGluZSIsIm11bHRpcGxleGVyIiwiZW5jcnlwdGlvbiIsInRyYW5zaWVudCIsImxvZyIsImxvZ2dlciIsImZvckNvbXBvbmVudCIsImdldFBlZXJJZCIsImVuY2Fwc3VsYXRlIiwiX25ld1N0cmVhbSIsIl9jbG9zZSIsIl9hYm9ydCIsIl9nZXRTdHJlYW1zIiwidGFncyIsInN0cmVhbXMiLCJwcm90b2NvbHMiLCJvcHRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwicnVuT25UcmFuc2llbnRDb25uZWN0aW9uIiwic3RyZWFtIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0IiwiSW5maW5pdHkiLCJ0cmFjZSIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJzIiwiZXJyIiwiZXJyb3IiLCJmb3JFYWNoIiwibGVuZ3RoIiwiY3JlYXRlQ29ubmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/connection/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/content-routing.js":
/*!*********************************************************!*\
  !*** ./node_modules/libp2p/dist/src/content-routing.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompoundContentRouting: () => (/* binding */ CompoundContentRouting)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/set.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-merge */ \"(ssr)/./node_modules/it-merge/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n\n\n\n\nclass CompoundContentRouting {\n    constructor(components, init){\n        this.routers = init.routers ?? [];\n        this.started = false;\n        this.components = components;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        this.started = true;\n    }\n    async stop() {\n        this.started = false;\n    }\n    /**\n     * Iterates over all content routers in parallel to find providers of the given key\n     */ async *findProviders(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(\"No content routers available\", _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        const self = this;\n        const seen = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__.PeerSet();\n        for await (const peer of (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...self.routers.map((router)=>router.findProviders(key, options)))){\n            // the peer was yielded by a content router without multiaddrs and we\n            // failed to load them\n            if (peer == null) {\n                continue;\n            }\n            // store the addresses for the peer if found\n            if (peer.multiaddrs.length > 0) {\n                await this.components.peerStore.merge(peer.id, {\n                    multiaddrs: peer.multiaddrs\n                });\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key\n     */ async provide(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(\"No content routers available\", _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        await Promise.all(this.routers.map(async (router)=>{\n            await router.provide(key, options);\n        }));\n    }\n    /**\n     * Store the given key/value pair in the available content routings\n     */ async put(key, value, options) {\n        if (!this.isStarted()) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(_errors_js__WEBPACK_IMPORTED_MODULE_2__.messages.NOT_STARTED_YET, _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_NODE_NOT_STARTED);\n        }\n        await Promise.all(this.routers.map(async (router)=>{\n            await router.put(key, value, options);\n        }));\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     */ async get(key, options) {\n        if (!this.isStarted()) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(_errors_js__WEBPACK_IMPORTED_MODULE_2__.messages.NOT_STARTED_YET, _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_NODE_NOT_STARTED);\n        }\n        return Promise.any(this.routers.map(async (router)=>{\n            return router.get(key, options);\n        }));\n    }\n} //# sourceMappingURL=content-routing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2NvbnRlbnQtcm91dGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QztBQUNLO0FBQ3RCO0FBQ2lCO0FBQ3ZDLE1BQU1LO0lBSVRDLFlBQVlDLFVBQVUsRUFBRUMsSUFBSSxDQUFFO1FBQzFCLElBQUksQ0FBQ0MsT0FBTyxHQUFHRCxLQUFLQyxPQUFPLElBQUksRUFBRTtRQUNqQyxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0gsVUFBVSxHQUFHQTtJQUN0QjtJQUNBSSxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUNELE9BQU87SUFDdkI7SUFDQSxNQUFNRSxRQUFRO1FBQ1YsSUFBSSxDQUFDRixPQUFPLEdBQUc7SUFDbkI7SUFDQSxNQUFNRyxPQUFPO1FBQ1QsSUFBSSxDQUFDSCxPQUFPLEdBQUc7SUFDbkI7SUFDQTs7S0FFQyxHQUNELE9BQU9JLGNBQWNDLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUNwQyxJQUFJLElBQUksQ0FBQ1AsT0FBTyxDQUFDUSxNQUFNLEtBQUssR0FBRztZQUMzQixNQUFNLElBQUlqQix3REFBU0EsQ0FBQyxnQ0FBZ0NHLDZDQUFLQSxDQUFDZSx3QkFBd0I7UUFDdEY7UUFDQSxNQUFNQyxPQUFPLElBQUk7UUFDakIsTUFBTUMsT0FBTyxJQUFJbkIsNkRBQU9BO1FBQ3hCLFdBQVcsTUFBTW9CLFFBQVFuQixvREFBS0EsSUFBSWlCLEtBQUtWLE9BQU8sQ0FBQ2EsR0FBRyxDQUFDQyxDQUFBQSxTQUFVQSxPQUFPVCxhQUFhLENBQUNDLEtBQUtDLFdBQVk7WUFDL0YscUVBQXFFO1lBQ3JFLHNCQUFzQjtZQUN0QixJQUFJSyxRQUFRLE1BQU07Z0JBQ2Q7WUFDSjtZQUNBLDRDQUE0QztZQUM1QyxJQUFJQSxLQUFLRyxVQUFVLENBQUNQLE1BQU0sR0FBRyxHQUFHO2dCQUM1QixNQUFNLElBQUksQ0FBQ1YsVUFBVSxDQUFDa0IsU0FBUyxDQUFDdkIsS0FBSyxDQUFDbUIsS0FBS0ssRUFBRSxFQUFFO29CQUMzQ0YsWUFBWUgsS0FBS0csVUFBVTtnQkFDL0I7WUFDSjtZQUNBLG9CQUFvQjtZQUNwQixJQUFJSixLQUFLTyxHQUFHLENBQUNOLEtBQUtLLEVBQUUsR0FBRztnQkFDbkI7WUFDSjtZQUNBTixLQUFLUSxHQUFHLENBQUNQLEtBQUtLLEVBQUU7WUFDaEIsTUFBTUw7UUFDVjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTVEsUUFBUWQsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQzdCLElBQUksSUFBSSxDQUFDUCxPQUFPLENBQUNRLE1BQU0sS0FBSyxHQUFHO1lBQzNCLE1BQU0sSUFBSWpCLHdEQUFTQSxDQUFDLGdDQUFnQ0csNkNBQUtBLENBQUNlLHdCQUF3QjtRQUN0RjtRQUNBLE1BQU1ZLFFBQVFDLEdBQUcsQ0FBQyxJQUFJLENBQUN0QixPQUFPLENBQUNhLEdBQUcsQ0FBQyxPQUFPQztZQUN0QyxNQUFNQSxPQUFPTSxPQUFPLENBQUNkLEtBQUtDO1FBQzlCO0lBQ0o7SUFDQTs7S0FFQyxHQUNELE1BQU1nQixJQUFJakIsR0FBRyxFQUFFa0IsS0FBSyxFQUFFakIsT0FBTyxFQUFFO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNMLFNBQVMsSUFBSTtZQUNuQixNQUFNLElBQUlYLHdEQUFTQSxDQUFDSSxnREFBUUEsQ0FBQzhCLGVBQWUsRUFBRS9CLDZDQUFLQSxDQUFDZ0Msb0JBQW9CO1FBQzVFO1FBQ0EsTUFBTUwsUUFBUUMsR0FBRyxDQUFDLElBQUksQ0FBQ3RCLE9BQU8sQ0FBQ2EsR0FBRyxDQUFDLE9BQU9DO1lBQ3RDLE1BQU1BLE9BQU9TLEdBQUcsQ0FBQ2pCLEtBQUtrQixPQUFPakI7UUFDakM7SUFDSjtJQUNBOzs7S0FHQyxHQUNELE1BQU1vQixJQUFJckIsR0FBRyxFQUFFQyxPQUFPLEVBQUU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQ0wsU0FBUyxJQUFJO1lBQ25CLE1BQU0sSUFBSVgsd0RBQVNBLENBQUNJLGdEQUFRQSxDQUFDOEIsZUFBZSxFQUFFL0IsNkNBQUtBLENBQUNnQyxvQkFBb0I7UUFDNUU7UUFDQSxPQUFPTCxRQUFRTyxHQUFHLENBQUMsSUFBSSxDQUFDNUIsT0FBTyxDQUFDYSxHQUFHLENBQUMsT0FBT0M7WUFDdkMsT0FBT0EsT0FBT2EsR0FBRyxDQUFDckIsS0FBS0M7UUFDM0I7SUFDSjtBQUNKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2NvbnRlbnQtcm91dGluZy5qcz8xMzJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVFcnJvciB9IGZyb20gJ0BsaWJwMnAvaW50ZXJmYWNlJztcbmltcG9ydCB7IFBlZXJTZXQgfSBmcm9tICdAbGlicDJwL3BlZXItY29sbGVjdGlvbnMnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2l0LW1lcmdlJztcbmltcG9ydCB7IGNvZGVzLCBtZXNzYWdlcyB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCBjbGFzcyBDb21wb3VuZENvbnRlbnRSb3V0aW5nIHtcbiAgICByb3V0ZXJzO1xuICAgIHN0YXJ0ZWQ7XG4gICAgY29tcG9uZW50cztcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzLCBpbml0KSB7XG4gICAgICAgIHRoaXMucm91dGVycyA9IGluaXQucm91dGVycyA/PyBbXTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgfVxuICAgIGlzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRlZDtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb250ZW50IHJvdXRlcnMgaW4gcGFyYWxsZWwgdG8gZmluZCBwcm92aWRlcnMgb2YgdGhlIGdpdmVuIGtleVxuICAgICAqL1xuICAgIGFzeW5jICpmaW5kUHJvdmlkZXJzKGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnJvdXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdObyBjb250ZW50IHJvdXRlcnMgYXZhaWxhYmxlJywgY29kZXMuRVJSX05PX1JPVVRFUlNfQVZBSUxBQkxFKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBQZWVyU2V0KCk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGVlciBvZiBtZXJnZSguLi5zZWxmLnJvdXRlcnMubWFwKHJvdXRlciA9PiByb3V0ZXIuZmluZFByb3ZpZGVycyhrZXksIG9wdGlvbnMpKSkpIHtcbiAgICAgICAgICAgIC8vIHRoZSBwZWVyIHdhcyB5aWVsZGVkIGJ5IGEgY29udGVudCByb3V0ZXIgd2l0aG91dCBtdWx0aWFkZHJzIGFuZCB3ZVxuICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGxvYWQgdGhlbVxuICAgICAgICAgICAgaWYgKHBlZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGFkZHJlc3NlcyBmb3IgdGhlIHBlZXIgaWYgZm91bmRcbiAgICAgICAgICAgIGlmIChwZWVyLm11bHRpYWRkcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcG9uZW50cy5wZWVyU3RvcmUubWVyZ2UocGVlci5pZCwge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWFkZHJzOiBwZWVyLm11bHRpYWRkcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZHVwbGljYXRlIHBlZXJzXG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMocGVlci5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uYWRkKHBlZXIuaWQpO1xuICAgICAgICAgICAgeWllbGQgcGVlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb250ZW50IHJvdXRlcnMgaW4gcGFyYWxsZWwgdG8gbm90aWZ5IGl0IGlzXG4gICAgICogYSBwcm92aWRlciBvZiB0aGUgZ2l2ZW4ga2V5XG4gICAgICovXG4gICAgYXN5bmMgcHJvdmlkZShrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignTm8gY29udGVudCByb3V0ZXJzIGF2YWlsYWJsZScsIGNvZGVzLkVSUl9OT19ST1VURVJTX0FWQUlMQUJMRSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5yb3V0ZXJzLm1hcChhc3luYyAocm91dGVyKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCByb3V0ZXIucHJvdmlkZShrZXksIG9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSBnaXZlbiBrZXkvdmFsdWUgcGFpciBpbiB0aGUgYXZhaWxhYmxlIGNvbnRlbnQgcm91dGluZ3NcbiAgICAgKi9cbiAgICBhc3luYyBwdXQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IobWVzc2FnZXMuTk9UX1NUQVJURURfWUVULCBjb2Rlcy5FUlJfTk9ERV9OT1RfU1RBUlRFRCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5yb3V0ZXJzLm1hcChhc3luYyAocm91dGVyKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCByb3V0ZXIucHV0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgdG8gdGhlIGdpdmVuIGtleS5cbiAgICAgKiBUaW1lcyBvdXQgYWZ0ZXIgMSBtaW51dGUgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihtZXNzYWdlcy5OT1RfU1RBUlRFRF9ZRVQsIGNvZGVzLkVSUl9OT0RFX05PVF9TVEFSVEVEKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbnkodGhpcy5yb3V0ZXJzLm1hcChhc3luYyAocm91dGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmdldChrZXksIG9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGVudC1yb3V0aW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlRXJyb3IiLCJQZWVyU2V0IiwibWVyZ2UiLCJjb2RlcyIsIm1lc3NhZ2VzIiwiQ29tcG91bmRDb250ZW50Um91dGluZyIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50cyIsImluaXQiLCJyb3V0ZXJzIiwic3RhcnRlZCIsImlzU3RhcnRlZCIsInN0YXJ0Iiwic3RvcCIsImZpbmRQcm92aWRlcnMiLCJrZXkiLCJvcHRpb25zIiwibGVuZ3RoIiwiRVJSX05PX1JPVVRFUlNfQVZBSUxBQkxFIiwic2VsZiIsInNlZW4iLCJwZWVyIiwibWFwIiwicm91dGVyIiwibXVsdGlhZGRycyIsInBlZXJTdG9yZSIsImlkIiwiaGFzIiwiYWRkIiwicHJvdmlkZSIsIlByb21pc2UiLCJhbGwiLCJwdXQiLCJ2YWx1ZSIsIk5PVF9TVEFSVEVEX1lFVCIsIkVSUl9OT0RFX05PVF9TVEFSVEVEIiwiZ2V0IiwiYW55Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/content-routing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/errors.js":
/*!************************************************!*\
  !*** ./node_modules/libp2p/dist/src/errors.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codes: () => (/* binding */ codes),\n/* harmony export */   messages: () => (/* binding */ messages)\n/* harmony export */ });\nvar messages;\n(function(messages) {\n    messages[\"NOT_STARTED_YET\"] = \"The libp2p node is not started yet\";\n    messages[\"ERR_PROTECTOR_REQUIRED\"] = \"Private network is enforced, but no protector was provided\";\n    messages[\"NOT_FOUND\"] = \"Not found\";\n})(messages || (messages = {}));\nvar codes;\n(function(codes) {\n    codes[\"ERR_PROTECTOR_REQUIRED\"] = \"ERR_PROTECTOR_REQUIRED\";\n    codes[\"ERR_PEER_DIAL_INTERCEPTED\"] = \"ERR_PEER_DIAL_INTERCEPTED\";\n    codes[\"ERR_CONNECTION_INTERCEPTED\"] = \"ERR_CONNECTION_INTERCEPTED\";\n    codes[\"ERR_INVALID_PROTOCOLS_FOR_STREAM\"] = \"ERR_INVALID_PROTOCOLS_FOR_STREAM\";\n    codes[\"ERR_CONNECTION_ENDED\"] = \"ERR_CONNECTION_ENDED\";\n    codes[\"ERR_CONNECTION_FAILED\"] = \"ERR_CONNECTION_FAILED\";\n    codes[\"ERR_NODE_NOT_STARTED\"] = \"ERR_NODE_NOT_STARTED\";\n    codes[\"ERR_ALREADY_ABORTED\"] = \"ERR_ALREADY_ABORTED\";\n    codes[\"ERR_TOO_MANY_ADDRESSES\"] = \"ERR_TOO_MANY_ADDRESSES\";\n    codes[\"ERR_NO_VALID_ADDRESSES\"] = \"ERR_NO_VALID_ADDRESSES\";\n    codes[\"ERR_RELAYED_DIAL\"] = \"ERR_RELAYED_DIAL\";\n    codes[\"ERR_DIALED_SELF\"] = \"ERR_DIALED_SELF\";\n    codes[\"ERR_DISCOVERED_SELF\"] = \"ERR_DISCOVERED_SELF\";\n    codes[\"ERR_DUPLICATE_TRANSPORT\"] = \"ERR_DUPLICATE_TRANSPORT\";\n    codes[\"ERR_ENCRYPTION_FAILED\"] = \"ERR_ENCRYPTION_FAILED\";\n    codes[\"ERR_HOP_REQUEST_FAILED\"] = \"ERR_HOP_REQUEST_FAILED\";\n    codes[\"ERR_INVALID_KEY\"] = \"ERR_INVALID_KEY\";\n    codes[\"ERR_INVALID_MESSAGE\"] = \"ERR_INVALID_MESSAGE\";\n    codes[\"ERR_INVALID_PARAMETERS\"] = \"ERR_INVALID_PARAMETERS\";\n    codes[\"ERR_INVALID_PEER\"] = \"ERR_INVALID_PEER\";\n    codes[\"ERR_MUXER_UNAVAILABLE\"] = \"ERR_MUXER_UNAVAILABLE\";\n    codes[\"ERR_NOT_FOUND\"] = \"ERR_NOT_FOUND\";\n    codes[\"ERR_TRANSPORT_UNAVAILABLE\"] = \"ERR_TRANSPORT_UNAVAILABLE\";\n    codes[\"ERR_TRANSPORT_DIAL_FAILED\"] = \"ERR_TRANSPORT_DIAL_FAILED\";\n    codes[\"ERR_UNSUPPORTED_PROTOCOL\"] = \"ERR_UNSUPPORTED_PROTOCOL\";\n    codes[\"ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED\"] = \"ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED\";\n    codes[\"ERR_INVALID_MULTIADDR\"] = \"ERR_INVALID_MULTIADDR\";\n    codes[\"ERR_SIGNATURE_NOT_VALID\"] = \"ERR_SIGNATURE_NOT_VALID\";\n    codes[\"ERR_FIND_SELF\"] = \"ERR_FIND_SELF\";\n    codes[\"ERR_NO_ROUTERS_AVAILABLE\"] = \"ERR_NO_ROUTERS_AVAILABLE\";\n    codes[\"ERR_CONNECTION_NOT_MULTIPLEXED\"] = \"ERR_CONNECTION_NOT_MULTIPLEXED\";\n    codes[\"ERR_NO_DIAL_TOKENS\"] = \"ERR_NO_DIAL_TOKENS\";\n    codes[\"ERR_INVALID_CMS\"] = \"ERR_INVALID_CMS\";\n    codes[\"ERR_MISSING_KEYS\"] = \"ERR_MISSING_KEYS\";\n    codes[\"ERR_NO_KEY\"] = \"ERR_NO_KEY\";\n    codes[\"ERR_INVALID_KEY_NAME\"] = \"ERR_INVALID_KEY_NAME\";\n    codes[\"ERR_INVALID_KEY_TYPE\"] = \"ERR_INVALID_KEY_TYPE\";\n    codes[\"ERR_KEY_ALREADY_EXISTS\"] = \"ERR_KEY_ALREADY_EXISTS\";\n    codes[\"ERR_INVALID_KEY_SIZE\"] = \"ERR_INVALID_KEY_SIZE\";\n    codes[\"ERR_KEY_NOT_FOUND\"] = \"ERR_KEY_NOT_FOUND\";\n    codes[\"ERR_OLD_KEY_NAME_INVALID\"] = \"ERR_OLD_KEY_NAME_INVALID\";\n    codes[\"ERR_NEW_KEY_NAME_INVALID\"] = \"ERR_NEW_KEY_NAME_INVALID\";\n    codes[\"ERR_PASSWORD_REQUIRED\"] = \"ERR_PASSWORD_REQUIRED\";\n    codes[\"ERR_PEM_REQUIRED\"] = \"ERR_PEM_REQUIRED\";\n    codes[\"ERR_CANNOT_READ_KEY\"] = \"ERR_CANNOT_READ_KEY\";\n    codes[\"ERR_MISSING_PRIVATE_KEY\"] = \"ERR_MISSING_PRIVATE_KEY\";\n    codes[\"ERR_MISSING_PUBLIC_KEY\"] = \"ERR_MISSING_PUBLIC_KEY\";\n    codes[\"ERR_INVALID_OLD_PASS_TYPE\"] = \"ERR_INVALID_OLD_PASS_TYPE\";\n    codes[\"ERR_INVALID_NEW_PASS_TYPE\"] = \"ERR_INVALID_NEW_PASS_TYPE\";\n    codes[\"ERR_INVALID_PASS_LENGTH\"] = \"ERR_INVALID_PASS_LENGTH\";\n    codes[\"ERR_NOT_IMPLEMENTED\"] = \"ERR_NOT_IMPLEMENTED\";\n    codes[\"ERR_WRONG_PING_ACK\"] = \"ERR_WRONG_PING_ACK\";\n    codes[\"ERR_INVALID_RECORD\"] = \"ERR_INVALID_RECORD\";\n    codes[\"ERR_ALREADY_SUCCEEDED\"] = \"ERR_ALREADY_SUCCEEDED\";\n    codes[\"ERR_NO_HANDLER_FOR_PROTOCOL\"] = \"ERR_NO_HANDLER_FOR_PROTOCOL\";\n    codes[\"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_CONNECTION_DENIED\"] = \"ERR_CONNECTION_DENIED\";\n    codes[\"ERR_TRANSFER_LIMIT_EXCEEDED\"] = \"ERR_TRANSFER_LIMIT_EXCEEDED\";\n})(codes || (codes = {})); //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLElBQUlBLFNBQVM7QUFDbkIsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUMsa0JBQWtCLEdBQUc7SUFDOUJBLFFBQVEsQ0FBQyx5QkFBeUIsR0FBRztJQUNyQ0EsUUFBUSxDQUFDLFlBQVksR0FBRztBQUM1QixHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDckIsSUFBSUMsTUFBTTtBQUNoQixVQUFVQSxLQUFLO0lBQ1pBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRztJQUNsQ0EsS0FBSyxDQUFDLDRCQUE0QixHQUFHO0lBQ3JDQSxLQUFLLENBQUMsNkJBQTZCLEdBQUc7SUFDdENBLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRztJQUM1Q0EsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQyx1QkFBdUIsR0FBRztJQUNoQ0EsS0FBSyxDQUFDLHNCQUFzQixHQUFHO0lBQy9CQSxLQUFLLENBQUMseUJBQXlCLEdBQUc7SUFDbENBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRztJQUNsQ0EsS0FBSyxDQUFDLG1CQUFtQixHQUFHO0lBQzVCQSxLQUFLLENBQUMsa0JBQWtCLEdBQUc7SUFDM0JBLEtBQUssQ0FBQyxzQkFBc0IsR0FBRztJQUMvQkEsS0FBSyxDQUFDLDBCQUEwQixHQUFHO0lBQ25DQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRztJQUNsQ0EsS0FBSyxDQUFDLGtCQUFrQixHQUFHO0lBQzNCQSxLQUFLLENBQUMsc0JBQXNCLEdBQUc7SUFDL0JBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRztJQUNsQ0EsS0FBSyxDQUFDLG1CQUFtQixHQUFHO0lBQzVCQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRztJQUN6QkEsS0FBSyxDQUFDLDRCQUE0QixHQUFHO0lBQ3JDQSxLQUFLLENBQUMsNEJBQTRCLEdBQUc7SUFDckNBLEtBQUssQ0FBQywyQkFBMkIsR0FBRztJQUNwQ0EsS0FBSyxDQUFDLDBDQUEwQyxHQUFHO0lBQ25EQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQywwQkFBMEIsR0FBRztJQUNuQ0EsS0FBSyxDQUFDLGdCQUFnQixHQUFHO0lBQ3pCQSxLQUFLLENBQUMsMkJBQTJCLEdBQUc7SUFDcENBLEtBQUssQ0FBQyxpQ0FBaUMsR0FBRztJQUMxQ0EsS0FBSyxDQUFDLHFCQUFxQixHQUFHO0lBQzlCQSxLQUFLLENBQUMsa0JBQWtCLEdBQUc7SUFDM0JBLEtBQUssQ0FBQyxtQkFBbUIsR0FBRztJQUM1QkEsS0FBSyxDQUFDLGFBQWEsR0FBRztJQUN0QkEsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDQSxLQUFLLENBQUMsdUJBQXVCLEdBQUc7SUFDaENBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRztJQUNsQ0EsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUc7SUFDN0JBLEtBQUssQ0FBQywyQkFBMkIsR0FBRztJQUNwQ0EsS0FBSyxDQUFDLDJCQUEyQixHQUFHO0lBQ3BDQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQyxtQkFBbUIsR0FBRztJQUM1QkEsS0FBSyxDQUFDLHNCQUFzQixHQUFHO0lBQy9CQSxLQUFLLENBQUMsMEJBQTBCLEdBQUc7SUFDbkNBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRztJQUNsQ0EsS0FBSyxDQUFDLDRCQUE0QixHQUFHO0lBQ3JDQSxLQUFLLENBQUMsNEJBQTRCLEdBQUc7SUFDckNBLEtBQUssQ0FBQywwQkFBMEIsR0FBRztJQUNuQ0EsS0FBSyxDQUFDLHNCQUFzQixHQUFHO0lBQy9CQSxLQUFLLENBQUMscUJBQXFCLEdBQUc7SUFDOUJBLEtBQUssQ0FBQyxxQkFBcUIsR0FBRztJQUM5QkEsS0FBSyxDQUFDLHdCQUF3QixHQUFHO0lBQ2pDQSxLQUFLLENBQUMsOEJBQThCLEdBQUc7SUFDdkNBLEtBQUssQ0FBQyx5Q0FBeUMsR0FBRztJQUNsREEsS0FBSyxDQUFDLHdDQUF3QyxHQUFHO0lBQ2pEQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQyw4QkFBOEIsR0FBRztBQUMzQyxHQUFHQSxTQUFVQSxDQUFBQSxRQUFRLENBQUMsS0FDdEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2Vycm9ycy5qcz8xNDg3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgbWVzc2FnZXM7XG4oZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgbWVzc2FnZXNbXCJOT1RfU1RBUlRFRF9ZRVRcIl0gPSBcIlRoZSBsaWJwMnAgbm9kZSBpcyBub3Qgc3RhcnRlZCB5ZXRcIjtcbiAgICBtZXNzYWdlc1tcIkVSUl9QUk9URUNUT1JfUkVRVUlSRURcIl0gPSBcIlByaXZhdGUgbmV0d29yayBpcyBlbmZvcmNlZCwgYnV0IG5vIHByb3RlY3RvciB3YXMgcHJvdmlkZWRcIjtcbiAgICBtZXNzYWdlc1tcIk5PVF9GT1VORFwiXSA9IFwiTm90IGZvdW5kXCI7XG59KShtZXNzYWdlcyB8fCAobWVzc2FnZXMgPSB7fSkpO1xuZXhwb3J0IHZhciBjb2RlcztcbihmdW5jdGlvbiAoY29kZXMpIHtcbiAgICBjb2Rlc1tcIkVSUl9QUk9URUNUT1JfUkVRVUlSRURcIl0gPSBcIkVSUl9QUk9URUNUT1JfUkVRVUlSRURcIjtcbiAgICBjb2Rlc1tcIkVSUl9QRUVSX0RJQUxfSU5URVJDRVBURURcIl0gPSBcIkVSUl9QRUVSX0RJQUxfSU5URVJDRVBURURcIjtcbiAgICBjb2Rlc1tcIkVSUl9DT05ORUNUSU9OX0lOVEVSQ0VQVEVEXCJdID0gXCJFUlJfQ09OTkVDVElPTl9JTlRFUkNFUFRFRFwiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfUFJPVE9DT0xTX0ZPUl9TVFJFQU1cIl0gPSBcIkVSUl9JTlZBTElEX1BST1RPQ09MU19GT1JfU1RSRUFNXCI7XG4gICAgY29kZXNbXCJFUlJfQ09OTkVDVElPTl9FTkRFRFwiXSA9IFwiRVJSX0NPTk5FQ1RJT05fRU5ERURcIjtcbiAgICBjb2Rlc1tcIkVSUl9DT05ORUNUSU9OX0ZBSUxFRFwiXSA9IFwiRVJSX0NPTk5FQ1RJT05fRkFJTEVEXCI7XG4gICAgY29kZXNbXCJFUlJfTk9ERV9OT1RfU1RBUlRFRFwiXSA9IFwiRVJSX05PREVfTk9UX1NUQVJURURcIjtcbiAgICBjb2Rlc1tcIkVSUl9BTFJFQURZX0FCT1JURURcIl0gPSBcIkVSUl9BTFJFQURZX0FCT1JURURcIjtcbiAgICBjb2Rlc1tcIkVSUl9UT09fTUFOWV9BRERSRVNTRVNcIl0gPSBcIkVSUl9UT09fTUFOWV9BRERSRVNTRVNcIjtcbiAgICBjb2Rlc1tcIkVSUl9OT19WQUxJRF9BRERSRVNTRVNcIl0gPSBcIkVSUl9OT19WQUxJRF9BRERSRVNTRVNcIjtcbiAgICBjb2Rlc1tcIkVSUl9SRUxBWUVEX0RJQUxcIl0gPSBcIkVSUl9SRUxBWUVEX0RJQUxcIjtcbiAgICBjb2Rlc1tcIkVSUl9ESUFMRURfU0VMRlwiXSA9IFwiRVJSX0RJQUxFRF9TRUxGXCI7XG4gICAgY29kZXNbXCJFUlJfRElTQ09WRVJFRF9TRUxGXCJdID0gXCJFUlJfRElTQ09WRVJFRF9TRUxGXCI7XG4gICAgY29kZXNbXCJFUlJfRFVQTElDQVRFX1RSQU5TUE9SVFwiXSA9IFwiRVJSX0RVUExJQ0FURV9UUkFOU1BPUlRcIjtcbiAgICBjb2Rlc1tcIkVSUl9FTkNSWVBUSU9OX0ZBSUxFRFwiXSA9IFwiRVJSX0VOQ1JZUFRJT05fRkFJTEVEXCI7XG4gICAgY29kZXNbXCJFUlJfSE9QX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJFUlJfSE9QX1JFUVVFU1RfRkFJTEVEXCI7XG4gICAgY29kZXNbXCJFUlJfSU5WQUxJRF9LRVlcIl0gPSBcIkVSUl9JTlZBTElEX0tFWVwiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfTUVTU0FHRVwiXSA9IFwiRVJSX0lOVkFMSURfTUVTU0FHRVwiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfUEFSQU1FVEVSU1wiXSA9IFwiRVJSX0lOVkFMSURfUEFSQU1FVEVSU1wiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfUEVFUlwiXSA9IFwiRVJSX0lOVkFMSURfUEVFUlwiO1xuICAgIGNvZGVzW1wiRVJSX01VWEVSX1VOQVZBSUxBQkxFXCJdID0gXCJFUlJfTVVYRVJfVU5BVkFJTEFCTEVcIjtcbiAgICBjb2Rlc1tcIkVSUl9OT1RfRk9VTkRcIl0gPSBcIkVSUl9OT1RfRk9VTkRcIjtcbiAgICBjb2Rlc1tcIkVSUl9UUkFOU1BPUlRfVU5BVkFJTEFCTEVcIl0gPSBcIkVSUl9UUkFOU1BPUlRfVU5BVkFJTEFCTEVcIjtcbiAgICBjb2Rlc1tcIkVSUl9UUkFOU1BPUlRfRElBTF9GQUlMRURcIl0gPSBcIkVSUl9UUkFOU1BPUlRfRElBTF9GQUlMRURcIjtcbiAgICBjb2Rlc1tcIkVSUl9VTlNVUFBPUlRFRF9QUk9UT0NPTFwiXSA9IFwiRVJSX1VOU1VQUE9SVEVEX1BST1RPQ09MXCI7XG4gICAgY29kZXNbXCJFUlJfUFJPVE9DT0xfSEFORExFUl9BTFJFQURZX1JFR0lTVEVSRURcIl0gPSBcIkVSUl9QUk9UT0NPTF9IQU5ETEVSX0FMUkVBRFlfUkVHSVNURVJFRFwiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfTVVMVElBRERSXCJdID0gXCJFUlJfSU5WQUxJRF9NVUxUSUFERFJcIjtcbiAgICBjb2Rlc1tcIkVSUl9TSUdOQVRVUkVfTk9UX1ZBTElEXCJdID0gXCJFUlJfU0lHTkFUVVJFX05PVF9WQUxJRFwiO1xuICAgIGNvZGVzW1wiRVJSX0ZJTkRfU0VMRlwiXSA9IFwiRVJSX0ZJTkRfU0VMRlwiO1xuICAgIGNvZGVzW1wiRVJSX05PX1JPVVRFUlNfQVZBSUxBQkxFXCJdID0gXCJFUlJfTk9fUk9VVEVSU19BVkFJTEFCTEVcIjtcbiAgICBjb2Rlc1tcIkVSUl9DT05ORUNUSU9OX05PVF9NVUxUSVBMRVhFRFwiXSA9IFwiRVJSX0NPTk5FQ1RJT05fTk9UX01VTFRJUExFWEVEXCI7XG4gICAgY29kZXNbXCJFUlJfTk9fRElBTF9UT0tFTlNcIl0gPSBcIkVSUl9OT19ESUFMX1RPS0VOU1wiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfQ01TXCJdID0gXCJFUlJfSU5WQUxJRF9DTVNcIjtcbiAgICBjb2Rlc1tcIkVSUl9NSVNTSU5HX0tFWVNcIl0gPSBcIkVSUl9NSVNTSU5HX0tFWVNcIjtcbiAgICBjb2Rlc1tcIkVSUl9OT19LRVlcIl0gPSBcIkVSUl9OT19LRVlcIjtcbiAgICBjb2Rlc1tcIkVSUl9JTlZBTElEX0tFWV9OQU1FXCJdID0gXCJFUlJfSU5WQUxJRF9LRVlfTkFNRVwiO1xuICAgIGNvZGVzW1wiRVJSX0lOVkFMSURfS0VZX1RZUEVcIl0gPSBcIkVSUl9JTlZBTElEX0tFWV9UWVBFXCI7XG4gICAgY29kZXNbXCJFUlJfS0VZX0FMUkVBRFlfRVhJU1RTXCJdID0gXCJFUlJfS0VZX0FMUkVBRFlfRVhJU1RTXCI7XG4gICAgY29kZXNbXCJFUlJfSU5WQUxJRF9LRVlfU0laRVwiXSA9IFwiRVJSX0lOVkFMSURfS0VZX1NJWkVcIjtcbiAgICBjb2Rlc1tcIkVSUl9LRVlfTk9UX0ZPVU5EXCJdID0gXCJFUlJfS0VZX05PVF9GT1VORFwiO1xuICAgIGNvZGVzW1wiRVJSX09MRF9LRVlfTkFNRV9JTlZBTElEXCJdID0gXCJFUlJfT0xEX0tFWV9OQU1FX0lOVkFMSURcIjtcbiAgICBjb2Rlc1tcIkVSUl9ORVdfS0VZX05BTUVfSU5WQUxJRFwiXSA9IFwiRVJSX05FV19LRVlfTkFNRV9JTlZBTElEXCI7XG4gICAgY29kZXNbXCJFUlJfUEFTU1dPUkRfUkVRVUlSRURcIl0gPSBcIkVSUl9QQVNTV09SRF9SRVFVSVJFRFwiO1xuICAgIGNvZGVzW1wiRVJSX1BFTV9SRVFVSVJFRFwiXSA9IFwiRVJSX1BFTV9SRVFVSVJFRFwiO1xuICAgIGNvZGVzW1wiRVJSX0NBTk5PVF9SRUFEX0tFWVwiXSA9IFwiRVJSX0NBTk5PVF9SRUFEX0tFWVwiO1xuICAgIGNvZGVzW1wiRVJSX01JU1NJTkdfUFJJVkFURV9LRVlcIl0gPSBcIkVSUl9NSVNTSU5HX1BSSVZBVEVfS0VZXCI7XG4gICAgY29kZXNbXCJFUlJfTUlTU0lOR19QVUJMSUNfS0VZXCJdID0gXCJFUlJfTUlTU0lOR19QVUJMSUNfS0VZXCI7XG4gICAgY29kZXNbXCJFUlJfSU5WQUxJRF9PTERfUEFTU19UWVBFXCJdID0gXCJFUlJfSU5WQUxJRF9PTERfUEFTU19UWVBFXCI7XG4gICAgY29kZXNbXCJFUlJfSU5WQUxJRF9ORVdfUEFTU19UWVBFXCJdID0gXCJFUlJfSU5WQUxJRF9ORVdfUEFTU19UWVBFXCI7XG4gICAgY29kZXNbXCJFUlJfSU5WQUxJRF9QQVNTX0xFTkdUSFwiXSA9IFwiRVJSX0lOVkFMSURfUEFTU19MRU5HVEhcIjtcbiAgICBjb2Rlc1tcIkVSUl9OT1RfSU1QTEVNRU5URURcIl0gPSBcIkVSUl9OT1RfSU1QTEVNRU5URURcIjtcbiAgICBjb2Rlc1tcIkVSUl9XUk9OR19QSU5HX0FDS1wiXSA9IFwiRVJSX1dST05HX1BJTkdfQUNLXCI7XG4gICAgY29kZXNbXCJFUlJfSU5WQUxJRF9SRUNPUkRcIl0gPSBcIkVSUl9JTlZBTElEX1JFQ09SRFwiO1xuICAgIGNvZGVzW1wiRVJSX0FMUkVBRFlfU1VDQ0VFREVEXCJdID0gXCJFUlJfQUxSRUFEWV9TVUNDRUVERURcIjtcbiAgICBjb2Rlc1tcIkVSUl9OT19IQU5ETEVSX0ZPUl9QUk9UT0NPTFwiXSA9IFwiRVJSX05PX0hBTkRMRVJfRk9SX1BST1RPQ09MXCI7XG4gICAgY29kZXNbXCJFUlJfVE9PX01BTllfT1VUQk9VTkRfUFJPVE9DT0xfU1RSRUFNU1wiXSA9IFwiRVJSX1RPT19NQU5ZX09VVEJPVU5EX1BST1RPQ09MX1NUUkVBTVNcIjtcbiAgICBjb2Rlc1tcIkVSUl9UT09fTUFOWV9JTkJPVU5EX1BST1RPQ09MX1NUUkVBTVNcIl0gPSBcIkVSUl9UT09fTUFOWV9JTkJPVU5EX1BST1RPQ09MX1NUUkVBTVNcIjtcbiAgICBjb2Rlc1tcIkVSUl9DT05ORUNUSU9OX0RFTklFRFwiXSA9IFwiRVJSX0NPTk5FQ1RJT05fREVOSUVEXCI7XG4gICAgY29kZXNbXCJFUlJfVFJBTlNGRVJfTElNSVRfRVhDRUVERURcIl0gPSBcIkVSUl9UUkFOU0ZFUl9MSU1JVF9FWENFRURFRFwiO1xufSkoY29kZXMgfHwgKGNvZGVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsibWVzc2FnZXMiLCJjb2RlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/get-peer.js":
/*!**************************************************!*\
  !*** ./node_modules/libp2p/dist/src/get-peer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPeerAddress: () => (/* binding */ getPeerAddress)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/peer-id/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/peer-id */ \"(ssr)/./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n\n\n\n\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */ function getPeerAddress(peer) {\n    if ((0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.isPeerId)(peer)) {\n        return {\n            peerId: peer,\n            multiaddrs: []\n        };\n    }\n    if (!Array.isArray(peer)) {\n        peer = [\n            peer\n        ];\n    }\n    let peerId;\n    if (peer.length > 0) {\n        const peerIdStr = peer[0].getPeerId();\n        peerId = peerIdStr == null ? undefined : (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_2__.peerIdFromString)(peerIdStr);\n        // ensure PeerId is either not set or is consistent\n        peer.forEach((ma)=>{\n            if (!(0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.isMultiaddr)(ma)) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"Invalid Multiaddr\", _errors_js__WEBPACK_IMPORTED_MODULE_4__.codes.ERR_INVALID_MULTIADDR);\n            }\n            const maPeerIdStr = ma.getPeerId();\n            if (maPeerIdStr == null) {\n                if (peerId != null) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"Multiaddrs must all have the same peer id or have no peer id\", _errors_js__WEBPACK_IMPORTED_MODULE_4__.codes.ERR_INVALID_PARAMETERS);\n                }\n            } else {\n                const maPeerId = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_2__.peerIdFromString)(maPeerIdStr);\n                if (peerId == null || !peerId.equals(maPeerId)) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"Multiaddrs must all have the same peer id or have no peer id\", _errors_js__WEBPACK_IMPORTED_MODULE_4__.codes.ERR_INVALID_PARAMETERS);\n                }\n            }\n        });\n    }\n    return {\n        peerId,\n        multiaddrs: peer\n    };\n} //# sourceMappingURL=get-peer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2dldC1wZWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3RDtBQUNMO0FBQ0c7QUFDbEI7QUFDcEM7O0NBRUMsR0FDTSxTQUFTSyxlQUFlQyxJQUFJO0lBQy9CLElBQUlMLDJEQUFRQSxDQUFDSyxPQUFPO1FBQ2hCLE9BQU87WUFBRUMsUUFBUUQ7WUFBTUUsWUFBWSxFQUFFO1FBQUM7SUFDMUM7SUFDQSxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0osT0FBTztRQUN0QkEsT0FBTztZQUFDQTtTQUFLO0lBQ2pCO0lBQ0EsSUFBSUM7SUFDSixJQUFJRCxLQUFLSyxNQUFNLEdBQUcsR0FBRztRQUNqQixNQUFNQyxZQUFZTixJQUFJLENBQUMsRUFBRSxDQUFDTyxTQUFTO1FBQ25DTixTQUFTSyxhQUFhLE9BQU9FLFlBQVlaLGlFQUFnQkEsQ0FBQ1U7UUFDMUQsbURBQW1EO1FBQ25ETixLQUFLUyxPQUFPLENBQUNDLENBQUFBO1lBQ1QsSUFBSSxDQUFDYixvRUFBV0EsQ0FBQ2EsS0FBSztnQkFDbEIsTUFBTSxJQUFJaEIsd0RBQVNBLENBQUMscUJBQXFCSSw2Q0FBS0EsQ0FBQ2EscUJBQXFCO1lBQ3hFO1lBQ0EsTUFBTUMsY0FBY0YsR0FBR0gsU0FBUztZQUNoQyxJQUFJSyxlQUFlLE1BQU07Z0JBQ3JCLElBQUlYLFVBQVUsTUFBTTtvQkFDaEIsTUFBTSxJQUFJUCx3REFBU0EsQ0FBQyxnRUFBZ0VJLDZDQUFLQSxDQUFDZSxzQkFBc0I7Z0JBQ3BIO1lBQ0osT0FDSztnQkFDRCxNQUFNQyxXQUFXbEIsaUVBQWdCQSxDQUFDZ0I7Z0JBQ2xDLElBQUlYLFVBQVUsUUFBUSxDQUFDQSxPQUFPYyxNQUFNLENBQUNELFdBQVc7b0JBQzVDLE1BQU0sSUFBSXBCLHdEQUFTQSxDQUFDLGdFQUFnRUksNkNBQUtBLENBQUNlLHNCQUFzQjtnQkFDcEg7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPO1FBQ0haO1FBQ0FDLFlBQVlGO0lBQ2hCO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvZ2V0LXBlZXIuanM/NTMyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRXJyb3IsIGlzUGVlcklkIH0gZnJvbSAnQGxpYnAycC9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgcGVlcklkRnJvbVN0cmluZyB9IGZyb20gJ0BsaWJwMnAvcGVlci1pZCc7XG5pbXBvcnQgeyBpc011bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJztcbmltcG9ydCB7IGNvZGVzIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuLyoqXG4gKiBFeHRyYWN0cyBhIFBlZXJJZCBhbmQvb3IgbXVsdGlhZGRyIGZyb20gdGhlIHBhc3NlZCBQZWVySWQgb3IgTXVsdGlhZGRyIG9yIGFuIGFycmF5IG9mIE11bHRpYWRkcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBlZXJBZGRyZXNzKHBlZXIpIHtcbiAgICBpZiAoaXNQZWVySWQocGVlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgcGVlcklkOiBwZWVyLCBtdWx0aWFkZHJzOiBbXSB9O1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGVlcikpIHtcbiAgICAgICAgcGVlciA9IFtwZWVyXTtcbiAgICB9XG4gICAgbGV0IHBlZXJJZDtcbiAgICBpZiAocGVlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBlZXJJZFN0ciA9IHBlZXJbMF0uZ2V0UGVlcklkKCk7XG4gICAgICAgIHBlZXJJZCA9IHBlZXJJZFN0ciA9PSBudWxsID8gdW5kZWZpbmVkIDogcGVlcklkRnJvbVN0cmluZyhwZWVySWRTdHIpO1xuICAgICAgICAvLyBlbnN1cmUgUGVlcklkIGlzIGVpdGhlciBub3Qgc2V0IG9yIGlzIGNvbnNpc3RlbnRcbiAgICAgICAgcGVlci5mb3JFYWNoKG1hID0+IHtcbiAgICAgICAgICAgIGlmICghaXNNdWx0aWFkZHIobWEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignSW52YWxpZCBNdWx0aWFkZHInLCBjb2Rlcy5FUlJfSU5WQUxJRF9NVUxUSUFERFIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFQZWVySWRTdHIgPSBtYS5nZXRQZWVySWQoKTtcbiAgICAgICAgICAgIGlmIChtYVBlZXJJZFN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlZXJJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ011bHRpYWRkcnMgbXVzdCBhbGwgaGF2ZSB0aGUgc2FtZSBwZWVyIGlkIG9yIGhhdmUgbm8gcGVlciBpZCcsIGNvZGVzLkVSUl9JTlZBTElEX1BBUkFNRVRFUlMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hUGVlcklkID0gcGVlcklkRnJvbVN0cmluZyhtYVBlZXJJZFN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHBlZXJJZCA9PSBudWxsIHx8ICFwZWVySWQuZXF1YWxzKG1hUGVlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdNdWx0aWFkZHJzIG11c3QgYWxsIGhhdmUgdGhlIHNhbWUgcGVlciBpZCBvciBoYXZlIG5vIHBlZXIgaWQnLCBjb2Rlcy5FUlJfSU5WQUxJRF9QQVJBTUVURVJTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwZWVySWQsXG4gICAgICAgIG11bHRpYWRkcnM6IHBlZXJcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXBlZXIuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVFcnJvciIsImlzUGVlcklkIiwicGVlcklkRnJvbVN0cmluZyIsImlzTXVsdGlhZGRyIiwiY29kZXMiLCJnZXRQZWVyQWRkcmVzcyIsInBlZXIiLCJwZWVySWQiLCJtdWx0aWFkZHJzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwicGVlcklkU3RyIiwiZ2V0UGVlcklkIiwidW5kZWZpbmVkIiwiZm9yRWFjaCIsIm1hIiwiRVJSX0lOVkFMSURfTVVMVElBRERSIiwibWFQZWVySWRTdHIiLCJFUlJfSU5WQUxJRF9QQVJBTUVURVJTIiwibWFQZWVySWQiLCJlcXVhbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/get-peer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/libp2p/dist/src/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLibp2p: () => (/* binding */ createLibp2p)\n/* harmony export */ });\n/* harmony import */ var _libp2p_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libp2p.js */ \"(ssr)/./node_modules/libp2p/dist/src/libp2p.js\");\n/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */ \n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncryption: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */ async function createLibp2p(options = {}) {\n    const node = await (0,_libp2p_js__WEBPACK_IMPORTED_MODULE_0__.createLibp2pNode)(options);\n    if (options.start !== false) {\n        await node.start();\n    }\n    return node;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDOEM7QUFDL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxlQUFlQyxhQUFhQyxVQUFVLENBQUMsQ0FBQztJQUMzQyxNQUFNQyxPQUFPLE1BQU1ILDREQUFnQkEsQ0FBQ0U7SUFDcEMsSUFBSUEsUUFBUUUsS0FBSyxLQUFLLE9BQU87UUFDekIsTUFBTUQsS0FBS0MsS0FBSztJQUNwQjtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvaW5kZXguanM/YTJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICpcbiAqIFVzZSB0aGUgYGNyZWF0ZUxpYnAycGAgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbGlicDJwIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBjcmVhdGVMaWJwMnAgfSBmcm9tICdsaWJwMnAnXG4gKlxuICogY29uc3Qgbm9kZSA9IGF3YWl0IGNyZWF0ZUxpYnAycCh7XG4gKiAgIC8vIC4uLm90aGVyIG9wdGlvbnNcbiAqIH0pXG4gKiBgYGBcbiAqL1xuaW1wb3J0IHsgY3JlYXRlTGlicDJwTm9kZSB9IGZyb20gJy4vbGlicDJwLmpzJztcbi8qKlxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTGlicDJwIGludGVyZmFjZSwgZ2VuZXJhdGluZyBhIG5ldyBQZWVySWRcbiAqIGlmIG9uZSBpcyBub3QgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIG9wdGlvbnMuXG4gKlxuICogVGhlIG5vZGUgd2lsbCBiZSBzdGFydGVkIHVubGVzcyBgc3RhcnQ6IGZhbHNlYCBpcyBwYXNzZWQgYXMgYW4gb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogaW1wb3J0IHsgY3JlYXRlTGlicDJwIH0gZnJvbSAnbGlicDJwJ1xuICogaW1wb3J0IHsgdGNwIH0gZnJvbSAnQGxpYnAycC90Y3AnXG4gKiBpbXBvcnQgeyBtcGxleCB9IGZyb20gJ0BsaWJwMnAvbXBsZXgnXG4gKiBpbXBvcnQgeyBub2lzZSB9IGZyb20gJ0BjaGFpbnNhZmUvbGlicDJwLW5vaXNlJ1xuICogaW1wb3J0IHsgeWFtdXggfSBmcm9tICdAY2hhaW5zYWZlL2xpYnAycC15YW11eCdcbiAqXG4gKiAvLyBzcGVjaWZ5IG9wdGlvbnNcbiAqIGNvbnN0IG9wdGlvbnMgPSB7XG4gKiAgIHRyYW5zcG9ydHM6IFt0Y3AoKV0sXG4gKiAgIHN0cmVhbU11eGVyczogW3lhbXV4KCksIG1wbGV4KCldLFxuICogICBjb25uZWN0aW9uRW5jcnlwdGlvbjogW25vaXNlKCldXG4gKiB9XG4gKlxuICogLy8gY3JlYXRlIGxpYnAycFxuICogY29uc3QgbGlicDJwID0gYXdhaXQgY3JlYXRlTGlicDJwKG9wdGlvbnMpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxpYnAycChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBub2RlID0gYXdhaXQgY3JlYXRlTGlicDJwTm9kZShvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5zdGFydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgYXdhaXQgbm9kZS5zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVMaWJwMnBOb2RlIiwiY3JlYXRlTGlicDJwIiwib3B0aW9ucyIsIm5vZGUiLCJzdGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/libp2p.js":
/*!************************************************!*\
  !*** ./node_modules/libp2p/dist/src/libp2p.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Libp2pNode: () => (/* binding */ Libp2pNode),\n/* harmony export */   createLibp2pNode: () => (/* binding */ createLibp2pNode)\n/* harmony export */ });\n/* harmony import */ var _libp2p_crypto_keys__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @libp2p/crypto/keys */ \"(ssr)/./node_modules/@libp2p/crypto/dist/src/keys/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/event-target.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/events.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/content-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/peer-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/peer-discovery/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"(ssr)/./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/set.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @libp2p/peer-id */ \"(ssr)/./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _libp2p_peer_id_factory__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @libp2p/peer-id-factory */ \"(ssr)/./node_modules/@libp2p/peer-id-factory/dist/src/index.js\");\n/* harmony import */ var _libp2p_peer_store__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/peer-store */ \"(ssr)/./node_modules/@libp2p/peer-store/dist/src/index.js\");\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"(ssr)/./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/* harmony import */ var datastore_core_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datastore-core/memory */ \"(ssr)/./node_modules/datastore-core/dist/src/memory.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/concat */ \"(ssr)/./node_modules/uint8arrays/dist/src/concat.node.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ \"(ssr)/./node_modules/uint8arrays/dist/src/from-string.node.js\");\n/* harmony import */ var _address_manager_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./address-manager/index.js */ \"(ssr)/./node_modules/libp2p/dist/src/address-manager/index.js\");\n/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components.js */ \"(ssr)/./node_modules/libp2p/dist/src/components.js\");\n/* harmony import */ var _config_connection_gater_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config/connection-gater.js */ \"(ssr)/./node_modules/libp2p/dist/src/config/connection-gater.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./config.js */ \"(ssr)/./node_modules/libp2p/dist/src/config.js\");\n/* harmony import */ var _connection_manager_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./connection-manager/index.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/index.js\");\n/* harmony import */ var _content_routing_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./content-routing.js */ \"(ssr)/./node_modules/libp2p/dist/src/content-routing.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n/* harmony import */ var _peer_routing_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./peer-routing.js */ \"(ssr)/./node_modules/libp2p/dist/src/peer-routing.js\");\n/* harmony import */ var _registrar_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./registrar.js */ \"(ssr)/./node_modules/libp2p/dist/src/registrar.js\");\n/* harmony import */ var _transport_manager_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transport-manager.js */ \"(ssr)/./node_modules/libp2p/dist/src/transport-manager.js\");\n/* harmony import */ var _upgrader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./upgrader.js */ \"(ssr)/./node_modules/libp2p/dist/src/upgrader.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/libp2p/dist/src/version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Libp2pNode extends _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.TypedEventEmitter {\n    constructor(init){\n        super();\n        this.status = \"stopped\";\n        // event bus - components can listen to this emitter to be notified of system events\n        // and also cause them to be emitted\n        const events = new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.TypedEventEmitter();\n        const originalDispatch = events.dispatchEvent.bind(events);\n        events.dispatchEvent = (evt)=>{\n            const internalResult = originalDispatch(evt);\n            const externalResult = this.dispatchEvent(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CustomEvent(evt.type, {\n                detail: evt.detail\n            }));\n            return internalResult || externalResult;\n        };\n        // This emitter gets listened to a lot\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_5__.setMaxListeners)(Infinity, events);\n        this.peerId = init.peerId;\n        this.logger = init.logger ?? (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.defaultLogger)();\n        this.log = this.logger.forComponent(\"libp2p\");\n        // @ts-expect-error {} may not be of type T\n        this.services = {};\n        const components = this.components = (0,_components_js__WEBPACK_IMPORTED_MODULE_7__.defaultComponents)({\n            peerId: init.peerId,\n            privateKey: init.privateKey,\n            nodeInfo: init.nodeInfo ?? {\n                name: _version_js__WEBPACK_IMPORTED_MODULE_8__.name,\n                version: _version_js__WEBPACK_IMPORTED_MODULE_8__.version\n            },\n            logger: this.logger,\n            events,\n            datastore: init.datastore ?? new datastore_core_memory__WEBPACK_IMPORTED_MODULE_1__.MemoryDatastore(),\n            connectionGater: (0,_config_connection_gater_js__WEBPACK_IMPORTED_MODULE_9__.connectionGater)(init.connectionGater),\n            dns: init.dns\n        });\n        this.peerStore = this.configureComponent(\"peerStore\", new _libp2p_peer_store__WEBPACK_IMPORTED_MODULE_10__.PersistentPeerStore(components, {\n            addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n            ...init.peerStore\n        }));\n        // Create Metrics\n        if (init.metrics != null) {\n            this.metrics = this.configureComponent(\"metrics\", init.metrics(this.components));\n        }\n        components.events.addEventListener(\"peer:update\", (evt)=>{\n            // if there was no peer previously in the peer store this is a new peer\n            if (evt.detail.previous == null) {\n                const peerInfo = {\n                    id: evt.detail.peer.id,\n                    multiaddrs: evt.detail.peer.addresses.map((a)=>a.multiaddr)\n                };\n                components.events.safeDispatchEvent(\"peer:discovery\", {\n                    detail: peerInfo\n                });\n            }\n        });\n        // Set up connection protector if configured\n        if (init.connectionProtector != null) {\n            this.configureComponent(\"connectionProtector\", init.connectionProtector(components));\n        }\n        // Set up the Upgrader\n        this.components.upgrader = new _upgrader_js__WEBPACK_IMPORTED_MODULE_11__.DefaultUpgrader(this.components, {\n            connectionEncryption: (init.connectionEncryption ?? []).map((fn, index)=>this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n            muxers: (init.streamMuxers ?? []).map((fn, index)=>this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n            inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout\n        });\n        // Setup the transport manager\n        this.configureComponent(\"transportManager\", new _transport_manager_js__WEBPACK_IMPORTED_MODULE_12__.DefaultTransportManager(this.components, init.transportManager));\n        // Create the Connection Manager\n        this.configureComponent(\"connectionManager\", new _connection_manager_index_js__WEBPACK_IMPORTED_MODULE_13__.DefaultConnectionManager(this.components, init.connectionManager));\n        // Create the Registrar\n        this.configureComponent(\"registrar\", new _registrar_js__WEBPACK_IMPORTED_MODULE_14__.DefaultRegistrar(this.components));\n        // Addresses {listen, announce, noAnnounce}\n        this.configureComponent(\"addressManager\", new _address_manager_index_js__WEBPACK_IMPORTED_MODULE_15__.DefaultAddressManager(this.components, init.addresses));\n        // Peer routers\n        const peerRouters = (init.peerRouters ?? []).map((fn, index)=>this.configureComponent(`peer-router-${index}`, fn(this.components)));\n        this.peerRouting = this.components.peerRouting = this.configureComponent(\"peerRouting\", new _peer_routing_js__WEBPACK_IMPORTED_MODULE_16__.DefaultPeerRouting(this.components, {\n            routers: peerRouters\n        }));\n        // Content routers\n        const contentRouters = (init.contentRouters ?? []).map((fn, index)=>this.configureComponent(`content-router-${index}`, fn(this.components)));\n        this.contentRouting = this.components.contentRouting = this.configureComponent(\"contentRouting\", new _content_routing_js__WEBPACK_IMPORTED_MODULE_17__.CompoundContentRouting(this.components, {\n            routers: contentRouters\n        }));\n        (init.peerDiscovery ?? []).forEach((fn, index)=>{\n            const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));\n            service.addEventListener(\"peer\", (evt)=>{\n                this.#onDiscoveryPeer(evt);\n            });\n        });\n        // Transport modules\n        init.transports?.forEach((fn, index)=>{\n            this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));\n        });\n        // User defined modules\n        if (init.services != null) {\n            for (const name of Object.keys(init.services)){\n                const createService = init.services[name];\n                const service = createService(this.components);\n                if (service == null) {\n                    this.log.error(\"service factory %s returned null or undefined instance\", name);\n                    continue;\n                }\n                this.services[name] = service;\n                this.configureComponent(name, service);\n                if (service[_libp2p_interface__WEBPACK_IMPORTED_MODULE_18__.contentRoutingSymbol] != null) {\n                    this.log(\"registering service %s for content routing\", name);\n                    contentRouters.push(service[_libp2p_interface__WEBPACK_IMPORTED_MODULE_18__.contentRoutingSymbol]);\n                }\n                if (service[_libp2p_interface__WEBPACK_IMPORTED_MODULE_19__.peerRoutingSymbol] != null) {\n                    this.log(\"registering service %s for peer routing\", name);\n                    peerRouters.push(service[_libp2p_interface__WEBPACK_IMPORTED_MODULE_19__.peerRoutingSymbol]);\n                }\n                if (service[_libp2p_interface__WEBPACK_IMPORTED_MODULE_20__.peerDiscoverySymbol] != null) {\n                    this.log(\"registering service %s for peer discovery\", name);\n                    service[_libp2p_interface__WEBPACK_IMPORTED_MODULE_20__.peerDiscoverySymbol].addEventListener?.(\"peer\", (evt)=>{\n                        this.#onDiscoveryPeer(evt);\n                    });\n                }\n            }\n        }\n    }\n    configureComponent(name, component) {\n        if (component == null) {\n            this.log.error(\"component %s was null or undefined\", name);\n        }\n        this.components[name] = component;\n        return component;\n    }\n    /**\n     * Starts the libp2p node and all its subsystems\n     */ async start() {\n        if (this.status !== \"stopped\") {\n            return;\n        }\n        this.status = \"starting\";\n        this.log(\"libp2p is starting\");\n        try {\n            await this.components.beforeStart?.();\n            await this.components.start();\n            await this.components.afterStart?.();\n            this.status = \"started\";\n            this.safeDispatchEvent(\"start\", {\n                detail: this\n            });\n            this.log(\"libp2p has started\");\n        } catch (err) {\n            this.log.error(\"An error occurred starting libp2p\", err);\n            // set status to 'started' so this.stop() will stop any running components\n            this.status = \"started\";\n            await this.stop();\n            throw err;\n        }\n    }\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     */ async stop() {\n        if (this.status !== \"started\") {\n            return;\n        }\n        this.log(\"libp2p is stopping\");\n        this.status = \"stopping\";\n        await this.components.beforeStop?.();\n        await this.components.stop();\n        await this.components.afterStop?.();\n        this.status = \"stopped\";\n        this.safeDispatchEvent(\"stop\", {\n            detail: this\n        });\n        this.log(\"libp2p has stopped\");\n    }\n    getConnections(peerId) {\n        return this.components.connectionManager.getConnections(peerId);\n    }\n    getDialQueue() {\n        return this.components.connectionManager.getDialQueue();\n    }\n    getPeers() {\n        const peerSet = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_21__.PeerSet();\n        for (const conn of this.components.connectionManager.getConnections()){\n            peerSet.add(conn.remotePeer);\n        }\n        return Array.from(peerSet);\n    }\n    async dial(peer, options = {}) {\n        return this.components.connectionManager.openConnection(peer, {\n            // ensure any userland dials take top priority in the queue\n            priority: 75,\n            ...options\n        });\n    }\n    async dialProtocol(peer, protocols, options = {}) {\n        if (protocols == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_22__.CodeError(\"no protocols were provided to open a stream\", _errors_js__WEBPACK_IMPORTED_MODULE_23__.codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n        }\n        protocols = Array.isArray(protocols) ? protocols : [\n            protocols\n        ];\n        if (protocols.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_22__.CodeError(\"no protocols were provided to open a stream\", _errors_js__WEBPACK_IMPORTED_MODULE_23__.codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n        }\n        const connection = await this.dial(peer, options);\n        return connection.newStream(protocols, options);\n    }\n    getMultiaddrs() {\n        return this.components.addressManager.getAddresses();\n    }\n    getProtocols() {\n        return this.components.registrar.getProtocols();\n    }\n    async hangUp(peer, options = {}) {\n        if ((0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.isMultiaddr)(peer)) {\n            peer = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_24__.peerIdFromString)(peer.getPeerId() ?? \"\");\n        }\n        await this.components.connectionManager.closeConnections(peer, options);\n    }\n    /**\n     * Get the public key for the given peer id\n     */ async getPublicKey(peer, options = {}) {\n        this.log(\"getPublicKey %p\", peer);\n        if (peer.publicKey != null) {\n            return peer.publicKey;\n        }\n        try {\n            const peerInfo = await this.peerStore.get(peer);\n            if (peerInfo.id.publicKey != null) {\n                return peerInfo.id.publicKey;\n            }\n        } catch (err) {\n            if (err.code !== _errors_js__WEBPACK_IMPORTED_MODULE_23__.codes.ERR_NOT_FOUND) {\n                throw err;\n            }\n        }\n        const peerKey = (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)(\"/pk/\"),\n            peer.multihash.digest\n        ]);\n        // search any available content routing methods\n        const bytes = await this.contentRouting.get(peerKey, options);\n        // ensure the returned key is valid\n        (0,_libp2p_crypto_keys__WEBPACK_IMPORTED_MODULE_25__.unmarshalPublicKey)(bytes);\n        await this.peerStore.patch(peer, {\n            publicKey: bytes\n        });\n        return bytes;\n    }\n    async handle(protocols, handler, options) {\n        if (!Array.isArray(protocols)) {\n            protocols = [\n                protocols\n            ];\n        }\n        await Promise.all(protocols.map(async (protocol)=>{\n            await this.components.registrar.handle(protocol, handler, options);\n        }));\n    }\n    async unhandle(protocols) {\n        if (!Array.isArray(protocols)) {\n            protocols = [\n                protocols\n            ];\n        }\n        await Promise.all(protocols.map(async (protocol)=>{\n            await this.components.registrar.unhandle(protocol);\n        }));\n    }\n    async register(protocol, topology) {\n        return this.components.registrar.register(protocol, topology);\n    }\n    unregister(id) {\n        this.components.registrar.unregister(id);\n    }\n    async isDialable(multiaddr, options = {}) {\n        return this.components.connectionManager.isDialable(multiaddr, options);\n    }\n    /**\n     * Called whenever peer discovery services emit `peer` events and adds peers\n     * to the peer store.\n     */ #onDiscoveryPeer(evt) {\n        const { detail: peer } = evt;\n        if (peer.id.toString() === this.peerId.toString()) {\n            this.log.error(new Error(_errors_js__WEBPACK_IMPORTED_MODULE_23__.codes.ERR_DISCOVERED_SELF));\n            return;\n        }\n        void this.components.peerStore.merge(peer.id, {\n            multiaddrs: peer.multiaddrs\n        }).catch((err)=>{\n            this.log.error(err);\n        });\n    }\n}\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */ async function createLibp2pNode(options = {}) {\n    const peerId = options.peerId ??= await (0,_libp2p_peer_id_factory__WEBPACK_IMPORTED_MODULE_26__.createEd25519PeerId)();\n    if (peerId.privateKey == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_22__.CodeError(\"peer id was missing private key\", \"ERR_MISSING_PRIVATE_KEY\");\n    }\n    options.privateKey ??= await (0,_libp2p_crypto_keys__WEBPACK_IMPORTED_MODULE_25__.unmarshalPrivateKey)(peerId.privateKey);\n    return new Libp2pNode(await (0,_config_js__WEBPACK_IMPORTED_MODULE_27__.validateConfig)(options));\n} //# sourceMappingURL=libp2p.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL2xpYnAycC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEU7QUFDK0U7QUFDOUc7QUFDSTtBQUNBO0FBQ1c7QUFDTDtBQUNIO0FBQ0U7QUFDUTtBQUNhO0FBQ1Y7QUFDZjtBQUNXO0FBQ2xCO0FBQzRCO0FBQ1g7QUFDMUI7QUFDbUI7QUFDTDtBQUNlO0FBQ2pCO0FBQ1o7QUFDN0IsTUFBTWdDLG1CQUFtQjVCLGdFQUFpQkE7SUFXN0M2QixZQUFZQyxJQUFJLENBQUU7UUFDZCxLQUFLO1FBQ0wsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxvRkFBb0Y7UUFDcEYsb0NBQW9DO1FBQ3BDLE1BQU1DLFNBQVMsSUFBSWhDLGdFQUFpQkE7UUFDcEMsTUFBTWlDLG1CQUFtQkQsT0FBT0UsYUFBYSxDQUFDQyxJQUFJLENBQUNIO1FBQ25EQSxPQUFPRSxhQUFhLEdBQUcsQ0FBQ0U7WUFDcEIsTUFBTUMsaUJBQWlCSixpQkFBaUJHO1lBQ3hDLE1BQU1FLGlCQUFpQixJQUFJLENBQUNKLGFBQWEsQ0FBQyxJQUFJakMsMERBQVdBLENBQUNtQyxJQUFJRyxJQUFJLEVBQUU7Z0JBQUVDLFFBQVFKLElBQUlJLE1BQU07WUFBQztZQUN6RixPQUFPSCxrQkFBa0JDO1FBQzdCO1FBQ0Esc0NBQXNDO1FBQ3RDcEMsa0VBQWVBLENBQUN1QyxVQUFVVDtRQUMxQixJQUFJLENBQUNVLE1BQU0sR0FBR1osS0FBS1ksTUFBTTtRQUN6QixJQUFJLENBQUNDLE1BQU0sR0FBR2IsS0FBS2EsTUFBTSxJQUFJdEMsNkRBQWFBO1FBQzFDLElBQUksQ0FBQ3VDLEdBQUcsR0FBRyxJQUFJLENBQUNELE1BQU0sQ0FBQ0UsWUFBWSxDQUFDO1FBQ3BDLDJDQUEyQztRQUMzQyxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO1FBQ2pCLE1BQU1DLGFBQWEsSUFBSSxDQUFDQSxVQUFVLEdBQUc5Qixp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QUNKO0FBQ0E7OztDQUdDLEdBQ00sZUFBZXdELGlCQUFpQjNDLFVBQVUsQ0FBQyxDQUFDO0lBQy9DLE1BQU12RSxTQUFTdUUsUUFBUXZFLE1BQU0sS0FBSyxNQUFNbEMsNkVBQW1CQTtJQUMzRCxJQUFJa0MsT0FBT00sVUFBVSxJQUFJLE1BQU07UUFDM0IsTUFBTSxJQUFJakQseURBQVNBLENBQUMsbUNBQW1DO0lBQzNEO0lBQ0FrSCxRQUFRakUsVUFBVSxLQUFLLE1BQU1wRCx5RUFBbUJBLENBQUM4QyxPQUFPTSxVQUFVO0lBQ2xFLE9BQU8sSUFBSXBCLFdBQVcsTUFBTVQsMkRBQWNBLENBQUM4RjtBQUMvQyxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy9saWJwMnAuanM/ZDMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bm1hcnNoYWxQcml2YXRlS2V5LCB1bm1hcnNoYWxQdWJsaWNLZXkgfSBmcm9tICdAbGlicDJwL2NyeXB0by9rZXlzJztcbmltcG9ydCB7IGNvbnRlbnRSb3V0aW5nU3ltYm9sLCBDb2RlRXJyb3IsIFR5cGVkRXZlbnRFbWl0dGVyLCBDdXN0b21FdmVudCwgc2V0TWF4TGlzdGVuZXJzLCBwZWVyRGlzY292ZXJ5U3ltYm9sLCBwZWVyUm91dGluZ1N5bWJvbCB9IGZyb20gJ0BsaWJwMnAvaW50ZXJmYWNlJztcbmltcG9ydCB7IGRlZmF1bHRMb2dnZXIgfSBmcm9tICdAbGlicDJwL2xvZ2dlcic7XG5pbXBvcnQgeyBQZWVyU2V0IH0gZnJvbSAnQGxpYnAycC9wZWVyLWNvbGxlY3Rpb25zJztcbmltcG9ydCB7IHBlZXJJZEZyb21TdHJpbmcgfSBmcm9tICdAbGlicDJwL3BlZXItaWQnO1xuaW1wb3J0IHsgY3JlYXRlRWQyNTUxOVBlZXJJZCB9IGZyb20gJ0BsaWJwMnAvcGVlci1pZC1mYWN0b3J5JztcbmltcG9ydCB7IFBlcnNpc3RlbnRQZWVyU3RvcmUgfSBmcm9tICdAbGlicDJwL3BlZXItc3RvcmUnO1xuaW1wb3J0IHsgaXNNdWx0aWFkZHIgfSBmcm9tICdAbXVsdGlmb3JtYXRzL211bHRpYWRkcic7XG5pbXBvcnQgeyBNZW1vcnlEYXRhc3RvcmUgfSBmcm9tICdkYXRhc3RvcmUtY29yZS9tZW1vcnknO1xuaW1wb3J0IHsgY29uY2F0IGFzIHVpbnQ4QXJyYXlDb25jYXQgfSBmcm9tICd1aW50OGFycmF5cy9jb25jYXQnO1xuaW1wb3J0IHsgZnJvbVN0cmluZyBhcyB1aW50OEFycmF5RnJvbVN0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJztcbmltcG9ydCB7IERlZmF1bHRBZGRyZXNzTWFuYWdlciB9IGZyb20gJy4vYWRkcmVzcy1tYW5hZ2VyL2luZGV4LmpzJztcbmltcG9ydCB7IGRlZmF1bHRDb21wb25lbnRzIH0gZnJvbSAnLi9jb21wb25lbnRzLmpzJztcbmltcG9ydCB7IGNvbm5lY3Rpb25HYXRlciB9IGZyb20gJy4vY29uZmlnL2Nvbm5lY3Rpb24tZ2F0ZXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVDb25maWcgfSBmcm9tICcuL2NvbmZpZy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0Q29ubmVjdGlvbk1hbmFnZXIgfSBmcm9tICcuL2Nvbm5lY3Rpb24tbWFuYWdlci9pbmRleC5qcyc7XG5pbXBvcnQgeyBDb21wb3VuZENvbnRlbnRSb3V0aW5nIH0gZnJvbSAnLi9jb250ZW50LXJvdXRpbmcuanMnO1xuaW1wb3J0IHsgY29kZXMgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0UGVlclJvdXRpbmcgfSBmcm9tICcuL3BlZXItcm91dGluZy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0UmVnaXN0cmFyIH0gZnJvbSAnLi9yZWdpc3RyYXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFRyYW5zcG9ydE1hbmFnZXIgfSBmcm9tICcuL3RyYW5zcG9ydC1tYW5hZ2VyLmpzJztcbmltcG9ydCB7IERlZmF1bHRVcGdyYWRlciB9IGZyb20gJy4vdXBncmFkZXIuanMnO1xuaW1wb3J0ICogYXMgcGtnIGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgY2xhc3MgTGlicDJwTm9kZSBleHRlbmRzIFR5cGVkRXZlbnRFbWl0dGVyIHtcbiAgICBwZWVySWQ7XG4gICAgcGVlclN0b3JlO1xuICAgIGNvbnRlbnRSb3V0aW5nO1xuICAgIHBlZXJSb3V0aW5nO1xuICAgIG1ldHJpY3M7XG4gICAgc2VydmljZXM7XG4gICAgbG9nZ2VyO1xuICAgIHN0YXR1cztcbiAgICBjb21wb25lbnRzO1xuICAgIGxvZztcbiAgICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ3N0b3BwZWQnO1xuICAgICAgICAvLyBldmVudCBidXMgLSBjb21wb25lbnRzIGNhbiBsaXN0ZW4gdG8gdGhpcyBlbWl0dGVyIHRvIGJlIG5vdGlmaWVkIG9mIHN5c3RlbSBldmVudHNcbiAgICAgICAgLy8gYW5kIGFsc28gY2F1c2UgdGhlbSB0byBiZSBlbWl0dGVkXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBUeXBlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gZXZlbnRzLmRpc3BhdGNoRXZlbnQuYmluZChldmVudHMpO1xuICAgICAgICBldmVudHMuZGlzcGF0Y2hFdmVudCA9IChldnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsUmVzdWx0ID0gb3JpZ2luYWxEaXNwYXRjaChldnQpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxSZXN1bHQgPSB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2dC50eXBlLCB7IGRldGFpbDogZXZ0LmRldGFpbCB9KSk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxSZXN1bHQgfHwgZXh0ZXJuYWxSZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgZW1pdHRlciBnZXRzIGxpc3RlbmVkIHRvIGEgbG90XG4gICAgICAgIHNldE1heExpc3RlbmVycyhJbmZpbml0eSwgZXZlbnRzKTtcbiAgICAgICAgdGhpcy5wZWVySWQgPSBpbml0LnBlZXJJZDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBpbml0LmxvZ2dlciA/PyBkZWZhdWx0TG9nZ2VyKCk7XG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5sb2dnZXIuZm9yQ29tcG9uZW50KCdsaWJwMnAnKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB7fSBtYXkgbm90IGJlIG9mIHR5cGUgVFxuICAgICAgICB0aGlzLnNlcnZpY2VzID0ge307XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMgPSBkZWZhdWx0Q29tcG9uZW50cyh7XG4gICAgICAgICAgICBwZWVySWQ6IGluaXQucGVlcklkLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogaW5pdC5wcml2YXRlS2V5LFxuICAgICAgICAgICAgbm9kZUluZm86IGluaXQubm9kZUluZm8gPz8ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBrZy5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBrZy52ZXJzaW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgIGRhdGFzdG9yZTogaW5pdC5kYXRhc3RvcmUgPz8gbmV3IE1lbW9yeURhdGFzdG9yZSgpLFxuICAgICAgICAgICAgY29ubmVjdGlvbkdhdGVyOiBjb25uZWN0aW9uR2F0ZXIoaW5pdC5jb25uZWN0aW9uR2F0ZXIpLFxuICAgICAgICAgICAgZG5zOiBpbml0LmRuc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZWVyU3RvcmUgPSB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudCgncGVlclN0b3JlJywgbmV3IFBlcnNpc3RlbnRQZWVyU3RvcmUoY29tcG9uZW50cywge1xuICAgICAgICAgICAgYWRkcmVzc0ZpbHRlcjogdGhpcy5jb21wb25lbnRzLmNvbm5lY3Rpb25HYXRlci5maWx0ZXJNdWx0aWFkZHJGb3JQZWVyLFxuICAgICAgICAgICAgLi4uaW5pdC5wZWVyU3RvcmVcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBDcmVhdGUgTWV0cmljc1xuICAgICAgICBpZiAoaW5pdC5tZXRyaWNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWV0cmljcyA9IHRoaXMuY29uZmlndXJlQ29tcG9uZW50KCdtZXRyaWNzJywgaW5pdC5tZXRyaWNzKHRoaXMuY29tcG9uZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudHMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoJ3BlZXI6dXBkYXRlJywgZXZ0ID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBwZWVyIHByZXZpb3VzbHkgaW4gdGhlIHBlZXIgc3RvcmUgdGhpcyBpcyBhIG5ldyBwZWVyXG4gICAgICAgICAgICBpZiAoZXZ0LmRldGFpbC5wcmV2aW91cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVlckluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBldnQuZGV0YWlsLnBlZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpYWRkcnM6IGV2dC5kZXRhaWwucGVlci5hZGRyZXNzZXMubWFwKGEgPT4gYS5tdWx0aWFkZHIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLmV2ZW50cy5zYWZlRGlzcGF0Y2hFdmVudCgncGVlcjpkaXNjb3ZlcnknLCB7IGRldGFpbDogcGVlckluZm8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgdXAgY29ubmVjdGlvbiBwcm90ZWN0b3IgaWYgY29uZmlndXJlZFxuICAgICAgICBpZiAoaW5pdC5jb25uZWN0aW9uUHJvdGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlQ29tcG9uZW50KCdjb25uZWN0aW9uUHJvdGVjdG9yJywgaW5pdC5jb25uZWN0aW9uUHJvdGVjdG9yKGNvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFVwZ3JhZGVyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy51cGdyYWRlciA9IG5ldyBEZWZhdWx0VXBncmFkZXIodGhpcy5jb21wb25lbnRzLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uRW5jcnlwdGlvbjogKGluaXQuY29ubmVjdGlvbkVuY3J5cHRpb24gPz8gW10pLm1hcCgoZm4sIGluZGV4KSA9PiB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudChgY29ubmVjdGlvbi1lbmNyeXB0aW9uLSR7aW5kZXh9YCwgZm4odGhpcy5jb21wb25lbnRzKSkpLFxuICAgICAgICAgICAgbXV4ZXJzOiAoaW5pdC5zdHJlYW1NdXhlcnMgPz8gW10pLm1hcCgoZm4sIGluZGV4KSA9PiB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudChgc3RyZWFtLW11eGVycy0ke2luZGV4fWAsIGZuKHRoaXMuY29tcG9uZW50cykpKSxcbiAgICAgICAgICAgIGluYm91bmRVcGdyYWRlVGltZW91dDogaW5pdC5jb25uZWN0aW9uTWFuYWdlci5pbmJvdW5kVXBncmFkZVRpbWVvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldHVwIHRoZSB0cmFuc3BvcnQgbWFuYWdlclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudCgndHJhbnNwb3J0TWFuYWdlcicsIG5ldyBEZWZhdWx0VHJhbnNwb3J0TWFuYWdlcih0aGlzLmNvbXBvbmVudHMsIGluaXQudHJhbnNwb3J0TWFuYWdlcikpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIENvbm5lY3Rpb24gTWFuYWdlclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudCgnY29ubmVjdGlvbk1hbmFnZXInLCBuZXcgRGVmYXVsdENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMuY29tcG9uZW50cywgaW5pdC5jb25uZWN0aW9uTWFuYWdlcikpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIFJlZ2lzdHJhclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudCgncmVnaXN0cmFyJywgbmV3IERlZmF1bHRSZWdpc3RyYXIodGhpcy5jb21wb25lbnRzKSk7XG4gICAgICAgIC8vIEFkZHJlc3NlcyB7bGlzdGVuLCBhbm5vdW5jZSwgbm9Bbm5vdW5jZX1cbiAgICAgICAgdGhpcy5jb25maWd1cmVDb21wb25lbnQoJ2FkZHJlc3NNYW5hZ2VyJywgbmV3IERlZmF1bHRBZGRyZXNzTWFuYWdlcih0aGlzLmNvbXBvbmVudHMsIGluaXQuYWRkcmVzc2VzKSk7XG4gICAgICAgIC8vIFBlZXIgcm91dGVyc1xuICAgICAgICBjb25zdCBwZWVyUm91dGVycyA9IChpbml0LnBlZXJSb3V0ZXJzID8/IFtdKS5tYXAoKGZuLCBpbmRleCkgPT4gdGhpcy5jb25maWd1cmVDb21wb25lbnQoYHBlZXItcm91dGVyLSR7aW5kZXh9YCwgZm4odGhpcy5jb21wb25lbnRzKSkpO1xuICAgICAgICB0aGlzLnBlZXJSb3V0aW5nID0gdGhpcy5jb21wb25lbnRzLnBlZXJSb3V0aW5nID0gdGhpcy5jb25maWd1cmVDb21wb25lbnQoJ3BlZXJSb3V0aW5nJywgbmV3IERlZmF1bHRQZWVyUm91dGluZyh0aGlzLmNvbXBvbmVudHMsIHtcbiAgICAgICAgICAgIHJvdXRlcnM6IHBlZXJSb3V0ZXJzXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gQ29udGVudCByb3V0ZXJzXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSb3V0ZXJzID0gKGluaXQuY29udGVudFJvdXRlcnMgPz8gW10pLm1hcCgoZm4sIGluZGV4KSA9PiB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudChgY29udGVudC1yb3V0ZXItJHtpbmRleH1gLCBmbih0aGlzLmNvbXBvbmVudHMpKSk7XG4gICAgICAgIHRoaXMuY29udGVudFJvdXRpbmcgPSB0aGlzLmNvbXBvbmVudHMuY29udGVudFJvdXRpbmcgPSB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudCgnY29udGVudFJvdXRpbmcnLCBuZXcgQ29tcG91bmRDb250ZW50Um91dGluZyh0aGlzLmNvbXBvbmVudHMsIHtcbiAgICAgICAgICAgIHJvdXRlcnM6IGNvbnRlbnRSb3V0ZXJzXG4gICAgICAgIH0pKTtcbiAgICAgICAgKGluaXQucGVlckRpc2NvdmVyeSA/PyBbXSkuZm9yRWFjaCgoZm4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5jb25maWd1cmVDb21wb25lbnQoYHBlZXItZGlzY292ZXJ5LSR7aW5kZXh9YCwgZm4odGhpcy5jb21wb25lbnRzKSk7XG4gICAgICAgICAgICBzZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BlZXInLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jb25EaXNjb3ZlcnlQZWVyKGV2dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyYW5zcG9ydCBtb2R1bGVzXG4gICAgICAgIGluaXQudHJhbnNwb3J0cz8uZm9yRWFjaCgoZm4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMudHJhbnNwb3J0TWFuYWdlci5hZGQodGhpcy5jb25maWd1cmVDb21wb25lbnQoYHRyYW5zcG9ydC0ke2luZGV4fWAsIGZuKHRoaXMuY29tcG9uZW50cykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVzZXIgZGVmaW5lZCBtb2R1bGVzXG4gICAgICAgIGlmIChpbml0LnNlcnZpY2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpbml0LnNlcnZpY2VzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVNlcnZpY2UgPSBpbml0LnNlcnZpY2VzW25hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBjcmVhdGVTZXJ2aWNlKHRoaXMuY29tcG9uZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignc2VydmljZSBmYWN0b3J5ICVzIHJldHVybmVkIG51bGwgb3IgdW5kZWZpbmVkIGluc3RhbmNlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VzW25hbWVdID0gc2VydmljZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUNvbXBvbmVudChuYW1lLCBzZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZVtjb250ZW50Um91dGluZ1N5bWJvbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygncmVnaXN0ZXJpbmcgc2VydmljZSAlcyBmb3IgY29udGVudCByb3V0aW5nJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb3V0ZXJzLnB1c2goc2VydmljZVtjb250ZW50Um91dGluZ1N5bWJvbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZVtwZWVyUm91dGluZ1N5bWJvbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygncmVnaXN0ZXJpbmcgc2VydmljZSAlcyBmb3IgcGVlciByb3V0aW5nJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJSb3V0ZXJzLnB1c2goc2VydmljZVtwZWVyUm91dGluZ1N5bWJvbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZVtwZWVyRGlzY292ZXJ5U3ltYm9sXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdyZWdpc3RlcmluZyBzZXJ2aWNlICVzIGZvciBwZWVyIGRpc2NvdmVyeScsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlW3BlZXJEaXNjb3ZlcnlTeW1ib2xdLmFkZEV2ZW50TGlzdGVuZXI/LigncGVlcicsIChldnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI29uRGlzY292ZXJ5UGVlcihldnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlndXJlQ29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdjb21wb25lbnQgJXMgd2FzIG51bGwgb3IgdW5kZWZpbmVkJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGxpYnAycCBub2RlIGFuZCBhbGwgaXRzIHN1YnN5c3RlbXNcbiAgICAgKi9cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9ICdzdGFydGluZyc7XG4gICAgICAgIHRoaXMubG9nKCdsaWJwMnAgaXMgc3RhcnRpbmcnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcG9uZW50cy5iZWZvcmVTdGFydD8uKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBvbmVudHMuc3RhcnQoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcG9uZW50cy5hZnRlclN0YXJ0Py4oKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gJ3N0YXJ0ZWQnO1xuICAgICAgICAgICAgdGhpcy5zYWZlRGlzcGF0Y2hFdmVudCgnc3RhcnQnLCB7IGRldGFpbDogdGhpcyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nKCdsaWJwMnAgaGFzIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgc3RhcnRpbmcgbGlicDJwJywgZXJyKTtcbiAgICAgICAgICAgIC8vIHNldCBzdGF0dXMgdG8gJ3N0YXJ0ZWQnIHNvIHRoaXMuc3RvcCgpIHdpbGwgc3RvcCBhbnkgcnVubmluZyBjb21wb25lbnRzXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9ICdzdGFydGVkJztcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGxpYnAycCBub2RlIGJ5IGNsb3NpbmcgaXRzIGxpc3RlbmVycyBhbmQgb3BlbiBjb25uZWN0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gJ3N0YXJ0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coJ2xpYnAycCBpcyBzdG9wcGluZycpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdzdG9wcGluZyc7XG4gICAgICAgIGF3YWl0IHRoaXMuY29tcG9uZW50cy5iZWZvcmVTdG9wPy4oKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb21wb25lbnRzLnN0b3AoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb21wb25lbnRzLmFmdGVyU3RvcD8uKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ3N0b3BwZWQnO1xuICAgICAgICB0aGlzLnNhZmVEaXNwYXRjaEV2ZW50KCdzdG9wJywgeyBkZXRhaWw6IHRoaXMgfSk7XG4gICAgICAgIHRoaXMubG9nKCdsaWJwMnAgaGFzIHN0b3BwZWQnKTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGlvbnMocGVlcklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbnMocGVlcklkKTtcbiAgICB9XG4gICAgZ2V0RGlhbFF1ZXVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldERpYWxRdWV1ZSgpO1xuICAgIH1cbiAgICBnZXRQZWVycygpIHtcbiAgICAgICAgY29uc3QgcGVlclNldCA9IG5ldyBQZWVyU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgY29ubiBvZiB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbnMoKSkge1xuICAgICAgICAgICAgcGVlclNldC5hZGQoY29ubi5yZW1vdGVQZWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwZWVyU2V0KTtcbiAgICB9XG4gICAgYXN5bmMgZGlhbChwZWVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5jb25uZWN0aW9uTWFuYWdlci5vcGVuQ29ubmVjdGlvbihwZWVyLCB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgYW55IHVzZXJsYW5kIGRpYWxzIHRha2UgdG9wIHByaW9yaXR5IGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcHJpb3JpdHk6IDc1LFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZGlhbFByb3RvY29sKHBlZXIsIHByb3RvY29scywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChwcm90b2NvbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignbm8gcHJvdG9jb2xzIHdlcmUgcHJvdmlkZWQgdG8gb3BlbiBhIHN0cmVhbScsIGNvZGVzLkVSUl9JTlZBTElEX1BST1RPQ09MU19GT1JfU1RSRUFNKTtcbiAgICAgICAgfVxuICAgICAgICBwcm90b2NvbHMgPSBBcnJheS5pc0FycmF5KHByb3RvY29scykgPyBwcm90b2NvbHMgOiBbcHJvdG9jb2xzXTtcbiAgICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ25vIHByb3RvY29scyB3ZXJlIHByb3ZpZGVkIHRvIG9wZW4gYSBzdHJlYW0nLCBjb2Rlcy5FUlJfSU5WQUxJRF9QUk9UT0NPTFNfRk9SX1NUUkVBTSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZGlhbChwZWVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ubmV3U3RyZWFtKHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGdldE11bHRpYWRkcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuYWRkcmVzc01hbmFnZXIuZ2V0QWRkcmVzc2VzKCk7XG4gICAgfVxuICAgIGdldFByb3RvY29scygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5yZWdpc3RyYXIuZ2V0UHJvdG9jb2xzKCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmdVcChwZWVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGlzTXVsdGlhZGRyKHBlZXIpKSB7XG4gICAgICAgICAgICBwZWVyID0gcGVlcklkRnJvbVN0cmluZyhwZWVyLmdldFBlZXJJZCgpID8/ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbk1hbmFnZXIuY2xvc2VDb25uZWN0aW9ucyhwZWVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMga2V5IGZvciB0aGUgZ2l2ZW4gcGVlciBpZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFB1YmxpY0tleShwZWVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5sb2coJ2dldFB1YmxpY0tleSAlcCcsIHBlZXIpO1xuICAgICAgICBpZiAocGVlci5wdWJsaWNLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBlZXIucHVibGljS2V5O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwZWVySW5mbyA9IGF3YWl0IHRoaXMucGVlclN0b3JlLmdldChwZWVyKTtcbiAgICAgICAgICAgIGlmIChwZWVySW5mby5pZC5wdWJsaWNLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZWVySW5mby5pZC5wdWJsaWNLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSBjb2Rlcy5FUlJfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlZXJLZXkgPSB1aW50OEFycmF5Q29uY2F0KFtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKCcvcGsvJyksXG4gICAgICAgICAgICBwZWVyLm11bHRpaGFzaC5kaWdlc3RcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIHNlYXJjaCBhbnkgYXZhaWxhYmxlIGNvbnRlbnQgcm91dGluZyBtZXRob2RzXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5jb250ZW50Um91dGluZy5nZXQocGVlcktleSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcmV0dXJuZWQga2V5IGlzIHZhbGlkXG4gICAgICAgIHVubWFyc2hhbFB1YmxpY0tleShieXRlcyk7XG4gICAgICAgIGF3YWl0IHRoaXMucGVlclN0b3JlLnBhdGNoKHBlZXIsIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogYnl0ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlKHByb3RvY29scywgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvdG9jb2xzLm1hcChhc3luYyAocHJvdG9jb2wpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcG9uZW50cy5yZWdpc3RyYXIuaGFuZGxlKHByb3RvY29sLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyB1bmhhbmRsZShwcm90b2NvbHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb3RvY29scy5tYXAoYXN5bmMgKHByb3RvY29sKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBvbmVudHMucmVnaXN0cmFyLnVuaGFuZGxlKHByb3RvY29sKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyByZWdpc3Rlcihwcm90b2NvbCwgdG9wb2xvZ3kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5yZWdpc3RyYXIucmVnaXN0ZXIocHJvdG9jb2wsIHRvcG9sb2d5KTtcbiAgICB9XG4gICAgdW5yZWdpc3RlcihpZCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucmVnaXN0cmFyLnVucmVnaXN0ZXIoaWQpO1xuICAgIH1cbiAgICBhc3luYyBpc0RpYWxhYmxlKG11bHRpYWRkciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbk1hbmFnZXIuaXNEaWFsYWJsZShtdWx0aWFkZHIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgcGVlciBkaXNjb3Zlcnkgc2VydmljZXMgZW1pdCBgcGVlcmAgZXZlbnRzIGFuZCBhZGRzIHBlZXJzXG4gICAgICogdG8gdGhlIHBlZXIgc3RvcmUuXG4gICAgICovXG4gICAgI29uRGlzY292ZXJ5UGVlcihldnQpIHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWw6IHBlZXIgfSA9IGV2dDtcbiAgICAgICAgaWYgKHBlZXIuaWQudG9TdHJpbmcoKSA9PT0gdGhpcy5wZWVySWQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IobmV3IEVycm9yKGNvZGVzLkVSUl9ESVNDT1ZFUkVEX1NFTEYpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIHRoaXMuY29tcG9uZW50cy5wZWVyU3RvcmUubWVyZ2UocGVlci5pZCwge1xuICAgICAgICAgICAgbXVsdGlhZGRyczogcGVlci5tdWx0aWFkZHJzXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHsgdGhpcy5sb2cuZXJyb3IoZXJyKTsgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IExpYnAycE5vZGUgaW5zdGFuY2UgLSB0aGlzIGV4cG9zZXMgbW9yZSBvZiB0aGUgaW50ZXJuYWxzIHRoYW4gdGhlXG4gKiBsaWJwMnAgaW50ZXJmYWNlIGFuZCBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgYW5kIGRlYnVnZ2luZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxpYnAycE5vZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGVlcklkID0gb3B0aW9ucy5wZWVySWQgPz89IGF3YWl0IGNyZWF0ZUVkMjU1MTlQZWVySWQoKTtcbiAgICBpZiAocGVlcklkLnByaXZhdGVLZXkgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdwZWVyIGlkIHdhcyBtaXNzaW5nIHByaXZhdGUga2V5JywgJ0VSUl9NSVNTSU5HX1BSSVZBVEVfS0VZJyk7XG4gICAgfVxuICAgIG9wdGlvbnMucHJpdmF0ZUtleSA/Pz0gYXdhaXQgdW5tYXJzaGFsUHJpdmF0ZUtleShwZWVySWQucHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIG5ldyBMaWJwMnBOb2RlKGF3YWl0IHZhbGlkYXRlQ29uZmlnKG9wdGlvbnMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpYnAycC5qcy5tYXAiXSwibmFtZXMiOlsidW5tYXJzaGFsUHJpdmF0ZUtleSIsInVubWFyc2hhbFB1YmxpY0tleSIsImNvbnRlbnRSb3V0aW5nU3ltYm9sIiwiQ29kZUVycm9yIiwiVHlwZWRFdmVudEVtaXR0ZXIiLCJDdXN0b21FdmVudCIsInNldE1heExpc3RlbmVycyIsInBlZXJEaXNjb3ZlcnlTeW1ib2wiLCJwZWVyUm91dGluZ1N5bWJvbCIsImRlZmF1bHRMb2dnZXIiLCJQZWVyU2V0IiwicGVlcklkRnJvbVN0cmluZyIsImNyZWF0ZUVkMjU1MTlQZWVySWQiLCJQZXJzaXN0ZW50UGVlclN0b3JlIiwiaXNNdWx0aWFkZHIiLCJNZW1vcnlEYXRhc3RvcmUiLCJjb25jYXQiLCJ1aW50OEFycmF5Q29uY2F0IiwiZnJvbVN0cmluZyIsInVpbnQ4QXJyYXlGcm9tU3RyaW5nIiwiRGVmYXVsdEFkZHJlc3NNYW5hZ2VyIiwiZGVmYXVsdENvbXBvbmVudHMiLCJjb25uZWN0aW9uR2F0ZXIiLCJ2YWxpZGF0ZUNvbmZpZyIsIkRlZmF1bHRDb25uZWN0aW9uTWFuYWdlciIsIkNvbXBvdW5kQ29udGVudFJvdXRpbmciLCJjb2RlcyIsIkRlZmF1bHRQZWVyUm91dGluZyIsIkRlZmF1bHRSZWdpc3RyYXIiLCJEZWZhdWx0VHJhbnNwb3J0TWFuYWdlciIsIkRlZmF1bHRVcGdyYWRlciIsInBrZyIsIkxpYnAycE5vZGUiLCJjb25zdHJ1Y3RvciIsImluaXQiLCJzdGF0dXMiLCJldmVudHMiLCJvcmlnaW5hbERpc3BhdGNoIiwiZGlzcGF0Y2hFdmVudCIsImJpbmQiLCJldnQiLCJpbnRlcm5hbFJlc3VsdCIsImV4dGVybmFsUmVzdWx0IiwidHlwZSIsImRldGFpbCIsIkluZmluaXR5IiwicGVlcklkIiwibG9nZ2VyIiwibG9nIiwiZm9yQ29tcG9uZW50Iiwic2VydmljZXMiLCJjb21wb25lbnRzIiwicHJpdmF0ZUtleSIsIm5vZGVJbmZvIiwibmFtZSIsInZlcnNpb24iLCJkYXRhc3RvcmUiLCJkbnMiLCJwZWVyU3RvcmUiLCJjb25maWd1cmVDb21wb25lbnQiLCJhZGRyZXNzRmlsdGVyIiwiZmlsdGVyTXVsdGlhZGRyRm9yUGVlciIsIm1ldHJpY3MiLCJhZGRFdmVudExpc3RlbmVyIiwicHJldmlvdXMiLCJwZWVySW5mbyIsImlkIiwicGVlciIsIm11bHRpYWRkcnMiLCJhZGRyZXNzZXMiLCJtYXAiLCJhIiwibXVsdGlhZGRyIiwic2FmZURpc3BhdGNoRXZlbnQiLCJjb25uZWN0aW9uUHJvdGVjdG9yIiwidXBncmFkZXIiLCJjb25uZWN0aW9uRW5jcnlwdGlvbiIsImZuIiwiaW5kZXgiLCJtdXhlcnMiLCJzdHJlYW1NdXhlcnMiLCJpbmJvdW5kVXBncmFkZVRpbWVvdXQiLCJjb25uZWN0aW9uTWFuYWdlciIsInRyYW5zcG9ydE1hbmFnZXIiLCJwZWVyUm91dGVycyIsInBlZXJSb3V0aW5nIiwicm91dGVycyIsImNvbnRlbnRSb3V0ZXJzIiwiY29udGVudFJvdXRpbmciLCJwZWVyRGlzY292ZXJ5IiwiZm9yRWFjaCIsInNlcnZpY2UiLCJvbkRpc2NvdmVyeVBlZXIiLCJ0cmFuc3BvcnRzIiwiYWRkIiwiT2JqZWN0Iiwia2V5cyIsImNyZWF0ZVNlcnZpY2UiLCJlcnJvciIsInB1c2giLCJjb21wb25lbnQiLCJzdGFydCIsImJlZm9yZVN0YXJ0IiwiYWZ0ZXJTdGFydCIsImVyciIsInN0b3AiLCJiZWZvcmVTdG9wIiwiYWZ0ZXJTdG9wIiwiZ2V0Q29ubmVjdGlvbnMiLCJnZXREaWFsUXVldWUiLCJnZXRQZWVycyIsInBlZXJTZXQiLCJjb25uIiwicmVtb3RlUGVlciIsIkFycmF5IiwiZnJvbSIsImRpYWwiLCJvcHRpb25zIiwib3BlbkNvbm5lY3Rpb24iLCJwcmlvcml0eSIsImRpYWxQcm90b2NvbCIsInByb3RvY29scyIsIkVSUl9JTlZBTElEX1BST1RPQ09MU19GT1JfU1RSRUFNIiwiaXNBcnJheSIsImxlbmd0aCIsImNvbm5lY3Rpb24iLCJuZXdTdHJlYW0iLCJnZXRNdWx0aWFkZHJzIiwiYWRkcmVzc01hbmFnZXIiLCJnZXRBZGRyZXNzZXMiLCJnZXRQcm90b2NvbHMiLCJyZWdpc3RyYXIiLCJoYW5nVXAiLCJnZXRQZWVySWQiLCJjbG9zZUNvbm5lY3Rpb25zIiwiZ2V0UHVibGljS2V5IiwicHVibGljS2V5IiwiZ2V0IiwiY29kZSIsIkVSUl9OT1RfRk9VTkQiLCJwZWVyS2V5IiwibXVsdGloYXNoIiwiZGlnZXN0IiwiYnl0ZXMiLCJwYXRjaCIsImhhbmRsZSIsImhhbmRsZXIiLCJQcm9taXNlIiwiYWxsIiwicHJvdG9jb2wiLCJ1bmhhbmRsZSIsInJlZ2lzdGVyIiwidG9wb2xvZ3kiLCJ1bnJlZ2lzdGVyIiwiaXNEaWFsYWJsZSIsInRvU3RyaW5nIiwiRXJyb3IiLCJFUlJfRElTQ09WRVJFRF9TRUxGIiwibWVyZ2UiLCJjYXRjaCIsImNyZWF0ZUxpYnAycE5vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/libp2p.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/peer-routing.js":
/*!******************************************************!*\
  !*** ./node_modules/libp2p/dist/src/peer-routing.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultPeerRouting: () => (/* binding */ DefaultPeerRouting)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/peer-collections */ \"(ssr)/./node_modules/@libp2p/peer-collections/dist/src/set.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-merge */ \"(ssr)/./node_modules/it-merge/dist/src/index.js\");\n/* harmony import */ var it_parallel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-parallel */ \"(ssr)/./node_modules/it-parallel/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n\n\n\n\n\nclass DefaultPeerRouting {\n    constructor(components, init = {}){\n        this.log = components.logger.forComponent(\"libp2p:peer-routing\");\n        this.peerId = components.peerId;\n        this.peerStore = components.peerStore;\n        this.routers = init.routers ?? [];\n    }\n    /**\n     * Iterates over all peer routers in parallel to find the given peer\n     */ async findPeer(id, options) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(\"No peer routers available\", _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        if (id.toString() === this.peerId.toString()) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(\"Should not try to find self\", _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_FIND_SELF);\n        }\n        const self = this;\n        const source = (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...this.routers.map((router)=>(async function*() {\n                try {\n                    yield await router.findPeer(id, options);\n                } catch (err) {\n                    self.log.error(err);\n                }\n            })()));\n        for await (const peer of source){\n            if (peer == null) {\n                continue;\n            }\n            // store the addresses for the peer if found\n            if (peer.multiaddrs.length > 0) {\n                await this.peerStore.merge(peer.id, {\n                    multiaddrs: peer.multiaddrs\n                });\n            }\n            return peer;\n        }\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(_errors_js__WEBPACK_IMPORTED_MODULE_3__.messages.NOT_FOUND, _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_NOT_FOUND);\n    }\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     */ async *getClosestPeers(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(\"No peer routers available\", _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        const self = this;\n        const seen = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_4__.PeerSet();\n        for await (const peer of (0,it_parallel__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(async function*() {\n            const source = (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...self.routers.map((router)=>router.getClosestPeers(key, options)));\n            for await (let peer of source){\n                yield async ()=>{\n                    // find multiaddrs if they are missing\n                    if (peer.multiaddrs.length === 0) {\n                        try {\n                            peer = await self.findPeer(peer.id, {\n                                ...options,\n                                useCache: false\n                            });\n                        } catch (err) {\n                            self.log.error(\"could not find peer multiaddrs\", err);\n                            return;\n                        }\n                    }\n                    return peer;\n                };\n            }\n        }())){\n            if (peer == null) {\n                continue;\n            }\n            // store the addresses for the peer if found\n            if (peer.multiaddrs.length > 0) {\n                await this.peerStore.merge(peer.id, {\n                    multiaddrs: peer.multiaddrs\n                });\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n} //# sourceMappingURL=peer-routing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL3BlZXItcm91dGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEM7QUFDSztBQUN0QjtBQUNNO0FBQ1c7QUFDdkMsTUFBTU07SUFLVEMsWUFBWUMsVUFBVSxFQUFFQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQy9CLElBQUksQ0FBQ0MsR0FBRyxHQUFHRixXQUFXRyxNQUFNLENBQUNDLFlBQVksQ0FBQztRQUMxQyxJQUFJLENBQUNDLE1BQU0sR0FBR0wsV0FBV0ssTUFBTTtRQUMvQixJQUFJLENBQUNDLFNBQVMsR0FBR04sV0FBV00sU0FBUztRQUNyQyxJQUFJLENBQUNDLE9BQU8sR0FBR04sS0FBS00sT0FBTyxJQUFJLEVBQUU7SUFDckM7SUFDQTs7S0FFQyxHQUNELE1BQU1DLFNBQVNDLEVBQUUsRUFBRUMsT0FBTyxFQUFFO1FBQ3hCLElBQUksSUFBSSxDQUFDSCxPQUFPLENBQUNJLE1BQU0sS0FBSyxHQUFHO1lBQzNCLE1BQU0sSUFBSW5CLHdEQUFTQSxDQUFDLDZCQUE2QkksNkNBQUtBLENBQUNnQix3QkFBd0I7UUFDbkY7UUFDQSxJQUFJSCxHQUFHSSxRQUFRLE9BQU8sSUFBSSxDQUFDUixNQUFNLENBQUNRLFFBQVEsSUFBSTtZQUMxQyxNQUFNLElBQUlyQix3REFBU0EsQ0FBQywrQkFBK0JJLDZDQUFLQSxDQUFDa0IsYUFBYTtRQUMxRTtRQUNBLE1BQU1DLE9BQU8sSUFBSTtRQUNqQixNQUFNQyxTQUFTdEIsb0RBQUtBLElBQUksSUFBSSxDQUFDYSxPQUFPLENBQUNVLEdBQUcsQ0FBQ0MsQ0FBQUEsU0FBVSxDQUFDO2dCQUNoRCxJQUFJO29CQUNBLE1BQU0sTUFBTUEsT0FBT1YsUUFBUSxDQUFDQyxJQUFJQztnQkFDcEMsRUFDQSxPQUFPUyxLQUFLO29CQUNSSixLQUFLYixHQUFHLENBQUNrQixLQUFLLENBQUNEO2dCQUNuQjtZQUNKO1FBQ0EsV0FBVyxNQUFNRSxRQUFRTCxPQUFRO1lBQzdCLElBQUlLLFFBQVEsTUFBTTtnQkFDZDtZQUNKO1lBQ0EsNENBQTRDO1lBQzVDLElBQUlBLEtBQUtDLFVBQVUsQ0FBQ1gsTUFBTSxHQUFHLEdBQUc7Z0JBQzVCLE1BQU0sSUFBSSxDQUFDTCxTQUFTLENBQUNaLEtBQUssQ0FBQzJCLEtBQUtaLEVBQUUsRUFBRTtvQkFDaENhLFlBQVlELEtBQUtDLFVBQVU7Z0JBQy9CO1lBQ0o7WUFDQSxPQUFPRDtRQUNYO1FBQ0EsTUFBTSxJQUFJN0Isd0RBQVNBLENBQUNLLGdEQUFRQSxDQUFDMEIsU0FBUyxFQUFFM0IsNkNBQUtBLENBQUM0QixhQUFhO0lBQy9EO0lBQ0E7O0tBRUMsR0FDRCxPQUFPQyxnQkFBZ0JDLEdBQUcsRUFBRWhCLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDdEMsSUFBSSxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksTUFBTSxLQUFLLEdBQUc7WUFDM0IsTUFBTSxJQUFJbkIsd0RBQVNBLENBQUMsNkJBQTZCSSw2Q0FBS0EsQ0FBQ2dCLHdCQUF3QjtRQUNuRjtRQUNBLE1BQU1HLE9BQU8sSUFBSTtRQUNqQixNQUFNWSxPQUFPLElBQUlsQyw2REFBT0E7UUFDeEIsV0FBVyxNQUFNNEIsUUFBUTFCLHVEQUFRQSxDQUFDO1lBQzlCLE1BQU1xQixTQUFTdEIsb0RBQUtBLElBQUlxQixLQUFLUixPQUFPLENBQUNVLEdBQUcsQ0FBQ0MsQ0FBQUEsU0FBVUEsT0FBT08sZUFBZSxDQUFDQyxLQUFLaEI7WUFDL0UsV0FBVyxJQUFJVyxRQUFRTCxPQUFRO2dCQUMzQixNQUFNO29CQUNGLHNDQUFzQztvQkFDdEMsSUFBSUssS0FBS0MsVUFBVSxDQUFDWCxNQUFNLEtBQUssR0FBRzt3QkFDOUIsSUFBSTs0QkFDQVUsT0FBTyxNQUFNTixLQUFLUCxRQUFRLENBQUNhLEtBQUtaLEVBQUUsRUFBRTtnQ0FDaEMsR0FBR0MsT0FBTztnQ0FDVmtCLFVBQVU7NEJBQ2Q7d0JBQ0osRUFDQSxPQUFPVCxLQUFLOzRCQUNSSixLQUFLYixHQUFHLENBQUNrQixLQUFLLENBQUMsa0NBQWtDRDs0QkFDakQ7d0JBQ0o7b0JBQ0o7b0JBQ0EsT0FBT0U7Z0JBQ1g7WUFDSjtRQUNKLEtBQU07WUFDRixJQUFJQSxRQUFRLE1BQU07Z0JBQ2Q7WUFDSjtZQUNBLDRDQUE0QztZQUM1QyxJQUFJQSxLQUFLQyxVQUFVLENBQUNYLE1BQU0sR0FBRyxHQUFHO2dCQUM1QixNQUFNLElBQUksQ0FBQ0wsU0FBUyxDQUFDWixLQUFLLENBQUMyQixLQUFLWixFQUFFLEVBQUU7b0JBQ2hDYSxZQUFZRCxLQUFLQyxVQUFVO2dCQUMvQjtZQUNKO1lBQ0Esb0JBQW9CO1lBQ3BCLElBQUlLLEtBQUtFLEdBQUcsQ0FBQ1IsS0FBS1osRUFBRSxHQUFHO2dCQUNuQjtZQUNKO1lBQ0FrQixLQUFLRyxHQUFHLENBQUNULEtBQUtaLEVBQUU7WUFDaEIsTUFBTVk7UUFDVjtJQUNKO0FBQ0osRUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvcGVlci1yb3V0aW5nLmpzPzI0YzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZUVycm9yIH0gZnJvbSAnQGxpYnAycC9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGVlclNldCB9IGZyb20gJ0BsaWJwMnAvcGVlci1jb2xsZWN0aW9ucyc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnaXQtbWVyZ2UnO1xuaW1wb3J0IHBhcmFsbGVsIGZyb20gJ2l0LXBhcmFsbGVsJztcbmltcG9ydCB7IGNvZGVzLCBtZXNzYWdlcyB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0UGVlclJvdXRpbmcge1xuICAgIGxvZztcbiAgICBwZWVySWQ7XG4gICAgcGVlclN0b3JlO1xuICAgIHJvdXRlcnM7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cywgaW5pdCA9IHt9KSB7XG4gICAgICAgIHRoaXMubG9nID0gY29tcG9uZW50cy5sb2dnZXIuZm9yQ29tcG9uZW50KCdsaWJwMnA6cGVlci1yb3V0aW5nJyk7XG4gICAgICAgIHRoaXMucGVlcklkID0gY29tcG9uZW50cy5wZWVySWQ7XG4gICAgICAgIHRoaXMucGVlclN0b3JlID0gY29tcG9uZW50cy5wZWVyU3RvcmU7XG4gICAgICAgIHRoaXMucm91dGVycyA9IGluaXQucm91dGVycyA/PyBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgcGVlciByb3V0ZXJzIGluIHBhcmFsbGVsIHRvIGZpbmQgdGhlIGdpdmVuIHBlZXJcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kUGVlcihpZCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignTm8gcGVlciByb3V0ZXJzIGF2YWlsYWJsZScsIGNvZGVzLkVSUl9OT19ST1VURVJTX0FWQUlMQUJMRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkLnRvU3RyaW5nKCkgPT09IHRoaXMucGVlcklkLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ1Nob3VsZCBub3QgdHJ5IHRvIGZpbmQgc2VsZicsIGNvZGVzLkVSUl9GSU5EX1NFTEYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXJnZSguLi50aGlzLnJvdXRlcnMubWFwKHJvdXRlciA9PiAoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgYXdhaXQgcm91dGVyLmZpbmRQZWVyKGlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxvZy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGVlciBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChwZWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBhZGRyZXNzZXMgZm9yIHRoZSBwZWVyIGlmIGZvdW5kXG4gICAgICAgICAgICBpZiAocGVlci5tdWx0aWFkZHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlZXJTdG9yZS5tZXJnZShwZWVyLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpYWRkcnM6IHBlZXIubXVsdGlhZGRyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBlZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihtZXNzYWdlcy5OT1RfRk9VTkQsIGNvZGVzLkVSUl9OT1RfRk9VTkQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGNsb3Nlc3QgcGVlcnMgb24gdGhlIG5ldHdvcmsgdG8gdGhlIGdpdmVuIGtleVxuICAgICAqL1xuICAgIGFzeW5jICpnZXRDbG9zZXN0UGVlcnMoa2V5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoJ05vIHBlZXIgcm91dGVycyBhdmFpbGFibGUnLCBjb2Rlcy5FUlJfTk9fUk9VVEVSU19BVkFJTEFCTEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBzZWVuID0gbmV3IFBlZXJTZXQoKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwZWVyIG9mIHBhcmFsbGVsKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXJnZSguLi5zZWxmLnJvdXRlcnMubWFwKHJvdXRlciA9PiByb3V0ZXIuZ2V0Q2xvc2VzdFBlZXJzKGtleSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAobGV0IHBlZXIgb2Ygc291cmNlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIG11bHRpYWRkcnMgaWYgdGhleSBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVlci5tdWx0aWFkZHJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVyID0gYXdhaXQgc2VsZi5maW5kUGVlcihwZWVyLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nLmVycm9yKCdjb3VsZCBub3QgZmluZCBwZWVyIG11bHRpYWRkcnMnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVlcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KCkpKSB7XG4gICAgICAgICAgICBpZiAocGVlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgYWRkcmVzc2VzIGZvciB0aGUgcGVlciBpZiBmb3VuZFxuICAgICAgICAgICAgaWYgKHBlZXIubXVsdGlhZGRycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wZWVyU3RvcmUubWVyZ2UocGVlci5pZCwge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWFkZHJzOiBwZWVyLm11bHRpYWRkcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZHVwbGljYXRlIHBlZXJzXG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMocGVlci5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uYWRkKHBlZXIuaWQpO1xuICAgICAgICAgICAgeWllbGQgcGVlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlZXItcm91dGluZy5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZUVycm9yIiwiUGVlclNldCIsIm1lcmdlIiwicGFyYWxsZWwiLCJjb2RlcyIsIm1lc3NhZ2VzIiwiRGVmYXVsdFBlZXJSb3V0aW5nIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRzIiwiaW5pdCIsImxvZyIsImxvZ2dlciIsImZvckNvbXBvbmVudCIsInBlZXJJZCIsInBlZXJTdG9yZSIsInJvdXRlcnMiLCJmaW5kUGVlciIsImlkIiwib3B0aW9ucyIsImxlbmd0aCIsIkVSUl9OT19ST1VURVJTX0FWQUlMQUJMRSIsInRvU3RyaW5nIiwiRVJSX0ZJTkRfU0VMRiIsInNlbGYiLCJzb3VyY2UiLCJtYXAiLCJyb3V0ZXIiLCJlcnIiLCJlcnJvciIsInBlZXIiLCJtdWx0aWFkZHJzIiwiTk9UX0ZPVU5EIiwiRVJSX05PVF9GT1VORCIsImdldENsb3Nlc3RQZWVycyIsImtleSIsInNlZW4iLCJ1c2VDYWNoZSIsImhhcyIsImFkZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/peer-routing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/registrar.js":
/*!***************************************************!*\
  !*** ./node_modules/libp2p/dist/src/registrar.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MAX_INBOUND_STREAMS: () => (/* binding */ DEFAULT_MAX_INBOUND_STREAMS),\n/* harmony export */   DEFAULT_MAX_OUTBOUND_STREAMS: () => (/* binding */ DEFAULT_MAX_OUTBOUND_STREAMS),\n/* harmony export */   DefaultRegistrar: () => (/* binding */ DefaultRegistrar)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! merge-options */ \"(ssr)/./node_modules/merge-options/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n\n\n\nconst DEFAULT_MAX_INBOUND_STREAMS = 32;\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * Responsible for notifying registered protocols of events in the network.\n */ class DefaultRegistrar {\n    constructor(components){\n        this.log = components.logger.forComponent(\"libp2p:registrar\");\n        this.topologies = new Map();\n        this.handlers = new Map();\n        this.components = components;\n        this._onDisconnect = this._onDisconnect.bind(this);\n        this._onPeerUpdate = this._onPeerUpdate.bind(this);\n        this._onPeerIdentify = this._onPeerIdentify.bind(this);\n        this.components.events.addEventListener(\"peer:disconnect\", this._onDisconnect);\n        this.components.events.addEventListener(\"peer:update\", this._onPeerUpdate);\n        this.components.events.addEventListener(\"peer:identify\", this._onPeerIdentify);\n    }\n    getProtocols() {\n        return Array.from(new Set([\n            ...this.handlers.keys()\n        ])).sort();\n    }\n    getHandler(protocol) {\n        const handler = this.handlers.get(protocol);\n        if (handler == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(`No handler registered for protocol ${protocol}`, _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_NO_HANDLER_FOR_PROTOCOL);\n        }\n        return handler;\n    }\n    getTopologies(protocol) {\n        const topologies = this.topologies.get(protocol);\n        if (topologies == null) {\n            return [];\n        }\n        return [\n            ...topologies.values()\n        ];\n    }\n    /**\n     * Registers the `handler` for each protocol\n     */ async handle(protocol, handler, opts) {\n        if (this.handlers.has(protocol)) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(`Handler already registered for protocol ${protocol}`, _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);\n        }\n        const options = merge_options__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bind({\n            ignoreUndefined: true\n        })({\n            maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n            maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n        }, opts);\n        this.handlers.set(protocol, {\n            handler,\n            options\n        });\n        // Add new protocol to self protocols in the peer store\n        await this.components.peerStore.merge(this.components.peerId, {\n            protocols: [\n                protocol\n            ]\n        });\n    }\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     */ async unhandle(protocols) {\n        const protocolList = Array.isArray(protocols) ? protocols : [\n            protocols\n        ];\n        protocolList.forEach((protocol)=>{\n            this.handlers.delete(protocol);\n        });\n        // Update self protocols in the peer store\n        await this.components.peerStore.patch(this.components.peerId, {\n            protocols: this.getProtocols()\n        });\n    }\n    /**\n     * Register handlers for a set of multicodecs given\n     */ async register(protocol, topology) {\n        if (topology == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.CodeError(\"invalid topology\", _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_INVALID_PARAMETERS);\n        }\n        // Create topology\n        const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;\n        let topologies = this.topologies.get(protocol);\n        if (topologies == null) {\n            topologies = new Map();\n            this.topologies.set(protocol, topologies);\n        }\n        topologies.set(id, topology);\n        return id;\n    }\n    /**\n     * Unregister topology\n     */ unregister(id) {\n        for (const [protocol, topologies] of this.topologies.entries()){\n            if (topologies.has(id)) {\n                topologies.delete(id);\n                if (topologies.size === 0) {\n                    this.topologies.delete(protocol);\n                }\n            }\n        }\n    }\n    /**\n     * Remove a disconnected peer from the record\n     */ _onDisconnect(evt) {\n        const remotePeer = evt.detail;\n        void this.components.peerStore.get(remotePeer).then((peer)=>{\n            for (const protocol of peer.protocols){\n                const topologies = this.topologies.get(protocol);\n                if (topologies == null) {\n                    continue;\n                }\n                for (const topology of topologies.values()){\n                    topology.onDisconnect?.(remotePeer);\n                }\n            }\n        }).catch((err)=>{\n            if (err.code === _errors_js__WEBPACK_IMPORTED_MODULE_2__.codes.ERR_NOT_FOUND) {\n                // peer has not completed identify so they are not in the peer store\n                return;\n            }\n            this.log.error(\"could not inform topologies of disconnecting peer %p\", remotePeer, err);\n        });\n    }\n    /**\n     * When a peer is updated, if they have removed supported protocols notify any\n     * topologies interested in the removed protocols.\n     */ _onPeerUpdate(evt) {\n        const { peer, previous } = evt.detail;\n        const removed = (previous?.protocols ?? []).filter((protocol)=>!peer.protocols.includes(protocol));\n        for (const protocol of removed){\n            const topologies = this.topologies.get(protocol);\n            if (topologies == null) {\n                continue;\n            }\n            for (const topology of topologies.values()){\n                topology.onDisconnect?.(peer.id);\n            }\n        }\n    }\n    /**\n     * After identify has completed and we have received the list of supported\n     * protocols, notify any topologies interested in those protocols.\n     */ _onPeerIdentify(evt) {\n        const protocols = evt.detail.protocols;\n        const connection = evt.detail.connection;\n        const peerId = evt.detail.peerId;\n        for (const protocol of protocols){\n            const topologies = this.topologies.get(protocol);\n            if (topologies == null) {\n                continue;\n            }\n            for (const topology of topologies.values()){\n                if (connection.transient && topology.notifyOnTransient !== true) {\n                    continue;\n                }\n                topology.onConnect?.(peerId, connection);\n            }\n        }\n    }\n} //# sourceMappingURL=registrar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL3JlZ2lzdHJhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEM7QUFDWjtBQUNFO0FBQzdCLE1BQU1HLDhCQUE4QixHQUFHO0FBQ3ZDLE1BQU1DLCtCQUErQixHQUFHO0FBQy9DOztDQUVDLEdBQ00sTUFBTUM7SUFLVEMsWUFBWUMsVUFBVSxDQUFFO1FBQ3BCLElBQUksQ0FBQ0MsR0FBRyxHQUFHRCxXQUFXRSxNQUFNLENBQUNDLFlBQVksQ0FBQztRQUMxQyxJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJQztRQUN0QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJRDtRQUNwQixJQUFJLENBQUNMLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDTyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ2pELElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYSxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUNqRCxJQUFJLENBQUNFLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDckQsSUFBSSxDQUFDUixVQUFVLENBQUNXLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsbUJBQW1CLElBQUksQ0FBQ0wsYUFBYTtRQUM3RSxJQUFJLENBQUNQLFVBQVUsQ0FBQ1csTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQyxlQUFlLElBQUksQ0FBQ0gsYUFBYTtRQUN6RSxJQUFJLENBQUNULFVBQVUsQ0FBQ1csTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDRixlQUFlO0lBQ2pGO0lBQ0FHLGVBQWU7UUFDWCxPQUFPQyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSTtlQUNuQixJQUFJLENBQUNWLFFBQVEsQ0FBQ1csSUFBSTtTQUN4QixHQUFHQyxJQUFJO0lBQ1o7SUFDQUMsV0FBV0MsUUFBUSxFQUFFO1FBQ2pC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SWhCLGNBQWMsTUFBTTtnQkFFcEI7WUFDSjtZQUNBLEtBQUssTUFBTXlDLFlBQVl6QyxXQUFXcUIsTUFBTSxHQUFJO2dCQUN4Q29CLFNBQVNnQixZQUFZLEdBQUdELEtBQUtiLEVBQUU7WUFDbkM7UUFDSjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0RyQyxnQkFBZ0I4QyxHQUFHLEVBQUU7UUFDakIsTUFBTW5CLFlBQVltQixJQUFJRSxNQUFNLENBQUNyQixTQUFTO1FBQ3RDLE1BQU1rQyxhQUFhZixJQUFJRSxNQUFNLENBQUNhLFVBQVU7UUFDeEMsTUFBTW5DLFNBQVNvQixJQUFJRSxNQUFNLENBQUN0QixNQUFNO1FBQ2hDLEtBQUssTUFBTWhCLFlBQVlpQixVQUFXO1lBQzlCLE1BQU1qQyxhQUFhLElBQUksQ0FBQ0EsVUFBVSxDQUFDa0IsR0FBRyxDQUFDRjtZQUN2QyxJQUFJaEIsY0FBYyxNQUFNO2dCQUVwQjtZQUNKO1lBQ0EsS0FBSyxNQUFNeUMsWUFBWXpDLFdBQVdxQixNQUFNLEdBQUk7Z0JBQ3hDLElBQUk4QyxXQUFXQyxTQUFTLElBQUkzQixTQUFTNEIsaUJBQWlCLEtBQUssTUFBTTtvQkFDN0Q7Z0JBQ0o7Z0JBQ0E1QixTQUFTNkIsU0FBUyxHQUFHdEMsUUFBUW1DO1lBQ2pDO1FBQ0o7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL3JlZ2lzdHJhci5qcz9kMDNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVFcnJvciB9IGZyb20gJ0BsaWJwMnAvaW50ZXJmYWNlJztcbmltcG9ydCBtZXJnZSBmcm9tICdtZXJnZS1vcHRpb25zJztcbmltcG9ydCB7IGNvZGVzIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX0lOQk9VTkRfU1RSRUFNUyA9IDMyO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX09VVEJPVU5EX1NUUkVBTVMgPSA2NDtcbi8qKlxuICogUmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyByZWdpc3RlcmVkIHByb3RvY29scyBvZiBldmVudHMgaW4gdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0UmVnaXN0cmFyIHtcbiAgICBsb2c7XG4gICAgdG9wb2xvZ2llcztcbiAgICBoYW5kbGVycztcbiAgICBjb21wb25lbnRzO1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMpIHtcbiAgICAgICAgdGhpcy5sb2cgPSBjb21wb25lbnRzLmxvZ2dlci5mb3JDb21wb25lbnQoJ2xpYnAycDpyZWdpc3RyYXInKTtcbiAgICAgICAgdGhpcy50b3BvbG9naWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLl9vbkRpc2Nvbm5lY3QgPSB0aGlzLl9vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25QZWVyVXBkYXRlID0gdGhpcy5fb25QZWVyVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uUGVlcklkZW50aWZ5ID0gdGhpcy5fb25QZWVySWRlbnRpZnkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKCdwZWVyOmRpc2Nvbm5lY3QnLCB0aGlzLl9vbkRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoJ3BlZXI6dXBkYXRlJywgdGhpcy5fb25QZWVyVXBkYXRlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKCdwZWVyOmlkZW50aWZ5JywgdGhpcy5fb25QZWVySWRlbnRpZnkpO1xuICAgIH1cbiAgICBnZXRQcm90b2NvbHMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoW1xuICAgICAgICAgICAgLi4udGhpcy5oYW5kbGVycy5rZXlzKClcbiAgICAgICAgXSkpLnNvcnQoKTtcbiAgICB9XG4gICAgZ2V0SGFuZGxlcihwcm90b2NvbCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQocHJvdG9jb2wpO1xuICAgICAgICBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKGBObyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIHByb3RvY29sICR7cHJvdG9jb2x9YCwgY29kZXMuRVJSX05PX0hBTkRMRVJfRk9SX1BST1RPQ09MKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgZ2V0VG9wb2xvZ2llcyhwcm90b2NvbCkge1xuICAgICAgICBjb25zdCB0b3BvbG9naWVzID0gdGhpcy50b3BvbG9naWVzLmdldChwcm90b2NvbCk7XG4gICAgICAgIGlmICh0b3BvbG9naWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udG9wb2xvZ2llcy52YWx1ZXMoKVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGBoYW5kbGVyYCBmb3IgZWFjaCBwcm90b2NvbFxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZShwcm90b2NvbCwgaGFuZGxlciwgb3B0cykge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKGBIYW5kbGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgcHJvdG9jb2wgJHtwcm90b2NvbH1gLCBjb2Rlcy5FUlJfUFJPVE9DT0xfSEFORExFUl9BTFJFQURZX1JFR0lTVEVSRUQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZS5iaW5kKHsgaWdub3JlVW5kZWZpbmVkOiB0cnVlIH0pKHtcbiAgICAgICAgICAgIG1heEluYm91bmRTdHJlYW1zOiBERUZBVUxUX01BWF9JTkJPVU5EX1NUUkVBTVMsXG4gICAgICAgICAgICBtYXhPdXRib3VuZFN0cmVhbXM6IERFRkFVTFRfTUFYX09VVEJPVU5EX1NUUkVBTVNcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KHByb3RvY29sLCB7XG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIG5ldyBwcm90b2NvbCB0byBzZWxmIHByb3RvY29scyBpbiB0aGUgcGVlciBzdG9yZVxuICAgICAgICBhd2FpdCB0aGlzLmNvbXBvbmVudHMucGVlclN0b3JlLm1lcmdlKHRoaXMuY29tcG9uZW50cy5wZWVySWQsIHtcbiAgICAgICAgICAgIHByb3RvY29sczogW3Byb3RvY29sXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgaGFuZGxlciBmb3IgZWFjaCBwcm90b2NvbC4gVGhlIHByb3RvY29sXG4gICAgICogd2lsbCBubyBsb25nZXIgYmUgc3VwcG9ydGVkIG9uIHN0cmVhbXMuXG4gICAgICovXG4gICAgYXN5bmMgdW5oYW5kbGUocHJvdG9jb2xzKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sTGlzdCA9IEFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSA/IHByb3RvY29scyA6IFtwcm90b2NvbHNdO1xuICAgICAgICBwcm90b2NvbExpc3QuZm9yRWFjaChwcm90b2NvbCA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmRlbGV0ZShwcm90b2NvbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVcGRhdGUgc2VsZiBwcm90b2NvbHMgaW4gdGhlIHBlZXIgc3RvcmVcbiAgICAgICAgYXdhaXQgdGhpcy5jb21wb25lbnRzLnBlZXJTdG9yZS5wYXRjaCh0aGlzLmNvbXBvbmVudHMucGVlcklkLCB7XG4gICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMuZ2V0UHJvdG9jb2xzKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGhhbmRsZXJzIGZvciBhIHNldCBvZiBtdWx0aWNvZGVjcyBnaXZlblxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyKHByb3RvY29sLCB0b3BvbG9neSkge1xuICAgICAgICBpZiAodG9wb2xvZ3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignaW52YWxpZCB0b3BvbG9neScsIGNvZGVzLkVSUl9JTlZBTElEX1BBUkFNRVRFUlMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0b3BvbG9neVxuICAgICAgICBjb25zdCBpZCA9IGAkeyhNYXRoLnJhbmRvbSgpICogMWU5KS50b1N0cmluZygzNil9JHtEYXRlLm5vdygpfWA7XG4gICAgICAgIGxldCB0b3BvbG9naWVzID0gdGhpcy50b3BvbG9naWVzLmdldChwcm90b2NvbCk7XG4gICAgICAgIGlmICh0b3BvbG9naWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcG9sb2dpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnRvcG9sb2dpZXMuc2V0KHByb3RvY29sLCB0b3BvbG9naWVzKTtcbiAgICAgICAgfVxuICAgICAgICB0b3BvbG9naWVzLnNldChpZCwgdG9wb2xvZ3kpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgdG9wb2xvZ3lcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGlkKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Byb3RvY29sLCB0b3BvbG9naWVzXSBvZiB0aGlzLnRvcG9sb2dpZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodG9wb2xvZ2llcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdG9wb2xvZ2llcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3BvbG9naWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3BvbG9naWVzLmRlbGV0ZShwcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRpc2Nvbm5lY3RlZCBwZWVyIGZyb20gdGhlIHJlY29yZFxuICAgICAqL1xuICAgIF9vbkRpc2Nvbm5lY3QoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZVBlZXIgPSBldnQuZGV0YWlsO1xuICAgICAgICB2b2lkIHRoaXMuY29tcG9uZW50cy5wZWVyU3RvcmUuZ2V0KHJlbW90ZVBlZXIpXG4gICAgICAgICAgICAudGhlbihwZWVyID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcGVlci5wcm90b2NvbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BvbG9naWVzID0gdGhpcy50b3BvbG9naWVzLmdldChwcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvcG9sb2dpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyB0b3BvbG9naWVzIGFyZSBpbnRlcmVzdGVkIGluIHRoaXMgcHJvdG9jb2xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9wb2xvZ3kgb2YgdG9wb2xvZ2llcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BvbG9neS5vbkRpc2Nvbm5lY3Q/LihyZW1vdGVQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gY29kZXMuRVJSX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgIC8vIHBlZXIgaGFzIG5vdCBjb21wbGV0ZWQgaWRlbnRpZnkgc28gdGhleSBhcmUgbm90IGluIHRoZSBwZWVyIHN0b3JlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBpbmZvcm0gdG9wb2xvZ2llcyBvZiBkaXNjb25uZWN0aW5nIHBlZXIgJXAnLCByZW1vdGVQZWVyLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBhIHBlZXIgaXMgdXBkYXRlZCwgaWYgdGhleSBoYXZlIHJlbW92ZWQgc3VwcG9ydGVkIHByb3RvY29scyBub3RpZnkgYW55XG4gICAgICogdG9wb2xvZ2llcyBpbnRlcmVzdGVkIGluIHRoZSByZW1vdmVkIHByb3RvY29scy5cbiAgICAgKi9cbiAgICBfb25QZWVyVXBkYXRlKGV2dCkge1xuICAgICAgICBjb25zdCB7IHBlZXIsIHByZXZpb3VzIH0gPSBldnQuZGV0YWlsO1xuICAgICAgICBjb25zdCByZW1vdmVkID0gKHByZXZpb3VzPy5wcm90b2NvbHMgPz8gW10pLmZpbHRlcihwcm90b2NvbCA9PiAhcGVlci5wcm90b2NvbHMuaW5jbHVkZXMocHJvdG9jb2wpKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiByZW1vdmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BvbG9naWVzID0gdGhpcy50b3BvbG9naWVzLmdldChwcm90b2NvbCk7XG4gICAgICAgICAgICBpZiAodG9wb2xvZ2llcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gdG9wb2xvZ2llcyBhcmUgaW50ZXJlc3RlZCBpbiB0aGlzIHByb3RvY29sXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvcG9sb2d5IG9mIHRvcG9sb2dpZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICB0b3BvbG9neS5vbkRpc2Nvbm5lY3Q/LihwZWVyLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZnRlciBpZGVudGlmeSBoYXMgY29tcGxldGVkIGFuZCB3ZSBoYXZlIHJlY2VpdmVkIHRoZSBsaXN0IG9mIHN1cHBvcnRlZFxuICAgICAqIHByb3RvY29scywgbm90aWZ5IGFueSB0b3BvbG9naWVzIGludGVyZXN0ZWQgaW4gdGhvc2UgcHJvdG9jb2xzLlxuICAgICAqL1xuICAgIF9vblBlZXJJZGVudGlmeShldnQpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2xzID0gZXZ0LmRldGFpbC5wcm90b2NvbHM7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBldnQuZGV0YWlsLmNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IGV2dC5kZXRhaWwucGVlcklkO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgICAgICAgY29uc3QgdG9wb2xvZ2llcyA9IHRoaXMudG9wb2xvZ2llcy5nZXQocHJvdG9jb2wpO1xuICAgICAgICAgICAgaWYgKHRvcG9sb2dpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIHRvcG9sb2dpZXMgYXJlIGludGVyZXN0ZWQgaW4gdGhpcyBwcm90b2NvbFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0b3BvbG9neSBvZiB0b3BvbG9naWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24udHJhbnNpZW50ICYmIHRvcG9sb2d5Lm5vdGlmeU9uVHJhbnNpZW50ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3BvbG9neS5vbkNvbm5lY3Q/LihwZWVySWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0cmFyLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlRXJyb3IiLCJtZXJnZSIsImNvZGVzIiwiREVGQVVMVF9NQVhfSU5CT1VORF9TVFJFQU1TIiwiREVGQVVMVF9NQVhfT1VUQk9VTkRfU1RSRUFNUyIsIkRlZmF1bHRSZWdpc3RyYXIiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudHMiLCJsb2ciLCJsb2dnZXIiLCJmb3JDb21wb25lbnQiLCJ0b3BvbG9naWVzIiwiTWFwIiwiaGFuZGxlcnMiLCJfb25EaXNjb25uZWN0IiwiYmluZCIsIl9vblBlZXJVcGRhdGUiLCJfb25QZWVySWRlbnRpZnkiLCJldmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0UHJvdG9jb2xzIiwiQXJyYXkiLCJmcm9tIiwiU2V0Iiwia2V5cyIsInNvcnQiLCJnZXRIYW5kbGVyIiwicHJvdG9jb2wiLCJoYW5kbGVyIiwiZ2V0IiwiRVJSX05PX0hBTkRMRVJfRk9SX1BST1RPQ09MIiwiZ2V0VG9wb2xvZ2llcyIsInZhbHVlcyIsImhhbmRsZSIsIm9wdHMiLCJoYXMiLCJFUlJfUFJPVE9DT0xfSEFORExFUl9BTFJFQURZX1JFR0lTVEVSRUQiLCJvcHRpb25zIiwiaWdub3JlVW5kZWZpbmVkIiwibWF4SW5ib3VuZFN0cmVhbXMiLCJtYXhPdXRib3VuZFN0cmVhbXMiLCJzZXQiLCJwZWVyU3RvcmUiLCJwZWVySWQiLCJwcm90b2NvbHMiLCJ1bmhhbmRsZSIsInByb3RvY29sTGlzdCIsImlzQXJyYXkiLCJmb3JFYWNoIiwiZGVsZXRlIiwicGF0Y2giLCJyZWdpc3RlciIsInRvcG9sb2d5IiwiRVJSX0lOVkFMSURfUEFSQU1FVEVSUyIsImlkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiRGF0ZSIsIm5vdyIsInVucmVnaXN0ZXIiLCJlbnRyaWVzIiwic2l6ZSIsImV2dCIsInJlbW90ZVBlZXIiLCJkZXRhaWwiLCJ0aGVuIiwicGVlciIsIm9uRGlzY29ubmVjdCIsImNhdGNoIiwiZXJyIiwiY29kZSIsIkVSUl9OT1RfRk9VTkQiLCJlcnJvciIsInByZXZpb3VzIiwicmVtb3ZlZCIsImZpbHRlciIsImluY2x1ZGVzIiwiY29ubmVjdGlvbiIsInRyYW5zaWVudCIsIm5vdGlmeU9uVHJhbnNpZW50Iiwib25Db25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/registrar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/transport-manager.js":
/*!***********************************************************!*\
  !*** ./node_modules/libp2p/dist/src/transport-manager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultTransportManager: () => (/* binding */ DefaultTransportManager)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/transport/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"(ssr)/./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n\n\n\nclass DefaultTransportManager {\n    constructor(components, init = {}){\n        this.log = components.logger.forComponent(\"libp2p:transports\");\n        this.components = components;\n        this.started = false;\n        this.transports = new Map();\n        this.listeners = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_0__.trackedMap)({\n            name: \"libp2p_transport_manager_listeners\",\n            metrics: this.components.metrics\n        });\n        this.faultTolerance = init.faultTolerance ?? _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.FaultTolerance.FATAL_ALL;\n    }\n    /**\n     * Adds a `Transport` to the manager\n     */ add(transport) {\n        const tag = transport[Symbol.toStringTag];\n        if (tag == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(\"Transport must have a valid tag\", _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_INVALID_KEY);\n        }\n        if (this.transports.has(tag)) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(`There is already a transport with the tag ${tag}`, _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_DUPLICATE_TRANSPORT);\n        }\n        this.log(\"adding transport %s\", tag);\n        this.transports.set(tag, transport);\n        if (!this.listeners.has(tag)) {\n            this.listeners.set(tag, []);\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    async afterStart() {\n        // Listen on the provided transports for the provided addresses\n        const addrs = this.components.addressManager.getListenAddrs();\n        await this.listen(addrs);\n    }\n    /**\n     * Stops all listeners\n     */ async stop() {\n        const tasks = [];\n        for (const [key, listeners] of this.listeners){\n            this.log(\"closing listeners for %s\", key);\n            while(listeners.length > 0){\n                const listener = listeners.pop();\n                if (listener == null) {\n                    continue;\n                }\n                tasks.push(listener.close());\n            }\n        }\n        await Promise.all(tasks);\n        this.log(\"all listeners closed\");\n        for (const key of this.listeners.keys()){\n            this.listeners.set(key, []);\n        }\n        this.started = false;\n    }\n    /**\n     * Dials the given Multiaddr over it's supported transport\n     */ async dial(ma, options) {\n        const transport = this.transportForMultiaddr(ma);\n        if (transport == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(`No transport available for address ${String(ma)}`, _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_TRANSPORT_UNAVAILABLE);\n        }\n        try {\n            return await transport.dial(ma, {\n                ...options,\n                upgrader: this.components.upgrader\n            });\n        } catch (err) {\n            if (err.code == null) {\n                err.code = _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_TRANSPORT_DIAL_FAILED;\n            }\n            throw err;\n        }\n    }\n    /**\n     * Returns all Multiaddr's the listeners are using\n     */ getAddrs() {\n        let addrs = [];\n        for (const listeners of this.listeners.values()){\n            for (const listener of listeners){\n                addrs = [\n                    ...addrs,\n                    ...listener.getAddrs()\n                ];\n            }\n        }\n        return addrs;\n    }\n    /**\n     * Returns all the transports instances\n     */ getTransports() {\n        return Array.of(...this.transports.values());\n    }\n    /**\n     * Returns all the listener instances\n     */ getListeners() {\n        return Array.of(...this.listeners.values()).flat();\n    }\n    /**\n     * Finds a transport that matches the given Multiaddr\n     */ transportForMultiaddr(ma) {\n        for (const transport of this.transports.values()){\n            const addrs = transport.filter([\n                ma\n            ]);\n            if (addrs.length > 0) {\n                return transport;\n            }\n        }\n    }\n    /**\n     * Starts listeners for each listen Multiaddr\n     */ async listen(addrs) {\n        if (!this.isStarted()) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(\"Not started\", _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_NODE_NOT_STARTED);\n        }\n        if (addrs == null || addrs.length === 0) {\n            this.log(\"no addresses were provided for listening, this node is dial only\");\n            return;\n        }\n        const couldNotListen = [];\n        for (const [key, transport] of this.transports.entries()){\n            const supportedAddrs = transport.filter(addrs);\n            const tasks = [];\n            // For each supported multiaddr, create a listener\n            for (const addr of supportedAddrs){\n                this.log(\"creating listener for %s on %a\", key, addr);\n                const listener = transport.createListener({\n                    upgrader: this.components.upgrader\n                });\n                let listeners = this.listeners.get(key) ?? [];\n                if (listeners == null) {\n                    listeners = [];\n                    this.listeners.set(key, listeners);\n                }\n                listeners.push(listener);\n                // Track listen/close events\n                listener.addEventListener(\"listening\", ()=>{\n                    this.components.events.safeDispatchEvent(\"transport:listening\", {\n                        detail: listener\n                    });\n                });\n                listener.addEventListener(\"close\", ()=>{\n                    const index = listeners.findIndex((l)=>l === listener);\n                    // remove the listener\n                    listeners.splice(index, 1);\n                    this.components.events.safeDispatchEvent(\"transport:close\", {\n                        detail: listener\n                    });\n                });\n                // We need to attempt to listen on everything\n                tasks.push(listener.listen(addr));\n            }\n            // Keep track of transports we had no addresses for\n            if (tasks.length === 0) {\n                couldNotListen.push(key);\n                continue;\n            }\n            const results = await Promise.allSettled(tasks);\n            // If we are listening on at least 1 address, succeed.\n            // TODO: we should look at adding a retry (`p-retry`) here to better support\n            // listening on remote addresses as they may be offline. We could then potentially\n            // just wait for any (`p-any`) listener to succeed on each transport before returning\n            const isListening = results.find((r)=>r.status === \"fulfilled\");\n            if (isListening == null && this.faultTolerance !== _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.FaultTolerance.NO_FATAL) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(`Transport (${key}) could not listen on any available address`, _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_NO_VALID_ADDRESSES);\n            }\n        }\n        // If no transports were able to listen, throw an error. This likely\n        // means we were given addresses we do not have transports for\n        if (couldNotListen.length === this.transports.size) {\n            const message = `no valid addresses were provided for transports [${couldNotListen.join(\", \")}]`;\n            if (this.faultTolerance === _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.FaultTolerance.FATAL_ALL) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(message, _errors_js__WEBPACK_IMPORTED_MODULE_3__.codes.ERR_NO_VALID_ADDRESSES);\n            }\n            this.log(`libp2p in dial mode only: ${message}`);\n        }\n    }\n    /**\n     * Removes the given transport from the manager.\n     * If a transport has any running listeners, they will be closed.\n     */ async remove(key) {\n        const listeners = this.listeners.get(key) ?? [];\n        this.log.trace(\"removing transport %s\", key);\n        // Close any running listeners\n        const tasks = [];\n        this.log.trace(\"closing listeners for %s\", key);\n        while(listeners.length > 0){\n            const listener = listeners.pop();\n            if (listener == null) {\n                continue;\n            }\n            tasks.push(listener.close());\n        }\n        await Promise.all(tasks);\n        this.transports.delete(key);\n        this.listeners.delete(key);\n    }\n    /**\n     * Removes all transports from the manager.\n     * If any listeners are running, they will be closed.\n     *\n     * @async\n     */ async removeAll() {\n        const tasks = [];\n        for (const key of this.transports.keys()){\n            tasks.push(this.remove(key));\n        }\n        await Promise.all(tasks);\n    }\n} //# sourceMappingURL=transport-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL3RyYW5zcG9ydC1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThEO0FBQ1A7QUFDbkI7QUFDN0IsTUFBTUk7SUFPVEMsWUFBWUMsVUFBVSxFQUFFQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQy9CLElBQUksQ0FBQ0MsR0FBRyxHQUFHRixXQUFXRyxNQUFNLENBQUNDLFlBQVksQ0FBQztRQUMxQyxJQUFJLENBQUNKLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDSyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJQztRQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBR1oscUVBQVVBLENBQUM7WUFDeEJhLE1BQU07WUFDTkMsU0FBUyxJQUFJLENBQUNWLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQztRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHVixLQUFLVSxjQUFjLElBQUloQiw2REFBY0EsQ0FBQ2lCLFNBQVM7SUFDekU7SUFDQTs7S0FFQyxHQUNEQyxJQUFJQyxTQUFTLEVBQUU7UUFDWCxNQUFNQyxNQUFNRCxTQUFTLENBQUNFLE9BQU9DLFdBQVcsQ0FBQztRQUN6QyxJQUFJRixPQUFPLE1BQU07WUFDYixNQUFNLElBQUlyQix3REFBU0EsQ0FBQyxtQ0FBbUNHLDZDQUFLQSxDQUFDcUIsZUFBZTtRQUNoRjtRQUNBLElBQUksSUFBSSxDQUFDWixVQUFVLENBQUNhLEdBQUcsQ0FBQ0osTUFBTTtZQUMxQixNQUFNLElBQUlyQix3REFBU0EsQ0FBQyxDQUFDLDBDQUEwQyxFQUFFcUIsSUFBSSxDQUFDLEVBQUVsQiw2Q0FBS0EsQ0FBQ3VCLHVCQUF1QjtRQUN6RztRQUNBLElBQUksQ0FBQ2xCLEdBQUcsQ0FBQyx1QkFBdUJhO1FBQ2hDLElBQUksQ0FBQ1QsVUFBVSxDQUFDZSxHQUFHLENBQUNOLEtBQUtEO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUNOLFNBQVMsQ0FBQ1cs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bW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvdHJhbnNwb3J0LW1hbmFnZXIuanM/YjhhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRXJyb3IsIEZhdWx0VG9sZXJhbmNlIH0gZnJvbSAnQGxpYnAycC9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgdHJhY2tlZE1hcCB9IGZyb20gJ0BsaWJwMnAvdXRpbHMvdHJhY2tlZC1tYXAnO1xuaW1wb3J0IHsgY29kZXMgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFRyYW5zcG9ydE1hbmFnZXIge1xuICAgIGxvZztcbiAgICBjb21wb25lbnRzO1xuICAgIHRyYW5zcG9ydHM7XG4gICAgbGlzdGVuZXJzO1xuICAgIGZhdWx0VG9sZXJhbmNlO1xuICAgIHN0YXJ0ZWQ7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cywgaW5pdCA9IHt9KSB7XG4gICAgICAgIHRoaXMubG9nID0gY29tcG9uZW50cy5sb2dnZXIuZm9yQ29tcG9uZW50KCdsaWJwMnA6dHJhbnNwb3J0cycpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHRyYWNrZWRNYXAoe1xuICAgICAgICAgICAgbmFtZTogJ2xpYnAycF90cmFuc3BvcnRfbWFuYWdlcl9saXN0ZW5lcnMnLFxuICAgICAgICAgICAgbWV0cmljczogdGhpcy5jb21wb25lbnRzLm1ldHJpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmF1bHRUb2xlcmFuY2UgPSBpbml0LmZhdWx0VG9sZXJhbmNlID8/IEZhdWx0VG9sZXJhbmNlLkZBVEFMX0FMTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGBUcmFuc3BvcnRgIHRvIHRoZSBtYW5hZ2VyXG4gICAgICovXG4gICAgYWRkKHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0cmFuc3BvcnRbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICAgICAgaWYgKHRhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdUcmFuc3BvcnQgbXVzdCBoYXZlIGEgdmFsaWQgdGFnJywgY29kZXMuRVJSX0lOVkFMSURfS0VZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzLmhhcyh0YWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGEgdHJhbnNwb3J0IHdpdGggdGhlIHRhZyAke3RhZ31gLCBjb2Rlcy5FUlJfRFVQTElDQVRFX1RSQU5TUE9SVCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coJ2FkZGluZyB0cmFuc3BvcnQgJXMnLCB0YWcpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMuc2V0KHRhZywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVycy5oYXModGFnKSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KHRhZywgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRlZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGFmdGVyU3RhcnQoKSB7XG4gICAgICAgIC8vIExpc3RlbiBvbiB0aGUgcHJvdmlkZWQgdHJhbnNwb3J0cyBmb3IgdGhlIHByb3ZpZGVkIGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBhZGRycyA9IHRoaXMuY29tcG9uZW50cy5hZGRyZXNzTWFuYWdlci5nZXRMaXN0ZW5BZGRycygpO1xuICAgICAgICBhd2FpdCB0aGlzLmxpc3RlbihhZGRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFsbCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGxpc3RlbmVyc10gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdjbG9zaW5nIGxpc3RlbmVycyBmb3IgJXMnLCBrZXkpO1xuICAgICAgICAgICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gobGlzdGVuZXIuY2xvc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgICAgICB0aGlzLmxvZygnYWxsIGxpc3RlbmVycyBjbG9zZWQnKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5saXN0ZW5lcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5zZXQoa2V5LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpYWxzIHRoZSBnaXZlbiBNdWx0aWFkZHIgb3ZlciBpdCdzIHN1cHBvcnRlZCB0cmFuc3BvcnRcbiAgICAgKi9cbiAgICBhc3luYyBkaWFsKG1hLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0Rm9yTXVsdGlhZGRyKG1hKTtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKGBObyB0cmFuc3BvcnQgYXZhaWxhYmxlIGZvciBhZGRyZXNzICR7U3RyaW5nKG1hKX1gLCBjb2Rlcy5FUlJfVFJBTlNQT1JUX1VOQVZBSUxBQkxFKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRyYW5zcG9ydC5kaWFsKG1hLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB1cGdyYWRlcjogdGhpcy5jb21wb25lbnRzLnVwZ3JhZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gY29kZXMuRVJSX1RSQU5TUE9SVF9ESUFMX0ZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBNdWx0aWFkZHIncyB0aGUgbGlzdGVuZXJzIGFyZSB1c2luZ1xuICAgICAqL1xuICAgIGdldEFkZHJzKCkge1xuICAgICAgICBsZXQgYWRkcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lcnMgb2YgdGhpcy5saXN0ZW5lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgYWRkcnMgPSBbLi4uYWRkcnMsIC4uLmxpc3RlbmVyLmdldEFkZHJzKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIHRyYW5zcG9ydHMgaW5zdGFuY2VzXG4gICAgICovXG4gICAgZ2V0VHJhbnNwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5Lm9mKC4uLnRoaXMudHJhbnNwb3J0cy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSBsaXN0ZW5lciBpbnN0YW5jZXNcbiAgICAgKi9cbiAgICBnZXRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5vZiguLi50aGlzLmxpc3RlbmVycy52YWx1ZXMoKSkuZmxhdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHRyYW5zcG9ydCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIE11bHRpYWRkclxuICAgICAqL1xuICAgIHRyYW5zcG9ydEZvck11bHRpYWRkcihtYSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zcG9ydCBvZiB0aGlzLnRyYW5zcG9ydHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJzID0gdHJhbnNwb3J0LmZpbHRlcihbbWFdKTtcbiAgICAgICAgICAgIGlmIChhZGRycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgbGlzdGVuZXJzIGZvciBlYWNoIGxpc3RlbiBNdWx0aWFkZHJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW4oYWRkcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdOb3Qgc3RhcnRlZCcsIGNvZGVzLkVSUl9OT0RFX05PVF9TVEFSVEVEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcnMgPT0gbnVsbCB8fCBhZGRycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdubyBhZGRyZXNzZXMgd2VyZSBwcm92aWRlZCBmb3IgbGlzdGVuaW5nLCB0aGlzIG5vZGUgaXMgZGlhbCBvbmx5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bGROb3RMaXN0ZW4gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB0cmFuc3BvcnRdIG9mIHRoaXMudHJhbnNwb3J0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZEFkZHJzID0gdHJhbnNwb3J0LmZpbHRlcihhZGRycyk7XG4gICAgICAgICAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggc3VwcG9ydGVkIG11bHRpYWRkciwgY3JlYXRlIGEgbGlzdGVuZXJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBzdXBwb3J0ZWRBZGRycykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdjcmVhdGluZyBsaXN0ZW5lciBmb3IgJXMgb24gJWEnLCBrZXksIGFkZHIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gdHJhbnNwb3J0LmNyZWF0ZUxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZXI6IHRoaXMuY29tcG9uZW50cy51cGdyYWRlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQoa2V5KSA/PyBbXTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNldChrZXksIGxpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAvLyBUcmFjayBsaXN0ZW4vY2xvc2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYWRkRXZlbnRMaXN0ZW5lcignbGlzdGVuaW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZXZlbnRzLnNhZmVEaXNwYXRjaEV2ZW50KCd0cmFuc3BvcnQ6bGlzdGVuaW5nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KGwgPT4gbCA9PT0gbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZXZlbnRzLnNhZmVEaXNwYXRjaEV2ZW50KCd0cmFuc3BvcnQ6Y2xvc2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXR0ZW1wdCB0byBsaXN0ZW4gb24gZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gobGlzdGVuZXIubGlzdGVuKGFkZHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdHJhbnNwb3J0cyB3ZSBoYWQgbm8gYWRkcmVzc2VzIGZvclxuICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvdWxkTm90TGlzdGVuLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQodGFza3MpO1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGxpc3RlbmluZyBvbiBhdCBsZWFzdCAxIGFkZHJlc3MsIHN1Y2NlZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbG9vayBhdCBhZGRpbmcgYSByZXRyeSAoYHAtcmV0cnlgKSBoZXJlIHRvIGJldHRlciBzdXBwb3J0XG4gICAgICAgICAgICAvLyBsaXN0ZW5pbmcgb24gcmVtb3RlIGFkZHJlc3NlcyBhcyB0aGV5IG1heSBiZSBvZmZsaW5lLiBXZSBjb3VsZCB0aGVuIHBvdGVudGlhbGx5XG4gICAgICAgICAgICAvLyBqdXN0IHdhaXQgZm9yIGFueSAoYHAtYW55YCkgbGlzdGVuZXIgdG8gc3VjY2VlZCBvbiBlYWNoIHRyYW5zcG9ydCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICAgICAgICBjb25zdCBpc0xpc3RlbmluZyA9IHJlc3VsdHMuZmluZChyID0+IHIuc3RhdHVzID09PSAnZnVsZmlsbGVkJyk7XG4gICAgICAgICAgICBpZiAoKGlzTGlzdGVuaW5nID09IG51bGwpICYmIHRoaXMuZmF1bHRUb2xlcmFuY2UgIT09IEZhdWx0VG9sZXJhbmNlLk5PX0ZBVEFMKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihgVHJhbnNwb3J0ICgke2tleX0pIGNvdWxkIG5vdCBsaXN0ZW4gb24gYW55IGF2YWlsYWJsZSBhZGRyZXNzYCwgY29kZXMuRVJSX05PX1ZBTElEX0FERFJFU1NFUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0cyB3ZXJlIGFibGUgdG8gbGlzdGVuLCB0aHJvdyBhbiBlcnJvci4gVGhpcyBsaWtlbHlcbiAgICAgICAgLy8gbWVhbnMgd2Ugd2VyZSBnaXZlbiBhZGRyZXNzZXMgd2UgZG8gbm90IGhhdmUgdHJhbnNwb3J0cyBmb3JcbiAgICAgICAgaWYgKGNvdWxkTm90TGlzdGVuLmxlbmd0aCA9PT0gdGhpcy50cmFuc3BvcnRzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgbm8gdmFsaWQgYWRkcmVzc2VzIHdlcmUgcHJvdmlkZWQgZm9yIHRyYW5zcG9ydHMgWyR7Y291bGROb3RMaXN0ZW4uam9pbignLCAnKX1dYDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZhdWx0VG9sZXJhbmNlID09PSBGYXVsdFRvbGVyYW5jZS5GQVRBTF9BTEwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKG1lc3NhZ2UsIGNvZGVzLkVSUl9OT19WQUxJRF9BRERSRVNTRVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coYGxpYnAycCBpbiBkaWFsIG1vZGUgb25seTogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHRyYW5zcG9ydCBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgICAqIElmIGEgdHJhbnNwb3J0IGhhcyBhbnkgcnVubmluZyBsaXN0ZW5lcnMsIHRoZXkgd2lsbCBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlKGtleSkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQoa2V5KSA/PyBbXTtcbiAgICAgICAgdGhpcy5sb2cudHJhY2UoJ3JlbW92aW5nIHRyYW5zcG9ydCAlcycsIGtleSk7XG4gICAgICAgIC8vIENsb3NlIGFueSBydW5uaW5nIGxpc3RlbmVyc1xuICAgICAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgICAgICB0aGlzLmxvZy50cmFjZSgnY2xvc2luZyBsaXN0ZW5lcnMgZm9yICVzJywga2V5KTtcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVycy5wb3AoKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrcy5wdXNoKGxpc3RlbmVyLmNsb3NlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRhc2tzKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRzLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdHJhbnNwb3J0cyBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgICAqIElmIGFueSBsaXN0ZW5lcnMgYXJlIHJ1bm5pbmcsIHRoZXkgd2lsbCBiZSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGwoKSB7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMudHJhbnNwb3J0cy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRhc2tzLnB1c2godGhpcy5yZW1vdmUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC1tYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlRXJyb3IiLCJGYXVsdFRvbGVyYW5jZSIsInRyYWNrZWRNYXAiLCJjb2RlcyIsIkRlZmF1bHRUcmFuc3BvcnRNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRzIiwiaW5pdCIsImxvZyIsImxvZ2dlciIsImZvckNvbXBvbmVudCIsInN0YXJ0ZWQiLCJ0cmFuc3BvcnRzIiwiTWFwIiwibGlzdGVuZXJzIiwibmFtZSIsIm1ldHJpY3MiLCJmYXVsdFRvbGVyYW5jZSIsIkZBVEFMX0FMTCIsImFkZCIsInRyYW5zcG9ydCIsInRhZyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiRVJSX0lOVkFMSURfS0VZIiwiaGFzIiwiRVJSX0RVUExJQ0FURV9UUkFOU1BPUlQiLCJzZXQiLCJpc1N0YXJ0ZWQiLCJzdGFydCIsImFmdGVyU3RhcnQiLCJhZGRycyIsImFkZHJlc3NNYW5hZ2VyIiwiZ2V0TGlzdGVuQWRkcnMiLCJsaXN0ZW4iLCJzdG9wIiwidGFza3MiLCJrZXkiLCJsZW5ndGgiLCJsaXN0ZW5lciIsInBvcCIsInB1c2giLCJjbG9zZSIsIlByb21pc2UiLCJhbGwiLCJrZXlzIiwiZGlhbCIsIm1hIiwib3B0aW9ucyIsInRyYW5zcG9ydEZvck11bHRpYWRkciIsIlN0cmluZyIsIkVSUl9UUkFOU1BPUlRfVU5BVkFJTEFCTEUiLCJ1cGdyYWRlciIsImVyciIsImNvZGUiLCJFUlJfVFJBTlNQT1JUX0RJQUxfRkFJTEVEIiwiZ2V0QWRkcnMiLCJ2YWx1ZXMiLCJnZXRUcmFuc3BvcnRzIiwiQXJyYXkiLCJvZiIsImdldExpc3RlbmVycyIsImZsYXQiLCJmaWx0ZXIiLCJFUlJfTk9ERV9OT1RfU1RBUlRFRCIsImNvdWxkTm90TGlzdGVuIiwiZW50cmllcyIsInN1cHBvcnRlZEFkZHJzIiwiYWRkciIsImNyZWF0ZUxpc3RlbmVyIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50cyIsInNhZmVEaXNwYXRjaEV2ZW50IiwiZGV0YWlsIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJsIiwic3BsaWNlIiwicmVzdWx0cyIsImFsbFNldHRsZWQiLCJpc0xpc3RlbmluZyIsImZpbmQiLCJyIiwic3RhdHVzIiwiTk9fRkFUQUwiLCJFUlJfTk9fVkFMSURfQUREUkVTU0VTIiwic2l6ZSIsIm1lc3NhZ2UiLCJqb2luIiwicmVtb3ZlIiwidHJhY2UiLCJkZWxldGUiLCJyZW1vdmVBbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/transport-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/upgrader.js":
/*!**************************************************!*\
  !*** ./node_modules/libp2p/dist/src/upgrader.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultUpgrader: () => (/* binding */ DefaultUpgrader)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"(ssr)/./node_modules/@libp2p/interface/dist/src/events.js\");\n/* harmony import */ var _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/multistream-select */ \"(ssr)/./node_modules/@libp2p/multistream-select/dist/src/handle.js\");\n/* harmony import */ var _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/multistream-select */ \"(ssr)/./node_modules/@libp2p/multistream-select/dist/src/select.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libp2p/peer-id */ \"(ssr)/./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _connection_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./connection/index.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection/index.js\");\n/* harmony import */ var _connection_manager_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./connection-manager/constants.js */ \"(ssr)/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/libp2p/dist/src/errors.js\");\n/* harmony import */ var _registrar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./registrar.js */ \"(ssr)/./node_modules/libp2p/dist/src/registrar.js\");\n\n\n\n\n\n\n\nconst DEFAULT_PROTOCOL_SELECT_TIMEOUT = 30000;\nfunction findIncomingStreamLimit(protocol, registrar) {\n    try {\n        const { options } = registrar.getHandler(protocol);\n        return options.maxInboundStreams;\n    } catch (err) {\n        if (err.code !== _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n            throw err;\n        }\n    }\n    return _registrar_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_MAX_INBOUND_STREAMS;\n}\nfunction findOutgoingStreamLimit(protocol, registrar, options = {}) {\n    try {\n        const { options } = registrar.getHandler(protocol);\n        if (options.maxOutboundStreams != null) {\n            return options.maxOutboundStreams;\n        }\n    } catch (err) {\n        if (err.code !== _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n            throw err;\n        }\n    }\n    return options.maxOutboundStreams ?? _registrar_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_MAX_OUTBOUND_STREAMS;\n}\nfunction countStreams(protocol, direction, connection) {\n    let streamCount = 0;\n    connection.streams.forEach((stream)=>{\n        if (stream.direction === direction && stream.protocol === protocol) {\n            streamCount++;\n        }\n    });\n    return streamCount;\n}\nclass DefaultUpgrader {\n    constructor(components, init){\n        this.components = components;\n        this.connectionEncryption = new Map();\n        init.connectionEncryption.forEach((encrypter)=>{\n            this.connectionEncryption.set(encrypter.protocol, encrypter);\n        });\n        this.muxers = new Map();\n        init.muxers.forEach((muxer)=>{\n            this.muxers.set(muxer.protocol, muxer);\n        });\n        this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? _connection_manager_constants_js__WEBPACK_IMPORTED_MODULE_2__.INBOUND_UPGRADE_TIMEOUT;\n        this.events = components.events;\n    }\n    async shouldBlockConnection(remotePeer, maConn, connectionType) {\n        const connectionGater = this.components.connectionGater[connectionType];\n        if (connectionGater !== undefined) {\n            if (await connectionGater(remotePeer, maConn)) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_CONNECTION_INTERCEPTED);\n            }\n        }\n    }\n    /**\n     * Upgrades an inbound connection\n     */ async upgradeInbound(maConn, opts) {\n        const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);\n        if (!accept) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"connection denied\", _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_CONNECTION_DENIED);\n        }\n        let encryptedConn;\n        let remotePeer;\n        let upgradedConn;\n        let muxerFactory;\n        let cryptoProtocol;\n        const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);\n        const onAbort = ()=>{\n            maConn.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"inbound upgrade timeout\", _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.ERR_TIMEOUT));\n        };\n        signal.addEventListener(\"abort\", onAbort, {\n            once: true\n        });\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.setMaxListeners)(Infinity, signal);\n        try {\n            if (await this.components.connectionGater.denyInboundConnection?.(maConn) === true) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"The multiaddr connection is blocked by gater.acceptConnection\", _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_CONNECTION_INTERCEPTED);\n            }\n            this.components.metrics?.trackMultiaddrConnection(maConn);\n            maConn.log(\"starting the inbound connection upgrade\");\n            // Protect\n            let protectedConn = maConn;\n            if (opts?.skipProtection !== true) {\n                const protector = this.components.connectionProtector;\n                if (protector != null) {\n                    maConn.log(\"protecting the inbound connection\");\n                    protectedConn = await protector.protect(maConn);\n                }\n            }\n            try {\n                // Encrypt the connection\n                encryptedConn = protectedConn;\n                if (opts?.skipEncryption !== true) {\n                    ({ conn: encryptedConn, remotePeer, protocol: cryptoProtocol } = await this._encryptInbound(protectedConn));\n                    const maConn = {\n                        ...protectedConn,\n                        ...encryptedConn\n                    };\n                    await this.shouldBlockConnection(remotePeer, maConn, \"denyInboundEncryptedConnection\");\n                } else {\n                    const idStr = maConn.remoteAddr.getPeerId();\n                    if (idStr == null) {\n                        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"inbound connection that skipped encryption must have a peer id\", _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_INVALID_MULTIADDR);\n                    }\n                    const remotePeerId = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_5__.peerIdFromString)(idStr);\n                    cryptoProtocol = \"native\";\n                    remotePeer = remotePeerId;\n                }\n                upgradedConn = encryptedConn;\n                if (opts?.muxerFactory != null) {\n                    muxerFactory = opts.muxerFactory;\n                } else if (this.muxers.size > 0) {\n                    // Multiplex the connection\n                    const multiplexed = await this._multiplexInbound({\n                        ...protectedConn,\n                        ...encryptedConn\n                    }, this.muxers);\n                    muxerFactory = multiplexed.muxerFactory;\n                    upgradedConn = multiplexed.stream;\n                }\n            } catch (err) {\n                maConn.log.error(\"failed to upgrade inbound connection\", err);\n                throw err;\n            }\n            await this.shouldBlockConnection(remotePeer, maConn, \"denyInboundUpgradedConnection\");\n            maConn.log(\"successfully upgraded inbound connection\");\n            return this._createConnection({\n                cryptoProtocol,\n                direction: \"inbound\",\n                maConn,\n                upgradedConn,\n                muxerFactory,\n                remotePeer,\n                transient: opts?.transient\n            });\n        } finally{\n            signal.removeEventListener(\"abort\", onAbort);\n            this.components.connectionManager.afterUpgradeInbound();\n        }\n    }\n    /**\n     * Upgrades an outbound connection\n     */ async upgradeOutbound(maConn, opts) {\n        const idStr = maConn.remoteAddr.getPeerId();\n        let remotePeerId;\n        if (idStr != null) {\n            remotePeerId = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_5__.peerIdFromString)(idStr);\n            await this.shouldBlockConnection(remotePeerId, maConn, \"denyOutboundConnection\");\n        }\n        let encryptedConn;\n        let remotePeer;\n        let upgradedConn;\n        let cryptoProtocol;\n        let muxerFactory;\n        this.components.metrics?.trackMultiaddrConnection(maConn);\n        maConn.log(\"starting the outbound connection upgrade\");\n        // If the transport natively supports encryption, skip connection\n        // protector and encryption\n        // Protect\n        let protectedConn = maConn;\n        if (opts?.skipProtection !== true) {\n            const protector = this.components.connectionProtector;\n            if (protector != null) {\n                protectedConn = await protector.protect(maConn);\n            }\n        }\n        try {\n            // Encrypt the connection\n            encryptedConn = protectedConn;\n            if (opts?.skipEncryption !== true) {\n                ({ conn: encryptedConn, remotePeer, protocol: cryptoProtocol } = await this._encryptOutbound(protectedConn, remotePeerId));\n                const maConn = {\n                    ...protectedConn,\n                    ...encryptedConn\n                };\n                await this.shouldBlockConnection(remotePeer, maConn, \"denyOutboundEncryptedConnection\");\n            } else {\n                if (remotePeerId == null) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"Encryption was skipped but no peer id was passed\", _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_INVALID_PEER);\n                }\n                cryptoProtocol = \"native\";\n                remotePeer = remotePeerId;\n            }\n            upgradedConn = encryptedConn;\n            if (opts?.muxerFactory != null) {\n                muxerFactory = opts.muxerFactory;\n            } else if (this.muxers.size > 0) {\n                // Multiplex the connection\n                const multiplexed = await this._multiplexOutbound({\n                    ...protectedConn,\n                    ...encryptedConn\n                }, this.muxers);\n                muxerFactory = multiplexed.muxerFactory;\n                upgradedConn = multiplexed.stream;\n            }\n        } catch (err) {\n            maConn.log.error(\"failed to upgrade outbound connection\", err);\n            await maConn.close(err);\n            throw err;\n        }\n        await this.shouldBlockConnection(remotePeer, maConn, \"denyOutboundUpgradedConnection\");\n        maConn.log(\"successfully upgraded outbound connection\");\n        return this._createConnection({\n            cryptoProtocol,\n            direction: \"outbound\",\n            maConn,\n            upgradedConn,\n            muxerFactory,\n            remotePeer,\n            transient: opts?.transient\n        });\n    }\n    /**\n     * A convenience method for generating a new `Connection`\n     */ _createConnection(opts) {\n        const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;\n        let muxer;\n        let newStream;\n        let connection; // eslint-disable-line prefer-const\n        if (muxerFactory != null) {\n            // Create the muxer\n            muxer = muxerFactory.createStreamMuxer({\n                direction,\n                // Run anytime a remote stream is created\n                onIncomingStream: (muxedStream)=>{\n                    if (connection == null) {\n                        return;\n                    }\n                    void Promise.resolve().then(async ()=>{\n                        const protocols = this.components.registrar.getProtocols();\n                        const { stream, protocol } = await _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_6__.handle(muxedStream, protocols, {\n                            log: muxedStream.log,\n                            yieldBytes: false\n                        });\n                        if (connection == null) {\n                            return;\n                        }\n                        connection.log(\"incoming stream opened on %s\", protocol);\n                        const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);\n                        const streamCount = countStreams(protocol, \"inbound\", connection);\n                        if (streamCount === incomingLimit) {\n                            const err = new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`, _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);\n                            muxedStream.abort(err);\n                            throw err;\n                        }\n                        // after the handshake the returned stream can have early data so override\n                        // the souce/sink\n                        muxedStream.source = stream.source;\n                        muxedStream.sink = stream.sink;\n                        muxedStream.protocol = protocol;\n                        // allow closing the write end of a not-yet-negotiated stream\n                        if (stream.closeWrite != null) {\n                            muxedStream.closeWrite = stream.closeWrite;\n                        }\n                        // allow closing the read end of a not-yet-negotiated stream\n                        if (stream.closeRead != null) {\n                            muxedStream.closeRead = stream.closeRead;\n                        }\n                        // make sure we don't try to negotiate a stream we are closing\n                        if (stream.close != null) {\n                            muxedStream.close = stream.close;\n                        }\n                        // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                        // the peerstore should ensure that the peer is registered with that protocol\n                        await this.components.peerStore.merge(remotePeer, {\n                            protocols: [\n                                protocol\n                            ]\n                        });\n                        this.components.metrics?.trackProtocolStream(muxedStream, connection);\n                        this._onStream({\n                            connection,\n                            stream: muxedStream,\n                            protocol\n                        });\n                    }).catch(async (err)=>{\n                        connection.log.error(\"error handling incoming stream id %s\", muxedStream.id, err.message, err.code, err.stack);\n                        if (muxedStream.timeline.close == null) {\n                            await muxedStream.close();\n                        }\n                    });\n                }\n            });\n            newStream = async (protocols, options = {})=>{\n                if (muxer == null) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"Stream is not multiplexed\", _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_MUXER_UNAVAILABLE);\n                }\n                connection.log(\"starting new stream for protocols %s\", protocols);\n                const muxedStream = await muxer.newStream();\n                connection.log.trace(\"started new stream %s for protocols %s\", muxedStream.id, protocols);\n                try {\n                    if (options.signal == null) {\n                        muxedStream.log(\"no abort signal was passed while trying to negotiate protocols %s falling back to default timeout\", protocols);\n                        const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT);\n                        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.setMaxListeners)(Infinity, signal);\n                        options = {\n                            ...options,\n                            signal\n                        };\n                    }\n                    muxedStream.log.trace(\"selecting protocol from protocols %s\", protocols);\n                    const { stream, protocol } = await _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_7__.select(muxedStream, protocols, {\n                        ...options,\n                        log: muxedStream.log,\n                        yieldBytes: true\n                    });\n                    muxedStream.log(\"selected protocol %s\", protocol);\n                    const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);\n                    const streamCount = countStreams(protocol, \"outbound\", connection);\n                    if (streamCount >= outgoingLimit) {\n                        const err = new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`, _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);\n                        muxedStream.abort(err);\n                        throw err;\n                    }\n                    // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                    // the peerstore should ensure that the peer is registered with that protocol\n                    await this.components.peerStore.merge(remotePeer, {\n                        protocols: [\n                            protocol\n                        ]\n                    });\n                    // after the handshake the returned stream can have early data so override\n                    // the souce/sink\n                    muxedStream.source = stream.source;\n                    muxedStream.sink = stream.sink;\n                    muxedStream.protocol = protocol;\n                    // allow closing the write end of a not-yet-negotiated stream\n                    if (stream.closeWrite != null) {\n                        muxedStream.closeWrite = stream.closeWrite;\n                    }\n                    // allow closing the read end of a not-yet-negotiated stream\n                    if (stream.closeRead != null) {\n                        muxedStream.closeRead = stream.closeRead;\n                    }\n                    // make sure we don't try to negotiate a stream we are closing\n                    if (stream.close != null) {\n                        muxedStream.close = stream.close;\n                    }\n                    this.components.metrics?.trackProtocolStream(muxedStream, connection);\n                    return muxedStream;\n                } catch (err) {\n                    connection.log.error(\"could not create new stream for protocols %s\", protocols, err);\n                    if (muxedStream.timeline.close == null) {\n                        muxedStream.abort(err);\n                    }\n                    if (err.code != null) {\n                        throw err;\n                    }\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_UNSUPPORTED_PROTOCOL);\n                }\n            };\n            // Pipe all data through the muxer\n            void Promise.all([\n                muxer.sink(upgradedConn.source),\n                upgradedConn.sink(muxer.source)\n            ]).catch((err)=>{\n                connection.log.error(\"error piping data through muxer\", err);\n            });\n        }\n        const _timeline = maConn.timeline;\n        maConn.timeline = new Proxy(_timeline, {\n            set: (...args)=>{\n                if (connection != null && args[1] === \"close\" && args[2] != null && _timeline.close == null) {\n                    // Wait for close to finish before notifying of the closure\n                    (async ()=>{\n                        try {\n                            if (connection.status === \"open\") {\n                                await connection.close();\n                            }\n                        } catch (err) {\n                            connection.log.error(\"error closing connection after timeline close\", err);\n                        } finally{\n                            this.events.safeDispatchEvent(\"connection:close\", {\n                                detail: connection\n                            });\n                        }\n                    })().catch((err)=>{\n                        connection.log.error(\"error thrown while dispatching connection:close event\", err);\n                    });\n                }\n                return Reflect.set(...args);\n            }\n        });\n        maConn.timeline.upgraded = Date.now();\n        const errConnectionNotMultiplexed = ()=>{\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"connection is not multiplexed\", _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n        };\n        // Create the connection\n        connection = (0,_connection_index_js__WEBPACK_IMPORTED_MODULE_8__.createConnection)({\n            remoteAddr: maConn.remoteAddr,\n            remotePeer,\n            status: \"open\",\n            direction,\n            timeline: maConn.timeline,\n            multiplexer: muxer?.protocol,\n            encryption: cryptoProtocol,\n            transient,\n            logger: this.components.logger,\n            newStream: newStream ?? errConnectionNotMultiplexed,\n            getStreams: ()=>{\n                if (muxer != null) {\n                    return muxer.streams;\n                } else {\n                    return [];\n                }\n            },\n            close: async (options)=>{\n                // Ensure remaining streams are closed gracefully\n                if (muxer != null) {\n                    connection.log.trace(\"close muxer\");\n                    await muxer.close(options);\n                }\n                connection.log.trace(\"close maconn\");\n                // close the underlying transport\n                await maConn.close(options);\n                connection.log.trace(\"closed maconn\");\n            },\n            abort: (err)=>{\n                maConn.abort(err);\n                // Ensure remaining streams are aborted\n                if (muxer != null) {\n                    muxer.abort(err);\n                }\n            }\n        });\n        this.events.safeDispatchEvent(\"connection:open\", {\n            detail: connection\n        });\n        return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     */ _onStream(opts) {\n        const { connection, stream, protocol } = opts;\n        const { handler, options } = this.components.registrar.getHandler(protocol);\n        if (connection.transient && options.runOnTransientConnection !== true) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(\"Cannot open protocol stream on transient connection\", \"ERR_TRANSIENT_CONNECTION\");\n        }\n        handler({\n            connection,\n            stream\n        });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n     */ async _encryptInbound(connection) {\n        const protocols = Array.from(this.connectionEncryption.keys());\n        connection.log(\"handling inbound crypto protocol selection\", protocols);\n        try {\n            const { stream, protocol } = await _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_6__.handle(connection, protocols, {\n                log: connection.log\n            });\n            const encrypter = this.connectionEncryption.get(protocol);\n            if (encrypter == null) {\n                throw new Error(`no crypto module found for ${protocol}`);\n            }\n            connection.log(\"encrypting inbound connection using\", protocol);\n            return {\n                ...await encrypter.secureInbound(this.components.peerId, stream),\n                protocol\n            };\n        } catch (err) {\n            connection.log.error(\"encrypting inbound connection to %p failed\", err);\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(err.message, _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_ENCRYPTION_FAILED);\n        }\n    }\n    /**\n     * Attempts to encrypt the given `connection` with the provided connection encrypters.\n     * The first `ConnectionEncrypter` module to succeed will be used\n     */ async _encryptOutbound(connection, remotePeerId) {\n        const protocols = Array.from(this.connectionEncryption.keys());\n        connection.log(\"selecting outbound crypto protocol\", protocols);\n        try {\n            connection.log.trace(\"selecting encrypter from %s\", protocols);\n            const { stream, protocol } = await _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_7__.select(connection, protocols, {\n                log: connection.log,\n                yieldBytes: true\n            });\n            const encrypter = this.connectionEncryption.get(protocol);\n            if (encrypter == null) {\n                throw new Error(`no crypto module found for ${protocol}`);\n            }\n            connection.log(\"encrypting outbound connection to %p using %s\", remotePeerId, encrypter);\n            return {\n                ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),\n                protocol\n            };\n        } catch (err) {\n            connection.log.error(\"encrypting outbound connection to %p failed\", err);\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(err.message, _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_ENCRYPTION_FAILED);\n        }\n    }\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     */ async _multiplexOutbound(connection, muxers) {\n        const protocols = Array.from(muxers.keys());\n        connection.log(\"outbound selecting muxer %s\", protocols);\n        try {\n            connection.log.trace(\"selecting stream muxer from %s\", protocols);\n            const { stream, protocol } = await _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_7__.select(connection, protocols, {\n                log: connection.log,\n                yieldBytes: true\n            });\n            connection.log(\"selected %s as muxer protocol\", protocol);\n            const muxerFactory = muxers.get(protocol);\n            return {\n                stream,\n                muxerFactory\n            };\n        } catch (err) {\n            connection.log.error(\"error multiplexing outbound connection\", err);\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_MUXER_UNAVAILABLE);\n        }\n    }\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     */ async _multiplexInbound(connection, muxers) {\n        const protocols = Array.from(muxers.keys());\n        connection.log(\"inbound handling muxers %s\", protocols);\n        try {\n            const { stream, protocol } = await _libp2p_multistream_select__WEBPACK_IMPORTED_MODULE_6__.handle(connection, protocols, {\n                log: connection.log\n            });\n            const muxerFactory = muxers.get(protocol);\n            return {\n                stream,\n                muxerFactory\n            };\n        } catch (err) {\n            connection.log.error(\"error multiplexing inbound connection\", err);\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), _errors_js__WEBPACK_IMPORTED_MODULE_0__.codes.ERR_MUXER_UNAVAILABLE);\n        }\n    }\n} //# sourceMappingURL=upgrader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL3VwZ3JhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNEU7QUFDMUI7QUFDQztBQUNNO0FBQ21CO0FBQ3hDO0FBQ3VEO0FBQzNGLE1BQU1VLGtDQUFrQztBQUN4QyxTQUFTQyx3QkFBd0JDLFFBQVEsRUFBRUMsU0FBUztJQUNoRCxJQUFJO1FBQ0EsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0QsVUFBVUUsVUFBVSxDQUFDSDtRQUN6QyxPQUFPRSxRQUFRRSxpQkFBaUI7SUFDcEMsRUFDQSxPQUFPQyxLQUFLO1FBQ1IsSUFBSUEsSUFBSUMsSUFBSSxLQUFLWCw2Q0FBS0EsQ0FBQ1ksMkJBQTJCLEVBQUU7WUFDaEQsTUFBTUY7UUFDVjtJQUNKO0lBQ0EsT0FBT1Qsc0VBQTJCQTtBQUN0QztBQUNBLFNBQVNZLHdCQUF3QlIsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzlELElBQUk7UUFDQSxNQUFNLEVBQUVBLE9BQU8sRUFBRSxHQUFHRCxVQUFVRSxVQUFVLENBQUNIO1FBQ3pDLElBQUlFLFFBQVFPLGtCQUFrQixJQUFJLE1BQU07WUFDcEMsT0FBT1AsUUFBUU8sa0JBQWtCO1FBQ3JDO0lBQ0osRUFDQSxPQUFPSixLQUFLO1FBQ1IsSUFBSUEsSUFBSUMsSUFBSSxLQUFLWCw2Q0FBS0EsQ0FBQ1ksMkJBQTJCLEVBQUU7WUFDaEQsTUFBTUY7UUFDVjtJQUNKO0lBQ0EsT0FBT0gsUUFBUU8sa0JBQWtCLElBQUlaLHVFQUE0QkE7QUFDckU7QUFDQSxTQUFTYSxhQUFhVixRQUFRLEVBQUVXLFNBQVMsRUFBRUMsVUFBVTtJQUNqRCxJQUFJQyxjQUFjO0lBQ2xCRCxXQUFXRSxPQUFPLENBQUNDLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDdkIsSUFBSUEsT0FBT0wsU0FBUyxLQUFLQSxhQUFhSyxPQUFPaEIsUUFBUSxLQUFLQSxVQUFVO1lBQ2hFYTtRQUNKO0lBQ0o7SUFD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QUFxQjtRQUNoRTtJQUNKO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9saWJwMnAvZGlzdC9zcmMvdXBncmFkZXIuanM/YTg4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRXJyb3IsIEVSUl9USU1FT1VULCBzZXRNYXhMaXN0ZW5lcnMgfSBmcm9tICdAbGlicDJwL2ludGVyZmFjZSc7XG5pbXBvcnQgKiBhcyBtc3MgZnJvbSAnQGxpYnAycC9tdWx0aXN0cmVhbS1zZWxlY3QnO1xuaW1wb3J0IHsgcGVlcklkRnJvbVN0cmluZyB9IGZyb20gJ0BsaWJwMnAvcGVlci1pZCc7XG5pbXBvcnQgeyBjcmVhdGVDb25uZWN0aW9uIH0gZnJvbSAnLi9jb25uZWN0aW9uL2luZGV4LmpzJztcbmltcG9ydCB7IElOQk9VTkRfVVBHUkFERV9USU1FT1VUIH0gZnJvbSAnLi9jb25uZWN0aW9uLW1hbmFnZXIvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGNvZGVzIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVGQVVMVF9NQVhfSU5CT1VORF9TVFJFQU1TLCBERUZBVUxUX01BWF9PVVRCT1VORF9TVFJFQU1TIH0gZnJvbSAnLi9yZWdpc3RyYXIuanMnO1xuY29uc3QgREVGQVVMVF9QUk9UT0NPTF9TRUxFQ1RfVElNRU9VVCA9IDMwMDAwO1xuZnVuY3Rpb24gZmluZEluY29taW5nU3RyZWFtTGltaXQocHJvdG9jb2wsIHJlZ2lzdHJhcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcmVnaXN0cmFyLmdldEhhbmRsZXIocHJvdG9jb2wpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5tYXhJbmJvdW5kU3RyZWFtcztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgIT09IGNvZGVzLkVSUl9OT19IQU5ETEVSX0ZPUl9QUk9UT0NPTCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBERUZBVUxUX01BWF9JTkJPVU5EX1NUUkVBTVM7XG59XG5mdW5jdGlvbiBmaW5kT3V0Z29pbmdTdHJlYW1MaW1pdChwcm90b2NvbCwgcmVnaXN0cmFyLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHJlZ2lzdHJhci5nZXRIYW5kbGVyKHByb3RvY29sKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4T3V0Ym91bmRTdHJlYW1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1heE91dGJvdW5kU3RyZWFtcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gY29kZXMuRVJSX05PX0hBTkRMRVJfRk9SX1BST1RPQ09MKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMubWF4T3V0Ym91bmRTdHJlYW1zID8/IERFRkFVTFRfTUFYX09VVEJPVU5EX1NUUkVBTVM7XG59XG5mdW5jdGlvbiBjb3VudFN0cmVhbXMocHJvdG9jb2wsIGRpcmVjdGlvbiwgY29ubmVjdGlvbikge1xuICAgIGxldCBzdHJlYW1Db3VudCA9IDA7XG4gICAgY29ubmVjdGlvbi5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgaWYgKHN0cmVhbS5kaXJlY3Rpb24gPT09IGRpcmVjdGlvbiAmJiBzdHJlYW0ucHJvdG9jb2wgPT09IHByb3RvY29sKSB7XG4gICAgICAgICAgICBzdHJlYW1Db3VudCsrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbUNvdW50O1xufVxuZXhwb3J0IGNsYXNzIERlZmF1bHRVcGdyYWRlciB7XG4gICAgY29tcG9uZW50cztcbiAgICBjb25uZWN0aW9uRW5jcnlwdGlvbjtcbiAgICBtdXhlcnM7XG4gICAgaW5ib3VuZFVwZ3JhZGVUaW1lb3V0O1xuICAgIGV2ZW50cztcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzLCBpbml0KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkVuY3J5cHRpb24gPSBuZXcgTWFwKCk7XG4gICAgICAgIGluaXQuY29ubmVjdGlvbkVuY3J5cHRpb24uZm9yRWFjaChlbmNyeXB0ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uRW5jcnlwdGlvbi5zZXQoZW5jcnlwdGVyLnByb3RvY29sLCBlbmNyeXB0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXhlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGluaXQubXV4ZXJzLmZvckVhY2gobXV4ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5tdXhlcnMuc2V0KG11eGVyLnByb3RvY29sLCBtdXhlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluYm91bmRVcGdyYWRlVGltZW91dCA9IGluaXQuaW5ib3VuZFVwZ3JhZGVUaW1lb3V0ID8/IElOQk9VTkRfVVBHUkFERV9USU1FT1VUO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IGNvbXBvbmVudHMuZXZlbnRzO1xuICAgIH1cbiAgICBhc3luYyBzaG91bGRCbG9ja0Nvbm5lY3Rpb24ocmVtb3RlUGVlciwgbWFDb25uLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uR2F0ZXIgPSB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbkdhdGVyW2Nvbm5lY3Rpb25UeXBlXTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25HYXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgY29ubmVjdGlvbkdhdGVyKHJlbW90ZVBlZXIsIG1hQ29ubikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKGBUaGUgbXVsdGlhZGRyIGNvbm5lY3Rpb24gaXMgYmxvY2tlZCBieSBnYXRlci4ke2Nvbm5lY3Rpb25UeXBlfWAsIGNvZGVzLkVSUl9DT05ORUNUSU9OX0lOVEVSQ0VQVEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGdyYWRlcyBhbiBpbmJvdW5kIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyB1cGdyYWRlSW5ib3VuZChtYUNvbm4sIG9wdHMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ID0gYXdhaXQgdGhpcy5jb21wb25lbnRzLmNvbm5lY3Rpb25NYW5hZ2VyLmFjY2VwdEluY29taW5nQ29ubmVjdGlvbihtYUNvbm4pO1xuICAgICAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignY29ubmVjdGlvbiBkZW5pZWQnLCBjb2Rlcy5FUlJfQ09OTkVDVElPTl9ERU5JRUQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmNyeXB0ZWRDb25uO1xuICAgICAgICBsZXQgcmVtb3RlUGVlcjtcbiAgICAgICAgbGV0IHVwZ3JhZGVkQ29ubjtcbiAgICAgICAgbGV0IG11eGVyRmFjdG9yeTtcbiAgICAgICAgbGV0IGNyeXB0b1Byb3RvY29sO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMuaW5ib3VuZFVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgIG1hQ29ubi5hYm9ydChuZXcgQ29kZUVycm9yKCdpbmJvdW5kIHVwZ3JhZGUgdGltZW91dCcsIEVSUl9USU1FT1VUKSk7XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5LCBzaWduYWwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChhd2FpdCB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvbkdhdGVyLmRlbnlJbmJvdW5kQ29ubmVjdGlvbj8uKG1hQ29ubikpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignVGhlIG11bHRpYWRkciBjb25uZWN0aW9uIGlzIGJsb2NrZWQgYnkgZ2F0ZXIuYWNjZXB0Q29ubmVjdGlvbicsIGNvZGVzLkVSUl9DT05ORUNUSU9OX0lOVEVSQ0VQVEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5tZXRyaWNzPy50cmFja011bHRpYWRkckNvbm5lY3Rpb24obWFDb25uKTtcbiAgICAgICAgICAgIG1hQ29ubi5sb2coJ3N0YXJ0aW5nIHRoZSBpbmJvdW5kIGNvbm5lY3Rpb24gdXBncmFkZScpO1xuICAgICAgICAgICAgLy8gUHJvdGVjdFxuICAgICAgICAgICAgbGV0IHByb3RlY3RlZENvbm4gPSBtYUNvbm47XG4gICAgICAgICAgICBpZiAob3B0cz8uc2tpcFByb3RlY3Rpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm90ZWN0b3IgPSB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvblByb3RlY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAocHJvdGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFDb25uLmxvZygncHJvdGVjdGluZyB0aGUgaW5ib3VuZCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3RlY3RlZENvbm4gPSBhd2FpdCBwcm90ZWN0b3IucHJvdGVjdChtYUNvbm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gRW5jcnlwdCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGVuY3J5cHRlZENvbm4gPSBwcm90ZWN0ZWRDb25uO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzPy5za2lwRW5jcnlwdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubjogZW5jcnlwdGVkQ29ubixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVBlZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogY3J5cHRvUHJvdG9jb2xcbiAgICAgICAgICAgICAgICAgICAgfSA9IGF3YWl0IHRoaXMuX2VuY3J5cHRJbmJvdW5kKHByb3RlY3RlZENvbm4pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFDb25uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJvdGVjdGVkQ29ubixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmVuY3J5cHRlZENvbm5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zaG91bGRCbG9ja0Nvbm5lY3Rpb24ocmVtb3RlUGVlciwgbWFDb25uLCAnZGVueUluYm91bmRFbmNyeXB0ZWRDb25uZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZFN0ciA9IG1hQ29ubi5yZW1vdGVBZGRyLmdldFBlZXJJZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWRTdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignaW5ib3VuZCBjb25uZWN0aW9uIHRoYXQgc2tpcHBlZCBlbmNyeXB0aW9uIG11c3QgaGF2ZSBhIHBlZXIgaWQnLCBjb2Rlcy5FUlJfSU5WQUxJRF9NVUxUSUFERFIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZVBlZXJJZCA9IHBlZXJJZEZyb21TdHJpbmcoaWRTdHIpO1xuICAgICAgICAgICAgICAgICAgICBjcnlwdG9Qcm90b2NvbCA9ICduYXRpdmUnO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVQZWVyID0gcmVtb3RlUGVlcklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGdyYWRlZENvbm4gPSBlbmNyeXB0ZWRDb25uO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzPy5tdXhlckZhY3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtdXhlckZhY3RvcnkgPSBvcHRzLm11eGVyRmFjdG9yeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tdXhlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGlwbGV4IHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG11bHRpcGxleGVkID0gYXdhaXQgdGhpcy5fbXVsdGlwbGV4SW5ib3VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm90ZWN0ZWRDb25uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZW5jcnlwdGVkQ29ublxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm11eGVycyk7XG4gICAgICAgICAgICAgICAgICAgIG11eGVyRmFjdG9yeSA9IG11bHRpcGxleGVkLm11eGVyRmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZWRDb25uID0gbXVsdGlwbGV4ZWQuc3RyZWFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBtYUNvbm4ubG9nLmVycm9yKCdmYWlsZWQgdG8gdXBncmFkZSBpbmJvdW5kIGNvbm5lY3Rpb24nLCBlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2hvdWxkQmxvY2tDb25uZWN0aW9uKHJlbW90ZVBlZXIsIG1hQ29ubiwgJ2RlbnlJbmJvdW5kVXBncmFkZWRDb25uZWN0aW9uJyk7XG4gICAgICAgICAgICBtYUNvbm4ubG9nKCdzdWNjZXNzZnVsbHkgdXBncmFkZWQgaW5ib3VuZCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgY3J5cHRvUHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnaW5ib3VuZCcsXG4gICAgICAgICAgICAgICAgbWFDb25uLFxuICAgICAgICAgICAgICAgIHVwZ3JhZGVkQ29ubixcbiAgICAgICAgICAgICAgICBtdXhlckZhY3RvcnksXG4gICAgICAgICAgICAgICAgcmVtb3RlUGVlcixcbiAgICAgICAgICAgICAgICB0cmFuc2llbnQ6IG9wdHM/LnRyYW5zaWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5jb25uZWN0aW9uTWFuYWdlci5hZnRlclVwZ3JhZGVJbmJvdW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBncmFkZXMgYW4gb3V0Ym91bmQgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIHVwZ3JhZGVPdXRib3VuZChtYUNvbm4sIG9wdHMpIHtcbiAgICAgICAgY29uc3QgaWRTdHIgPSBtYUNvbm4ucmVtb3RlQWRkci5nZXRQZWVySWQoKTtcbiAgICAgICAgbGV0IHJlbW90ZVBlZXJJZDtcbiAgICAgICAgaWYgKGlkU3RyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW90ZVBlZXJJZCA9IHBlZXJJZEZyb21TdHJpbmcoaWRTdHIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaG91bGRCbG9ja0Nvbm5lY3Rpb24ocmVtb3RlUGVlcklkLCBtYUNvbm4sICdkZW55T3V0Ym91bmRDb25uZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuY3J5cHRlZENvbm47XG4gICAgICAgIGxldCByZW1vdGVQZWVyO1xuICAgICAgICBsZXQgdXBncmFkZWRDb25uO1xuICAgICAgICBsZXQgY3J5cHRvUHJvdG9jb2w7XG4gICAgICAgIGxldCBtdXhlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5tZXRyaWNzPy50cmFja011bHRpYWRkckNvbm5lY3Rpb24obWFDb25uKTtcbiAgICAgICAgbWFDb25uLmxvZygnc3RhcnRpbmcgdGhlIG91dGJvdW5kIGNvbm5lY3Rpb24gdXBncmFkZScpO1xuICAgICAgICAvLyBJZiB0aGUgdHJhbnNwb3J0IG5hdGl2ZWx5IHN1cHBvcnRzIGVuY3J5cHRpb24sIHNraXAgY29ubmVjdGlvblxuICAgICAgICAvLyBwcm90ZWN0b3IgYW5kIGVuY3J5cHRpb25cbiAgICAgICAgLy8gUHJvdGVjdFxuICAgICAgICBsZXQgcHJvdGVjdGVkQ29ubiA9IG1hQ29ubjtcbiAgICAgICAgaWYgKG9wdHM/LnNraXBQcm90ZWN0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90ZWN0b3IgPSB0aGlzLmNvbXBvbmVudHMuY29ubmVjdGlvblByb3RlY3RvcjtcbiAgICAgICAgICAgIGlmIChwcm90ZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZENvbm4gPSBhd2FpdCBwcm90ZWN0b3IucHJvdGVjdChtYUNvbm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFbmNyeXB0IHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICBlbmNyeXB0ZWRDb25uID0gcHJvdGVjdGVkQ29ubjtcbiAgICAgICAgICAgIGlmIChvcHRzPy5za2lwRW5jcnlwdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgICAgICAgIGNvbm46IGVuY3J5cHRlZENvbm4sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVBlZXIsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBjcnlwdG9Qcm90b2NvbFxuICAgICAgICAgICAgICAgIH0gPSBhd2FpdCB0aGlzLl9lbmNyeXB0T3V0Ym91bmQocHJvdGVjdGVkQ29ubiwgcmVtb3RlUGVlcklkKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFDb25uID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5wcm90ZWN0ZWRDb25uLFxuICAgICAgICAgICAgICAgICAgICAuLi5lbmNyeXB0ZWRDb25uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNob3VsZEJsb2NrQ29ubmVjdGlvbihyZW1vdGVQZWVyLCBtYUNvbm4sICdkZW55T3V0Ym91bmRFbmNyeXB0ZWRDb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlUGVlcklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignRW5jcnlwdGlvbiB3YXMgc2tpcHBlZCBidXQgbm8gcGVlciBpZCB3YXMgcGFzc2VkJywgY29kZXMuRVJSX0lOVkFMSURfUEVFUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyeXB0b1Byb3RvY29sID0gJ25hdGl2ZSc7XG4gICAgICAgICAgICAgICAgcmVtb3RlUGVlciA9IHJlbW90ZVBlZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZ3JhZGVkQ29ubiA9IGVuY3J5cHRlZENvbm47XG4gICAgICAgICAgICBpZiAob3B0cz8ubXV4ZXJGYWN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtdXhlckZhY3RvcnkgPSBvcHRzLm11eGVyRmFjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubXV4ZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbGV4IHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgbXVsdGlwbGV4ZWQgPSBhd2FpdCB0aGlzLl9tdWx0aXBsZXhPdXRib3VuZCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3RlY3RlZENvbm4sXG4gICAgICAgICAgICAgICAgICAgIC4uLmVuY3J5cHRlZENvbm5cbiAgICAgICAgICAgICAgICB9LCB0aGlzLm11eGVycyk7XG4gICAgICAgICAgICAgICAgbXV4ZXJGYWN0b3J5ID0gbXVsdGlwbGV4ZWQubXV4ZXJGYWN0b3J5O1xuICAgICAgICAgICAgICAgIHVwZ3JhZGVkQ29ubiA9IG11bHRpcGxleGVkLnN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBtYUNvbm4ubG9nLmVycm9yKCdmYWlsZWQgdG8gdXBncmFkZSBvdXRib3VuZCBjb25uZWN0aW9uJywgZXJyKTtcbiAgICAgICAgICAgIGF3YWl0IG1hQ29ubi5jbG9zZShlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2hvdWxkQmxvY2tDb25uZWN0aW9uKHJlbW90ZVBlZXIsIG1hQ29ubiwgJ2RlbnlPdXRib3VuZFVwZ3JhZGVkQ29ubmVjdGlvbicpO1xuICAgICAgICBtYUNvbm4ubG9nKCdzdWNjZXNzZnVsbHkgdXBncmFkZWQgb3V0Ym91bmQgY29ubmVjdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBjcnlwdG9Qcm90b2NvbCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ291dGJvdW5kJyxcbiAgICAgICAgICAgIG1hQ29ubixcbiAgICAgICAgICAgIHVwZ3JhZGVkQ29ubixcbiAgICAgICAgICAgIG11eGVyRmFjdG9yeSxcbiAgICAgICAgICAgIHJlbW90ZVBlZXIsXG4gICAgICAgICAgICB0cmFuc2llbnQ6IG9wdHM/LnRyYW5zaWVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgYSBuZXcgYENvbm5lY3Rpb25gXG4gICAgICovXG4gICAgX2NyZWF0ZUNvbm5lY3Rpb24ob3B0cykge1xuICAgICAgICBjb25zdCB7IGNyeXB0b1Byb3RvY29sLCBkaXJlY3Rpb24sIG1hQ29ubiwgdXBncmFkZWRDb25uLCByZW1vdGVQZWVyLCBtdXhlckZhY3RvcnksIHRyYW5zaWVudCB9ID0gb3B0cztcbiAgICAgICAgbGV0IG11eGVyO1xuICAgICAgICBsZXQgbmV3U3RyZWFtO1xuICAgICAgICBsZXQgY29ubmVjdGlvbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgaWYgKG11eGVyRmFjdG9yeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG11eGVyXG4gICAgICAgICAgICBtdXhlciA9IG11eGVyRmFjdG9yeS5jcmVhdGVTdHJlYW1NdXhlcih7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIC8vIFJ1biBhbnl0aW1lIGEgcmVtb3RlIHN0cmVhbSBpcyBjcmVhdGVkXG4gICAgICAgICAgICAgICAgb25JbmNvbWluZ1N0cmVhbTogbXV4ZWRTdHJlYW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xzID0gdGhpcy5jb21wb25lbnRzLnJlZ2lzdHJhci5nZXRQcm90b2NvbHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RyZWFtLCBwcm90b2NvbCB9ID0gYXdhaXQgbXNzLmhhbmRsZShtdXhlZFN0cmVhbSwgcHJvdG9jb2xzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nOiBtdXhlZFN0cmVhbS5sb2csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGRCeXRlczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9nKCdpbmNvbWluZyBzdHJlYW0gb3BlbmVkIG9uICVzJywgcHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmdMaW1pdCA9IGZpbmRJbmNvbWluZ1N0cmVhbUxpbWl0KHByb3RvY29sLCB0aGlzLmNvbXBvbmVudHMucmVnaXN0cmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbUNvdW50ID0gY291bnRTdHJlYW1zKHByb3RvY29sLCAnaW5ib3VuZCcsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbUNvdW50ID09PSBpbmNvbWluZ0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IENvZGVFcnJvcihgVG9vIG1hbnkgaW5ib3VuZCBwcm90b2NvbCBzdHJlYW1zIGZvciBwcm90b2NvbCBcIiR7cHJvdG9jb2x9XCIgLSBsaW1pdCAke2luY29taW5nTGltaXR9YCwgY29kZXMuRVJSX1RPT19NQU5ZX0lOQk9VTkRfUFJPVE9DT0xfU1RSRUFNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV4ZWRTdHJlYW0uYWJvcnQoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgaGFuZHNoYWtlIHRoZSByZXR1cm5lZCBzdHJlYW0gY2FuIGhhdmUgZWFybHkgZGF0YSBzbyBvdmVycmlkZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNvdWNlL3NpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11eGVkU3RyZWFtLnNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5zaW5rID0gc3RyZWFtLnNpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgY2xvc2luZyB0aGUgd3JpdGUgZW5kIG9mIGEgbm90LXlldC1uZWdvdGlhdGVkIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5jbG9zZVdyaXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5jbG9zZVdyaXRlID0gc3RyZWFtLmNsb3NlV3JpdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBjbG9zaW5nIHRoZSByZWFkIGVuZCBvZiBhIG5vdC15ZXQtbmVnb3RpYXRlZCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY2xvc2VSZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5jbG9zZVJlYWQgPSBzdHJlYW0uY2xvc2VSZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IHRyeSB0byBuZWdvdGlhdGUgYSBzdHJlYW0gd2UgYXJlIGNsb3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY2xvc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11eGVkU3RyZWFtLmNsb3NlID0gc3RyZWFtLmNsb3NlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBwcm90b2NvbCBzdHJlYW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG5lZ290aWF0ZWQgYW5kIGlzIHRvIGJlIHBhc3NlZCB0byB0aGUgYXBwbGljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGVlcnN0b3JlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgcGVlciBpcyByZWdpc3RlcmVkIHdpdGggdGhhdCBwcm90b2NvbFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wb25lbnRzLnBlZXJTdG9yZS5tZXJnZShyZW1vdGVQZWVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzOiBbcHJvdG9jb2xdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5tZXRyaWNzPy50cmFja1Byb3RvY29sU3RyZWFtKG11eGVkU3RyZWFtLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uU3RyZWFtKHsgY29ubmVjdGlvbiwgc3RyZWFtOiBtdXhlZFN0cmVhbSwgcHJvdG9jb2wgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cuZXJyb3IoJ2Vycm9yIGhhbmRsaW5nIGluY29taW5nIHN0cmVhbSBpZCAlcycsIG11eGVkU3RyZWFtLmlkLCBlcnIubWVzc2FnZSwgZXJyLmNvZGUsIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV4ZWRTdHJlYW0udGltZWxpbmUuY2xvc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG11eGVkU3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3U3RyZWFtID0gYXN5bmMgKHByb3RvY29scywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG11eGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignU3RyZWFtIGlzIG5vdCBtdWx0aXBsZXhlZCcsIGNvZGVzLkVSUl9NVVhFUl9VTkFWQUlMQUJMRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9nKCdzdGFydGluZyBuZXcgc3RyZWFtIGZvciBwcm90b2NvbHMgJXMnLCBwcm90b2NvbHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG11eGVkU3RyZWFtID0gYXdhaXQgbXV4ZXIubmV3U3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cudHJhY2UoJ3N0YXJ0ZWQgbmV3IHN0cmVhbSAlcyBmb3IgcHJvdG9jb2xzICVzJywgbXV4ZWRTdHJlYW0uaWQsIHByb3RvY29scyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11eGVkU3RyZWFtLmxvZygnbm8gYWJvcnQgc2lnbmFsIHdhcyBwYXNzZWQgd2hpbGUgdHJ5aW5nIHRvIG5lZ290aWF0ZSBwcm90b2NvbHMgJXMgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQgdGltZW91dCcsIHByb3RvY29scyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KERFRkFVTFRfUFJPVE9DT0xfU0VMRUNUX1RJTUVPVVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5LCBzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5sb2cudHJhY2UoJ3NlbGVjdGluZyBwcm90b2NvbCBmcm9tIHByb3RvY29scyAlcycsIHByb3RvY29scyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RyZWFtLCBwcm90b2NvbCB9ID0gYXdhaXQgbXNzLnNlbGVjdChtdXhlZFN0cmVhbSwgcHJvdG9jb2xzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nOiBtdXhlZFN0cmVhbS5sb2csXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZEJ5dGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5sb2coJ3NlbGVjdGVkIHByb3RvY29sICVzJywgcHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRnb2luZ0xpbWl0ID0gZmluZE91dGdvaW5nU3RyZWFtTGltaXQocHJvdG9jb2wsIHRoaXMuY29tcG9uZW50cy5yZWdpc3RyYXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1Db3VudCA9IGNvdW50U3RyZWFtcyhwcm90b2NvbCwgJ291dGJvdW5kJywgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1Db3VudCA+PSBvdXRnb2luZ0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgQ29kZUVycm9yKGBUb28gbWFueSBvdXRib3VuZCBwcm90b2NvbCBzdHJlYW1zIGZvciBwcm90b2NvbCBcIiR7cHJvdG9jb2x9XCIgLSBsaW1pdCAke291dGdvaW5nTGltaXR9YCwgY29kZXMuRVJSX1RPT19NQU5ZX09VVEJPVU5EX1BST1RPQ09MX1NUUkVBTVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV4ZWRTdHJlYW0uYWJvcnQoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHByb3RvY29sIHN0cmVhbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbmVnb3RpYXRlZCBhbmQgaXMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHBsaWNhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBlZXJzdG9yZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHBlZXIgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoYXQgcHJvdG9jb2xcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wb25lbnRzLnBlZXJTdG9yZS5tZXJnZShyZW1vdGVQZWVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHM6IFtwcm90b2NvbF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBoYW5kc2hha2UgdGhlIHJldHVybmVkIHN0cmVhbSBjYW4gaGF2ZSBlYXJseSBkYXRhIHNvIG92ZXJyaWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzb3VjZS9zaW5rXG4gICAgICAgICAgICAgICAgICAgIG11eGVkU3RyZWFtLnNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIG11eGVkU3RyZWFtLnNpbmsgPSBzdHJlYW0uc2luaztcbiAgICAgICAgICAgICAgICAgICAgbXV4ZWRTdHJlYW0ucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgY2xvc2luZyB0aGUgd3JpdGUgZW5kIG9mIGEgbm90LXlldC1uZWdvdGlhdGVkIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNsb3NlV3JpdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV4ZWRTdHJlYW0uY2xvc2VXcml0ZSA9IHN0cmVhbS5jbG9zZVdyaXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IGNsb3NpbmcgdGhlIHJlYWQgZW5kIG9mIGEgbm90LXlldC1uZWdvdGlhdGVkIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNsb3NlUmVhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXhlZFN0cmVhbS5jbG9zZVJlYWQgPSBzdHJlYW0uY2xvc2VSZWFkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCB0cnkgdG8gbmVnb3RpYXRlIGEgc3RyZWFtIHdlIGFyZSBjbG9zaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY2xvc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV4ZWRTdHJlYW0uY2xvc2UgPSBzdHJlYW0uY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLm1ldHJpY3M/LnRyYWNrUHJvdG9jb2xTdHJlYW0obXV4ZWRTdHJlYW0sIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXV4ZWRTdHJlYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBjcmVhdGUgbmV3IHN0cmVhbSBmb3IgcHJvdG9jb2xzICVzJywgcHJvdG9jb2xzLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXV4ZWRTdHJlYW0udGltZWxpbmUuY2xvc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV4ZWRTdHJlYW0uYWJvcnQoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb2RlRXJyb3IoU3RyaW5nKGVyciksIGNvZGVzLkVSUl9VTlNVUFBPUlRFRF9QUk9UT0NPTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFBpcGUgYWxsIGRhdGEgdGhyb3VnaCB0aGUgbXV4ZXJcbiAgICAgICAgICAgIHZvaWQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG11eGVyLnNpbmsodXBncmFkZWRDb25uLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgdXBncmFkZWRDb25uLnNpbmsobXV4ZXIuc291cmNlKVxuICAgICAgICAgICAgXSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxvZy5lcnJvcignZXJyb3IgcGlwaW5nIGRhdGEgdGhyb3VnaCBtdXhlcicsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfdGltZWxpbmUgPSBtYUNvbm4udGltZWxpbmU7XG4gICAgICAgIG1hQ29ubi50aW1lbGluZSA9IG5ldyBQcm94eShfdGltZWxpbmUsIHtcbiAgICAgICAgICAgIHNldDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAhPSBudWxsICYmIGFyZ3NbMV0gPT09ICdjbG9zZScgJiYgYXJnc1syXSAhPSBudWxsICYmIF90aW1lbGluZS5jbG9zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGNsb3NlIHRvIGZpbmlzaCBiZWZvcmUgbm90aWZ5aW5nIG9mIHRoZSBjbG9zdXJlXG4gICAgICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXR1cyA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cuZXJyb3IoJ2Vycm9yIGNsb3NpbmcgY29ubmVjdGlvbiBhZnRlciB0aW1lbGluZSBjbG9zZScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5zYWZlRGlzcGF0Y2hFdmVudCgnY29ubmVjdGlvbjpjbG9zZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9nLmVycm9yKCdlcnJvciB0aHJvd24gd2hpbGUgZGlzcGF0Y2hpbmcgY29ubmVjdGlvbjpjbG9zZSBldmVudCcsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtYUNvbm4udGltZWxpbmUudXBncmFkZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBlcnJDb25uZWN0aW9uTm90TXVsdGlwbGV4ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKCdjb25uZWN0aW9uIGlzIG5vdCBtdWx0aXBsZXhlZCcsIGNvZGVzLkVSUl9DT05ORUNUSU9OX05PVF9NVUxUSVBMRVhFRCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY29ubmVjdGlvblxuICAgICAgICBjb25uZWN0aW9uID0gY3JlYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICByZW1vdGVBZGRyOiBtYUNvbm4ucmVtb3RlQWRkcixcbiAgICAgICAgICAgIHJlbW90ZVBlZXIsXG4gICAgICAgICAgICBzdGF0dXM6ICdvcGVuJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgIHRpbWVsaW5lOiBtYUNvbm4udGltZWxpbmUsXG4gICAgICAgICAgICBtdWx0aXBsZXhlcjogbXV4ZXI/LnByb3RvY29sLFxuICAgICAgICAgICAgZW5jcnlwdGlvbjogY3J5cHRvUHJvdG9jb2wsXG4gICAgICAgICAgICB0cmFuc2llbnQsXG4gICAgICAgICAgICBsb2dnZXI6IHRoaXMuY29tcG9uZW50cy5sb2dnZXIsXG4gICAgICAgICAgICBuZXdTdHJlYW06IG5ld1N0cmVhbSA/PyBlcnJDb25uZWN0aW9uTm90TXVsdGlwbGV4ZWQsXG4gICAgICAgICAgICBnZXRTdHJlYW1zOiAoKSA9PiB7IGlmIChtdXhlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11eGVyLnN0cmVhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjbG9zZTogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgcmVtYWluaW5nIHN0cmVhbXMgYXJlIGNsb3NlZCBncmFjZWZ1bGx5XG4gICAgICAgICAgICAgICAgaWYgKG11eGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cudHJhY2UoJ2Nsb3NlIG11eGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG11eGVyLmNsb3NlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxvZy50cmFjZSgnY2xvc2UgbWFjb25uJyk7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgYXdhaXQgbWFDb25uLmNsb3NlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9nLnRyYWNlKCdjbG9zZWQgbWFjb25uJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWJvcnQ6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBtYUNvbm4uYWJvcnQoZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgcmVtYWluaW5nIHN0cmVhbXMgYXJlIGFib3J0ZWRcbiAgICAgICAgICAgICAgICBpZiAobXV4ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtdXhlci5hYm9ydChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnNhZmVEaXNwYXRjaEV2ZW50KCdjb25uZWN0aW9uOm9wZW4nLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGNvbm5lY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3V0ZXMgaW5jb21pbmcgc3RyZWFtcyB0byB0aGUgY29ycmVjdCBoYW5kbGVyXG4gICAgICovXG4gICAgX29uU3RyZWFtKG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uLCBzdHJlYW0sIHByb3RvY29sIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZXIsIG9wdGlvbnMgfSA9IHRoaXMuY29tcG9uZW50cy5yZWdpc3RyYXIuZ2V0SGFuZGxlcihwcm90b2NvbCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnRyYW5zaWVudCAmJiBvcHRpb25zLnJ1bk9uVHJhbnNpZW50Q29ubmVjdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcignQ2Fubm90IG9wZW4gcHJvdG9jb2wgc3RyZWFtIG9uIHRyYW5zaWVudCBjb25uZWN0aW9uJywgJ0VSUl9UUkFOU0lFTlRfQ09OTkVDVElPTicpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXIoeyBjb25uZWN0aW9uLCBzdHJlYW0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGVuY3J5cHQgdGhlIGluY29taW5nIGBjb25uZWN0aW9uYCB3aXRoIHRoZSBwcm92aWRlZCBgY3J5cHRvc2BcbiAgICAgKi9cbiAgICBhc3luYyBfZW5jcnlwdEluYm91bmQoY29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGlvbkVuY3J5cHRpb24ua2V5cygpKTtcbiAgICAgICAgY29ubmVjdGlvbi5sb2coJ2hhbmRsaW5nIGluYm91bmQgY3J5cHRvIHByb3RvY29sIHNlbGVjdGlvbicsIHByb3RvY29scyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgcHJvdG9jb2wgfSA9IGF3YWl0IG1zcy5oYW5kbGUoY29ubmVjdGlvbiwgcHJvdG9jb2xzLCB7XG4gICAgICAgICAgICAgICAgbG9nOiBjb25uZWN0aW9uLmxvZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZXIgPSB0aGlzLmNvbm5lY3Rpb25FbmNyeXB0aW9uLmdldChwcm90b2NvbCk7XG4gICAgICAgICAgICBpZiAoZW5jcnlwdGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGNyeXB0byBtb2R1bGUgZm91bmQgZm9yICR7cHJvdG9jb2x9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0aW9uLmxvZygnZW5jcnlwdGluZyBpbmJvdW5kIGNvbm5lY3Rpb24gdXNpbmcnLCBwcm90b2NvbCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmF3YWl0IGVuY3J5cHRlci5zZWN1cmVJbmJvdW5kKHRoaXMuY29tcG9uZW50cy5wZWVySWQsIHN0cmVhbSksXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cuZXJyb3IoJ2VuY3J5cHRpbmcgaW5ib3VuZCBjb25uZWN0aW9uIHRvICVwIGZhaWxlZCcsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29kZUVycm9yKGVyci5tZXNzYWdlLCBjb2Rlcy5FUlJfRU5DUllQVElPTl9GQUlMRUQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGVuY3J5cHQgdGhlIGdpdmVuIGBjb25uZWN0aW9uYCB3aXRoIHRoZSBwcm92aWRlZCBjb25uZWN0aW9uIGVuY3J5cHRlcnMuXG4gICAgICogVGhlIGZpcnN0IGBDb25uZWN0aW9uRW5jcnlwdGVyYCBtb2R1bGUgdG8gc3VjY2VlZCB3aWxsIGJlIHVzZWRcbiAgICAgKi9cbiAgICBhc3luYyBfZW5jcnlwdE91dGJvdW5kKGNvbm5lY3Rpb24sIHJlbW90ZVBlZXJJZCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGlvbkVuY3J5cHRpb24ua2V5cygpKTtcbiAgICAgICAgY29ubmVjdGlvbi5sb2coJ3NlbGVjdGluZyBvdXRib3VuZCBjcnlwdG8gcHJvdG9jb2wnLCBwcm90b2NvbHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cudHJhY2UoJ3NlbGVjdGluZyBlbmNyeXB0ZXIgZnJvbSAlcycsIHByb3RvY29scyk7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgcHJvdG9jb2wgfSA9IGF3YWl0IG1zcy5zZWxlY3QoY29ubmVjdGlvbiwgcHJvdG9jb2xzLCB7XG4gICAgICAgICAgICAgICAgbG9nOiBjb25uZWN0aW9uLmxvZyxcbiAgICAgICAgICAgICAgICB5aWVsZEJ5dGVzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlciA9IHRoaXMuY29ubmVjdGlvbkVuY3J5cHRpb24uZ2V0KHByb3RvY29sKTtcbiAgICAgICAgICAgIGlmIChlbmNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gY3J5cHRvIG1vZHVsZSBmb3VuZCBmb3IgJHtwcm90b2NvbH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9nKCdlbmNyeXB0aW5nIG91dGJvdW5kIGNvbm5lY3Rpb24gdG8gJXAgdXNpbmcgJXMnLCByZW1vdGVQZWVySWQsIGVuY3J5cHRlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmF3YWl0IGVuY3J5cHRlci5zZWN1cmVPdXRib3VuZCh0aGlzLmNvbXBvbmVudHMucGVlcklkLCBzdHJlYW0sIHJlbW90ZVBlZXJJZCksXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cuZXJyb3IoJ2VuY3J5cHRpbmcgb3V0Ym91bmQgY29ubmVjdGlvbiB0byAlcCBmYWlsZWQnLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihlcnIubWVzc2FnZSwgY29kZXMuRVJSX0VOQ1JZUFRJT05fRkFJTEVEKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIG9uZSBvZiB0aGUgZ2l2ZW4gbXV4ZXJzIHZpYSBtdWx0aXN0cmVhbS1zZWxlY3QuIFRoYXRcbiAgICAgKiBtdXhlciB3aWxsIGJlIHVzZWQgZm9yIGFsbCBmdXR1cmUgc3RyZWFtcyBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfbXVsdGlwbGV4T3V0Ym91bmQoY29ubmVjdGlvbiwgbXV4ZXJzKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29scyA9IEFycmF5LmZyb20obXV4ZXJzLmtleXMoKSk7XG4gICAgICAgIGNvbm5lY3Rpb24ubG9nKCdvdXRib3VuZCBzZWxlY3RpbmcgbXV4ZXIgJXMnLCBwcm90b2NvbHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cudHJhY2UoJ3NlbGVjdGluZyBzdHJlYW0gbXV4ZXIgZnJvbSAlcycsIHByb3RvY29scyk7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgcHJvdG9jb2wgfSA9IGF3YWl0IG1zcy5zZWxlY3QoY29ubmVjdGlvbiwgcHJvdG9jb2xzLCB7XG4gICAgICAgICAgICAgICAgbG9nOiBjb25uZWN0aW9uLmxvZyxcbiAgICAgICAgICAgICAgICB5aWVsZEJ5dGVzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9nKCdzZWxlY3RlZCAlcyBhcyBtdXhlciBwcm90b2NvbCcsIHByb3RvY29sKTtcbiAgICAgICAgICAgIGNvbnN0IG11eGVyRmFjdG9yeSA9IG11eGVycy5nZXQocHJvdG9jb2wpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RyZWFtLCBtdXhlckZhY3RvcnkgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmxvZy5lcnJvcignZXJyb3IgbXVsdGlwbGV4aW5nIG91dGJvdW5kIGNvbm5lY3Rpb24nLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihTdHJpbmcoZXJyKSwgY29kZXMuRVJSX01VWEVSX1VOQVZBSUxBQkxFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgc3VwcG9ydCBmb3Igb25lIG9mIHRoZSBnaXZlbiBtdXhlcnMgdmlhIG11bHRpc3RyZWFtLXNlbGVjdC4gVGhlXG4gICAgICogc2VsZWN0ZWQgbXV4ZXIgd2lsbCBiZSB1c2VkIGZvciBhbGwgZnV0dXJlIHN0cmVhbXMgb24gdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgX211bHRpcGxleEluYm91bmQoY29ubmVjdGlvbiwgbXV4ZXJzKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29scyA9IEFycmF5LmZyb20obXV4ZXJzLmtleXMoKSk7XG4gICAgICAgIGNvbm5lY3Rpb24ubG9nKCdpbmJvdW5kIGhhbmRsaW5nIG11eGVycyAlcycsIHByb3RvY29scyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgcHJvdG9jb2wgfSA9IGF3YWl0IG1zcy5oYW5kbGUoY29ubmVjdGlvbiwgcHJvdG9jb2xzLCB7XG4gICAgICAgICAgICAgICAgbG9nOiBjb25uZWN0aW9uLmxvZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtdXhlckZhY3RvcnkgPSBtdXhlcnMuZ2V0KHByb3RvY29sKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0cmVhbSwgbXV4ZXJGYWN0b3J5IH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5sb2cuZXJyb3IoJ2Vycm9yIG11bHRpcGxleGluZyBpbmJvdW5kIGNvbm5lY3Rpb24nLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvZGVFcnJvcihTdHJpbmcoZXJyKSwgY29kZXMuRVJSX01VWEVSX1VOQVZBSUxBQkxFKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZ3JhZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlRXJyb3IiLCJFUlJfVElNRU9VVCIsInNldE1heExpc3RlbmVycyIsIm1zcyIsInBlZXJJZEZyb21TdHJpbmciLCJjcmVhdGVDb25uZWN0aW9uIiwiSU5CT1VORF9VUEdSQURFX1RJTUVPVVQiLCJjb2RlcyIsIkRFRkFVTFRfTUFYX0lOQk9VTkRfU1RSRUFNUyIsIkRFRkFVTFRfTUFYX09VVEJPVU5EX1NUUkVBTVMiLCJERUZBVUxUX1BST1RPQ09MX1NFTEVDVF9USU1FT1VUIiwiZmluZEluY29taW5nU3RyZWFtTGltaXQiLCJwcm90b2NvbCIsInJlZ2lzdHJhciIsIm9wdGlvbnMiLCJnZXRIYW5kbGVyIiwibWF4SW5ib3VuZFN0cmVhbXMiLCJlcnIiLCJjb2RlIiwiRVJSX05PX0hBTkRMRVJfRk9SX1BST1RPQ09MIiwiZmluZE91dGdvaW5nU3RyZWFtTGltaXQiLCJtYXhPdXRib3VuZFN0cmVhbXMiLCJjb3VudFN0cmVhbXMiLCJkaXJlY3Rpb24iLCJjb25uZWN0aW9uIiwic3RyZWFtQ291bnQiLCJzdHJlYW1zIiwiZm9yRWFjaCIsInN0cmVhbSIsIkRlZmF1bHRVcGdyYWRlciIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50cyIsImluaXQiLCJjb25uZWN0aW9uRW5jcnlwdGlvbiIsIk1hcCIsImVuY3J5cHRlciIsInNldCIsIm11eGVycyIsIm11eGVyIiwiaW5ib3VuZFVwZ3JhZGVUaW1lb3V0IiwiZXZlbnRzIiwic2hvdWxkQmxvY2tDb25uZWN0aW9uIiwicmVtb3RlUGVlciIsIm1hQ29ubiIsImNvbm5lY3Rpb25UeXBlIiwiY29ubmVjdGlvbkdhdGVyIiwidW5kZWZpbmVkIiwiRVJSX0NPTk5FQ1RJT05fSU5URVJDRVBURUQiLCJ1cGdyYWRlSW5ib3VuZCIsIm9wdHMiLCJhY2NlcHQiLCJjb25uZWN0aW9uTWFuYWdlciIsImFjY2VwdEluY29taW5nQ29ubmVjdGlvbiIsIkVSUl9DT05ORUNUSU9OX0RFTklFRCIsImVuY3J5cHRlZENvbm4iLCJ1cGdyYWRlZENvbm4iLCJtdXhlckZhY3RvcnkiLCJjcnlwdG9Qcm90b2NvbCIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIm9uQWJvcnQiLCJhYm9ydCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwiSW5maW5pdHkiLCJkZW55SW5ib3VuZENvbm5lY3Rpb24iLCJtZXRyaWNzIiwidHJhY2tNdWx0aWFkZHJDb25uZWN0aW9uIiwibG9nIiwicHJvdGVjdGVkQ29ubiIsInNraXBQcm90ZWN0aW9uIiwicHJvdGVjdG9yIiwiY29ubmVjdGlvblByb3RlY3RvciIsInByb3RlY3QiLCJza2lwRW5jcnlwdGlvbiIsImNvbm4iLCJfZW5jcnlwdEluYm91bmQiLCJpZFN0ciIsInJlbW90ZUFkZHIiLCJnZXRQZWVySWQiLCJFUlJfSU5WQUxJRF9NVUxUSUFERFIiLCJyZW1vdGVQZWVySWQiLCJzaXplIiwibXVsdGlwbGV4ZWQiLCJfbXVsdGlwbGV4SW5ib3VuZCIsImVycm9yIiwiX2NyZWF0ZUNvbm5lY3Rpb24iLCJ0cmFuc2llbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWZ0ZXJVcGdyYWRlSW5ib3VuZCIsInVwZ3JhZGVPdXRib3VuZCIsIl9lbmNyeXB0T3V0Ym91bmQiLCJFUlJfSU5WQUxJRF9QRUVSIiwiX211bHRpcGxleE91dGJvdW5kIiwiY2xvc2UiLCJuZXdTdHJlYW0iLCJjcmVhdGVTdHJlYW1NdXhlciIsIm9uSW5jb21pbmdTdHJlYW0iLCJtdXhlZFN0cmVhbSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInByb3RvY29scyIsImdldFByb3RvY29scyIsImhhbmRsZSIsInlpZWxkQnl0ZXMiLCJpbmNvbWluZ0xpbWl0IiwiRVJSX1RPT19NQU5ZX0lOQk9VTkRfUFJPVE9DT0xfU1RSRUFNUyIsInNvdXJjZSIsInNpbmsiLCJjbG9zZVdyaXRlIiwiY2xvc2VSZWFkIiwicGVlclN0b3JlIiwibWVyZ2UiLCJ0cmFja1Byb3RvY29sU3RyZWFtIiwiX29uU3RyZWFtIiwiY2F0Y2giLCJpZCIsIm1lc3NhZ2UiLCJzdGFjayIsInRpbWVsaW5lIiwiRVJSX01VWEVSX1VOQVZBSUxBQkxFIiwidHJhY2UiLCJzZWxlY3QiLCJvdXRnb2luZ0xpbWl0IiwiRVJSX1RPT19NQU5ZX09VVEJPVU5EX1BST1RPQ09MX1NUUkVBTVMiLCJTdHJpbmciLCJFUlJfVU5TVVBQT1JURURfUFJPVE9DT0wiLCJhbGwiLCJfdGltZWxpbmUiLCJQcm94eSIsImFyZ3MiLCJzdGF0dXMiLCJzYWZlRGlzcGF0Y2hFdmVudCIsImRldGFpbCIsIlJlZmxlY3QiLCJ1cGdyYWRlZCIsIkRhdGUiLCJub3ciLCJlcnJDb25uZWN0aW9uTm90TXVsdGlwbGV4ZWQiLCJFUlJfQ09OTkVDVElPTl9OT1RfTVVMVElQTEVYRUQiLCJtdWx0aXBsZXhlciIsImVuY3J5cHRpb24iLCJsb2dnZXIiLCJnZXRTdHJlYW1zIiwiaGFuZGxlciIsInJ1bk9uVHJhbnNpZW50Q29ubmVjdGlvbiIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJnZXQiLCJFcnJvciIsInNlY3VyZUluYm91bmQiLCJwZWVySWQiLCJFUlJfRU5DUllQVElPTl9GQUlMRUQiLCJzZWN1cmVPdXRib3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/upgrader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/libp2p/dist/src/version.js":
/*!*************************************************!*\
  !*** ./node_modules/libp2p/dist/src/version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   name: () => (/* binding */ name),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"1.4.2\";\nconst name = \"libp2p\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlicDJwL2Rpc3Qvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxVQUFVLFFBQVE7QUFDeEIsTUFBTUMsT0FBTyxTQUFTLENBQzdCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL2xpYnAycC9kaXN0L3NyYy92ZXJzaW9uLmpzPzhjZjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS40LjInO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnbGlicDJwJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/libp2p/dist/src/version.js\n");

/***/ })

};
;