"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uint8arraylist";
exports.ids = ["vendor-chunks/uint8arraylist"];
exports.modules = {

/***/ "(ssr)/./node_modules/uint8arraylist/dist/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/uint8arraylist/dist/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Uint8ArrayList: () => (/* binding */ Uint8ArrayList),\n/* harmony export */   isUint8ArrayList: () => (/* binding */ isUint8ArrayList)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/alloc */ \"(ssr)/./node_modules/uint8arrays/dist/src/alloc.node.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/concat */ \"(ssr)/./node_modules/uint8arrays/dist/src/concat.node.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/equals */ \"(ssr)/./node_modules/uint8arrays/dist/src/equals.js\");\n/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */ \n\n\nconst symbol = Symbol.for(\"@achingbrain/uint8arraylist\");\nfunction findBufAndOffset(bufs, index) {\n    if (index == null || index < 0) {\n        throw new RangeError(\"index is out of bounds\");\n    }\n    let offset = 0;\n    for (const buf of bufs){\n        const bufEnd = offset + buf.byteLength;\n        if (index < bufEnd) {\n            return {\n                buf,\n                index: index - offset\n            };\n        }\n        offset = bufEnd;\n    }\n    throw new RangeError(\"index is out of bounds\");\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */ function isUint8ArrayList(value) {\n    return Boolean(value?.[symbol]);\n}\nclass Uint8ArrayList {\n    constructor(...data){\n        this[symbol] = true;\n        this.bufs = [];\n        this.length = 0;\n        if (data.length > 0) {\n            this.appendAll(data);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.bufs;\n    }\n    get byteLength() {\n        return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */ append(...bufs) {\n        this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */ appendAll(bufs) {\n        let length = 0;\n        for (const buf of bufs){\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.push(buf);\n            } else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.push(...buf.bufs);\n            } else {\n                throw new Error(\"Could not append value, must be an Uint8Array or a Uint8ArrayList\");\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */ prepend(...bufs) {\n        this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */ prependAll(bufs) {\n        let length = 0;\n        for (const buf of bufs.reverse()){\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.unshift(buf);\n            } else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.unshift(...buf.bufs);\n            } else {\n                throw new Error(\"Could not prepend value, must be an Uint8Array or a Uint8ArrayList\");\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */ get(index) {\n        const res = findBufAndOffset(this.bufs, index);\n        return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */ set(index, value) {\n        const res = findBufAndOffset(this.bufs, index);\n        res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */ write(buf, offset = 0) {\n        if (buf instanceof Uint8Array) {\n            for(let i = 0; i < buf.length; i++){\n                this.set(offset + i, buf[i]);\n            }\n        } else if (isUint8ArrayList(buf)) {\n            for(let i = 0; i < buf.length; i++){\n                this.set(offset + i, buf.get(i));\n            }\n        } else {\n            throw new Error(\"Could not write value, must be an Uint8Array or a Uint8ArrayList\");\n        }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */ consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes);\n        // do nothing if not a positive number\n        if (Number.isNaN(bytes) || bytes <= 0) {\n            return;\n        }\n        // if consuming all bytes, skip iterating\n        if (bytes === this.byteLength) {\n            this.bufs = [];\n            this.length = 0;\n            return;\n        }\n        while(this.bufs.length > 0){\n            if (bytes >= this.bufs[0].byteLength) {\n                bytes -= this.bufs[0].byteLength;\n                this.length -= this.bufs[0].byteLength;\n                this.bufs.shift();\n            } else {\n                this.bufs[0] = this.bufs[0].subarray(bytes);\n                this.length -= bytes;\n                break;\n            }\n        }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */ slice(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */ subarray(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        if (bufs.length === 1) {\n            return bufs[0];\n        }\n        return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */ sublist(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        const list = new Uint8ArrayList();\n        list.length = length;\n        // don't loop, just set the bufs\n        list.bufs = [\n            ...bufs\n        ];\n        return list;\n    }\n    _subList(beginInclusive, endExclusive) {\n        beginInclusive = beginInclusive ?? 0;\n        endExclusive = endExclusive ?? this.length;\n        if (beginInclusive < 0) {\n            beginInclusive = this.length + beginInclusive;\n        }\n        if (endExclusive < 0) {\n            endExclusive = this.length + endExclusive;\n        }\n        if (beginInclusive < 0 || endExclusive > this.length) {\n            throw new RangeError(\"index is out of bounds\");\n        }\n        if (beginInclusive === endExclusive) {\n            return {\n                bufs: [],\n                length: 0\n            };\n        }\n        if (beginInclusive === 0 && endExclusive === this.length) {\n            return {\n                bufs: this.bufs,\n                length: this.length\n            };\n        }\n        const bufs = [];\n        let offset = 0;\n        for(let i = 0; i < this.bufs.length; i++){\n            const buf = this.bufs[i];\n            const bufStart = offset;\n            const bufEnd = bufStart + buf.byteLength;\n            // for next loop\n            offset = bufEnd;\n            if (beginInclusive >= bufEnd) {\n                continue;\n            }\n            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n            if (sliceStartInBuf && sliceEndsInBuf) {\n                // slice is wholly contained within this buffer\n                if (beginInclusive === bufStart && endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                const start = beginInclusive - bufStart;\n                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n                break;\n            }\n            if (sliceStartInBuf) {\n                // slice starts in this buffer\n                if (beginInclusive === 0) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    continue;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(beginInclusive - bufStart));\n                continue;\n            }\n            if (sliceEndsInBuf) {\n                if (endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(0, endExclusive - bufStart));\n                break;\n            }\n            // slice started before this buffer and ends after it\n            bufs.push(buf);\n        }\n        return {\n            bufs,\n            length: endExclusive - beginInclusive\n        };\n    }\n    indexOf(search, offset = 0) {\n        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n            throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n        }\n        const needle = search instanceof Uint8Array ? search : search.subarray();\n        offset = Number(offset ?? 0);\n        if (isNaN(offset)) {\n            offset = 0;\n        }\n        if (offset < 0) {\n            offset = this.length + offset;\n        }\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (search.length === 0) {\n            return offset > this.length ? this.length : offset;\n        }\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n        const M = needle.byteLength;\n        if (M === 0) {\n            throw new TypeError(\"search must be at least 1 byte long\");\n        }\n        // radix\n        const radix = 256;\n        const rightmostPositions = new Int32Array(radix);\n        // position of the rightmost occurrence of the byte c in the pattern\n        for(let c = 0; c < radix; c++){\n            // -1 for bytes not in pattern\n            rightmostPositions[c] = -1;\n        }\n        for(let j = 0; j < M; j++){\n            // rightmost position for bytes in pattern\n            rightmostPositions[needle[j]] = j;\n        }\n        // Return offset of first match, -1 if no match\n        const right = rightmostPositions;\n        const lastIndex = this.byteLength - needle.byteLength;\n        const lastPatIndex = needle.byteLength - 1;\n        let skip;\n        for(let i = offset; i <= lastIndex; i += skip){\n            skip = 0;\n            for(let j = lastPatIndex; j >= 0; j--){\n                const char = this.get(i + j);\n                if (needle[j] !== char) {\n                    skip = Math.max(1, j - right[char]);\n                    break;\n                }\n            }\n            if (skip === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getInt8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt8(0);\n    }\n    setInt8(byteOffset, value) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getInt16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt16(0, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getInt32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt32(0, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigInt64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigInt64(0, littleEndian);\n    }\n    setBigInt64(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigInt64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint8(0);\n    }\n    setUint8(byteOffset, value) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getUint16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint16(0, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint32(0, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigUint64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigUint64(0, littleEndian);\n    }\n    setBigUint64(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigUint64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat32(0, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat64(0, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof Uint8ArrayList)) {\n            return false;\n        }\n        if (other.bufs.length !== this.bufs.length) {\n            return false;\n        }\n        for(let i = 0; i < this.bufs.length; i++){\n            if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__.equals)(this.bufs[i], other.bufs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */ static fromUint8Arrays(bufs, length) {\n        const list = new Uint8ArrayList();\n        list.bufs = bufs;\n        if (length == null) {\n            length = bufs.reduce((acc, curr)=>acc + curr.byteLength, 0);\n        }\n        list.length = length;\n        return list;\n    }\n} /*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/  //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdWludDhhcnJheWxpc3QvZGlzdC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUZDLEdBQ3NEO0FBQ1g7QUFDQTtBQUM1QyxNQUFNSSxTQUFTQyxPQUFPQyxHQUFHLENBQUM7QUFDMUIsU0FBU0MsaUJBQWlCQyxJQUFJLEVBQUVDLEtBQUs7SUFDakMsSUFBSUEsU0FBUyxRQUFRQSxRQUFRLEdBQUc7UUFDNUIsTUFBTSxJQUFJQyxXQUFXO0lBQ3pCO0lBQ0EsSUFBSUMsU0FBUztJQUNiLEtBQUssTUFBTUMsT0FBT0osS0FBTTtRQUNwQixNQUFNSyxTQUFTRixTQUFTQyxJQUFJRSxVQUFVO1FBQ3RDLElBQUlMLFFBQVFJLFFBQVE7WUFDaEIsT0FBTztnQkFDSEQ7Z0JBQ0FILE9BQU9BLFFBQVFFO1lBQ25CO1FBQ0o7UUFDQUEsU0FBU0U7SUFDYjtJQUNBLE1BQU0sSUFBSUgsV0FBVztBQUN6QjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNLLGlCQUFpQkMsS0FBSztJQUNsQyxPQUFPQyxRQUFRRCxPQUFPLENBQUNaLE9BQU87QUFDbEM7QUFDTyxNQUFNYztJQUlUQyxZQUFZLEdBQUdDLElBQUksQ0FBRTtZQURyQixDQUFDaEIsT0FBTyxHQUFHO1FBRVAsSUFBSSxDQUFDSSxJQUFJLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQ2EsTUFBTSxHQUFHO1FBQ2QsSUFBSUQsS0FBS0MsTUFBTSxHQUFHLEdBQUc7WUFDakIsSUFBSSxDQUFDQyxTQUFTLENBQUNGO1FBQ25CO0lBQ0o7SUFDQSxDQUFDLENBQUNmLE9BQU9rQixRQUFRLENBQUMsR0FBRztRQUNqQixPQUFPLElBQUksQ0FBQ2YsSUFBSTtJQUNwQjtJQUNBLElBQUlNLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ08sTUFBTTtJQUN0QjtJQUNBOztLQUVDLEdBQ0RHLE9BQU8sR0FBR2hCLElBQUksRUFBRTtRQUNaLElBQUksQ0FBQ2MsU0FBUyxDQUFDZDtJQUNuQjtJQUNBOztLQUVDLEdBQ0RjLFVBQVVkLElBQUksRUFBRTtRQUNaLElBQUlhLFNBQVM7UUFDYixLQUFLLE1BQU1ULE9BQU9KLEtBQU07WUFDcEIsSUFBSUksZUFBZWEsWUFBWTtnQkFDM0JKLFVBQVVULElBQUlFLFVBQVU7Z0JBQ3hCLElBQUksQ0FBQ04sSUFBSSxDQUFDa0IsSUFBSSxDQUFDZDtZQUNuQixPQUNLLElBQUlHLGlCQUFpQkgsTUFBTTtnQkFDNUJTLFVBQVVULElBQUlFLFVBQVU7Z0JBQ3hCLElBQUksQ0FBQ04sSUFBSSxDQUFDa0IsSUFBSSxJQUFJZCxJQUFJSixJQUFJO1lBQzlCLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJbUIsTUFBTTtZQUNwQjtRQUNKO1FBQ0EsSUFBSSxDQUFDTixNQUFNLElBQUlBO0lBQ25CO0lBQ0E7O0tBRUMsR0FDRE8sUUFBUSxHQUFHcEIsSUFBSSxFQUFFO1FBQ2IsSUFBSSxDQUFDcUIsVUFBVSxDQUFDckI7SUFDcEI7SUFDQTs7S0FFQyxHQUNEcUIsV0FBV3JCLElBQUksRUFBRTtRQUNiLElBQUlhLFNBQVM7UUFDYixLQUFLLE1BQU1ULE9BQU9KLEtBQUtzQixPQUFPLEdBQUk7WUFDOUIsSUFBSWxCLGVBQWVhLFlBQVk7Z0JBQzNCSixVQUFVVCxJQUFJRSxVQUFVO2dCQUN4QixJQUFJLENBQUNOLElBQUksQ0FBQ3VCLE9BQU8sQ0FBQ25CO1lBQ3RCLE9BQ0ssSUFBSUcsaUJBQWlCSCxNQUFNO2dCQUM1QlMsVUFBVVQsSUFBSUUsVUFBVTtnQkFDeEIsSUFBSSxDQUFDTixJQUFJLENBQUN1QixPQUFPLElBQUluQixJQUFJSixJQUFJO1lBQ2pDLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJbUIsTUFBTTtZQUNwQjtRQUNKO1FBQ0EsSUFBSSxDQUFDTixNQUFNLElBQUlBO0lBQ25CO0lBQ0E7O0tBRUMsR0FDRFcsSUFBSXZCLEtBQUssRUFBRTtRQUNQLE1BQU13QixNQUFNMUIsaUJBQWlCLElBQUksQ0FBQ0MsSUFBSSxFQUFFQztRQUN4QyxPQUFPd0IsSUFBSXJCLEdBQUcsQ0FBQ3FCLElBQUl4QixLQUFLLENBQUM7SUFDN0I7SUFDQTs7S0FFQyxHQUNEeUIsSUFBSXpCLEtBQUssRUFBRU8sS0FBSyxFQUFFO1FBQ2QsTUFBTWlCLE1BQU0xQixpQkFBaUIsSUFBSSxDQUFDQyxJQUFJLEVBQUVDO1FBQ3hDd0IsSUFBSXJCLEdBQUcsQ0FBQ3FCLElBQUl4QixLQUFLLENBQUMsR0FBR087SUFDekI7SUFDQTs7S0FFQyxHQUNEbUIsTUFBTXZCLEdBQUcsRUFBRUQsU0FBUyxDQUFDLEVBQUU7UUFDbkIsSUFBSUMsZUFBZWEsWUFBWTtZQUMzQixJQUFLLElBQUlXLElBQUksR0FBR0EsSUFBSXhCLElBQUlTLE1BQU0sRUFBRWUsSUFBSztnQkFDakMsSUFBSSxDQUFDRixHQUFHLENBQUN2QixTQUFTeUIsR0FBR3hCLEdBQUcsQ0FBQ3dCLEVBQUU7WUFDL0I7UUFDSixPQUNLLElBQUlyQixpQkFBaUJILE1BQU07WUFDNUIsSUFBSyxJQUFJd0IsSUFBSSxHQUFHQSxJQUFJeEIsSUFBSVMsTUFBTSxFQUFFZSxJQUFLO2dCQUNqQyxJQUFJLENBQUNGLEdBQUcsQ0FBQ3ZCLFNBQVN5QixHQUFHeEIsSUFBSW9CLEdBQUcsQ0FBQ0k7WUFDakM7UUFDSixPQUNLO1lBQ0QsTUFBTSxJQUFJVCxNQUFNO1FBQ3BCO0lBQ0o7SUFDQTs7S0FFQyxHQUNEVSxRQUFRQyxLQUFLLEVBQUU7UUFDWCx1RUFBdUU7UUFDdkVBLFFBQVFDLEtBQUtDLEtBQUssQ0FBQ0Y7UUFDbkIsc0NBQXNDO1FBQ3RDLElBQUlHLE9BQU9DLEtBQUssQ0FBQ0osVUFBVUEsU0FBUyxHQUFHO1lBQ25DO1FBQ0o7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSUEsVUFBVSxJQUFJLENBQUN4QixVQUFVLEVBQUU7WUFDM0IsSUFBSSxDQUFDTixJQUFJLEdBQUcsRUFBRTtZQUNkLElBQUksQ0FBQ2EsTUFBTSxHQUFHO1lBQ2Q7UUFDSjtRQUNBLE1BQU8sSUFBSSxDQUFDYixJQUFJLENBQUNhLE1BQU0sR0FBRyxFQUFHO1lBQ3pCLElBQUlpQixTQUFTLElBQUksQ0FBQzlCLElBQUksQ0FBQyxFQUFFLENBQUNNLFVBQVUsRUFBRTtnQkFDbEN3QixTQUFTLElBQUksQ0FBQzlCLElBQUksQ0FBQyxFQUFFLENBQUNNLFVBQVU7Z0JBQ2hDLElBQUksQ0FBQ08sTUFBTSxJQUFJLElBQUksQ0FBQ2IsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sVUFBVTtnQkFDdEMsSUFBSSxDQUFDTixJQUFJLENBQUNtQyxLQUFLO1lBQ25CLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDbkMsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNvQyxRQUFRLENBQUNOO2dCQUNyQyxJQUFJLENBQUNqQixNQUFNLElBQUlpQjtnQkFDZjtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RPLE1BQU1DLGNBQWMsRUFBRUMsWUFBWSxFQUFFO1FBQ2hDLE1BQU0sRUFBRXZDLElBQUksRUFBRWEsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDMkIsUUFBUSxDQUFDRixnQkFBZ0JDO1FBQ3ZELE9BQU83QywwREFBTUEsQ0FBQ00sTUFBTWE7SUFDeEI7SUFDQTs7Ozs7S0FLQyxHQUNEdUIsU0FBU0UsY0FBYyxFQUFFQyxZQUFZLEVBQUU7UUFDbkMsTUFBTSxFQUFFdkMsSUFBSSxFQUFFYSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMyQixRQUFRLENBQUNGLGdCQUFnQkM7UUFDdkQsSUFBSXZDLEtBQUthLE1BQU0sS0FBSyxHQUFHO1lBQ25CLE9BQU9iLElBQUksQ0FBQyxFQUFFO1FBQ2xCO1FBQ0EsT0FBT04sMERBQU1BLENBQUNNLE1BQU1hO0lBQ3hCO0lBQ0E7Ozs7S0FJQyxHQUNENEIsUUFBUUgsY0FBYyxFQUFFQyxZQUFZLEVBQUU7UUFDbEMsTUFBTSxFQUFFdkMsSUFBSSxFQUFFYSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMyQixRQUFRLENBQUNGLGdCQUFnQkM7UUFDdkQsTUFBTUcsT0FBTyxJQUFJaEM7UUFDakJnQyxLQUFLN0IsTUFBTSxHQUFHQTtRQUNkLGdDQUFnQztRQUNoQzZCLEtBQUsxQyxJQUFJLEdBQUc7ZUFBSUE7U0FBSztRQUNyQixPQUFPMEM7SUFDWDtJQUNBRixTQUFTRixjQUFjLEVBQUVDLFlBQVksRUFBRTtRQUNuQ0QsaUJBQWlCQSxrQkFBa0I7UUFDbkNDLGVBQWVBLGdCQUFnQixJQUFJLENBQUMxQixNQUFNO1FBQzFDLElBQUl5QixpQkFBaUIsR0FBRztZQUNwQkEsaUJBQWlCLElBQUksQ0FBQ3pCLE1BQU0sR0FBR3lCO1FBQ25DO1FBQ0EsSUFBSUMsZUFBZSxHQUFHO1lBQ2xCQSxlQUFlLElBQUksQ0FBQzFCLE1BQU0sR0FBRzBCO1FBQ2pDO1FBQ0EsSUFBSUQsaUJBQWlCLEtBQUtDLGVBQWUsSUFBSSxDQUFDMUIsTUFBTSxFQUFFO1lBQ2xELE1BQU0sSUFBSVgsV0FBVztRQUN6QjtRQUNBLElBQUlvQyxtQkFBbUJDLGNBQWM7WUFDakMsT0FBTztnQkFBRXZDLE1BQU0sRUFBRTtnQkFBRWEsUUFBUTtZQUFFO1FBQ2pDO1FBQ0EsSUFBSXlCLG1CQUFtQixLQUFLQyxpQkFBaUIsSUFBSSxDQUFDMUIsTUFBTSxFQUFFO1lBQ3RELE9BQU87Z0JBQUViLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUFFYSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUFDO1FBQ2xEO1FBQ0EsTUFBTWIsT0FBTyxFQUFFO1FBQ2YsSUFBSUcsU0FBUztRQUNiLElBQUssSUFBSXlCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM1QixJQUFJLENBQUNhLE1BQU0sRUFBRWUsSUFBSztZQUN2QyxNQUFNeEIsTUFBTSxJQUFJLENBQUNKLElBQUksQ0FBQzRCLEVBQUU7WUFDeEIsTUFBTWUsV0FBV3hDO1lBQ2pCLE1BQU1FLFNBQVNzQyxXQUFXdkMsSUFBSUUsVUFBVTtZQUN4QyxnQkFBZ0I7WUFDaEJILFNBQVNFO1lBQ1QsSUFBSWlDLGtCQUFrQmpDLFFBQVE7Z0JBRTFCO1lBQ0o7WUFDQSxNQUFNdUMsa0JBQWtCTixrQkFBa0JLLFlBQVlMLGlCQUFpQmpDO1lBQ3ZFLE1BQU13QyxpQkFBaUJOLGVBQWVJLFlBQVlKLGdCQUFnQmxDO1lBQ2xFLElBQUl1QyxtQkFBbUJDLGdCQUFnQjtnQkFDbkMsK0NBQStDO2dCQUMvQyxJQUFJUCxtQkFBbUJLLFlBQVlKLGlCQUFpQmxDLFFBQVE7b0JBQ3hELHlCQUF5QjtvQkFDekJMLEtBQUtrQixJQUFJLENBQUNkO29CQUNWO2dCQUNKO2dCQUNBLDJCQUEyQjtnQkFDM0IsTUFBTTBDLFFBQVFSLGlCQUFpQks7Z0JBQy9CM0MsS0FBS2tCLElBQUksQ0FBQ2QsSUFBSWdDLFFBQVEsQ0FBQ1UsT0FBT0EsUUFBU1AsQ0FBQUEsZUFBZUQsY0FBYTtnQkFDbkU7WUFDSjtZQUNBLElBQUlNLGlCQUFpQjtnQkFDakIsOEJBQThCO2dCQUM5QixJQUFJTixtQkFBbUIsR0FBRztvQkFDdEIseUJBQXlCO29CQUN6QnRDLEtBQUtrQixJQUFJLENBQUNkO29CQUNWO2dCQUNKO2dCQUNBLDJCQUEyQjtnQkFDM0JKLEtBQUtrQixJQUFJLENBQUNkLElBQUlnQyxRQUFRLENBQUNFLGlCQUFpQks7Z0JBQ3hDO1lBQ0o7WUFDQSxJQUFJRSxnQkFBZ0I7Z0JBQ2hCLElBQUlOLGlCQUFpQmxDLFFBQVE7b0JBQ3pCLHlCQUF5QjtvQkFDekJMLEtBQUtrQixJQUFJLENBQUNkO29CQUNWO2dCQUNKO2dCQUNBLDJCQUEyQjtnQkFDM0JKLEtBQUtrQixJQUFJLENBQUNkLElBQUlnQyxRQUFRLENBQUMsR0FBR0csZUFBZUk7Z0JBQ3pDO1lBQ0o7WUFDQSxxREFBcUQ7WUFDckQzQyxLQUFLa0IsSUFBSSxDQUFDZDtRQUNkO1FBQ0EsT0FBTztZQUFFSjtZQUFNYSxRQUFRMEIsZUFBZUQ7UUFBZTtJQUN6RDtJQUNBUyxRQUFRQyxNQUFNLEVBQUU3QyxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJLENBQUNJLGlCQUFpQnlDLFdBQVcsQ0FBRUEsQ0FBQUEsa0JBQWtCL0IsVUFBUyxHQUFJO1lBQzlELE1BQU0sSUFBSWdDLFVBQVU7UUFDeEI7UUFDQSxNQUFNQyxTQUFTRixrQkFBa0IvQixhQUFhK0IsU0FBU0EsT0FBT1osUUFBUTtRQUN0RWpDLFNBQVM4QixPQUFPOUIsVUFBVTtRQUMxQixJQUFJK0IsTUFBTS9CLFNBQVM7WUFDZkEsU0FBUztRQUNiO1FBQ0EsSUFBSUEsU0FBUyxHQUFHO1lBQ1pBLFNBQVMsSUFBSSxDQUFDVSxNQUFNLEdBQUdWO1FBQzNCO1FBQ0EsSUFBSUEsU0FBUyxHQUFHO1lBQ1pBLFNBQVM7UUFDYjtRQUNBLElBQUk2QyxPQUFPbkMsTUFBTSxLQUFLLEdBQUc7WUFDckIsT0FBT1YsU0FBUyxJQUFJLENBQUNVLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sR0FBR1Y7UUFDaEQ7UUFDQSw0RUFBNEU7UUFDNUUsTUFBTWdELElBQUlELE9BQU81QyxVQUFVO1FBQzNCLElBQUk2QyxNQUFNLEdBQUc7WUFDVCxNQUFNLElBQUlGLFVBQVU7UUFDeEI7UUFDQSxRQUFRO1FBQ1IsTUFBTUcsUUFBUTtRQUNkLE1BQU1DLHFCQUFxQixJQUFJQyxXQUFXRjtRQUMxQyxvRUFBb0U7UUFDcEUsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlILE9BQU9HLElBQUs7WUFDNUIsOEJBQThCO1lBQzlCRixrQkFBa0IsQ0FBQ0UsRUFBRSxHQUFHLENBQUM7UUFDN0I7UUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsR0FBR0ssSUFBSztZQUN4QiwwQ0FBMEM7WUFDMUNILGtCQUFrQixDQUFDSCxNQUFNLENBQUNNLEVBQUUsQ0FBQyxHQUFHQTtRQUNwQztRQUNBLCtDQUErQztRQUMvQyxNQUFNQyxRQUFRSjtRQUNkLE1BQU1LLFlBQVksSUFBSSxDQUFDcEQsVUFBVSxHQUFHNEMsT0FBTzVDLFVBQVU7UUFDckQsTUFBTXFELGVBQWVULE9BQU81QyxVQUFVLEdBQUc7UUFDekMsSUFBSXNEO1FBQ0osSUFBSyxJQUFJaEMsSUFBSXpCLFFBQVF5QixLQUFLOEIsV0FBVzlCLEtBQUtnQyxLQUFNO1lBQzVDQSxPQUFPO1lBQ1AsSUFBSyxJQUFJSixJQUFJRyxjQUFjSCxLQUFLLEdBQUdBLElBQUs7Z0JBQ3BDLE1BQU1LLE9BQU8sSUFBSSxDQUFDckMsR0FBRyxDQUFDSSxJQUFJNEI7Z0JBQzFCLElBQUlOLE1BQU0sQ0FBQ00sRUFBRSxLQUFLSyxNQUFNO29CQUNwQkQsT0FBTzdCLEtBQUsrQixHQUFHLENBQUMsR0FBR04sSUFBSUMsS0FBSyxDQUFDSSxLQUFLO29CQUNsQztnQkFDSjtZQUNKO1lBQ0EsSUFBSUQsU0FBUyxHQUFHO2dCQUNaLE9BQU9oQztZQUNYO1FBQ0o7UUFDQSxPQUFPLENBQUM7SUFDWjtJQUNBbUMsUUFBUUMsVUFBVSxFQUFFO1FBQ2hCLE1BQU01RCxNQUFNLElBQUksQ0FBQ2dDLFFBQVEsQ0FBQzRCLFlBQVlBLGFBQWE7UUFDbkQsTUFBTUMsT0FBTyxJQUFJQyxTQUFTOUQsSUFBSStELE1BQU0sRUFBRS9ELElBQUk0RCxVQUFVLEVBQUU1RCxJQUFJRSxVQUFVO1FBQ3BFLE9BQU8yRCxLQUFLRixPQUFPLENBQUM7SUFDeEI7SUFDQUssUUFBUUosVUFBVSxFQUFFeEQsS0FBSyxFQUFFO1FBQ3ZCLE1BQU1KLE1BQU1aLDhEQUFXQSxDQUFDO1FBQ3hCLE1BQU15RSxPQUFPLElBQUlDLFNBQVM5RCxJQUFJK0QsTUFBTSxFQUFFL0QsSUFBSTRELFVBQVUsRUFBRTVELElBQUlFLFVBQVU7UUFDcEUyRCxLQUFLRyxPQUFPLENBQUMsR0FBRzVEO1FBQ2hCLElBQUksQ0FBQ21CLEtBQUssQ0FBQ3ZCLEtBQUs0RDtJQUNwQjtJQUNBSyxTQUFTTCxVQUFVLEVBQUVNLFlBQVksRUFBRTtRQUMvQixNQUFNbEUsTUFBTSxJQUFJLENBQUNnQyxRQUFRLENBQUM0QixZQUFZQSxhQUFhO1FBQ25ELE1BQU1DLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRSxPQUFPMkQsS0FBS0ksUUFBUSxDQUFDLEdBQUdDO0lBQzVCO0lBQ0FDLFNBQVNQLFVBQVUsRUFBRXhELEtBQUssRUFBRThELFlBQVksRUFBRTtRQUN0QyxNQUFNbEUsTUFBTVgsd0RBQUtBLENBQUM7UUFDbEIsTUFBTXdFLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRTJELEtBQUtNLFFBQVEsQ0FBQyxHQUFHL0QsT0FBTzhEO1FBQ3hCLElBQUksQ0FBQzNDLEtBQUssQ0FBQ3ZCLEtBQUs0RDtJQUNwQjtJQUNBUSxTQUFTUixVQUFVLEVBQUVNLFlBQVksRUFBRTtRQUMvQixNQUFNbEUsTUFBTSxJQUFJLENBQUNnQyxRQUFRLENBQUM0QixZQUFZQSxhQUFhO1FBQ25ELE1BQU1DLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRSxPQUFPMkQsS0FBS08sUUFBUSxDQUFDLEdBQUdGO0lBQzVCO0lBQ0FHLFNBQVNULFVBQVUsRUFBRXhELEtBQUssRUFBRThELFlBQVksRUFBRTtRQUN0QyxNQUFNbEUsTUFBTVgsd0RBQUtBLENBQUM7UUFDbEIsTUFBTXdFLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRTJELEtBQUtRLFFBQVEsQ0FBQyxHQUFHakUsT0FBTzhEO1FBQ3hCLElBQUksQ0FBQzNDLEtBQUssQ0FBQ3ZCLEtBQUs0RDtJQUNwQjtJQUNBVSxZQUFZVixVQUFVLEVBQUVNLFlBQVksRUFBRTtRQUNsQyxNQUFNbEUsTUFBTSxJQUFJLENBQUNnQyxRQUFRLENBQUM0QixZQUFZQSxhQUFhO1FBQ25ELE1BQU1DLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRSxPQUFPMkQsS0FBS1MsV0FBVyxDQUFDLEdBQUdKO0lBQy9CO0lBQ0FLLFlBQVlYLFVBQVUsRUFBRXhELEtBQUssRUFBRThELFlBQVksRUFBRTtRQUN6QyxNQUFNbEUsTUFBTVgsd0RBQUtBLENBQUM7UUFDbEIsTUFBTXdFLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRTJELEtBQUtVLFdBQVcsQ0FBQyxHQUFHbkUsT0FBTzhEO1FBQzNCLElBQUksQ0FBQzNDLEtBQUssQ0FBQ3ZCLEtBQUs0RDtJQUNwQjtJQUNBWSxTQUFTWixVQUFVLEVBQUU7UUFDakIsTUFBTTVELE1BQU0sSUFBSSxDQUFDZ0MsUUFBUSxDQUFDNEIsWUFBWUEsYUFBYTtRQUNuRCxNQUFNQyxPQUFPLElBQUlDLFNBQVM5RCxJQUFJK0QsTUFBTSxFQUFFL0QsSUFBSTRELFVBQVUsRUFBRTVELElBQUlFLFVBQVU7UUFDcEUsT0FBTzJELEtBQUtXLFFBQVEsQ0FBQztJQUN6QjtJQUNBQyxTQUFTYixVQUFVLEVBQUV4RCxLQUFLLEVBQUU7UUFDeEIsTUFBTUosTUFBTVosOERBQVdBLENBQUM7UUFDeEIsTUFBTXlFLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRTJELEtBQUtZLFFBQVEsQ0FBQyxHQUFHckU7UUFDakIsSUFBSSxDQUFDbUIsS0FBSyxDQUFDdkIsS0FBSzREO0lBQ3BCO0lBQ0FjLFVBQVVkLFVBQVUsRUFBRU0sWUFBWSxFQUFFO1FBQ2hDLE1BQU1sRSxNQUFNLElBQUksQ0FBQ2dDLFFBQVEsQ0FBQzRCLFlBQVlBLGFBQWE7UUFDbkQsTUFBTUMsT0FBTyxJQUFJQyxTQUFTOUQsSUFBSStELE1BQU0sRUFBRS9ELElBQUk0RCxVQUFVLEVBQUU1RCxJQUFJRSxVQUFVO1FBQ3BFLE9BQU8yRCxLQUFLYSxTQUFTLENBQUMsR0FBR1I7SUFDN0I7SUFDQVMsVUFBVWYsVUFBVSxFQUFFeEQsS0FBSyxFQUFFOEQsWUFBWSxFQUFFO1FBQ3ZDLE1BQU1sRSxNQUFNWCx3REFBS0EsQ0FBQztRQUNsQixNQUFNd0UsT0FBTyxJQUFJQyxTQUFTOUQsSUFBSStELE1BQU0sRUFBRS9ELElBQUk0RCxVQUFVLEVBQUU1RCxJQUFJRSxVQUFVO1FBQ3BFMkQsS0FBS2MsU0FBUyxDQUFDLEdBQUd2RSxPQUFPOEQ7UUFDekIsSUFBSSxDQUFDM0MsS0FBSyxDQUFDdkIsS0FBSzREO0lBQ3BCO0lBQ0FnQixVQUFVaEIsVUFBVSxFQUFFTSxZQUFZLEVBQUU7UUFDaEMsTUFBTWxFLE1BQU0sSUFBSSxDQUFDZ0MsUUFBUSxDQUFDNEIsWUFBWUEsYUFBYTtRQUNuRCxNQUFNQyxPQUFPLElBQUlDLFNBQVM5RCxJQUFJK0QsTUFBTSxFQUFFL0QsSUFBSTRELFVBQVUsRUFBRTVELElBQUlFLFVBQVU7UUFDcEUsT0FBTzJELEtBQUtlLFNBQVMsQ0FBQyxHQUFHVjtJQUM3QjtJQUNBVyxVQUFVakIsVUFBVSxFQUFFeEQsS0FBSyxFQUFFOEQsWUFBWSxFQUFFO1FBQ3ZDLE1BQU1sRSxNQUFNWCx3REFBS0EsQ0FBQztRQUNsQixNQUFNd0UsT0FBTyxJQUFJQyxTQUFTOUQsSUFBSStELE1BQU0sRUFBRS9ELElBQUk0RCxVQUFVLEVBQUU1RCxJQUFJRSxVQUFVO1FBQ3BFMkQsS0FBS2dCLFNBQVMsQ0FBQyxHQUFHekUsT0FBTzhEO1FBQ3pCLElBQUksQ0FBQzNDLEtBQUssQ0FBQ3ZCLEtBQUs0RDtJQUNwQjtJQUNBa0IsYUFBYWxCLFVBQVUsRUFBRU0sWUFBWSxFQUFFO1FBQ25DLE1BQU1sRSxNQUFNLElBQUksQ0FBQ2dDLFFBQVEsQ0FBQzRCLFlBQVlBLGFBQWE7UUFDbkQsTUFBTUMsT0FBTyxJQUFJQyxTQUFTOUQsSUFBSStELE1BQU0sRUFBRS9ELElBQUk0RCxVQUFVLEVBQUU1RCxJQUFJRSxVQUFVO1FBQ3BFLE9BQU8yRCxLQUFLaUIsWUFBWSxDQUFDLEdBQUdaO0lBQ2hDO0lBQ0FhLGFBQWFuQixVQUFVLEVBQUV4RCxLQUFLLEVBQUU4RCxZQUFZLEVBQUU7UUFDMUMsTUFBTWxFLE1BQU1YLHdEQUFLQSxDQUFDO1FBQ2xCLE1BQU13RSxPQUFPLElBQUlDLFNBQVM5RCxJQUFJK0QsTUFBTSxFQUFFL0QsSUFBSTRELFVBQVUsRUFBRTVELElBQUlFLFVBQVU7UUFDcEUyRCxLQUFLa0IsWUFBWSxDQUFDLEdBQUczRSxPQUFPOEQ7UUFDNUIsSUFBSSxDQUFDM0MsS0FBSyxDQUFDdkIsS0FBSzREO0lBQ3BCO0lBQ0FvQixXQUFXcEIsVUFBVSxFQUFFTSxZQUFZLEVBQUU7UUFDakMsTUFBTWxFLE1BQU0sSUFBSSxDQUFDZ0MsUUFBUSxDQUFDNEIsWUFBWUEsYUFBYTtRQUNuRCxNQUFNQyxPQUFPLElBQUlDLFNBQVM5RCxJQUFJK0QsTUFBTSxFQUFFL0QsSUFBSTRELFVBQVUsRUFBRTVELElBQUlFLFVBQVU7UUFDcEUsT0FBTzJELEtBQUttQixVQUFVLENBQUMsR0FBR2Q7SUFDOUI7SUFDQWUsV0FBV3JCLFVBQVUsRUFBRXhELEtBQUssRUFBRThELFlBQVksRUFBRTtRQUN4QyxNQUFNbEUsTUFBTVgsd0RBQUtBLENBQUM7UUFDbEIsTUFBTXdFLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRTJELEtBQUtvQixVQUFVLENBQUMsR0FBRzdFLE9BQU84RDtRQUMxQixJQUFJLENBQUMzQyxLQUFLLENBQUN2QixLQUFLNEQ7SUFDcEI7SUFDQXNCLFdBQVd0QixVQUFVLEVBQUVNLFlBQVksRUFBRTtRQUNqQyxNQUFNbEUsTUFBTSxJQUFJLENBQUNnQyxRQUFRLENBQUM0QixZQUFZQSxhQUFhO1FBQ25ELE1BQU1DLE9BQU8sSUFBSUMsU0FBUzlELElBQUkrRCxNQUFNLEVBQUUvRCxJQUFJNEQsVUFBVSxFQUFFNUQsSUFBSUUsVUFBVTtRQUNwRSxPQUFPMkQsS0FBS3FCLFVBQVUsQ0FBQyxHQUFHaEI7SUFDOUI7SUFDQWlCLFdBQVd2QixVQUFVLEVBQUV4RCxLQUFLLEVBQUU4RCxZQUFZLEVBQUU7UUFDeEMsTUFBTWxFLE1BQU1YLHdEQUFLQSxDQUFDO1FBQ2xCLE1BQU13RSxPQUFPLElBQUlDLFNBQVM5RCxJQUFJK0QsTUFBTSxFQUFFL0QsSUFBSTRELFVBQVUsRUFBRTVELElBQUlFLFVBQVU7UUFDcEUyRCxLQUFLc0IsVUFBVSxDQUFDLEdBQUcvRSxPQUFPOEQ7UUFDMUIsSUFBSSxDQUFDM0MsS0FBSyxDQUFDdkIsS0FBSzREO0lBQ3BCO0lBQ0FyRSxPQUFPNkYsS0FBSyxFQUFFO1FBQ1YsSUFBSUEsU0FBUyxNQUFNO1lBQ2YsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUI5RSxjQUFhLEdBQUk7WUFDcEMsT0FBTztRQUNYO1FBQ0EsSUFBSThFLE1BQU14RixJQUFJLENBQUNhLE1BQU0sS0FBSyxJQUFJLENBQUNiLElBQUksQ0FBQ2EsTUFBTSxFQUFFO1lBQ3hDLE9BQU87UUFDWDtRQUNBLElBQUssSUFBSWUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzVCLElBQUksQ0FBQ2EsTUFBTSxFQUFFZSxJQUFLO1lBQ3ZDLElBQUksQ0FBQ2pDLDBEQUFNQSxDQUFDLElBQUksQ0FBQ0ssSUFBSSxDQUFDNEIsRUFBRSxFQUFFNEQsTUFBTXhGLElBQUksQ0FBQzRCLEVBQUUsR0FBRztnQkFDdEMsT0FBTztZQUNYO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxPQUFPNkQsZ0JBQWdCekYsSUFBSSxFQUFFYSxNQUFNLEVBQUU7UUFDakMsTUFBTTZCLE9BQU8sSUFBSWhDO1FBQ2pCZ0MsS0FBSzFDLElBQUksR0FBR0E7UUFDWixJQUFJYSxVQUFVLE1BQU07WUFDaEJBLFNBQVNiLEtBQUswRixNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsT0FBU0QsTUFBTUMsS0FBS3RGLFVBQVUsRUFBRTtRQUMvRDtRQUNBb0MsS0FBSzdCLE1BQU0sR0FBR0E7UUFDZCxPQUFPNkI7SUFDWDtBQUNKLEVBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLElBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvdWludDhhcnJheWxpc3QvZGlzdC9zcmMvaW5kZXguanM/YjUyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICpcbiAqIEEgY2xhc3MgdGhhdCBsZXRzIHlvdSBkbyBvcGVyYXRpb25zIG92ZXIgYSBsaXN0IG9mIFVpbnQ4QXJyYXlzIHdpdGhvdXRcbiAqIGNvcHlpbmcgdGhlbS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgVWludDhBcnJheUxpc3QgfSBmcm9tICd1aW50OGFycmF5bGlzdCdcbiAqXG4gKiBjb25zdCBsaXN0ID0gbmV3IFVpbnQ4QXJyYXlMaXN0KClcbiAqIGxpc3QuYXBwZW5kKFVpbnQ4QXJyYXkuZnJvbShbMCwgMSwgMl0pKVxuICogbGlzdC5hcHBlbmQoVWludDhBcnJheS5mcm9tKFszLCA0LCA1XSkpXG4gKlxuICogbGlzdC5zdWJhcnJheSgpXG4gKiAvLyAtPiBVaW50OEFycmF5KFswLCAxLCAyLCAzLCA0LCA1XSlcbiAqXG4gKiBsaXN0LmNvbnN1bWUoMylcbiAqIGxpc3Quc3ViYXJyYXkoKVxuICogLy8gLT4gVWludDhBcnJheShbMywgNCwgNV0pXG4gKlxuICogLy8geW91IGNhbiBhbHNvIGl0ZXJhdGUgb3ZlciB0aGUgbGlzdFxuICogZm9yIChjb25zdCBidWYgb2YgbGlzdCkge1xuICogICAvLyAuLmRvIHNvbWV0aGluZyB3aXRoIGBidWZgXG4gKiB9XG4gKlxuICogbGlzdC5zdWJhcnJheSgwLCAxKVxuICogLy8gLT4gVWludDhBcnJheShbMF0pXG4gKiBgYGBcbiAqXG4gKiAjIyBDb252ZXJ0aW5nIFVpbnQ4QXJyYXlMaXN0cyB0byBVaW50OEFycmF5c1xuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB0dXJuIGEgYFVpbnQ4QXJyYXlMaXN0YCBpbnRvIGEgYFVpbnQ4QXJyYXlgIC0gYC5zbGljZWAgYW5kIGAuc3ViYXJyYXlgIGFuZCBvbmUgd2F5IHRvIHR1cm4gYSBgVWludDhBcnJheUxpc3RgIGludG8gYSBgVWludDhBcnJheUxpc3RgIHdpdGggZGlmZmVyZW50IGNvbnRlbnRzIC0gYC5zdWJsaXN0YC5cbiAqXG4gKiAjIyMgc2xpY2VcbiAqXG4gKiBTbGljZSBmb2xsb3dzIHRoZSBzYW1lIHNlbWFudGljcyBhcyBbVWludDhBcnJheS5zbGljZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZWRBcnJheS9zbGljZSkgaW4gdGhhdCBpdCBjcmVhdGVzIGEgbmV3IGBVaW50OEFycmF5YCBhbmQgY29waWVzIGJ5dGVzIGludG8gaXQgdXNpbmcgYW4gb3B0aW9uYWwgb2Zmc2V0ICYgbGVuZ3RoLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaXN0ID0gbmV3IFVpbnQ4QXJyYXlMaXN0KClcbiAqIGxpc3QuYXBwZW5kKFVpbnQ4QXJyYXkuZnJvbShbMCwgMSwgMl0pKVxuICogbGlzdC5hcHBlbmQoVWludDhBcnJheS5mcm9tKFszLCA0LCA1XSkpXG4gKlxuICogbGlzdC5zbGljZSgwLCAxKVxuICogLy8gLT4gVWludDhBcnJheShbMF0pXG4gKiBgYGBcbiAqXG4gKiAjIyMgc3ViYXJyYXlcbiAqXG4gKiBTdWJhcnJheSBhdHRlbXB0cyB0byBmb2xsb3cgdGhlIHNhbWUgc2VtYW50aWNzIGFzIFtVaW50OEFycmF5LnN1YmFycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9UeXBlZEFycmF5L3N1YmFycmF5KSB3aXRoIG9uZSBpbXBvcnRhbnQgZGlmZmVyZW50IC0gdGhpcyBpcyBhIG5vLWNvcHkgb3BlcmF0aW9uLCB1bmxlc3MgdGhlIHJlcXVlc3RlZCBieXRlcyBzcGFuIHR3byBpbnRlcm5hbCBidWZmZXJzIGluIHdoaWNoIGNhc2UgaXQgaXMgYSBjb3B5IG9wZXJhdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbGlzdCA9IG5ldyBVaW50OEFycmF5TGlzdCgpXG4gKiBsaXN0LmFwcGVuZChVaW50OEFycmF5LmZyb20oWzAsIDEsIDJdKSlcbiAqIGxpc3QuYXBwZW5kKFVpbnQ4QXJyYXkuZnJvbShbMywgNCwgNV0pKVxuICpcbiAqIGxpc3Quc3ViYXJyYXkoMCwgMSlcbiAqIC8vIC0+IFVpbnQ4QXJyYXkoWzBdKSAtIG5vLWNvcHlcbiAqXG4gKiBsaXN0LnN1YmFycmF5KDIsIDUpXG4gKiAvLyAtPiBVaW50OEFycmF5KFsyLCAzLCA0XSkgLSBjb3B5XG4gKiBgYGBcbiAqXG4gKiAjIyMgc3VibGlzdFxuICpcbiAqIFN1Ymxpc3QgY3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgVWludDhBcnJheUxpc3RgIHRoYXQgc2hhcmVzIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlcnMgd2l0aCB0aGUgb3JpZ2luYWwgc28gaXMgYWx3YXlzIGEgbm8tY29weSBvcGVyYXRpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3QgPSBuZXcgVWludDhBcnJheUxpc3QoKVxuICogbGlzdC5hcHBlbmQoVWludDhBcnJheS5mcm9tKFswLCAxLCAyXSkpXG4gKiBsaXN0LmFwcGVuZChVaW50OEFycmF5LmZyb20oWzMsIDQsIDVdKSlcbiAqXG4gKiBsaXN0LnN1Ymxpc3QoMCwgMSlcbiAqIC8vIC0+IFVpbnQ4QXJyYXlMaXN0KFswXSkgLSBuby1jb3B5XG4gKlxuICogbGlzdC5zdWJsaXN0KDIsIDUpXG4gKiAvLyAtPiBVaW50OEFycmF5TGlzdChbMl0sIFszLCA0XSkgLSBuby1jb3B5XG4gKiBgYGBcbiAqXG4gKiAjIyBJbnNwaXJhdGlvblxuICpcbiAqIEJvcnJvd3MgbGliZXJhbGx5IGZyb20gW2JsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9ibCkgYnV0IG9ubHkgdXNlcyBuYXRpdmUgSlMgdHlwZXMuXG4gKi9cbmltcG9ydCB7IGFsbG9jVW5zYWZlLCBhbGxvYyB9IGZyb20gJ3VpbnQ4YXJyYXlzL2FsbG9jJztcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gJ3VpbnQ4YXJyYXlzL2NvbmNhdCc7XG5pbXBvcnQgeyBlcXVhbHMgfSBmcm9tICd1aW50OGFycmF5cy9lcXVhbHMnO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcignQGFjaGluZ2JyYWluL3VpbnQ4YXJyYXlsaXN0Jyk7XG5mdW5jdGlvbiBmaW5kQnVmQW5kT2Zmc2V0KGJ1ZnMsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09IG51bGwgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgYnVmIG9mIGJ1ZnMpIHtcbiAgICAgICAgY29uc3QgYnVmRW5kID0gb2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA8IGJ1ZkVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBidWYsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4IC0gb2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IGJ1ZkVuZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IGlzIG91dCBvZiBib3VuZHMnKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgb2JqZWN0IGlzIGEgQ0lEIGluc3RhbmNlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgaXNVaW50OEFycmF5TGlzdCwgVWludDhBcnJheUxpc3QgfSBmcm9tICd1aW50OGFycmF5bGlzdCdcbiAqXG4gKiBpc1VpbnQ4QXJyYXlMaXN0KHRydWUpIC8vIGZhbHNlXG4gKiBpc1VpbnQ4QXJyYXlMaXN0KFtdKSAvLyBmYWxzZVxuICogaXNVaW50OEFycmF5TGlzdChuZXcgVWludDhBcnJheUxpc3QoKSkgLy8gdHJ1ZVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VpbnQ4QXJyYXlMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWU/LltzeW1ib2xdKTtcbn1cbmV4cG9ydCBjbGFzcyBVaW50OEFycmF5TGlzdCB7XG4gICAgYnVmcztcbiAgICBsZW5ndGg7XG4gICAgW3N5bWJvbF0gPSB0cnVlO1xuICAgIGNvbnN0cnVjdG9yKC4uLmRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZzID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRBbGwoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5idWZzO1xuICAgIH1cbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb25lIG9yIG1vcmUgYGJ1ZnNgIHRvIHRoZSBlbmQgb2YgdGhpcyBVaW50OEFycmF5TGlzdFxuICAgICAqL1xuICAgIGFwcGVuZCguLi5idWZzKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQWxsKGJ1ZnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIGBidWZzYCB0byB0aGUgZW5kIG9mIHRoaXMgVWludDhBcnJheUxpc3RcbiAgICAgKi9cbiAgICBhcHBlbmRBbGwoYnVmcykge1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidWYgb2YgYnVmcykge1xuICAgICAgICAgICAgaWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZzLnB1c2goYnVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheUxpc3QoYnVmKSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZnMucHVzaCguLi5idWYuYnVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBhcHBlbmQgdmFsdWUsIG11c3QgYmUgYW4gVWludDhBcnJheSBvciBhIFVpbnQ4QXJyYXlMaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb25lIG9yIG1vcmUgYGJ1ZnNgIHRvIHRoZSBzdGFydCBvZiB0aGlzIFVpbnQ4QXJyYXlMaXN0XG4gICAgICovXG4gICAgcHJlcGVuZCguLi5idWZzKSB7XG4gICAgICAgIHRoaXMucHJlcGVuZEFsbChidWZzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFsbCBgYnVmc2AgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgVWludDhBcnJheUxpc3RcbiAgICAgKi9cbiAgICBwcmVwZW5kQWxsKGJ1ZnMpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYnVmIG9mIGJ1ZnMucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZnMudW5zaGlmdChidWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5TGlzdChidWYpKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmcy51bnNoaWZ0KC4uLmJ1Zi5idWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHByZXBlbmQgdmFsdWUsIG11c3QgYmUgYW4gVWludDhBcnJheSBvciBhIFVpbnQ4QXJyYXlMaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSB2YWx1ZSBhdCBgaW5kZXhgXG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbmRCdWZBbmRPZmZzZXQodGhpcy5idWZzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiByZXMuYnVmW3Jlcy5pbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgYXQgYGluZGV4YCB0byBgdmFsdWVgXG4gICAgICovXG4gICAgc2V0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXMgPSBmaW5kQnVmQW5kT2Zmc2V0KHRoaXMuYnVmcywgaW5kZXgpO1xuICAgICAgICByZXMuYnVmW3Jlcy5pbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29weSBieXRlcyBmcm9tIGBidWZgIHRvIHRoZSBpbmRleCBzcGVjaWZpZWQgYnkgYG9mZnNldGBcbiAgICAgKi9cbiAgICB3cml0ZShidWYsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQob2Zmc2V0ICsgaSwgYnVmW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXlMaXN0KGJ1ZikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQob2Zmc2V0ICsgaSwgYnVmLmdldChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCB3cml0ZSB2YWx1ZSwgbXVzdCBiZSBhbiBVaW50OEFycmF5IG9yIGEgVWludDhBcnJheUxpc3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYnl0ZXMgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIHBvb2xcbiAgICAgKi9cbiAgICBjb25zdW1lKGJ5dGVzKSB7XG4gICAgICAgIC8vIGZpcnN0LCBub3JtYWxpemUgdGhlIGFyZ3VtZW50LCBpbiBhY2NvcmRhbmNlIHdpdGggaG93IEJ1ZmZlciBkb2VzIGl0XG4gICAgICAgIGJ5dGVzID0gTWF0aC50cnVuYyhieXRlcyk7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgbm90IGEgcG9zaXRpdmUgbnVtYmVyXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZXMpIHx8IGJ5dGVzIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjb25zdW1pbmcgYWxsIGJ5dGVzLCBza2lwIGl0ZXJhdGluZ1xuICAgICAgICBpZiAoYnl0ZXMgPT09IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZzID0gW107XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgPj0gdGhpcy5idWZzWzBdLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBieXRlcyAtPSB0aGlzLmJ1ZnNbMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLmJ1ZnNbMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZnMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmc1swXSA9IHRoaXMuYnVmc1swXS5zdWJhcnJheShieXRlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggLT0gYnl0ZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYSBzZWN0aW9uIG9mIGFuIGFycmF5IGFuZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGNvcHkgb3BlcmF0aW9uIGFzIGl0IGlzIHdpdGggVWludDhBcnJheXMgYW5kIEFycmF5c1xuICAgICAqIC0gbm90ZSB0aGlzIGlzIGRpZmZlcmVudCB0byB0aGUgYmVoYXZpb3VyIG9mIE5vZGUgQnVmZmVycy5cbiAgICAgKi9cbiAgICBzbGljZShiZWdpbkluY2x1c2l2ZSwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmcywgbGVuZ3RoIH0gPSB0aGlzLl9zdWJMaXN0KGJlZ2luSW5jbHVzaXZlLCBlbmRFeGNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gY29uY2F0KGJ1ZnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBhbGxvYyBmcm9tIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIGVsZW1lbnQgaW5kZXguXG4gICAgICpcbiAgICAgKiBJbiB0aGUgYmVzdCBjYXNlIHdoZXJlIHRoZSBkYXRhIGV4dHJhY3RlZCBjb21lcyBmcm9tIGEgc2luZ2xlIFVpbnQ4QXJyYXlcbiAgICAgKiBpbnRlcm5hbGx5IHRoaXMgaXMgYSBuby1jb3B5IG9wZXJhdGlvbiBvdGhlcndpc2UgaXQgaXMgYSBjb3B5IG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBzdWJhcnJheShiZWdpbkluY2x1c2l2ZSwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmcywgbGVuZ3RoIH0gPSB0aGlzLl9zdWJMaXN0KGJlZ2luSW5jbHVzaXZlLCBlbmRFeGNsdXNpdmUpO1xuICAgICAgICBpZiAoYnVmcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoYnVmcywgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGFsbG9jTGlzdCBmcm9tIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIGVsZW1lbnQgaW5kZXguXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbm8tY29weSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgc3VibGlzdChiZWdpbkluY2x1c2l2ZSwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmcywgbGVuZ3RoIH0gPSB0aGlzLl9zdWJMaXN0KGJlZ2luSW5jbHVzaXZlLCBlbmRFeGNsdXNpdmUpO1xuICAgICAgICBjb25zdCBsaXN0ID0gbmV3IFVpbnQ4QXJyYXlMaXN0KCk7XG4gICAgICAgIGxpc3QubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAvLyBkb24ndCBsb29wLCBqdXN0IHNldCB0aGUgYnVmc1xuICAgICAgICBsaXN0LmJ1ZnMgPSBbLi4uYnVmc107XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBfc3ViTGlzdChiZWdpbkluY2x1c2l2ZSwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIGJlZ2luSW5jbHVzaXZlID0gYmVnaW5JbmNsdXNpdmUgPz8gMDtcbiAgICAgICAgZW5kRXhjbHVzaXZlID0gZW5kRXhjbHVzaXZlID8/IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoYmVnaW5JbmNsdXNpdmUgPCAwKSB7XG4gICAgICAgICAgICBiZWdpbkluY2x1c2l2ZSA9IHRoaXMubGVuZ3RoICsgYmVnaW5JbmNsdXNpdmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZEV4Y2x1c2l2ZSA8IDApIHtcbiAgICAgICAgICAgIGVuZEV4Y2x1c2l2ZSA9IHRoaXMubGVuZ3RoICsgZW5kRXhjbHVzaXZlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbkluY2x1c2l2ZSA8IDAgfHwgZW5kRXhjbHVzaXZlID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luSW5jbHVzaXZlID09PSBlbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGJ1ZnM6IFtdLCBsZW5ndGg6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVnaW5JbmNsdXNpdmUgPT09IDAgJiYgZW5kRXhjbHVzaXZlID09PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgYnVmczogdGhpcy5idWZzLCBsZW5ndGg6IHRoaXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmcyA9IFtdO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZlN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgYnVmRW5kID0gYnVmU3RhcnQgKyBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIC8vIGZvciBuZXh0IGxvb3BcbiAgICAgICAgICAgIG9mZnNldCA9IGJ1ZkVuZDtcbiAgICAgICAgICAgIGlmIChiZWdpbkluY2x1c2l2ZSA+PSBidWZFbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhZnRlciB0aGlzIGJ1ZlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2xpY2VTdGFydEluQnVmID0gYmVnaW5JbmNsdXNpdmUgPj0gYnVmU3RhcnQgJiYgYmVnaW5JbmNsdXNpdmUgPCBidWZFbmQ7XG4gICAgICAgICAgICBjb25zdCBzbGljZUVuZHNJbkJ1ZiA9IGVuZEV4Y2x1c2l2ZSA+IGJ1ZlN0YXJ0ICYmIGVuZEV4Y2x1c2l2ZSA8PSBidWZFbmQ7XG4gICAgICAgICAgICBpZiAoc2xpY2VTdGFydEluQnVmICYmIHNsaWNlRW5kc0luQnVmKSB7XG4gICAgICAgICAgICAgICAgLy8gc2xpY2UgaXMgd2hvbGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBidWZmZXJcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW5JbmNsdXNpdmUgPT09IGJ1ZlN0YXJ0ICYmIGVuZEV4Y2x1c2l2ZSA9PT0gYnVmRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RlZCB3aG9sZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0ZWQgcGFydCBvZiBidWZmZXJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGJlZ2luSW5jbHVzaXZlIC0gYnVmU3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyAoZW5kRXhjbHVzaXZlIC0gYmVnaW5JbmNsdXNpdmUpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2xpY2VTdGFydEluQnVmKSB7XG4gICAgICAgICAgICAgICAgLy8gc2xpY2Ugc3RhcnRzIGluIHRoaXMgYnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKGJlZ2luSW5jbHVzaXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RlZCB3aG9sZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0ZWQgcGFydCBvZiBidWZmZXJcbiAgICAgICAgICAgICAgICBidWZzLnB1c2goYnVmLnN1YmFycmF5KGJlZ2luSW5jbHVzaXZlIC0gYnVmU3RhcnQpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzbGljZUVuZHNJbkJ1Zikge1xuICAgICAgICAgICAgICAgIGlmIChlbmRFeGNsdXNpdmUgPT09IGJ1ZkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0ZWQgd2hvbGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZnMucHVzaChidWYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdGVkIHBhcnQgb2YgYnVmZmVyXG4gICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zi5zdWJhcnJheSgwLCBlbmRFeGNsdXNpdmUgLSBidWZTdGFydCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2xpY2Ugc3RhcnRlZCBiZWZvcmUgdGhpcyBidWZmZXIgYW5kIGVuZHMgYWZ0ZXIgaXRcbiAgICAgICAgICAgIGJ1ZnMucHVzaChidWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ1ZnMsIGxlbmd0aDogZW5kRXhjbHVzaXZlIC0gYmVnaW5JbmNsdXNpdmUgfTtcbiAgICB9XG4gICAgaW5kZXhPZihzZWFyY2gsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKCFpc1VpbnQ4QXJyYXlMaXN0KHNlYXJjaCkgJiYgIShzZWFyY2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IGJlIGEgVWludDhBcnJheUxpc3Qgb3IgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRsZSA9IHNlYXJjaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBzZWFyY2ggOiBzZWFyY2guc3ViYXJyYXkoKTtcbiAgICAgICAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCA/PyAwKTtcbiAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMubGVuZ3RoICsgb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0ID4gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aCA6IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cb3llciVFMiU4MCU5M01vb3JlX3N0cmluZy1zZWFyY2hfYWxnb3JpdGhtXG4gICAgICAgIGNvbnN0IE0gPSBuZWVkbGUuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKE0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NlYXJjaCBtdXN0IGJlIGF0IGxlYXN0IDEgYnl0ZSBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmFkaXhcbiAgICAgICAgY29uc3QgcmFkaXggPSAyNTY7XG4gICAgICAgIGNvbnN0IHJpZ2h0bW9zdFBvc2l0aW9ucyA9IG5ldyBJbnQzMkFycmF5KHJhZGl4KTtcbiAgICAgICAgLy8gcG9zaXRpb24gb2YgdGhlIHJpZ2h0bW9zdCBvY2N1cnJlbmNlIG9mIHRoZSBieXRlIGMgaW4gdGhlIHBhdHRlcm5cbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByYWRpeDsgYysrKSB7XG4gICAgICAgICAgICAvLyAtMSBmb3IgYnl0ZXMgbm90IGluIHBhdHRlcm5cbiAgICAgICAgICAgIHJpZ2h0bW9zdFBvc2l0aW9uc1tjXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTTsgaisrKSB7XG4gICAgICAgICAgICAvLyByaWdodG1vc3QgcG9zaXRpb24gZm9yIGJ5dGVzIGluIHBhdHRlcm5cbiAgICAgICAgICAgIHJpZ2h0bW9zdFBvc2l0aW9uc1tuZWVkbGVbal1dID0gajtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gb2Zmc2V0IG9mIGZpcnN0IG1hdGNoLCAtMSBpZiBubyBtYXRjaFxuICAgICAgICBjb25zdCByaWdodCA9IHJpZ2h0bW9zdFBvc2l0aW9ucztcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5ieXRlTGVuZ3RoIC0gbmVlZGxlLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IGxhc3RQYXRJbmRleCA9IG5lZWRsZS5ieXRlTGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IHNraXA7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPD0gbGFzdEluZGV4OyBpICs9IHNraXApIHtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGxhc3RQYXRJbmRleDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gdGhpcy5nZXQoaSArIGopO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkbGVbal0gIT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCA9IE1hdGgubWF4KDEsIGogLSByaWdodFtjaGFyXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgMSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50OCgwKTtcbiAgICB9XG4gICAgc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBidWYgPSBhbGxvY1Vuc2FmZSgxKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2aWV3LnNldEludDgoMCwgdmFsdWUpO1xuICAgICAgICB0aGlzLndyaXRlKGJ1ZiwgYnl0ZU9mZnNldCk7XG4gICAgfVxuICAgIGdldEludDE2KGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnN1YmFycmF5KGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyAyKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdmlldy5nZXRJbnQxNigwLCBsaXR0bGVFbmRpYW4pO1xuICAgIH1cbiAgICBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKDIpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0SW50MTYoMCwgdmFsdWUsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIHRoaXMud3JpdGUoYnVmLCBieXRlT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0SW50MzIoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuc3ViYXJyYXkoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIDQpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB2aWV3LmdldEludDMyKDAsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmID0gYWxsb2MoNCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB2YWx1ZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy53cml0ZShidWYsIGJ5dGVPZmZzZXQpO1xuICAgIH1cbiAgICBnZXRCaWdJbnQ2NChieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgOCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0QmlnSW50NjQoMCwgbGl0dGxlRW5kaWFuKTtcbiAgICB9XG4gICAgc2V0QmlnSW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICBjb25zdCBidWYgPSBhbGxvYyg4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2aWV3LnNldEJpZ0ludDY0KDAsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB0aGlzLndyaXRlKGJ1ZiwgYnl0ZU9mZnNldCk7XG4gICAgfVxuICAgIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgMSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDgoMCk7XG4gICAgfVxuICAgIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGFsbG9jVW5zYWZlKDEpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgoMCwgdmFsdWUpO1xuICAgICAgICB0aGlzLndyaXRlKGJ1ZiwgYnl0ZU9mZnNldCk7XG4gICAgfVxuICAgIGdldFVpbnQxNihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgMik7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDE2KDAsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKDIpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDE2KDAsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB0aGlzLndyaXRlKGJ1ZiwgYnl0ZU9mZnNldCk7XG4gICAgfVxuICAgIGdldFVpbnQzMihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgNCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKDAsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKDQpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKDAsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB0aGlzLndyaXRlKGJ1ZiwgYnl0ZU9mZnNldCk7XG4gICAgfVxuICAgIGdldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgOCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0QmlnVWludDY0KDAsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0QmlnVWludDY0KDAsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB0aGlzLndyaXRlKGJ1ZiwgYnl0ZU9mZnNldCk7XG4gICAgfVxuICAgIGdldEZsb2F0MzIoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuc3ViYXJyYXkoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIDQpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIoMCwgbGl0dGxlRW5kaWFuKTtcbiAgICB9XG4gICAgc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKDQpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0RmxvYXQzMigwLCB2YWx1ZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy53cml0ZShidWYsIGJ5dGVPZmZzZXQpO1xuICAgIH1cbiAgICBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnN1YmFycmF5KGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyA4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDY0KDAsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICBjb25zdCBidWYgPSBhbGxvYyg4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2aWV3LnNldEZsb2F0NjQoMCwgdmFsdWUsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIHRoaXMud3JpdGUoYnVmLCBieXRlT2Zmc2V0KTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5TGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuYnVmcy5sZW5ndGggIT09IHRoaXMuYnVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHModGhpcy5idWZzW2ldLCBvdGhlci5idWZzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgVWludDhBcnJheUxpc3QgZnJvbSBhIHByZS1leGlzdGluZyBsaXN0IG9mIFVpbnQ4QXJyYXlzLiAgVXNlIHRoaXNcbiAgICAgKiBtZXRob2QgaWYgeW91IGtub3cgdGhlIHRvdGFsIHNpemUgb2YgYWxsIHRoZSBVaW50OEFycmF5cyBhaGVhZCBvZiB0aW1lLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheXMoYnVmcywgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBuZXcgVWludDhBcnJheUxpc3QoKTtcbiAgICAgICAgbGlzdC5idWZzID0gYnVmcztcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBidWZzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmJ5dGVMZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG59XG4vKlxuZnVuY3Rpb24gaW5kZXhPZiAobmVlZGxlOiBVaW50OEFycmF5LCBoYXlzdGFjazogVWludDhBcnJheSwgb2Zmc2V0ID0gMCkge1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgaGF5c3RhY2suYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZWVkbGUubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChoYXlzdGFja1tpICsgal0gIT09IG5lZWRsZVtqXSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAoaiA9PT0gbmVlZGxlLmJ5dGVMZW5ndGggLTEpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGF5c3RhY2suYnl0ZUxlbmd0aCAtIGkgPCBuZWVkbGUuYnl0ZUxlbmd0aCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiYWxsb2NVbnNhZmUiLCJhbGxvYyIsImNvbmNhdCIsImVxdWFscyIsInN5bWJvbCIsIlN5bWJvbCIsImZvciIsImZpbmRCdWZBbmRPZmZzZXQiLCJidWZzIiwiaW5kZXgiLCJSYW5nZUVycm9yIiwib2Zmc2V0IiwiYnVmIiwiYnVmRW5kIiwiYnl0ZUxlbmd0aCIsImlzVWludDhBcnJheUxpc3QiLCJ2YWx1ZSIsIkJvb2xlYW4iLCJVaW50OEFycmF5TGlzdCIsImNvbnN0cnVjdG9yIiwiZGF0YSIsImxlbmd0aCIsImFwcGVuZEFsbCIsIml0ZXJhdG9yIiwiYXBwZW5kIiwiVWludDhBcnJheSIsInB1c2giLCJFcnJvciIsInByZXBlbmQiLCJwcmVwZW5kQWxsIiwicmV2ZXJzZSIsInVuc2hpZnQiLCJnZXQiLCJyZXMiLCJzZXQiLCJ3cml0ZSIsImkiLCJjb25zdW1lIiwiYnl0ZXMiLCJNYXRoIiwidHJ1bmMiLCJOdW1iZXIiLCJpc05hTiIsInNoaWZ0Iiwic3ViYXJyYXkiLCJzbGljZSIsImJlZ2luSW5jbHVzaXZlIiwiZW5kRXhjbHVzaXZlIiwiX3N1Ykxpc3QiLCJzdWJsaXN0IiwibGlzdCIsImJ1ZlN0YXJ0Iiwic2xpY2VTdGFydEluQnVmIiwic2xpY2VFbmRzSW5CdWYiLCJzdGFydCIsImluZGV4T2YiLCJzZWFyY2giLCJUeXBlRXJyb3IiLCJuZWVkbGUiLCJNIiwicmFkaXgiLCJyaWdodG1vc3RQb3NpdGlvbnMiLCJJbnQzMkFycmF5IiwiYyIsImoiLCJyaWdodCIsImxhc3RJbmRleCIsImxhc3RQYXRJbmRleCIsInNraXAiLCJjaGFyIiwibWF4IiwiZ2V0SW50OCIsImJ5dGVPZmZzZXQiLCJ2aWV3IiwiRGF0YVZpZXciLCJidWZmZXIiLCJzZXRJbnQ4IiwiZ2V0SW50MTYiLCJsaXR0bGVFbmRpYW4iLCJzZXRJbnQxNiIsImdldEludDMyIiwic2V0SW50MzIiLCJnZXRCaWdJbnQ2NCIsInNldEJpZ0ludDY0IiwiZ2V0VWludDgiLCJzZXRVaW50OCIsImdldFVpbnQxNiIsInNldFVpbnQxNiIsImdldFVpbnQzMiIsInNldFVpbnQzMiIsImdldEJpZ1VpbnQ2NCIsInNldEJpZ1VpbnQ2NCIsImdldEZsb2F0MzIiLCJzZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEZsb2F0NjQiLCJvdGhlciIsImZyb21VaW50OEFycmF5cyIsInJlZHVjZSIsImFjYyIsImN1cnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uint8arraylist/dist/src/index.js\n");

/***/ })

};
;