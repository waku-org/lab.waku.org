"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/interface-datastore";
exports.ids = ["vendor-chunks/interface-datastore"];
exports.modules = {

/***/ "(ssr)/./node_modules/interface-datastore/dist/src/key.js":
/*!**********************************************************!*\
  !*** ./node_modules/interface-datastore/dist/src/key.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Key: () => (/* binding */ Key)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ \"(ssr)/./node_modules/uint8arrays/dist/src/from-string.node.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/uint8arrays/dist/src/to-string.node.js\");\n\n\nconst pathSepS = \"/\";\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */ class Key {\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */ constructor(s, clean){\n        if (typeof s === \"string\") {\n            this._buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(s);\n        } else if (s instanceof Uint8Array) {\n            this._buf = s;\n        } else {\n            throw new Error(\"Invalid key, should be String of Uint8Array\");\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error(\"Invalid key\");\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */ toString(encoding = \"utf8\") {\n        return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */ uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */ get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */ static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/344502982398')\n     * ```\n     */ static random() {\n        return new Key(Math.random().toString().substring(2));\n    }\n    /**\n     * @param {*} other\n     */ static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === \"string\") {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === \"function\") {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */ clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while(this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep){\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */ less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for(let i = 0; i < list1.length; i++){\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            } else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */ reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */ namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */ baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */ list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */ type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */ name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */ instance(s) {\n        return new Key(this.toString() + \":\" + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */ path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */ parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */ child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        } else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */ isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */ isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */ isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */ concat(...keys) {\n        return Key.withNamespaces([\n            ...this.namespaces(),\n            ...flatten(keys.map((key)=>key.namespaces()))\n        ]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */ function namespaceType(ns) {\n    const parts = ns.split(\":\");\n    if (parts.length < 2) {\n        return \"\";\n    }\n    return parts.slice(0, -1).join(\":\");\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */ function namespaceValue(ns) {\n    const parts = ns.split(\":\");\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */ function flatten(arr) {\n    return [].concat(...arr);\n} //# sourceMappingURL=key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW50ZXJmYWNlLWRhdGFzdG9yZS9kaXN0L3NyYy9rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZFO0FBQ047QUFDdkUsTUFBTUksV0FBVztBQUNqQixNQUFNQyxXQUFXLElBQUlDLGNBQWNDLE1BQU0sQ0FBQ0g7QUFDMUMsTUFBTUksVUFBVUgsUUFBUSxDQUFDLEVBQUU7QUFDM0I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTUk7SUFFVDs7O0tBR0MsR0FDREMsWUFBWUMsQ0FBQyxFQUFFQyxLQUFLLENBQUU7UUFDbEIsSUFBSSxPQUFPRCxNQUFNLFVBQVU7WUFDdkIsSUFBSSxDQUFDRSxJQUFJLEdBQUdaLG1FQUFvQkEsQ0FBQ1U7UUFDckMsT0FDSyxJQUFJQSxhQUFhRyxZQUFZO1lBQzlCLElBQUksQ0FBQ0QsSUFBSSxHQUFHRjtRQUNoQixPQUNLO1lBQ0QsTUFBTSxJQUFJSSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUgsU0FBUyxNQUFNO1lBQ2ZBLFFBQVE7UUFDWjtRQUNBLElBQUlBLE9BQU87WUFDUCxJQUFJLENBQUNBLEtBQUs7UUFDZDtRQUNBLElBQUksSUFBSSxDQUFDQyxJQUFJLENBQUNHLFVBQVUsS0FBSyxLQUFLLElBQUksQ0FBQ0gsSUFBSSxDQUFDLEVBQUUsS0FBS0wsU0FBUztZQUN4RCxNQUFNLElBQUlPLE1BQU07UUFDcEI7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RiLFNBQVNlLFdBQVcsTUFBTSxFQUFFO1FBQ3hCLE9BQU9kLCtEQUFrQkEsQ0FBQyxJQUFJLENBQUNVLElBQUksRUFBRUk7SUFDekM7SUFDQTs7OztLQUlDLEdBQ0RDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ0wsSUFBSTtJQUNwQjtJQUNBOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNNLE9BQU9DLFdBQVcsQ0FBQyxHQUFHO1FBQ3ZCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDbEIsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNw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K0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvaW50ZXJmYWNlLWRhdGFzdG9yZS9kaXN0L3NyYy9rZXkuanM/N2RhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcm9tU3RyaW5nIGFzIHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvZnJvbS1zdHJpbmcnO1xuaW1wb3J0IHsgdG9TdHJpbmcgYXMgdWludDhBcnJheVRvU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvdG8tc3RyaW5nJztcbmNvbnN0IHBhdGhTZXBTID0gJy8nO1xuY29uc3QgcGF0aFNlcEIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF0aFNlcFMpO1xuY29uc3QgcGF0aFNlcCA9IHBhdGhTZXBCWzBdO1xuLyoqXG4gKiBBIEtleSByZXByZXNlbnRzIHRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhbiBvYmplY3QuXG4gKiBPdXIgS2V5IHNjaGVtZSBpcyBpbnNwaXJlZCBieSBmaWxlIHN5c3RlbXMgYW5kIEdvb2dsZSBBcHAgRW5naW5lIGtleSBtb2RlbC5cbiAqIEtleXMgYXJlIG1lYW50IHRvIGJlIHVuaXF1ZSBhY3Jvc3MgYSBzeXN0ZW0uIEtleXMgYXJlIGhpZXJhcmNoaWNhbCxcbiAqIGluY29ycG9yYXRpbmcgbW9yZSBhbmQgbW9yZSBzcGVjaWZpYyBuYW1lc3BhY2VzLiBUaHVzIGtleXMgY2FuIGJlIGRlZW1lZFxuICogJ2NoaWxkcmVuJyBvciAnYW5jZXN0b3JzJyBvZiBvdGhlciBrZXlzOlxuICogLSBgbmV3IEtleSgnL0NvbWVkeScpYFxuICogLSBgbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbicpYFxuICogQWxzbywgZXZlcnkgbmFtZXNwYWNlIGNhbiBiZSBwYXJhbWV0cml6ZWQgdG8gZW1iZWQgcmVsZXZhbnQgb2JqZWN0XG4gKiBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIHRoZSBLZXkgYG5hbWVgIChtb3N0IHNwZWNpZmljIG5hbWVzcGFjZSkgY291bGRcbiAqIGluY2x1ZGUgdGhlIG9iamVjdCB0eXBlOlxuICogLSBgbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcjpKb2huQ2xlZXNlJylgXG4gKiAtIGBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL1NrZXRjaDpDaGVlc2VTaG9wJylgXG4gKiAtIGBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL1NrZXRjaDpDaGVlc2VTaG9wL0NoYXJhY3RlcjpNb3VzZWJlbmRlcicpYFxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEtleSB7XG4gICAgX2J1ZjtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhbl1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzLCBjbGVhbikge1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9idWYgPSB1aW50OEFycmF5RnJvbVN0cmluZyhzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fYnVmID0gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXksIHNob3VsZCBiZSBTdHJpbmcgb2YgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFuKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2J1Zi5ieXRlTGVuZ3RoID09PSAwIHx8IHRoaXMuX2J1ZlswXSAhPT0gcGF0aFNlcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpLlN1cHBvcnRlZEVuY29kaW5nc30gW2VuY29kaW5nPSd1dGY4J10gLSBUaGUgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyh0aGlzLl9idWYsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHVpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBgS2V5KCR7dGhpcy50b1N0cmluZygpfSlgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEga2V5IG91dCBvZiBhIG5hbWVzcGFjZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbGlzdCAtIFRoZSBhcnJheSBvZiBuYW1lc3BhY2VzXG4gICAgICogQHJldHVybnMge0tleX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBLZXkud2l0aE5hbWVzcGFjZXMoWydvbmUnLCAndHdvJ10pXG4gICAgICogLy8gPT4gS2V5KCcvb25lL3R3bycpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIHdpdGhOYW1lc3BhY2VzKGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZXkobGlzdC5qb2luKHBhdGhTZXBTKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb21seSAodXVpZCkgZ2VuZXJhdGVkIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtLZXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogS2V5LnJhbmRvbSgpXG4gICAgICogLy8gPT4gS2V5KCcvMzQ0NTAyOTgyMzk4JylcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleShNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBvdGhlclxuICAgICAqL1xuICAgIHN0YXRpYyBhc0tleShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiBvdGhlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjcmVhdGUgYSBrZXkgZnJvbSB0aGlzXG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleShvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlci51aW50OEFycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGFuIG9sZGVyIHZlcnNpb24gb3IgbWF5IGhhdmUgY3Jvc3NlZCB0aGUgZXNtL2NqcyBib3VuZGFyeVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXkob3RoZXIudWludDhBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW51cCB0aGUgY3VycmVudCBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGNsZWFuKCkge1xuICAgICAgICBpZiAodGhpcy5fYnVmID09IG51bGwgfHwgdGhpcy5fYnVmLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZiA9IHBhdGhTZXBCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9idWZbMF0gIT09IHBhdGhTZXApIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmLmJ5dGVMZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGJ5dGVzLmZpbGwocGF0aFNlcCwgMCwgMSk7XG4gICAgICAgICAgICBieXRlcy5zZXQodGhpcy5fYnVmLCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2J1ZiA9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBkb2VzIG5vdCByZW1vdmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgICB3aGlsZSAodGhpcy5fYnVmLmJ5dGVMZW5ndGggPiAxICYmIHRoaXMuX2J1Zlt0aGlzLl9idWYuYnl0ZUxlbmd0aCAtIDFdID09PSBwYXRoU2VwKSB7XG4gICAgICAgICAgICB0aGlzLl9idWYgPSB0aGlzLl9idWYuc3ViYXJyYXkoMCwgLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBrZXkgaXMgc29ydGVkIGxvd2VyIHRoYW4gb3Vyc2VsZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5fSBrZXkgLSBUaGUgb3RoZXIgS2V5IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBsZXNzKGtleSkge1xuICAgICAgICBjb25zdCBsaXN0MSA9IHRoaXMubGlzdCgpO1xuICAgICAgICBjb25zdCBsaXN0MiA9IGtleS5saXN0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaXN0Mi5sZW5ndGggPCBpICsgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGMxID0gbGlzdDFbaV07XG4gICAgICAgICAgICBjb25zdCBjMiA9IGxpc3QyW2ldO1xuICAgICAgICAgICAgaWYgKGMxIDwgYzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMxID4gYzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3QxLmxlbmd0aCA8IGxpc3QyLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUga2V5IHdpdGggYWxsIHBhcnRzIGluIHJldmVyc2VkIG9yZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0tleX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS5yZXZlcnNlKClcbiAgICAgKiAvLyA9PiBLZXkoJy9BY3RvcjpKb2huQ2xlZXNlL01vbnR5UHl0aG9uL0NvbWVkeScpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIEtleS53aXRoTmFtZXNwYWNlcyh0aGlzLmxpc3QoKS5zbGljZSgpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBuYW1lc3BhY2VzYCBtYWtpbmcgdXAgdGhpcyBLZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBuYW1lc3BhY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0KCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBcImJhc2VcIiBuYW1lc3BhY2Ugb2YgdGhpcyBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3I6Sm9obkNsZWVzZScpLmJhc2VOYW1lc3BhY2UoKVxuICAgICAqIC8vID0+ICdBY3RvcjpKb2huQ2xlZXNlJ1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGJhc2VOYW1lc3BhY2UoKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5uYW1lc3BhY2VzKCk7XG4gICAgICAgIHJldHVybiBuc1tucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGxpc3RgIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcjpKb2huQ2xlZXNlJykubGlzdCgpXG4gICAgICogLy8gPT4gWydDb21lZHknLCAnTW9udHlQeXRob25nJywgJ0FjdG9yOkpvaG5DbGVlc2UnXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkuc3BsaXQocGF0aFNlcFMpLnNsaWNlKDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBcInR5cGVcIiBvZiB0aGlzIGtleSAodmFsdWUgb2YgbGFzdCBuYW1lc3BhY2UpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS50eXBlKClcbiAgICAgKiAvLyA9PiAnQWN0b3InXG4gICAgICogYGBgXG4gICAgICovXG4gICAgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZVR5cGUodGhpcy5iYXNlTmFtZXNwYWNlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBcIm5hbWVcIiBvZiB0aGlzIGtleSAoZmllbGQgb2YgbGFzdCBuYW1lc3BhY2UpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS5uYW1lKClcbiAgICAgKiAvLyA9PiAnSm9obkNsZWVzZSdcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBuYW1lKCkge1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlVmFsdWUodGhpcy5iYXNlTmFtZXNwYWNlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFwiaW5zdGFuY2VcIiBvZiB0aGlzIHR5cGUga2V5IChhcHBlbmRzIHZhbHVlIHRvIG5hbWVzcGFjZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gYXBwZW5kLlxuICAgICAqIEByZXR1cm5zIHtLZXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcicpLmluc3RhbmNlKCdKb2huQ2xlc3NlJylcbiAgICAgKiAvLyA9PiBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3I6Sm9obkNsZWVzZScpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaW5zdGFuY2Uocykge1xuICAgICAgICByZXR1cm4gbmV3IEtleSh0aGlzLnRvU3RyaW5nKCkgKyAnOicgKyBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgXCJwYXRoXCIgb2YgdGhpcyBrZXkgKHBhcmVudCArIHR5cGUpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0tleX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS5wYXRoKClcbiAgICAgKiAvLyA9PiBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3InKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHBhdGgoKSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5wYXJlbnQoKS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIXAuZW5kc1dpdGgocGF0aFNlcFMpKSB7XG4gICAgICAgICAgICBwICs9IHBhdGhTZXBTO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gdGhpcy50eXBlKCk7XG4gICAgICAgIHJldHVybiBuZXcgS2V5KHApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgcGFyZW50YCBLZXkgb2YgdGhpcyBLZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7S2V5fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBLZXkoXCIvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2VcIikucGFyZW50KClcbiAgICAgKiAvLyA9PiBLZXkoXCIvQ29tZWR5L01vbnR5UHl0aG9uXCIpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5saXN0KCk7XG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXkocGF0aFNlcFMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgS2V5KGxpc3Quc2xpY2UoMCwgLTEpLmpvaW4ocGF0aFNlcFMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGNoaWxkYCBLZXkgb2YgdGhpcyBLZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleX0ga2V5IC0gVGhlIGNoaWxkIEtleSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7S2V5fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24nKS5jaGlsZChuZXcgS2V5KCdBY3RvcjpKb2huQ2xlZXNlJykpXG4gICAgICogLy8gPT4gS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNoaWxkKGtleSkge1xuICAgICAgICBpZiAodGhpcy50b1N0cmluZygpID09PSBwYXRoU2VwUykge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkudG9TdHJpbmcoKSA9PT0gcGF0aFNlcFMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgS2V5KHRoaXMudG9TdHJpbmcoKSArIGtleS50b1N0cmluZygpLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIGtleSBpcyBhIHByZWZpeCBvZiBgb3RoZXJgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleX0gb3RoZXIgLSBUaGUgb3RoZXIga2V5IHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBLZXkoJy9Db21lZHknKS5pc0FuY2VzdG9yT2YoJy9Db21lZHkvTW9udHlQeXRob24nKVxuICAgICAqIC8vID0+IHRydWVcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpc0FuY2VzdG9yT2Yob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnRvU3RyaW5nKCkgPT09IHRoaXMudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdGhlci50b1N0cmluZygpLnN0YXJ0c1dpdGgodGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMga2V5IGlzIGEgY29udGFpbnMgYW5vdGhlciBhcyBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleX0gb3RoZXIgLSBUaGUgb3RoZXIgS2V5IHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24nKS5pc0RlY2VuZGFudE9mKCcvQ29tZWR5JylcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaXNEZWNlbmRhbnRPZihvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudG9TdHJpbmcoKSA9PT0gdGhpcy50b1N0cmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5zdGFydHNXaXRoKG90aGVyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBrZXkgaGFzIG9ubHkgb25lIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVG9wTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QoKS5sZW5ndGggPT09IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmNhdHMgb25lIG9yIG1vcmUgS2V5cyBpbnRvIG9uZSBuZXcgS2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxLZXk+fSBrZXlzIC0gVGhlIGFycmF5IG9mIGtleXMgdG8gY29uY2F0ZW5hdGVcbiAgICAgKiBAcmV0dXJucyB7S2V5fVxuICAgICAqL1xuICAgIGNvbmNhdCguLi5rZXlzKSB7XG4gICAgICAgIHJldHVybiBLZXkud2l0aE5hbWVzcGFjZXMoWy4uLnRoaXMubmFtZXNwYWNlcygpLCAuLi5mbGF0dGVuKGtleXMubWFwKGtleSA9PiBrZXkubmFtZXNwYWNlcygpKSldKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBmaXJzdCBjb21wb25lbnQgb2YgYSBuYW1lc3BhY2UuIGBmb29gIGluIGBmb286YmFyYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbmFtZXNwYWNlVHlwZShucykge1xuICAgIGNvbnN0IHBhcnRzID0gbnMuc3BsaXQoJzonKTtcbiAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbignOicpO1xufVxuLyoqXG4gKiBUaGUgbGFzdCBjb21wb25lbnQgb2YgYSBuYW1lc3BhY2UsIGBiYXpgIGluIGBmb286YmFyOmJhemAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBuYW1lc3BhY2VWYWx1ZShucykge1xuICAgIGNvbnN0IHBhcnRzID0gbnMuc3BsaXQoJzonKTtcbiAgICByZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG59XG4vKipcbiAqIEZsYXR0ZW4gYXJyYXkgb2YgYXJyYXlzIChvbmx5IG9uZSBsZXZlbClcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAqIEByZXR1cm5zIHtUW119XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgcmV0dXJuIChbXSkuY29uY2F0KC4uLmFycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuanMubWFwIl0sIm5hbWVzIjpbImZyb21TdHJpbmciLCJ1aW50OEFycmF5RnJvbVN0cmluZyIsInRvU3RyaW5nIiwidWludDhBcnJheVRvU3RyaW5nIiwicGF0aFNlcFMiLCJwYXRoU2VwQiIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwicGF0aFNlcCIsIktleSIsImNvbnN0cnVjdG9yIiwicyIsImNsZWFuIiwiX2J1ZiIsIlVpbnQ4QXJyYXkiLCJFcnJvciIsImJ5dGVMZW5ndGgiLCJlbmNvZGluZyIsInVpbnQ4QXJyYXkiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIndpdGhOYW1lc3BhY2VzIiwibGlzdCIsImpvaW4iLCJyYW5kb20iLCJNYXRoIiwic3Vic3RyaW5nIiwiYXNLZXkiLCJvdGhlciIsImJ5dGVzIiwiZmlsbCIsInNldCIsInN1YmFycmF5IiwibGVzcyIsImtleSIsImxpc3QxIiwibGlzdDIiLCJpIiwibGVuZ3RoIiwiYzEiLCJjMiIsInJldmVyc2UiLCJzbGljZSIsIm5hbWVzcGFjZXMiLCJiYXNlTmFtZXNwYWNlIiwibnMiLCJzcGxpdCIsInR5cGUiLCJuYW1lc3BhY2VUeXBlIiwibmFtZSIsIm5hbWVzcGFjZVZhbHVlIiwiaW5zdGFuY2UiLCJwYXRoIiwicCIsInBhcmVudCIsImVuZHNXaXRoIiwiY2hpbGQiLCJpc0FuY2VzdG9yT2YiLCJzdGFydHNXaXRoIiwiaXNEZWNlbmRhbnRPZiIsImlzVG9wTGV2ZWwiLCJjb25jYXQiLCJrZXlzIiwiZmxhdHRlbiIsIm1hcCIsInBhcnRzIiwiYXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/interface-datastore/dist/src/key.js\n");

/***/ })

};
;