"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/ciphers/esm/_arx.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/_arx.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCipher: () => (/* binding */ createCipher),\n/* harmony export */   rotl: () => (/* binding */ rotl)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/ const sigma16 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"expand 16-byte k\");\nconst sigma32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"expand 32-byte k\");\nconst sigma16_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(sigma16);\nconst sigma32_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(sigma32);\nfunction rotl(a, b) {\n    return a << b | a >>> 32 - b;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(data) : U32_EMPTY;\n    const o32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(output) : U32_EMPTY;\n    for(let pos = 0; pos < len; counter++){\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER) throw new Error(\"arx: counter overflow\");\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0) throw new Error(\"arx: invalid block position\");\n            for(let j = 0, posj; j < BLOCK_LEN32; j++){\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for(let j = 0, posj; j < take; j++){\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\nfunction createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({\n        allowShortKeys: false,\n        counterLength: 8,\n        counterRight: false,\n        rounds: 20\n    }, opts);\n    if (typeof core !== \"function\") throw new Error(\"core must be a function\");\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(counterLength);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(rounds);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bool)(counterRight);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0)=>{\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(key);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(nonce);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n        const len = data.length;\n        if (!output) output = new Uint8Array(len);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(output);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(counter);\n        if (counter < 0 || counter >= MAX_COUNTER) throw new Error(\"arx: counter overflow\");\n        if (output.length < len) throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length, k, sigma;\n        if (l === 32) {\n            k = key.slice();\n            toClean.push(k);\n            sigma = sigma32_32;\n        } else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        } else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce)) {\n            nonce = nonce.slice();\n            toClean.push(nonce);\n        }\n        const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length) throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        while(toClean.length > 0)toClean.pop().fill(0);\n        return output;\n    };\n} //# sourceMappingURL=_arx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL19hcnguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlFQUFpRTtBQUNnQjtBQUN4QjtBQUN6RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBLEdBQ0EsTUFBTVMsVUFBVUQsc0RBQVdBLENBQUM7QUFDNUIsTUFBTUUsVUFBVUYsc0RBQVdBLENBQUM7QUFDNUIsTUFBTUcsYUFBYUosOENBQUdBLENBQUNFO0FBQ3ZCLE1BQU1HLGFBQWFMLDhDQUFHQSxDQUFDRztBQUNoQixTQUFTRyxLQUFLQyxDQUFDLEVBQUVDLENBQUM7SUFDckIsT0FBTyxLQUFNQSxJQUFNRCxNQUFPLEtBQUtDO0FBQ25DO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVNDLFlBQVlELENBQUM7SUFDbEIsT0FBT0EsRUFBRUUsVUFBVSxHQUFHLE1BQU07QUFDaEM7QUFDQSxrREFBa0Q7QUFDbEQsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxjQUFjO0FBQ3BCLHdEQUF3RDtBQUN4RCxpRUFBaUU7QUFDakUsTUFBTUMsY0FBYyxLQUFLLEtBQUs7QUFDOUIsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixTQUFTQyxVQUFVQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU07SUFDckUsTUFBTUMsTUFBTUosS0FBS0ssTUFBTTtJQUN2QixNQUFNQyxRQUFRLElBQUlDLFdBQVdqQjtJQUM3QixNQUFNa0IsTUFBTTdCLDhDQUFHQSxDQUFDMkI7SUFDaEIsNENBQTRDO0lBQzVDLE1BQU1HLFlBQVlyQixZQUFZWSxTQUFTWixZQUFZYTtJQUNuRCxNQUFNUyxNQUFNRCxZQUFZOUIsOENBQUdBLENBQUNxQixRQUFRUDtJQUNwQyxNQUFNa0IsTUFBTUYsWUFBWTlCLDhDQUFHQSxDQUFDc0IsVUFBVVI7SUFDdEMsSUFBSyxJQUFJbUIs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QjtRQUN6QixJQUFJLENBQUN2QyxZQUFZVyxRQUFRO1lBQ3JCQSxRQUFRQSxNQUFNOEIsS0FBSztZQUNuQkgsUUFBUUksSUFBSSxDQUFDL0I7UUFDakI7UUFDQSxNQUFNaUMsTUFBTXJELDhDQUFHQSxDQUFDaUQ7UUFDaEIsMENBQTBDO1FBQzFDLElBQUlMLGVBQWU7WUFDZixJQUFJeEIsTUFBTU0sTUFBTSxLQUFLLElBQ2pCLE1BQU0sSUFBSVEsTUFBTSxDQUFDLG9DQUFvQyxDQUFDO1lBQzFEVSxjQUFjMUIsT0FBT21DLEtBQUtyRCw4Q0FBR0EsQ0FBQ29CLE1BQU1rQyxRQUFRLENBQUMsR0FBRyxNQUFNRDtZQUN0RGpDLFFBQVFBLE1BQU1rQyxRQUFRLENBQUM7UUFDM0I7UUFDQSx1QkFBdUI7UUFDdkIsTUFBTUMsYUFBYSxLQUFLVjtRQUN4QixJQUFJVSxlQUFlbkMsTUFBTU0sTUFBTSxFQUMzQixNQUFNLElBQUlRLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRXFCLFdBQVcsWUFBWSxDQUFDO1FBQ2xFLG1DQUFtQztRQUNuQyxJQUFJQSxlQUFlLElBQUk7WUFDbkIsTUFBTUMsS0FBSyxJQUFJNUIsV0FBVztZQUMxQjRCLEdBQUdKLEdBQUcsQ0FBQ2hDLE9BQU8wQixlQUFlLElBQUksS0FBSzFCLE1BQU1NLE1BQU07WUFDbEROLFFBQVFvQztZQUNSVCxRQUFRSSxJQUFJLENBQUMvQjtRQUNqQjtRQUNBLE1BQU1xQyxNQUFNekQsOENBQUdBLENBQUNvQjtRQUNoQkosVUFBVUMsTUFBTUMsT0FBT21DLEtBQUtJLEtBQUtwQyxNQUFNQyxRQUFRQyxTQUFTQztRQUN4RCxNQUFPdUIsUUFBUXJCLE1BQU0sR0FBRyxFQUNwQnFCLFFBQVFXLEdBQUcsR0FBR0MsSUFBSSxDQUFDO1FBQ3ZCLE9BQU9yQztJQUNYO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX2FyeC5qcz8zM2M3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEJhc2ljIHV0aWxzIGZvciBBUlggKGFkZC1yb3RhdGUteG9yKSBzYWxzYSBhbmQgY2hhY2hhIGNpcGhlcnMuXG5pbXBvcnQgeyBudW1iZXIgYXMgYW51bWJlciwgYnl0ZXMgYXMgYWJ5dGVzLCBib29sIGFzIGFib29sIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNoZWNrT3B0cywgdTMyLCB1dGY4VG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLypcblJGQzg0MzkgcmVxdWlyZXMgbXVsdGktc3RlcCBjaXBoZXIgc3RyZWFtLCB3aGVyZVxuYXV0aEtleSBzdGFydHMgd2l0aCBjb3VudGVyOiAwLCBhY3R1YWwgbXNnIHdpdGggY291bnRlcjogMS5cblxuRm9yIHRoaXMsIHdlIG5lZWQgYSB3YXkgdG8gcmUtdXNlIG5vbmNlIC8gY291bnRlcjpcblxuICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAxXG4gICAgY2hhY2hhKC4uLiwgY291bnRlciwgLi4uKTsgLy8gY291bnRlciBpcyBub3cgMlxuXG5UaGlzIGlzIGNvbXBsaWNhdGVkOlxuXG4tIDMyLWJpdCBjb3VudGVycyBhcmUgZW5vdWdoLCBubyBuZWVkIGZvciA2NC1iaXQ6IG1heCBBcnJheUJ1ZmZlciBzaXplIGluIEpTIGlzIDRHQlxuLSBPcmlnaW5hbCBwYXBlcnMgZG9uJ3QgYWxsb3cgbXV0YXRpbmcgY291bnRlcnNcbi0gQ291bnRlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgW14xXVxuLSBJZGVhIEE6IGFsbG93IHByb3ZpZGluZyAobm9uY2UgfCBjb3VudGVyKSBpbnN0ZWFkIG9mIGp1c3Qgbm9uY2UsIHJlLXVzZSBpdFxuLSBDYXZlYXQ6IENhbm5vdCBiZSByZS11c2VkIHRocm91Z2ggYWxsIGNhc2VzOlxuLSAqIGNoYWNoYSBoYXMgKGNvdW50ZXIgfCBub25jZSlcbi0gKiB4Y2hhY2hhIGhhcyAobm9uY2UxNiB8IGNvdW50ZXIgfCBub25jZTE2KVxuLSBJZGVhIEI6IHNlcGFyYXRlIG5vbmNlIC8gY291bnRlciBhbmQgcHJvdmlkZSBzZXBhcmF0ZSBBUEkgZm9yIGNvdW50ZXIgcmUtdXNlXG4tIENhdmVhdDogdGhlcmUgYXJlIGRpZmZlcmVudCBjb3VudGVyIHNpemVzIGRlcGVuZGluZyBvbiBhbiBhbGdvcml0aG0uXG4tIHNhbHNhICYgY2hhY2hhIGFsc28gZGlmZmVyIGluIHN0cnVjdHVyZXMgb2Yga2V5ICYgc2lnbWE6XG4gIHNhbHNhMjA6ICAgICAgc1swXSB8IGsoNCkgfCBzWzFdIHwgbm9uY2UoMikgfCBjdHIoMikgfCBzWzJdIHwgayg0KSB8IHNbM11cbiAgY2hhY2hhOiAgICAgICBzKDQpIHwgayg4KSB8IGN0cigxKSB8IG5vbmNlKDMpXG4gIGNoYWNoYTIwb3JpZzogcyg0KSB8IGsoOCkgfCBjdHIoMikgfCBub25jZSgyKVxuLSBJZGVhIEM6IGhlbHBlciBtZXRob2Qgc3VjaCBhcyBgc2V0U2Fsc2FTdGF0ZShrZXksIG5vbmNlLCBzaWdtYSwgZGF0YSlgXG4tIENhdmVhdDogd2UgY2FuJ3QgcmUtdXNlIGNvdW50ZXIgYXJyYXlcblxueGNoYWNoYSBbXjJdIHVzZXMgdGhlIHN1YmtleSBhbmQgcmVtYWluaW5nIDggYnl0ZSBub25jZSB3aXRoIENoYUNoYTIwIGFzIG5vcm1hbFxuKHByZWZpeGVkIGJ5IDQgTlVMIGJ5dGVzLCBzaW5jZSBbUkZDODQzOV0gc3BlY2lmaWVzIGEgMTItYnl0ZSBub25jZSkuXG5cblteMV06IGh0dHBzOi8vbWFpbGFyY2hpdmUuaWV0Zi5vcmcvYXJjaC9tc2cvY2ZyZy9nc09uVEp6Y2JnRzZPcUQ4U2MwR081YVJfdFUvXG5bXjJdOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhI2FwcGVuZGl4LUEuMlxuKi9cbmNvbnN0IHNpZ21hMTYgPSB1dGY4VG9CeXRlcygnZXhwYW5kIDE2LWJ5dGUgaycpO1xuY29uc3Qgc2lnbWEzMiA9IHV0ZjhUb0J5dGVzKCdleHBhbmQgMzItYnl0ZSBrJyk7XG5jb25zdCBzaWdtYTE2XzMyID0gdTMyKHNpZ21hMTYpO1xuY29uc3Qgc2lnbWEzMl8zMiA9IHUzMihzaWdtYTMyKTtcbmV4cG9ydCBmdW5jdGlvbiByb3RsKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xufVxuLy8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5mdW5jdGlvbiBpc0FsaWduZWQzMihiKSB7XG4gICAgcmV0dXJuIGIuYnl0ZU9mZnNldCAlIDQgPT09IDA7XG59XG4vLyBTYWxzYSBhbmQgQ2hhY2hhIGJsb2NrIGxlbmd0aCBpcyBhbHdheXMgNTEyLWJpdFxuY29uc3QgQkxPQ0tfTEVOID0gNjQ7XG5jb25zdCBCTE9DS19MRU4zMiA9IDE2O1xuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMl0pICAgLy8gPT4gVWludDMyQXJyYXkoMSkgWyAwIF1cbi8vIG5ldyBVaW50MzJBcnJheShbMioqMzItMV0pIC8vID0+IFVpbnQzMkFycmF5KDEpIFsgNDI5NDk2NzI5NSBdXG5jb25zdCBNQVhfQ09VTlRFUiA9IDIgKiogMzIgLSAxO1xuY29uc3QgVTMyX0VNUFRZID0gbmV3IFVpbnQzMkFycmF5KCk7XG5mdW5jdGlvbiBydW5DaXBoZXIoY29yZSwgc2lnbWEsIGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgY291bnRlciwgcm91bmRzKSB7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgYmxvY2sgPSBuZXcgVWludDhBcnJheShCTE9DS19MRU4pO1xuICAgIGNvbnN0IGIzMiA9IHUzMihibG9jayk7XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVycyBhbGlnbmVkIHRvIDQgYnl0ZXNcbiAgICBjb25zdCBpc0FsaWduZWQgPSBpc0FsaWduZWQzMihkYXRhKSAmJiBpc0FsaWduZWQzMihvdXRwdXQpO1xuICAgIGNvbnN0IGQzMiA9IGlzQWxpZ25lZCA/IHUzMihkYXRhKSA6IFUzMl9FTVBUWTtcbiAgICBjb25zdCBvMzIgPSBpc0FsaWduZWQgPyB1MzIob3V0cHV0KSA6IFUzMl9FTVBUWTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47IGNvdW50ZXIrKykge1xuICAgICAgICBjb3JlKHNpZ21hLCBrZXksIG5vbmNlLCBiMzIsIGNvdW50ZXIsIHJvdW5kcyk7XG4gICAgICAgIGlmIChjb3VudGVyID49IE1BWF9DT1VOVEVSKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKEJMT0NLX0xFTiwgbGVuIC0gcG9zKTtcbiAgICAgICAgLy8gYWxpZ25lZCB0byA0IGJ5dGVzXG4gICAgICAgIGlmIChpc0FsaWduZWQgJiYgdGFrZSA9PT0gQkxPQ0tfTEVOKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MzMiA9IHBvcyAvIDQ7XG4gICAgICAgICAgICBpZiAocG9zICUgNCAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyeDogaW52YWxpZCBibG9jayBwb3NpdGlvbicpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCBCTE9DS19MRU4zMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9zaiA9IHBvczMyICsgajtcbiAgICAgICAgICAgICAgICBvMzJbcG9zal0gPSBkMzJbcG9zal0gXiBiMzJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gQkxPQ0tfTEVOO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCB0YWtlOyBqKyspIHtcbiAgICAgICAgICAgIHBvc2ogPSBwb3MgKyBqO1xuICAgICAgICAgICAgb3V0cHV0W3Bvc2pdID0gZGF0YVtwb3NqXSBeIGJsb2NrW2pdO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB0YWtlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaXBoZXIoY29yZSwgb3B0cykge1xuICAgIGNvbnN0IHsgYWxsb3dTaG9ydEtleXMsIGV4dGVuZE5vbmNlRm4sIGNvdW50ZXJMZW5ndGgsIGNvdW50ZXJSaWdodCwgcm91bmRzIH0gPSBjaGVja09wdHMoeyBhbGxvd1Nob3J0S2V5czogZmFsc2UsIGNvdW50ZXJMZW5ndGg6IDgsIGNvdW50ZXJSaWdodDogZmFsc2UsIHJvdW5kczogMjAgfSwgb3B0cyk7XG4gICAgaWYgKHR5cGVvZiBjb3JlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgYW51bWJlcihjb3VudGVyTGVuZ3RoKTtcbiAgICBhbnVtYmVyKHJvdW5kcyk7XG4gICAgYWJvb2woY291bnRlclJpZ2h0KTtcbiAgICBhYm9vbChhbGxvd1Nob3J0S2V5cyk7XG4gICAgcmV0dXJuIChrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIgPSAwKSA9PiB7XG4gICAgICAgIGFieXRlcyhrZXkpO1xuICAgICAgICBhYnl0ZXMobm9uY2UpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoIW91dHB1dClcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGFieXRlcyhvdXRwdXQpO1xuICAgICAgICBhbnVtYmVyKGNvdW50ZXIpO1xuICAgICAgICBpZiAoY291bnRlciA8IDAgfHwgY291bnRlciA+PSBNQVhfQ09VTlRFUilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG91dHB1dCAoJHtvdXRwdXQubGVuZ3RofSkgaXMgc2hvcnRlciB0aGFuIGRhdGEgKCR7bGVufSlgKTtcbiAgICAgICAgY29uc3QgdG9DbGVhbiA9IFtdO1xuICAgICAgICAvLyBLZXkgJiBzaWdtYVxuICAgICAgICAvLyBrZXk9MTYgLT4gc2lnbWExNiwgaz1rZXl8a2V5XG4gICAgICAgIC8vIGtleT0zMiAtPiBzaWdtYTMyLCBrPWtleVxuICAgICAgICBsZXQgbCA9IGtleS5sZW5ndGgsIGssIHNpZ21hO1xuICAgICAgICBpZiAobCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGsgPSBrZXkuc2xpY2UoKTtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWEzMl8zMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsID09PSAxNiAmJiBhbGxvd1Nob3J0S2V5cykge1xuICAgICAgICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGsuc2V0KGtleSk7XG4gICAgICAgICAgICBrLnNldChrZXksIDE2KTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJ4OiBpbnZhbGlkIDMyLWJ5dGUga2V5LCBnb3QgbGVuZ3RoPSR7bH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb25jZVxuICAgICAgICAvLyBzYWxzYTIwOiAgICAgIDggICAoOC1ieXRlIGNvdW50ZXIpXG4gICAgICAgIC8vIGNoYWNoYTIwb3JpZzogOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAgICAgLy8gY2hhY2hhMjA6ICAgICAxMiAgKDQtYnl0ZSBjb3VudGVyKVxuICAgICAgICAvLyB4c2Fsc2EyMDogICAgIDI0ICAoMTYgLT4gaHNhbHNhLCAgOCAtPiBvbGQgbm9uY2UpXG4gICAgICAgIC8vIHhjaGFjaGEyMDogICAgMjQgICgxNiAtPiBoY2hhY2hhLCA4IC0+IG9sZCBub25jZSlcbiAgICAgICAgLy8gQWxpZ24gbm9uY2UgdG8gNCBieXRlc1xuICAgICAgICBpZiAoIWlzQWxpZ25lZDMyKG5vbmNlKSkge1xuICAgICAgICAgICAgbm9uY2UgPSBub25jZS5zbGljZSgpO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrMzIgPSB1MzIoayk7XG4gICAgICAgIC8vIGhzYWxzYSAmIGhjaGFjaGE6IGhhbmRsZSBleHRlbmRlZCBub25jZVxuICAgICAgICBpZiAoZXh0ZW5kTm9uY2VGbikge1xuICAgICAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCAhPT0gMjQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGV4dGVuZGVkIG5vbmNlIG11c3QgYmUgMjQgYnl0ZXNgKTtcbiAgICAgICAgICAgIGV4dGVuZE5vbmNlRm4oc2lnbWEsIGszMiwgdTMyKG5vbmNlLnN1YmFycmF5KDAsIDE2KSksIGszMik7XG4gICAgICAgICAgICBub25jZSA9IG5vbmNlLnN1YmFycmF5KDE2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbm9uY2UgY291bnRlclxuICAgICAgICBjb25zdCBub25jZU5jTGVuID0gMTYgLSBjb3VudGVyTGVuZ3RoO1xuICAgICAgICBpZiAobm9uY2VOY0xlbiAhPT0gbm9uY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG5vbmNlIG11c3QgYmUgJHtub25jZU5jTGVufSBvciAxNiBieXRlc2ApO1xuICAgICAgICAvLyBQYWQgY291bnRlciB3aGVuIG5vbmNlIGlzIDY0IGJpdFxuICAgICAgICBpZiAobm9uY2VOY0xlbiAhPT0gMTIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5jID0gbmV3IFVpbnQ4QXJyYXkoMTIpO1xuICAgICAgICAgICAgbmMuc2V0KG5vbmNlLCBjb3VudGVyUmlnaHQgPyAwIDogMTIgLSBub25jZS5sZW5ndGgpO1xuICAgICAgICAgICAgbm9uY2UgPSBuYztcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbjMyID0gdTMyKG5vbmNlKTtcbiAgICAgICAgcnVuQ2lwaGVyKGNvcmUsIHNpZ21hLCBrMzIsIG4zMiwgZGF0YSwgb3V0cHV0LCBjb3VudGVyLCByb3VuZHMpO1xuICAgICAgICB3aGlsZSAodG9DbGVhbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdG9DbGVhbi5wb3AoKS5maWxsKDApO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXJ4LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJhbnVtYmVyIiwiYnl0ZXMiLCJhYnl0ZXMiLCJib29sIiwiYWJvb2wiLCJjaGVja09wdHMiLCJ1MzIiLCJ1dGY4VG9CeXRlcyIsInNpZ21hMTYiLCJzaWdtYTMyIiwic2lnbWExNl8zMiIsInNpZ21hMzJfMzIiLCJyb3RsIiwiYSIsImIiLCJpc0FsaWduZWQzMiIsImJ5dGVPZmZzZXQiLCJCTE9DS19MRU4iLCJCTE9DS19MRU4zMiIsIk1BWF9DT1VOVEVSIiwiVTMyX0VNUFRZIiwiVWludDMyQXJyYXkiLCJydW5DaXBoZXIiLCJjb3JlIiwic2lnbWEiLCJrZXkiLCJub25jZSIsImRhdGEiLCJvdXRwdXQiLCJjb3VudGVyIiwicm91bmRzIiwibGVuIiwibGVuZ3RoIiwiYmxvY2siLCJVaW50OEFycmF5IiwiYjMyIiwiaXNBbGlnbmVkIiwiZDMyIiwibzMyIiwicG9zIiwiRXJyb3IiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsInBvczMyIiwiaiIsInBvc2oiLCJjcmVhdGVDaXBoZXIiLCJvcHRzIiwiYWxsb3dTaG9ydEtleXMiLCJleHRlbmROb25jZUZuIiwiY291bnRlckxlbmd0aCIsImNvdW50ZXJSaWdodCIsInRvQ2xlYW4iLCJsIiwiayIsInNsaWNlIiwicHVzaCIsInNldCIsImszMiIsInN1YmFycmF5Iiwibm9uY2VOY0xlbiIsIm5jIiwibjMyIiwicG9wIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/ciphers/esm/_arx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/ciphers/esm/_assert.js":
/*!****************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/_assert.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`boolean expected, not ${b}`);\n}\n// TODO: merge with utils\nfunction isBytes(a) {\n    return a != null && typeof a === \"object\" && (a instanceof Uint8Array || a.constructor.name === \"Uint8Array\");\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"hash must be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFNBQVNBLE9BQU9DLENBQUM7SUFDYixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUgsRUFBRSxDQUFDO0FBQ3REO0FBQ0EsU0FBU0ksS0FBS0MsQ0FBQztJQUNYLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUYsTUFBTSxDQUFDLHNCQUFzQixFQUFFRSxFQUFFLENBQUM7QUFDcEQ7QUFDQSx5QkFBeUI7QUFDekIsU0FBU0MsUUFBUUMsQ0FBQztJQUNkLE9BQVFBLEtBQUssUUFDVCxPQUFPQSxNQUFNLFlBQ1pBLENBQUFBLGFBQWFDLGNBQWNELEVBQUVFLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLLFlBQVc7QUFDdEU7QUFDQSxTQUFTQyxNQUFNTixDQUFDLEVBQUUsR0FBR08sT0FBTztJQUN4QixJQUFJLENBQUNOLFFBQVFELElBQ1QsTUFBTSxJQUFJRixNQUFNO0lBQ3BCLElBQUlTLFFBQVFDLE1BQU0sR0FBRyxLQUFLLENBQUNELFFBQVFFLFFBQVEsQ0FBQ1QsRUFBRVEsTUFBTSxHQUNoRCxNQUFNLElBQUlWLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRVMsUUFBUSxnQkFBZ0IsRUFBRVAsRUFBRVEsTUFBTSxDQUFDLENBQUM7QUFDN0Y7QUFDQSxTQUFTRSxLQUFLQSxJQUFJO0lBQ2QsSUFBSSxPQUFPQSxTQUFTLGNBQWMsT0FBT0EsS0FBS0MsTUFBTSxLQUFLLFlBQ3JELE1BQU0sSUFBSWIsTUFBTTtJQUNwQkosT0FBT2dCLEtBQUtFLFNBQVM7SUFDckJsQixPQUFPZ0IsS0FBS0csUUFBUTtBQUN4QjtBQUNBLFNBQVNDLE9BQU9DLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDMUMsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUluQixNQUFNO0lBQ3BCLElBQUlrQixpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJcEIsTUFBTTtBQUN4QjtBQUNBLFNBQVNxQixPQUFPQyxHQUFHLEVBQUVMLFFBQVE7SUFDekJULE1BQU1jO0lBQ04sTUFBTUMsTUFBTU4sU0FBU0gsU0FBUztJQUM5QixJQUFJUSxJQUFJWixNQUFNLEdBQUdhLEtBQUs7UUFDbEIsTUFBTSxJQUFJdkIsTUFBTSxDQUFDLHNEQUFzRCxFQUFFdUIsSUFBSSxDQUFDO0lBQ2xGO0FBQ0o7QUFDcUQ7QUFDckQsTUFBTUMsU0FBUztJQUFFNUI7SUFBUUs7SUFBTU87SUFBT0k7SUFBTUk7SUFBUUs7QUFBTztBQUMzRCxpRUFBZUcsTUFBTUEsRUFBQyxDQUN0QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX2Fzc2VydC5qcz80MWM0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3cm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLy8gVE9ETzogbWVyZ2Ugd2l0aCB1dGlsc1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoIG11c3QgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYm9vbCIsImIiLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJieXRlcyIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImhhc2giLCJjcmVhdGUiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImV4aXN0cyIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwib3V0cHV0Iiwib3V0IiwibWluIiwiYXNzZXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/ciphers/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/ciphers/esm/_poly1305.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/_poly1305.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poly1305: () => (/* binding */ poly1305),\n/* harmony export */   wrapConstructorWithKey: () => (/* binding */ wrapConstructorWithKey)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n\n\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i)=>a[i++] & 0xff | (a[i++] & 0xff) << 8;\nclass Poly1305 {\n    constructor(key){\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(key);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n        this.r[5] = t4 >>> 1 & 0x1ffe;\n        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n        this.r[9] = t7 >>> 5 & 0x007f;\n        for(let i = 0; i < 8; i++)this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 0x1fff);\n        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 0x1fff);\n        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 0x1fff);\n        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 0x1fff);\n        let h5 = h[5] + (t4 >>> 1 & 0x1fff);\n        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 0x1fff);\n        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 0x1fff);\n        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 0x1fff);\n        let h9 = h[9] + (t7 >>> 5 | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = (c << 2) + c | 0;\n        c = c + d0 | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for(let i = 2; i < 10; i++){\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for(let i = 1; i < 10; i++){\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for(let i = 0; i < 10; i++)g[i] &= mask;\n        mask = ~mask;\n        for(let i = 0; i < 10; i++)h[i] = h[i] & mask | g[i];\n        h[0] = (h[0] | h[1] << 13) & 0xffff;\n        h[1] = (h[1] >>> 3 | h[2] << 10) & 0xffff;\n        h[2] = (h[2] >>> 6 | h[3] << 7) & 0xffff;\n        h[3] = (h[3] >>> 9 | h[4] << 4) & 0xffff;\n        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 0xffff;\n        h[5] = (h[6] >>> 2 | h[7] << 11) & 0xffff;\n        h[6] = (h[7] >>> 5 | h[8] << 8) & 0xffff;\n        h[7] = (h[8] >>> 8 | h[9] << 5) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for(let i = 1; i < 8; i++){\n            f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;\n            h[i] = f & 0xffff;\n        }\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.exists)(this);\n        const { buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for(; blockLen <= len - pos; pos += blockLen)this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.h.fill(0);\n        this.r.fill(0);\n        this.buffer.fill(0);\n        this.pad.fill(0);\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.output)(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            // buffer.subarray(pos).fill(0);\n            for(; pos < 16; pos++)buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for(let i = 0; i < 8; i++){\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key)=>hashCons(key).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key)=>hashCons(key);\n    return hashC;\n}\nconst poly1305 = wrapConstructorWithKey((key)=>new Poly1305(key)); //# sourceMappingURL=_poly1305.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL19wb2x5MTMwNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9FO0FBQ2xCO0FBQ2xELDBFQUEwRTtBQUMxRSx3RUFBd0U7QUFDeEUsZ0RBQWdEO0FBQ2hELHNGQUFzRjtBQUN0RixNQUFNTSxTQUFTLENBQUNDLEdBQUdDLElBQU0sQ0FBRSxDQUFDQSxJQUFJLEdBQUcsT0FBUyxDQUFDRCxDQUFDLENBQUNDLElBQUksR0FBRyxJQUFHLEtBQU07QUFDL0QsTUFBTUM7SUFDRkMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsV0FBVztRQUM3QixJQUFJLENBQUNDLENBQUMsR0FBRyxJQUFJQyxZQUFZO1FBQ3pCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLElBQUlELFlBQVk7UUFDekIsSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSUYsWUFBWTtRQUMzQixJQUFJLENBQUNHLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCVixNQUFNTixrREFBT0EsQ0FBQ007UUFDZFAsc0RBQVdBLENBQUNPLEtBQUs7UUFDakIsTUFBTVcsS0FBS2hCLE9BQU9LLEtBQUs7UUFDdkIsTUFBTVksS0FBS2pCLE9BQU9LLEtBQUs7UUFDdkIsTUFBTWEsS0FBS2xCLE9BQU9LLEtBQUs7UUFDdkIsTUFBTWMsS0FBS25CLE9BQU9LLEtBQUs7UUFDdkIsTUFBTWUsS0FBS3BCLE9BQU9LLEtBQUs7UUFDdkIsTUFBTWdCLEtBQUtyQixPQUFPSyxLQUFLO1FBQ3ZCLE1BQU1pQixLQUFLdEIsT0FBT0ssS0FBSztRQUN2QixNQUFNa0IsS0FBS3ZCLE9BQU9LLEtBQUs7UUFDdkIsc0hBQXNIO1FBQ3RILElBQUksQ0FBQ0ssQ0FBQyxDQUFDLEVBQUUsR0FBR00sS0FBSztRQUNq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d2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9fcG9seTEzMDUuanM/NTkzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMgYXMgYWV4aXN0cywgb3V0cHV0IGFzIGFvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHkxMzA1IGlzIGEgZmFzdCBhbmQgcGFyYWxsZWwgc2VjcmV0LWtleSBtZXNzYWdlLWF1dGhlbnRpY2F0aW9uIGNvZGUuXG4vLyBodHRwczovL2NyLnlwLnRvL21hYy5odG1sLCBodHRwczovL2NyLnlwLnRvL21hYy9wb2x5MTMwNS0yMDA1MDMyOS5wZGZcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQzOVxuLy8gQmFzZWQgb24gUHVibGljIERvbWFpbiBwb2x5MTMwNS1kb25uYSBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbmNvbnN0IHU4dG8xNiA9IChhLCBpKSA9PiAoYVtpKytdICYgMHhmZikgfCAoKGFbaSsrXSAmIDB4ZmYpIDw8IDgpO1xuY2xhc3MgUG9seTEzMDUge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gMTY7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMTY7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnIgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICB0aGlzLmggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGtleSA9IHRvQnl0ZXMoa2V5KTtcbiAgICAgICAgZW5zdXJlQnl0ZXMoa2V5LCAzMik7XG4gICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGtleSwgMCk7XG4gICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGtleSwgMik7XG4gICAgICAgIGNvbnN0IHQyID0gdTh0bzE2KGtleSwgNCk7XG4gICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGtleSwgNik7XG4gICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGtleSwgOCk7XG4gICAgICAgIGNvbnN0IHQ1ID0gdTh0bzE2KGtleSwgMTApO1xuICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihrZXksIDEyKTtcbiAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoa2V5LCAxNCk7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYS9ibG9iL2U2YWQ2ZTA5MWQzMGQ3ZjRlYzJkNGY5NzhiZTFmY2ZjYmNlNzI3ODEvcG9seTEzMDUtZG9ubmEtMTYuaCNMNDdcbiAgICAgICAgdGhpcy5yWzBdID0gdDAgJiAweDFmZmY7XG4gICAgICAgIHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAzKSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCA2KSkgJiAweDFmMDM7XG4gICAgICAgIHRoaXMuclszXSA9ICgodDIgPj4+IDcpIHwgKHQzIDw8IDkpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzRdID0gKCh0MyA+Pj4gNCkgfCAodDQgPDwgMTIpKSAmIDB4MDBmZjtcbiAgICAgICAgdGhpcy5yWzVdID0gKHQ0ID4+PiAxKSAmIDB4MWZmZTtcbiAgICAgICAgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8IDIpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8IDUpKSAmIDB4MWY4MTtcbiAgICAgICAgdGhpcy5yWzhdID0gKCh0NiA+Pj4gOCkgfCAodDcgPDwgOCkpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbOV0gPSAodDcgPj4+IDUpICYgMHgwMDdmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGFkW2ldID0gdTh0bzE2KGtleSwgMTYgKyAyICogaSk7XG4gICAgfVxuICAgIHByb2Nlc3MoZGF0YSwgb2Zmc2V0LCBpc0xhc3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaWJpdCA9IGlzTGFzdCA/IDAgOiAxIDw8IDExO1xuICAgICAgICBjb25zdCB7IGgsIHIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHIwID0gclswXTtcbiAgICAgICAgY29uc3QgcjEgPSByWzFdO1xuICAgICAgICBjb25zdCByMiA9IHJbMl07XG4gICAgICAgIGNvbnN0IHIzID0gclszXTtcbiAgICAgICAgY29uc3QgcjQgPSByWzRdO1xuICAgICAgICBjb25zdCByNSA9IHJbNV07XG4gICAgICAgIGNvbnN0IHI2ID0gcls2XTtcbiAgICAgICAgY29uc3QgcjcgPSByWzddO1xuICAgICAgICBjb25zdCByOCA9IHJbOF07XG4gICAgICAgIGNvbnN0IHI5ID0gcls5XTtcbiAgICAgICAgY29uc3QgdDAgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMCk7XG4gICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDIpO1xuICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgY29uc3QgdDMgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDgpO1xuICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMCk7XG4gICAgICAgIGNvbnN0IHQ2ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEyKTtcbiAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTQpO1xuICAgICAgICBsZXQgaDAgPSBoWzBdICsgKHQwICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgxID0gaFsxXSArICgoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgyID0gaFsyXSArICgoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgzID0gaFszXSArICgoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDQgPSBoWzRdICsgKCgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDUgPSBoWzVdICsgKCh0NCA+Pj4gMSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDYgPSBoWzZdICsgKCgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDcgPSBoWzddICsgKCgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDggPSBoWzhdICsgKCgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoOSA9IGhbOV0gKyAoKHQ3ID4+PiA1KSB8IGhpYml0KTtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBsZXQgZDAgPSBjICsgaDAgKiByMCArIGgxICogKDUgKiByOSkgKyBoMiAqICg1ICogcjgpICsgaDMgKiAoNSAqIHI3KSArIGg0ICogKDUgKiByNik7XG4gICAgICAgIGMgPSBkMCA+Pj4gMTM7XG4gICAgICAgIGQwICY9IDB4MWZmZjtcbiAgICAgICAgZDAgKz0gaDUgKiAoNSAqIHI1KSArIGg2ICogKDUgKiByNCkgKyBoNyAqICg1ICogcjMpICsgaDggKiAoNSAqIHIyKSArIGg5ICogKDUgKiByMSk7XG4gICAgICAgIGMgKz0gZDAgPj4+IDEzO1xuICAgICAgICBkMCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMSA9IGMgKyBoMCAqIHIxICsgaDEgKiByMCArIGgyICogKDUgKiByOSkgKyBoMyAqICg1ICogcjgpICsgaDQgKiAoNSAqIHI3KTtcbiAgICAgICAgYyA9IGQxID4+PiAxMztcbiAgICAgICAgZDEgJj0gMHgxZmZmO1xuICAgICAgICBkMSArPSBoNSAqICg1ICogcjYpICsgaDYgKiAoNSAqIHI1KSArIGg3ICogKDUgKiByNCkgKyBoOCAqICg1ICogcjMpICsgaDkgKiAoNSAqIHIyKTtcbiAgICAgICAgYyArPSBkMSA+Pj4gMTM7XG4gICAgICAgIGQxICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQyID0gYyArIGgwICogcjIgKyBoMSAqIHIxICsgaDIgKiByMCArIGgzICogKDUgKiByOSkgKyBoNCAqICg1ICogcjgpO1xuICAgICAgICBjID0gZDIgPj4+IDEzO1xuICAgICAgICBkMiAmPSAweDFmZmY7XG4gICAgICAgIGQyICs9IGg1ICogKDUgKiByNykgKyBoNiAqICg1ICogcjYpICsgaDcgKiAoNSAqIHI1KSArIGg4ICogKDUgKiByNCkgKyBoOSAqICg1ICogcjMpO1xuICAgICAgICBjICs9IGQyID4+PiAxMztcbiAgICAgICAgZDIgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDMgPSBjICsgaDAgKiByMyArIGgxICogcjIgKyBoMiAqIHIxICsgaDMgKiByMCArIGg0ICogKDUgKiByOSk7XG4gICAgICAgIGMgPSBkMyA+Pj4gMTM7XG4gICAgICAgIGQzICY9IDB4MWZmZjtcbiAgICAgICAgZDMgKz0gaDUgKiAoNSAqIHI4KSArIGg2ICogKDUgKiByNykgKyBoNyAqICg1ICogcjYpICsgaDggKiAoNSAqIHI1KSArIGg5ICogKDUgKiByNCk7XG4gICAgICAgIGMgKz0gZDMgPj4+IDEzO1xuICAgICAgICBkMyAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNCA9IGMgKyBoMCAqIHI0ICsgaDEgKiByMyArIGgyICogcjIgKyBoMyAqIHIxICsgaDQgKiByMDtcbiAgICAgICAgYyA9IGQ0ID4+PiAxMztcbiAgICAgICAgZDQgJj0gMHgxZmZmO1xuICAgICAgICBkNCArPSBoNSAqICg1ICogcjkpICsgaDYgKiAoNSAqIHI4KSArIGg3ICogKDUgKiByNykgKyBoOCAqICg1ICogcjYpICsgaDkgKiAoNSAqIHI1KTtcbiAgICAgICAgYyArPSBkNCA+Pj4gMTM7XG4gICAgICAgIGQ0ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ1ID0gYyArIGgwICogcjUgKyBoMSAqIHI0ICsgaDIgKiByMyArIGgzICogcjIgKyBoNCAqIHIxO1xuICAgICAgICBjID0gZDUgPj4+IDEzO1xuICAgICAgICBkNSAmPSAweDFmZmY7XG4gICAgICAgIGQ1ICs9IGg1ICogcjAgKyBoNiAqICg1ICogcjkpICsgaDcgKiAoNSAqIHI4KSArIGg4ICogKDUgKiByNykgKyBoOSAqICg1ICogcjYpO1xuICAgICAgICBjICs9IGQ1ID4+PiAxMztcbiAgICAgICAgZDUgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDYgPSBjICsgaDAgKiByNiArIGgxICogcjUgKyBoMiAqIHI0ICsgaDMgKiByMyArIGg0ICogcjI7XG4gICAgICAgIGMgPSBkNiA+Pj4gMTM7XG4gICAgICAgIGQ2ICY9IDB4MWZmZjtcbiAgICAgICAgZDYgKz0gaDUgKiByMSArIGg2ICogcjAgKyBoNyAqICg1ICogcjkpICsgaDggKiAoNSAqIHI4KSArIGg5ICogKDUgKiByNyk7XG4gICAgICAgIGMgKz0gZDYgPj4+IDEzO1xuICAgICAgICBkNiAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNyA9IGMgKyBoMCAqIHI3ICsgaDEgKiByNiArIGgyICogcjUgKyBoMyAqIHI0ICsgaDQgKiByMztcbiAgICAgICAgYyA9IGQ3ID4+PiAxMztcbiAgICAgICAgZDcgJj0gMHgxZmZmO1xuICAgICAgICBkNyArPSBoNSAqIHIyICsgaDYgKiByMSArIGg3ICogcjAgKyBoOCAqICg1ICogcjkpICsgaDkgKiAoNSAqIHI4KTtcbiAgICAgICAgYyArPSBkNyA+Pj4gMTM7XG4gICAgICAgIGQ3ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ4ID0gYyArIGgwICogcjggKyBoMSAqIHI3ICsgaDIgKiByNiArIGgzICogcjUgKyBoNCAqIHI0O1xuICAgICAgICBjID0gZDggPj4+IDEzO1xuICAgICAgICBkOCAmPSAweDFmZmY7XG4gICAgICAgIGQ4ICs9IGg1ICogcjMgKyBoNiAqIHIyICsgaDcgKiByMSArIGg4ICogcjAgKyBoOSAqICg1ICogcjkpO1xuICAgICAgICBjICs9IGQ4ID4+PiAxMztcbiAgICAgICAgZDggJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDkgPSBjICsgaDAgKiByOSArIGgxICogcjggKyBoMiAqIHI3ICsgaDMgKiByNiArIGg0ICogcjU7XG4gICAgICAgIGMgPSBkOSA+Pj4gMTM7XG4gICAgICAgIGQ5ICY9IDB4MWZmZjtcbiAgICAgICAgZDkgKz0gaDUgKiByNCArIGg2ICogcjMgKyBoNyAqIHIyICsgaDggKiByMSArIGg5ICogcjA7XG4gICAgICAgIGMgKz0gZDkgPj4+IDEzO1xuICAgICAgICBkOSAmPSAweDFmZmY7XG4gICAgICAgIGMgPSAoKGMgPDwgMikgKyBjKSB8IDA7XG4gICAgICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICAgICAgYyA9IGMgPj4+IDEzO1xuICAgICAgICBkMSArPSBjO1xuICAgICAgICBoWzBdID0gZDA7XG4gICAgICAgIGhbMV0gPSBkMTtcbiAgICAgICAgaFsyXSA9IGQyO1xuICAgICAgICBoWzNdID0gZDM7XG4gICAgICAgIGhbNF0gPSBkNDtcbiAgICAgICAgaFs1XSA9IGQ1O1xuICAgICAgICBoWzZdID0gZDY7XG4gICAgICAgIGhbN10gPSBkNztcbiAgICAgICAgaFs4XSA9IGQ4O1xuICAgICAgICBoWzldID0gZDk7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICBjb25zdCB7IGgsIHBhZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIGxldCBjID0gaFsxXSA+Pj4gMTM7XG4gICAgICAgIGhbMV0gJj0gMHgxZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGhbaV0gKz0gYztcbiAgICAgICAgICAgIGMgPSBoW2ldID4+PiAxMztcbiAgICAgICAgICAgIGhbaV0gJj0gMHgxZmZmO1xuICAgICAgICB9XG4gICAgICAgIGhbMF0gKz0gYyAqIDU7XG4gICAgICAgIGMgPSBoWzBdID4+PiAxMztcbiAgICAgICAgaFswXSAmPSAweDFmZmY7XG4gICAgICAgIGhbMV0gKz0gYztcbiAgICAgICAgYyA9IGhbMV0gPj4+IDEzO1xuICAgICAgICBoWzFdICY9IDB4MWZmZjtcbiAgICAgICAgaFsyXSArPSBjO1xuICAgICAgICBnWzBdID0gaFswXSArIDU7XG4gICAgICAgIGMgPSBnWzBdID4+PiAxMztcbiAgICAgICAgZ1swXSAmPSAweDFmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgZ1tpXSA9IGhbaV0gKyBjO1xuICAgICAgICAgICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgICAgICAgICAgZ1tpXSAmPSAweDFmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZ1s5XSAtPSAxIDw8IDEzO1xuICAgICAgICBsZXQgbWFzayA9IChjIF4gMSkgLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgICAgICBnW2ldICY9IG1hc2s7XG4gICAgICAgIG1hc2sgPSB+bWFzaztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgaFtpXSA9IChoW2ldICYgbWFzaykgfCBnW2ldO1xuICAgICAgICBoWzBdID0gKGhbMF0gfCAoaFsxXSA8PCAxMykpICYgMHhmZmZmO1xuICAgICAgICBoWzFdID0gKChoWzFdID4+PiAzKSB8IChoWzJdIDw8IDEwKSkgJiAweGZmZmY7XG4gICAgICAgIGhbMl0gPSAoKGhbMl0gPj4+IDYpIHwgKGhbM10gPDwgNykpICYgMHhmZmZmO1xuICAgICAgICBoWzNdID0gKChoWzNdID4+PiA5KSB8IChoWzRdIDw8IDQpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs0XSA9ICgoaFs0XSA+Pj4gMTIpIHwgKGhbNV0gPDwgMSkgfCAoaFs2XSA8PCAxNCkpICYgMHhmZmZmO1xuICAgICAgICBoWzVdID0gKChoWzZdID4+PiAyKSB8IChoWzddIDw8IDExKSkgJiAweGZmZmY7XG4gICAgICAgIGhbNl0gPSAoKGhbN10gPj4+IDUpIHwgKGhbOF0gPDwgOCkpICYgMHhmZmZmO1xuICAgICAgICBoWzddID0gKChoWzhdID4+PiA4KSB8IChoWzldIDw8IDUpKSAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGYgPSBoWzBdICsgcGFkWzBdO1xuICAgICAgICBoWzBdID0gZiAmIDB4ZmZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIGYgPSAoKChoW2ldICsgcGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgICAgICAgICAgaFtpXSA9IGYgJiAweGZmZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dFxuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YSwgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuci5maWxsKDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnBhZC5maWxsKDApO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgaCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBidWZmZXJbcG9zKytdID0gMTtcbiAgICAgICAgICAgIC8vIGJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgICAgICBmb3IgKDsgcG9zIDwgMTY7IHBvcysrKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltwb3NdID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhidWZmZXIsIDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgbGV0IG9wb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiAwO1xuICAgICAgICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aEtleShoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywga2V5KSA9PiBoYXNoQ29ucyhrZXkpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKG5ldyBVaW50OEFycmF5KDMyKSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoa2V5KSA9PiBoYXNoQ29ucyhrZXkpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBjb25zdCBwb2x5MTMwNSA9IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoKGtleSkgPT4gbmV3IFBvbHkxMzA1KGtleSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3BvbHkxMzA1LmpzLm1hcCJdLCJuYW1lcyI6WyJleGlzdHMiLCJhZXhpc3RzIiwib3V0cHV0IiwiYW91dHB1dCIsImVuc3VyZUJ5dGVzIiwidG9CeXRlcyIsInU4dG8xNiIsImEiLCJpIiwiUG9seTEzMDUiLCJjb25zdHJ1Y3RvciIsImtleSIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwiYnVmZmVyIiwiVWludDhBcnJheSIsInIiLCJVaW50MTZBcnJheSIsImgiLCJwYWQiLCJwb3MiLCJmaW5pc2hlZCIsInQwIiwidDEiLCJ0MiIsInQzIiwidDQiLCJ0NSIsInQ2IiwidDciLCJwcm9jZXNzIiwiZGF0YSIsIm9mZnNldCIsImlzTGFzdCIsImhpYml0IiwicjAiLCJyMSIsInIyIiwicjMiLCJyNCIsInI1IiwicjYiLCJyNyIsInI4IiwicjkiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImg3IiwiaDgiLCJoOSIsImMiLCJkMCIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZDgiLCJkOSIsImZpbmFsaXplIiwiZyIsIm1hc2siLCJmIiwidXBkYXRlIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJzZXQiLCJzdWJhcnJheSIsImRlc3Ryb3kiLCJmaWxsIiwiZGlnZXN0SW50byIsIm91dCIsIm9wb3MiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsIndyYXBDb25zdHJ1Y3RvcldpdGhLZXkiLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidG1wIiwiY3JlYXRlIiwicG9seTEzMDUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/ciphers/esm/_poly1305.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/ciphers/esm/chacha.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/chacha.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _poly1305_aead: () => (/* binding */ _poly1305_aead),\n/* harmony export */   chacha12: () => (/* binding */ chacha12),\n/* harmony export */   chacha20: () => (/* binding */ chacha20),\n/* harmony export */   chacha20orig: () => (/* binding */ chacha20orig),\n/* harmony export */   chacha20poly1305: () => (/* binding */ chacha20poly1305),\n/* harmony export */   chacha8: () => (/* binding */ chacha8),\n/* harmony export */   hchacha: () => (/* binding */ hchacha),\n/* harmony export */   xchacha20: () => (/* binding */ xchacha20),\n/* harmony export */   xchacha20poly1305: () => (/* binding */ xchacha20poly1305)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _poly1305_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_poly1305.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/_poly1305.js\");\n/* harmony import */ var _arx_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_arx.js */ \"(ssr)/./node_modules/@noble/ciphers/esm/_arx.js\");\n\n\n\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n/**\n * ChaCha core function.\n */ // prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for(let r = 0; r < rounds; r += 2){\n        x00 = x00 + x04 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x00, 16);\n        x08 = x08 + x12 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x08, 12);\n        x00 = x00 + x04 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x00, 8);\n        x08 = x08 + x12 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x08, 7);\n        x01 = x01 + x05 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x01, 16);\n        x09 = x09 + x13 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x09, 12);\n        x01 = x01 + x05 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x01, 8);\n        x09 = x09 + x13 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x09, 7);\n        x02 = x02 + x06 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x02, 16);\n        x10 = x10 + x14 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x10, 12);\n        x02 = x02 + x06 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x02, 8);\n        x10 = x10 + x14 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x10, 7);\n        x03 = x03 + x07 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x03, 16);\n        x11 = x11 + x15 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x11, 12);\n        x03 = x03 + x07 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x03, 8);\n        x11 = x11 + x15 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x11, 7);\n        x00 = x00 + x05 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x00, 16);\n        x10 = x10 + x15 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x10, 12);\n        x00 = x00 + x05 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x00, 8);\n        x10 = x10 + x15 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x10, 7);\n        x01 = x01 + x06 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x01, 16);\n        x11 = x11 + x12 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x11, 12);\n        x01 = x01 + x06 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x01, 8);\n        x11 = x11 + x12 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x11, 7);\n        x02 = x02 + x07 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x02, 16);\n        x08 = x08 + x13 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x08, 12);\n        x02 = x02 + x07 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x02, 8);\n        x08 = x08 + x13 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x08, 7);\n        x03 = x03 + x04 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x03, 16);\n        x09 = x09 + x14 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x09, 12);\n        x03 = x03 + x04 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x03, 8);\n        x09 = x09 + x14 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = y00 + x00 | 0;\n    out[oi++] = y01 + x01 | 0;\n    out[oi++] = y02 + x02 | 0;\n    out[oi++] = y03 + x03 | 0;\n    out[oi++] = y04 + x04 | 0;\n    out[oi++] = y05 + x05 | 0;\n    out[oi++] = y06 + x06 | 0;\n    out[oi++] = y07 + x07 | 0;\n    out[oi++] = y08 + x08 | 0;\n    out[oi++] = y09 + x09 | 0;\n    out[oi++] = y10 + x10 | 0;\n    out[oi++] = y11 + x11 | 0;\n    out[oi++] = y12 + x12 | 0;\n    out[oi++] = y13 + x13 | 0;\n    out[oi++] = y14 + x14 | 0;\n    out[oi++] = y15 + x15 | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */ // prettier-ignore\nfunction hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for(let r = 0; r < 20; r += 2){\n        x00 = x00 + x04 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x00, 16);\n        x08 = x08 + x12 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x08, 12);\n        x00 = x00 + x04 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x00, 8);\n        x08 = x08 + x12 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x08, 7);\n        x01 = x01 + x05 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x01, 16);\n        x09 = x09 + x13 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x09, 12);\n        x01 = x01 + x05 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x01, 8);\n        x09 = x09 + x13 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x09, 7);\n        x02 = x02 + x06 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x02, 16);\n        x10 = x10 + x14 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x10, 12);\n        x02 = x02 + x06 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x02, 8);\n        x10 = x10 + x14 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x10, 7);\n        x03 = x03 + x07 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x03, 16);\n        x11 = x11 + x15 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x11, 12);\n        x03 = x03 + x07 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x03, 8);\n        x11 = x11 + x15 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x11, 7);\n        x00 = x00 + x05 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x00, 16);\n        x10 = x10 + x15 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x10, 12);\n        x00 = x00 + x05 | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x15 ^ x00, 8);\n        x10 = x10 + x15 | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x05 ^ x10, 7);\n        x01 = x01 + x06 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x01, 16);\n        x11 = x11 + x12 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x11, 12);\n        x01 = x01 + x06 | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x12 ^ x01, 8);\n        x11 = x11 + x12 | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x06 ^ x11, 7);\n        x02 = x02 + x07 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x02, 16);\n        x08 = x08 + x13 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x08, 12);\n        x02 = x02 + x07 | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x13 ^ x02, 8);\n        x08 = x08 + x13 | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x07 ^ x08, 7);\n        x03 = x03 + x04 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x03, 16);\n        x09 = x09 + x14 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x09, 12);\n        x03 = x03 + x04 | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x14 ^ x03, 8);\n        x09 = x09 + x14 | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */ const chacha20orig = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */ const chacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */ const xchacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */ const chacha8 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */ const chacha12 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_2__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg)=>{\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left) h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = _poly1305_js__WEBPACK_IMPORTED_MODULE_1__.poly1305.create(authKey);\n    if (AAD) updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(num);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setBigUint64)(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    authKey.fill(0);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */ const _poly1305_aead = (xorStream)=>(key, nonce, AAD)=>{\n        const tagLength = 16;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(key, 32);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(nonce);\n        return {\n            encrypt: (plaintext, output)=>{\n                const plength = plaintext.length;\n                const clength = plength + tagLength;\n                if (output) {\n                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(output, clength);\n                } else {\n                    output = new Uint8Array(clength);\n                }\n                xorStream(key, nonce, plaintext, output, 1);\n                const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n                output.set(tag, plength); // append tag\n                return output;\n            },\n            decrypt: (ciphertext, output)=>{\n                const clength = ciphertext.length;\n                const plength = clength - tagLength;\n                if (clength < tagLength) throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n                if (output) {\n                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(output, plength);\n                } else {\n                    output = new Uint8Array(plength);\n                }\n                const data = ciphertext.subarray(0, -tagLength);\n                const passedTag = ciphertext.subarray(-tagLength);\n                const tag = computeTag(xorStream, key, nonce, data, AAD);\n                if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.equalBytes)(passedTag, tag)) throw new Error(\"invalid tag\");\n                xorStream(key, nonce, data, output, 1);\n                return output;\n            }\n        };\n    };\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */ const chacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapCipher)({\n    blockSize: 64,\n    nonceLength: 12,\n    tagLength: 16\n}, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */ const xchacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapCipher)({\n    blockSize: 64,\n    nonceLength: 24,\n    tagLength: 16\n}, _poly1305_aead(xchacha20)); //# sourceMappingURL=chacha.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL2NoYWNoYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNEY7QUFDbEQ7QUFDSztBQUMvQyx1RUFBdUU7QUFDdkUsZ0VBQWdFO0FBQ2hFLDJFQUEyRTtBQUMzRTs7Q0FFQyxHQUNELGtCQUFrQjtBQUNsQixTQUFTUSxXQUFXQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsU0FBUyxFQUFFO0lBQzlDLElBQUlDLE1BQU1OLENBQUMsQ0FBQyxFQUFFLEVBQUVPLE1BQU1QLENBQUMsQ0FBQyxFQUFFLEVBQUVRLE1BQU1SLENBQUMsQ0FBQyxFQUFFLEVBQUVTLE1BQU1ULENBQUMsQ0FBQyxFQUFFLEVBQ2xEVSxNQUFNVCxDQUFDLENBQUMsRUFBRSxFQUFFVSxNQUFNVixDQUFDLENBQUMsRUFBRSxFQUFFVyxNQUFNWCxDQUFDLENBQUMsRUFBRSxFQUFFWSxNQUFNWixDQUFDLENBQUMsRUFBRSxFQUM5Q2EsTUFBTWIsQ0FBQyxDQUFDLEVBQUUsRUFBRWMsTUFBTWQsQ0FBQyxDQUFDLEVBQUUsRUFBRWUsTUFBTWYsQ0FBQyxDQUFDLEVBQUUsRUFBRWdCLE1BQU1oQixDQUFDLENBQUMsRUFBRSxFQUM5Q2lCLE1BQU1kLEtBQUtlLE1BQU1qQixDQUFDLENBQUMsRUFBRSxFQUFFa0IsTUFBTWxCLENBQUMsQ0FBQyxFQUFFLEVBQUVtQixNQUFNbkIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxpQ0FBaUM7SUFDaEYsb0NBQW9DO0lBQ3BDLElBQUlvQixNQUFNaEIsS0FBS2lCLE1BQU1oQixLQUFLaUIsTUFBTWhCLEtBQUtpQixNQUFNaEIsS0FBS2lCLE1BQU1oQixLQUFLaUIsTUFBTWhCLEtBQUtpQixNQUFNaEIsS0FBS2lCLE1BQU1oQixLQUFLaUIsTUFBTWhCLEtBQUtpQixNQUFNaEIsS0FBS2lCLE1BQU1oQixLQUFLaUIsTUFBTWhCLEtBQUtp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QUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9jaGFjaGEuanM/ODFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3cmFwQ2lwaGVyLCBjcmVhdGVWaWV3LCBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcywgc2V0QmlnVWludDY0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgcG9seTEzMDUgfSBmcm9tICcuL19wb2x5MTMwNS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDaXBoZXIsIHJvdGwgfSBmcm9tICcuL19hcnguanMnO1xuLy8gQ2hhQ2hhMjAgc3RyZWFtIGNpcGhlciB3YXMgcmVsZWFzZWQgaW4gMjAwOC4gQ2hhQ2hhIGFpbXMgdG8gaW5jcmVhc2Vcbi8vIHRoZSBkaWZmdXNpb24gcGVyIHJvdW5kLCBidXQgaGFkIHNsaWdodGx5IGxlc3MgY3J5cHRhbmFseXNpcy5cbi8vIGh0dHBzOi8vY3IueXAudG8vY2hhY2hhLmh0bWwsIGh0dHA6Ly9jci55cC50by9jaGFjaGEvY2hhY2hhLTIwMDgwMTI4LnBkZlxuLyoqXG4gKiBDaGFDaGEgY29yZSBmdW5jdGlvbi5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuICAgIGxldCB5MDAgPSBzWzBdLCB5MDEgPSBzWzFdLCB5MDIgPSBzWzJdLCB5MDMgPSBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICB5MDQgPSBrWzBdLCB5MDUgPSBrWzFdLCB5MDYgPSBrWzJdLCB5MDcgPSBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIHkxMiA9IGNudCwgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlc1xuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXRcbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbi8qKlxuICogaGNoYWNoYSBoZWxwZXIgbWV0aG9kLCB1c2VkIHByaW1hcmlseSBpbiB4Y2hhY2hhLCB0byBoYXNoXG4gKiBrZXkgYW5kIG5vbmNlIGludG8ga2V5JyBhbmQgbm9uY2UnLlxuICogU2FtZSBhcyBjaGFjaGFDb3JlLCBidXQgdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgd2F5IHRvIG1vdmUgdGhlIGJsb2NrXG4gKiBvdXQgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBmdW5jdGlvbiBoY2hhY2hhKHMsIGssIGksIG8zMikge1xuICAgIGxldCB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLCB4MDQgPSBrWzBdLCB4MDUgPSBrWzFdLCB4MDYgPSBrWzJdLCB4MDcgPSBrWzNdLCB4MDggPSBrWzRdLCB4MDkgPSBrWzVdLCB4MTAgPSBrWzZdLCB4MTEgPSBrWzddLCB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgMjA7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICBsZXQgb2kgPSAwO1xuICAgIG8zMltvaSsrXSA9IHgwMDtcbiAgICBvMzJbb2krK10gPSB4MDE7XG4gICAgbzMyW29pKytdID0geDAyO1xuICAgIG8zMltvaSsrXSA9IHgwMztcbiAgICBvMzJbb2krK10gPSB4MTI7XG4gICAgbzMyW29pKytdID0geDEzO1xuICAgIG8zMltvaSsrXSA9IHgxNDtcbiAgICBvMzJbb2krK10gPSB4MTU7XG59XG4vKipcbiAqIE9yaWdpbmFsLCBub24tUkZDIGNoYWNoYTIwIGZyb20gREpCLiA4LWJ5dGUgbm9uY2UsIDgtYnl0ZSBjb3VudGVyLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjBvcmlnID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA4LFxuICAgIGFsbG93U2hvcnRLZXlzOiB0cnVlLFxufSk7XG4vKipcbiAqIENoYUNoYSBzdHJlYW0gY2lwaGVyLiBDb25mb3JtcyB0byBSRkMgODQzOSAoSUVURiwgVExTKS4gMTItYnl0ZSBub25jZSwgNC1ieXRlIGNvdW50ZXIuXG4gKiBXaXRoIDEyLWJ5dGUgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDQsXG4gICAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxufSk7XG4vKipcbiAqIFhDaGFDaGEgZVh0ZW5kZWQtbm9uY2UgQ2hhQ2hhLiAyNC1ieXRlIG5vbmNlLlxuICogV2l0aCAyNC1ieXRlIG5vbmNlLCBpdCdzIHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORykuXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDgsXG4gICAgZXh0ZW5kTm9uY2VGbjogaGNoYWNoYSxcbiAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogUmVkdWNlZCA4LXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhOCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogNCxcbiAgICByb3VuZHM6IDgsXG59KTtcbi8qKlxuICogUmVkdWNlZCAxMi1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTEyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA0LFxuICAgIHJvdW5kczogMTIsXG59KTtcbmNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoLCBtc2cpID0+IHtcbiAgICBoLnVwZGF0ZShtc2cpO1xuICAgIGNvbnN0IGxlZnQgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgaWYgKGxlZnQpXG4gICAgICAgIGgudXBkYXRlKFpFUk9TMTYuc3ViYXJyYXkobGVmdCkpO1xufTtcbmNvbnN0IFpFUk9TMzIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwga2V5LCBub25jZSwgZGF0YSwgQUFEKSB7XG4gICAgY29uc3QgYXV0aEtleSA9IGZuKGtleSwgbm9uY2UsIFpFUk9TMzIpO1xuICAgIGNvbnN0IGggPSBwb2x5MTMwNS5jcmVhdGUoYXV0aEtleSk7XG4gICAgaWYgKEFBRClcbiAgICAgICAgdXBkYXRlUGFkZGVkKGgsIEFBRCk7XG4gICAgdXBkYXRlUGFkZGVkKGgsIGRhdGEpO1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhudW0pO1xuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCAwLCBCaWdJbnQoQUFEID8gQUFELmxlbmd0aCA6IDApLCB0cnVlKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGRhdGEubGVuZ3RoKSwgdHJ1ZSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICAgIGF1dGhLZXkuZmlsbCgwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBBRUFEIGFsZ29yaXRobSBmcm9tIFJGQyA4NDM5LlxuICogU2Fsc2EyMCBhbmQgY2hhY2hhIChSRkMgODQzOSkgdXNlIHBvbHkxMzA1IGRpZmZlcmVudGx5LlxuICogV2UgY291bGQgaGF2ZSBjb21wb3NlZCB0aGVtIHNpbWlsYXIgdG86XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJhc2UvYmxvYi9iMjY2YzczZGRlOTc3YjFkZDdlZjQwZWY3YTIzY2MxNWFhYjUyNmIzL2luZGV4LnRzI0wyNTBcbiAqIEJ1dCBpdCdzIGhhcmQgYmVjYXVzZSBvZiBhdXRoS2V5OlxuICogSW4gc2Fsc2EyMCwgYXV0aEtleSBjaGFuZ2VzIHBvc2l0aW9uIGluIHNhbHNhIHN0cmVhbS5cbiAqIEluIGNoYWNoYSwgYXV0aEtleSBjYW4ndCBiZSBjb21wdXRlZCBpbnNpZGUgY29tcHV0ZVRhZywgaXQgbW9kaWZpZXMgdGhlIGNvdW50ZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBfcG9seTEzMDVfYWVhZCA9ICh4b3JTdHJlYW0pID0+IChrZXksIG5vbmNlLCBBQUQpID0+IHtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICBlbnN1cmVCeXRlcyhrZXksIDMyKTtcbiAgICBlbnN1cmVCeXRlcyhub25jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jcnlwdDogKHBsYWludGV4dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGVuZ3RoID0gcGxhaW50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGNsZW5ndGggPSBwbGVuZ3RoICsgdGFnTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGVuc3VyZUJ5dGVzKG91dHB1dCwgY2xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShjbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBwbGFpbnRleHQsIG91dHB1dCwgMSk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgb3V0cHV0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpLCBBQUQpO1xuICAgICAgICAgICAgb3V0cHV0LnNldCh0YWcsIHBsZW5ndGgpOyAvLyBhcHBlbmQgdGFnXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVuZ3RoID0gY2lwaGVydGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwbGVuZ3RoID0gY2xlbmd0aCAtIHRhZ0xlbmd0aDtcbiAgICAgICAgICAgIGlmIChjbGVuZ3RoIDwgdGFnTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZW5jcnlwdGVkIGRhdGEgbXVzdCBiZSBhdCBsZWFzdCAke3RhZ0xlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBlbnN1cmVCeXRlcyhvdXRwdXQsIHBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkocGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgZGF0YSwgQUFEKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxCeXRlcyhwYXNzZWRUYWcsIHRhZykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZycpO1xuICAgICAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBDaGFDaGEyMC1Qb2x5MTMwNSBmcm9tIFJGQyA4NDM5LlxuICogV2l0aCAxMi1ieXRlIG5vbmNlLCBpdCdzIG5vdCBzYWZlIHRvIHVzZSBmaWxsIGl0IHdpdGggcmFuZG9tIChDU1BSTkcpLCBkdWUgdG8gY29sbGlzaW9uIGNoYW5jZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwcG9seTEzMDUgPSAvKiBAX19QVVJFX18gKi8gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LCBfcG9seTEzMDVfYWVhZChjaGFjaGEyMCkpO1xuLyoqXG4gKiBYQ2hhQ2hhMjAtUG9seTEzMDUgZXh0ZW5kZWQtbm9uY2UgY2hhY2hhLlxuICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYVxuICogV2l0aCAyNC1ieXRlIG5vbmNlLCBpdCdzIHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORykuXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjBwb2x5MTMwNSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKHsgYmxvY2tTaXplOiA2NCwgbm9uY2VMZW5ndGg6IDI0LCB0YWdMZW5ndGg6IDE2IH0sIF9wb2x5MTMwNV9hZWFkKHhjaGFjaGEyMCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhY2hhLmpzLm1hcCJdLCJuYW1lcyI6WyJ3cmFwQ2lwaGVyIiwiY3JlYXRlVmlldyIsImVuc3VyZUJ5dGVzIiwiZXF1YWxCeXRlcyIsInNldEJpZ1VpbnQ2NCIsInBvbHkxMzA1IiwiY3JlYXRlQ2lwaGVyIiwicm90bCIsImNoYWNoYUNvcmUiLCJzIiwiayIsIm4iLCJvdXQiLCJjbnQiLCJyb3VuZHMiLCJ5MDAiLCJ5MDEiLCJ5MDIiLCJ5MDMiLCJ5MDQiLCJ5MDUiLCJ5MDYiLCJ5MDciLCJ5MDgiLCJ5MDkiLCJ5MTAiLCJ5MTEiLCJ5MTIiLCJ5MTMiLCJ5MTQiLCJ5MTUiLCJ4MDAiLCJ4MDEiLCJ4MDIiLCJ4MDMiLCJ4MDQiLCJ4MDUiLCJ4MDYiLCJ4MDciLCJ4MDgiLCJ4MDkiLCJ4MTAiLCJ4MTEiLCJ4MTIiLCJ4MTMiLCJ4MTQiLCJ4MTUiLCJyIiwib2kiLCJoY2hhY2hhIiwiaSIsIm8zMiIsImNoYWNoYTIwb3JpZyIsImNvdW50ZXJSaWdodCIsImNvdW50ZXJMZW5ndGgiLCJhbGxvd1Nob3J0S2V5cyIsImNoYWNoYTIwIiwieGNoYWNoYTIwIiwiZXh0ZW5kTm9uY2VGbiIsImNoYWNoYTgiLCJjaGFjaGExMiIsIlpFUk9TMTYiLCJVaW50OEFycmF5IiwidXBkYXRlUGFkZGVkIiwiaCIsIm1zZyIsInVwZGF0ZSIsImxlZnQiLCJsZW5ndGgiLCJzdWJhcnJheSIsIlpFUk9TMzIiLCJjb21wdXRlVGFnIiwiZm4iLCJrZXkiLCJub25jZSIsImRhdGEiLCJBQUQiLCJhdXRoS2V5IiwiY3JlYXRlIiwibnVtIiwidmlldyIsIkJpZ0ludCIsInJlcyIsImRpZ2VzdCIsImZpbGwiLCJfcG9seTEzMDVfYWVhZCIsInhvclN0cmVhbSIsInRhZ0xlbmd0aCIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJvdXRwdXQiLCJwbGVuZ3RoIiwiY2xlbmd0aCIsInRhZyIsInNldCIsImRlY3J5cHQiLCJjaXBoZXJ0ZXh0IiwiRXJyb3IiLCJwYXNzZWRUYWciLCJjaGFjaGEyMHBvbHkxMzA1IiwiYmxvY2tTaXplIiwibm9uY2VMZW5ndGgiLCJ4Y2hhY2hhMjBwb2x5MTMwNSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/ciphers/esm/chacha.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/ciphers/esm/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u16: () => (/* binding */ u16),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u64Lengths: () => (/* binding */ u64Lengths),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapCipher: () => (/* binding */ wrapCipher)\n/* harmony export */ });\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ // Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u16 = (arr)=>new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\");\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!isBytes(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    else if (isBytes(data)) data = data.slice();\n    else throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        if (!isBytes(a)) throw new Error(\"Uint8Array expected\");\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new Error(\"options must be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction ensureBytes(b, len) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (typeof len === \"number\") {\n        if (b.length !== len) throw new Error(`Uint8Array length ${len} expected`);\n    }\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// For runtime check if class implements interface\nclass Hash {\n}\nconst wrapCipher = (params, c)=>{\n    Object.assign(c, params);\n    return c;\n};\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nfunction u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUVBQXFFLEdBQ3JFLCtCQUErQjtBQUN4QixNQUFNQSxLQUFLLENBQUNDLE1BQVEsSUFBSUMsV0FBV0QsSUFBSUUsTUFBTSxFQUFFRixJQUFJRyxVQUFVLEVBQUVILElBQUlJLFVBQVUsRUFBRTtBQUMvRSxNQUFNQyxNQUFNLENBQUNMLE1BQVEsSUFBSU0sWUFBWU4sSUFBSUUsTUFBTSxFQUFFRixJQUFJRyxVQUFVLEVBQUVJLEtBQUtDLEtBQUssQ0FBQ1IsSUFBSUksVUFBVSxHQUFHLElBQUk7QUFDakcsTUFBTUssTUFBTSxDQUFDVCxNQUFRLElBQUlVLFlBQVlWLElBQUlFLE1BQU0sRUFBRUYsSUFBSUcsVUFBVSxFQUFFSSxLQUFLQyxLQUFLLENBQUNSLElBQUlJLFVBQVUsR0FBRyxJQUFJO0FBQ3hHLFNBQVNPLFFBQVFDLENBQUM7SUFDZCxPQUFRQSxhQUFhWCxjQUNoQlcsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUMsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQSxxQkFBcUI7QUFDZCxNQUFNQyxhQUFhLENBQUNmLE1BQVEsSUFBSWdCLFNBQVNoQixJQUFJRSxNQUFNLEVBQUVGLElBQUlHLFVBQVUsRUFBRUgsSUFBSUksVUFBVSxFQUFFO0FBQzVGLGtGQUFrRjtBQUNsRix3REFBd0Q7QUFDakQsTUFBTWEsT0FBTyxJQUFJaEIsV0FBVyxJQUFJUyxZQUFZO0lBQUM7Q0FBVyxFQUFFUixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSztBQUNyRixJQUFJLENBQUNlLE1BQ0QsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCLHdEQUF3RDtBQUN4RCxNQUFNQyxRQUFRLGFBQWEsR0FBR0MsTUFBTUMsSUFBSSxDQUFDO0lBQUVDLFFBQVE7QUFBSSxHQUFHLENBQUNDLEdBQUdDLElB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YSxDQUFDQyxRQUFRQztJQUMvQmQsT0FBT08sTUFBTSxDQUFDTyxHQUFHRDtJQUNqQixPQUFPQztBQUNYLEVBQUU7QUFDRix5QkFBeUI7QUFDbEIsU0FBU0MsYUFBYUMsSUFBSSxFQUFFL0YsVUFBVSxFQUFFZ0csS0FBSyxFQUFFbEYsSUFBSTtJQUN0RCxJQUFJLE9BQU9pRixLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDOUYsWUFBWWdHLE9BQU9sRjtJQUNoRCxNQUFNbUYsT0FBT2xELE9BQU87SUFDcEIsTUFBTW1ELFdBQVduRCxPQUFPO0lBQ3hCLE1BQU1vRCxLQUFLQyxPQUFPLFNBQVVILE9BQVFDO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9KLFFBQVFFO0lBQzFCLE1BQU1JLElBQUl4RixPQUFPLElBQUk7SUFDckIsTUFBTXlGLElBQUl6RixPQUFPLElBQUk7SUFDckJpRixLQUFLUyxTQUFTLENBQUN4RyxhQUFhc0csR0FBR0gsSUFBSXJGO0lBQ25DaUYsS0FBS1MsU0FBUyxDQUFDeEcsYUFBYXVHLEdBQUdGLElBQUl2RjtBQUN2QztBQUNPLFNBQVMyRixXQUFXQyxVQUFVLEVBQUVDLEdBQUc7SUFDdEMsTUFBTUMsTUFBTSxJQUFJOUcsV0FBVztJQUMzQixNQUFNaUcsT0FBT25GLFdBQVdnRztJQUN4QmQsYUFBYUMsTUFBTSxHQUFHaEQsT0FBTzRELE1BQU1BLElBQUl4RixNQUFNLEdBQUcsSUFBSTtJQUNwRDJFLGFBQWFDLE1BQU0sR0FBR2hELE9BQU8yRCxXQUFXdkYsTUFBTSxHQUFHO0lBQ2pELE9BQU95RjtBQUNYLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL3V0aWxzLmpzP2U5ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWNpcGhlcnMgLSBNSVQgTGljZW5zZSAoYykgMjAyMyBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTE2ID0gKGFycikgPT4gbmV3IFVpbnQxNkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gMikpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gY2lwaGVyczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoKTtcbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKCFpc0J5dGVzKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGIsIGxlbikge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICdudW1iZXInKVxuICAgICAgICBpZiAoYi5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBsZW5ndGggJHtsZW59IGV4cGVjdGVkYCk7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG5leHBvcnQgY29uc3Qgd3JhcENpcGhlciA9IChwYXJhbXMsIGMpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKGMsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGM7XG59O1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZXhwb3J0IGZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdTY0TGVuZ3RocyhjaXBoZXJ0ZXh0LCBBQUQpIHtcbiAgICBjb25zdCBudW0gPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcobnVtKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgMCwgQmlnSW50KEFBRCA/IEFBRC5sZW5ndGggOiAwKSwgdHJ1ZSk7XG4gICAgc2V0QmlnVWludDY0KHZpZXcsIDgsIEJpZ0ludChjaXBoZXJ0ZXh0Lmxlbmd0aCksIHRydWUpO1xuICAgIHJldHVybiBudW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsidTgiLCJhcnIiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJ1MTYiLCJVaW50MTZBcnJheSIsIk1hdGgiLCJmbG9vciIsInUzMiIsIlVpbnQzMkFycmF5IiwiaXNCeXRlcyIsImEiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjcmVhdGVWaWV3IiwiRGF0YVZpZXciLCJpc0xFIiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsImhleCIsImFzY2lpcyIsIl8wIiwiXzkiLCJfQSIsIl9GIiwiX2EiLCJfZiIsImFzY2lpVG9CYXNlMTYiLCJjaGFyIiwiaGV4VG9CeXRlcyIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsImhleFRvTnVtYmVyIiwiQmlnSW50IiwiYnl0ZXNUb051bWJlckJFIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsImxlbiIsIm5leHRUaWNrIiwiYXN5bmNMb29wIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJ5dGVzVG9VdGY4IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJ0b0J5dGVzIiwiZGF0YSIsInNsaWNlIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJzdW0iLCJyZXMiLCJwYWQiLCJzZXQiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsImNoZWNrT3B0cyIsImRlZmF1bHRzIiwib3B0cyIsIm1lcmdlZCIsImFzc2lnbiIsImVuc3VyZUJ5dGVzIiwiYiIsImVxdWFsQnl0ZXMiLCJIYXNoIiwid3JhcENpcGhlciIsInBhcmFtcyIsImMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwidmFsdWUiLCJfMzJuIiwiX3UzMl9tYXgiLCJ3aCIsIk51bWJlciIsIndsIiwiaCIsImwiLCJzZXRVaW50MzIiLCJ1NjRMZW5ndGhzIiwiY2lwaGVydGV4dCIsIkFBRCIsIm51bSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/ciphers/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLG9FQUFvRSxHQUMxQjtBQUNxQjtBQUNQO0FBQ3hELHdDQUF3QztBQUNqQyxTQUFTSSxRQUFRQyxJQUFJO0lBQ3hCLE9BQU87UUFDSEE7UUFDQUwsTUFBTSxDQUFDTSxLQUFLLEdBQUdDLE9BQVNQLHdEQUFJQSxDQUFDSyxNQUFNQyxLQUFLTCxnRUFBV0EsSUFBSU07UUFDdkRMLFdBQVdBLDhEQUFBQTtJQUNmO0FBQ0o7QUFDTyxTQUFTTSxZQUFZQyxRQUFRLEVBQUVDLE9BQU87SUFDekMsTUFBTUMsU0FBUyxDQUFDTixPQUFTRixxRUFBV0EsQ0FBQztZQUFFLEdBQUdNLFFBQVE7WUFBRSxHQUFHTCxRQUFRQyxLQUFLO1FBQUM7SUFDckUsT0FBT08sT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR0YsT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3RELEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcz9mMjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJ3ZWllcnN0cmFzcyIsImdldEhhc2giLCJoYXNoIiwia2V5IiwibXNncyIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSwwQkFBMEI7QUFDNEI7QUFDVjtBQUM1QyxNQUFNRyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsNkRBQTZEO0FBQzdELG1HQUFtRztBQUNuRyx5REFBeUQ7QUFDekQsNERBQTREO0FBQzVELCtFQUErRTtBQUMvRSxvR0FBb0c7QUFDcEcsb0dBQW9HO0FBQ3BHLHFDQUFxQztBQUNyQyxrR0FBa0c7QUFDbEcsZ0dBQWdHO0FBQ2hHLDhDQUE4QztBQUN2QyxTQUFTRSxLQUFLQyxDQUFDLEVBQUVDLElBQUk7SUFDeEIsTUFBTUMsa0JBQWtCLENBQUNDLFdBQVdDO1FBQ2hDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07UUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7SUFDN0I7SUFDQSxNQUFNRyxPQUFPLENBQUNDO1FBQ1YsTUFBTUMsVUFBVUMsS0FBS0MsSUFBSSxDQUFDVixPQUFPTyxLQUFLLEdBQUcsY0FBYztRQUN2RCxNQUFNSSxhQUFhLEtBQU1KLENBQUFBLElBQUksSUFBSSwwQkFBMEI7UUFDM0QsT0FBTztZQUFFQztZQUFTRztRQUFXO0lBQ2pDO0lBQ0EsT0FBTztRQUNIVjtRQUNBLHVDQUF1QztRQUN2Q1csY0FBYUMsR0FBRyxFQUFFQyxDQUFDO1lBQ2YsSUFBSUMsSUFBSWhCLEVBQUVpQixJQUFJO1lBQ2QsSUFBSUMsSUFBSUo7WUFDUixNQUFPQyxJQUFJbkIsSUFBSztnQkFDWixJQUFJbUIsSUFBSWpCLEtBQ0prQixJQUFJQSxFQUFFRyxHQUFHLENBQUNEO2dCQUNkQSxJQUFJQSxFQUFFRSxNQUFNO2dCQUNaTCxNQUFNakI7WUFDVjtZQUNBLE9BQU9rQjtRQUNYO1FBQ0E7Ozs7Ozs7OztTQVNDLEdBQ0RLLGtCQUFpQlAsR0FBRyxFQUFFTixDQUFDO1lBQ25CLE1BQU0s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RCx5REFBY0EsQ0FBQ3VELE9BQU87UUFDbEJuQyxHQUFHO1FBQ0hxQyxHQUFHO1FBQ0hDLElBQUk7UUFDSkMsSUFBSTtJQUNSLEdBQUc7UUFDQ0MsWUFBWTtRQUNaQyxhQUFhO0lBQ2pCO0lBQ0EsZUFBZTtJQUNmLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUNqQixHQUFHaEUsb0RBQU9BLENBQUN3RCxNQUFNbkMsQ0FBQyxFQUFFbUMsTUFBTUssVUFBVSxDQUFDO1FBQ3JDLEdBQUdMLEtBQUs7UUFDUixHQUFHO1lBQUVsQyxHQUFHa0MsTUFBTUMsRUFBRSxDQUFDUSxLQUFLO1FBQUMsQ0FBQztJQUM1QjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/NjFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUZpZWxkIiwibkxlbmd0aCIsInZhbGlkYXRlT2JqZWN0IiwiXzBuIiwiQmlnSW50IiwiXzFuIiwid05BRiIsImMiLCJiaXRzIiwiY29uc3RUaW1lTmVnYXRlIiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIm5lZ2F0ZSIsIm9wdHMiLCJXIiwid2luZG93cyIsIk1hdGgiLCJjZWlsIiwid2luZG93U2l6ZSIsInVuc2FmZUxhZGRlciIsImVsbSIsIm4iLCJwIiwiWkVSTyIsImQiLCJhZGQiLCJkb3VibGUiLCJwcmVjb21wdXRlV2luZG93IiwicG9pbnRzIiwiYmFzZSIsIndpbmRvdyIsInB1c2giLCJpIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGQ2FjaGVkIiwiUCIsInByZWNvbXB1dGVzTWFwIiwidHJhbnNmb3JtIiwiX1dJTkRPV19TSVpFIiwiY29tcCIsImdldCIsInNldCIsInZhbGlkYXRlQmFzaWMiLCJjdXJ2ZSIsIkZwIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/edwards.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = {\n    zip215: true\n};\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: \"function\",\n        a: \"bigint\",\n        d: \"bigint\",\n        randomBytes: \"function\"\n    }, {\n        adjustScalarBytes: \"function\",\n        domain: \"function\",\n        uvRatio: \"function\",\n        mapToCurve: \"function\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...opts\n    });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;\n    const MASK = _2n << BigInt(nByteLength * 8) - _1n;\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio || ((u, v)=>{\n        try {\n            return {\n                isValid: true,\n                value: Fp.sqrt(u * Fp.inv(v))\n            };\n        } catch (e) {\n            return {\n                isValid: false,\n                value: _0n\n            };\n        }\n    });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes); // NOOP\n    const domain = CURVE.domain || ((data, ctx, phflag)=>{\n        if (ctx.length || phflag) throw new Error(\"Contexts/pre-hash are not supported\");\n        return data;\n    }); // NOOP\n    const inBig = (n)=>typeof n === \"bigint\" && _0n < n; // n in [1..]\n    const inRange = (n, max)=>inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n)=>n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max)) return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ExtendedPoint expected\");\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et){\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex)) throw new Error(\"x required\");\n            if (!in0MaskRange(ey)) throw new Error(\"y required\");\n            if (!in0MaskRange(ez)) throw new Error(\"z required\");\n            if (!in0MaskRange(et)) throw new Error(\"t required\");\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point) throw new Error(\"extended point not allowed\");\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error(\"invalid affine point\");\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.ez));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0()) throw new Error(\"bad point: ZERO\"); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X²\n            const Y2 = modP(Y * Y); // Y²\n            const Z2 = modP(Z * Z); // Z²\n            const Z4 = modP(Z2 * Z2); // Z⁴\n            const aX2 = modP(X2 * a); // aX²\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n            if (left !== right) throw new Error(\"bad point: equation left != right (1)\");\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT) throw new Error(\"bad point: equation left != right (2)\");\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([\n                p,\n                f\n            ])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n) return I;\n            if (this.equals(I) || n === _1n) return this;\n            if (this.equals(G)) return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0) return {\n                x: _0n,\n                y: _1n\n            };\n            if (zz !== _1n) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n) return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n            // y=0 is allowed\n            } else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid) throw new Error(\"Point.fromHex: invalid y coordinate\");\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail\n            throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({\n                x,\n                y\n            });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */ function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"hashed private key\", cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return {\n            head,\n            prefix,\n            scalar,\n            point,\n            pointBytes\n        };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"context\", context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"result\", res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"signature\", sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        } catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder()) return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: ()=>randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        }\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils\n    };\n} //# sourceMappingURL=edwards.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDhEQUE4RDtBQUMzQjtBQUNGO0FBQ1E7QUFDUTtBQUNqRCxxRUFBcUU7QUFDckUsa0JBQWtCO0FBQ2xCLE1BQU1LLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsOEVBQThFO0FBQzlFLE1BQU1JLGlCQUFpQjtJQUFFQyxRQUFRO0FBQUs7QUFDdEMsU0FBU0MsYUFBYUMsS0FBSztJQUN2QixNQUFNQyxPQUFPVix3REFBYUEsQ0FBQ1M7SUFDM0JaLHFEQUFpQixDQUFDWSxPQUFPO1FBQ3JCRyxNQUFNO1FBQ05DLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxhQUFhO0lBQ2pCLEdBQUc7UUFDQ0MsbUJBQW1CO1FBQ25CQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsWUFBWTtJQUNoQjtJQUNBLGVBQWU7SUFDZixPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHWCxJQUFJO0lBQUM7QUFDbkM7QUFDQSxvRkFBb0Y7QUFDN0UsU0FBU1ksZUFBZUMsUUFBUTtJQUNuQyxNQUFNQyxRQUFRaEIsYUFBYWU7SUFDM0IsTUFBTSxFQUFFRSxFQUFFLEVBQUVDLEdBQUdDLFdBQVcsRUFBRUMsU0FBU0EsT0FBTyxFQUFFaEIsTUFBTWlCLEtBQUssRUFBRWQsV0FBVyxFQUFFZSxXQUFXLEVBQUVDLEdBQUdDLFFBQVEsRUFBRyxHQUFHUjtJQUN0RyxNQUFNUyxPQUFPN0IsT0FBUUYsT0FBTzRCLGNBQWMsS0FBSzNCO0lBQy9DLE1BQU0rQixPQUFPVCxHQUFHVSxNQUFNLEVBQUUscUJBQXFCO0lBQzdDLFlBQVk7SUFDWixNQUFNakIsVUFBVU0sTUFBTU4sT0FBTyxJQUN4QixFQUFDa0IsR0FBR0M7UUFDRCxJQUFJO1lBQ0EsT0FBTztnQkFB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dEk7UUFDZm1JO0lBQ0o7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanM/NjhiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBUd2lzdGVkIEVkd2FyZHMgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbmltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzhuID0gQmlnSW50KDgpO1xuLy8gdmVyaWZpY2F0aW9uIHJ1bGUgaXMgZWl0aGVyIHppcDIxNSBvciByZmM4MDMyIC8gbmlzdDE4Ni01LiBDb25zdWx0IGZyb21IZXg6XG5jb25zdCBWRVJJRllfREVGQVVMVCA9IHsgemlwMjE1OiB0cnVlIH07XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgaGFzaDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgICAgIGQ6ICdiaWdpbnQnLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHV2UmF0aW86ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gSXQgaXMgbm90IGdlbmVyaWMgdHdpc3RlZCBjdXJ2ZSBmb3Igbm93LCBidXQgZWQyNTUxOS9lZDQ0OCBnZW5lcmljIGltcGxlbWVudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIsIHByZWhhc2g6IHByZWhhc2gsIGhhc2g6IGNIYXNoLCByYW5kb21CeXRlcywgbkJ5dGVMZW5ndGgsIGg6IGNvZmFjdG9yLCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgTUFTSyA9IF8ybiA8PCAoQmlnSW50KG5CeXRlTGVuZ3RoICogOCkgLSBfMW4pO1xuICAgIGNvbnN0IG1vZFAgPSBGcC5jcmVhdGU7IC8vIEZ1bmN0aW9uIG92ZXJyaWRlc1xuICAgIC8vIHNxcnQodS92KVxuICAgIGNvbnN0IHV2UmF0aW8gPSBDVVJWRS51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydCh1ICogRnAuaW52KHYpKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgdmFsdWU6IF8wbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTsgLy8gTk9PUFxuICAgIGNvbnN0IGRvbWFpbiA9IENVUlZFLmRvbWFpbiB8fFxuICAgICAgICAoKGRhdGEsIGN0eCwgcGhmbGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCB8fCBwaGZsYWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0cy9wcmUtaGFzaCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pOyAvLyBOT09QXG4gICAgY29uc3QgaW5CaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8IG47IC8vIG4gaW4gWzEuLl1cbiAgICBjb25zdCBpblJhbmdlID0gKG4sIG1heCkgPT4gaW5CaWcobikgJiYgaW5CaWcobWF4KSAmJiBuIDwgbWF4OyAvLyBuIGluIFsxLi5tYXgtMV1cbiAgICBjb25zdCBpbjBNYXNrUmFuZ2UgPSAobikgPT4gbiA9PT0gXzBuIHx8IGluUmFuZ2UobiwgTUFTSyk7IC8vIG4gaW4gWzAuLk1BU0stMV1cbiAgICBmdW5jdGlvbiBhc3NlcnRJblJhbmdlKG4sIG1heCkge1xuICAgICAgICAvLyBuIGluIFsxLi5tYXgtMV1cbiAgICAgICAgaWYgKGluUmFuZ2UobiwgbWF4KSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIHNjYWxhciA8ICR7bWF4fSwgZ290ICR7dHlwZW9mIG59ICR7bn1gKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UwKG4pIHtcbiAgICAgICAgLy8gbiBpbiBbMC4uQ1VSVkVfT1JERVItMV1cbiAgICAgICAgcmV0dXJuIG4gPT09IF8wbiA/IG4gOiBhc3NlcnRJblJhbmdlKG4sIENVUlZFX09SREVSKTsgLy8gR0UgPSBwcmltZSBzdWJncm91cCwgbm90IGZ1bGwgZ3JvdXBcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpc1BvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbmRlZFBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIEV4dGVuZGVkIFBvaW50IHdvcmtzIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzOiAoeCwgeSwgeiwgdCkg4oiLICh4PXgveiwgeT15L3osIHQ9eHkpLlxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3aXN0ZWRfRWR3YXJkc19jdXJ2ZSNFeHRlbmRlZF9jb29yZGluYXRlc1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoZXgsIGV5LCBleiwgZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZXggPSBleDtcbiAgICAgICAgICAgIHRoaXMuZXkgPSBleTtcbiAgICAgICAgICAgIHRoaXMuZXogPSBlejtcbiAgICAgICAgICAgIHRoaXMuZXQgPSBldDtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3QgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5kZWQgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKHgpIHx8ICFpbjBNYXNrUmFuZ2UoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5leikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHJlcXVpcmVkIGZvciBmcm9tSGV4KCksIHdoaWNoIGFsd2F5cyBjcmVhdGVzIHZhbGlkIHBvaW50cy5cbiAgICAgICAgLy8gQ291bGQgYmUgdXNlZnVsIGZvciBmcm9tQWZmaW5lKCkuXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7IC8vIFRPRE86IG9wdGltaXplLCB3aXRoIHZhcnMgYmVsb3c/XG4gICAgICAgICAgICAvLyBFcXVhdGlvbiBpbiBhZmZpbmUgY29vcmRpbmF0ZXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCslxuICAgICAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgsIGV5OiBZLCBlejogWiwgZXQ6IFQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFnCslxuICAgICAgICAgICAgY29uc3QgWjIgPSBtb2RQKFogKiBaKTsgLy8gWsKyXG4gICAgICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgICAgIGNvbnN0IGFYMiA9IG1vZFAoWDIgKiBhKTsgLy8gYVjCslxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG1vZFAoWjIgKiBtb2RQKGFYMiArIFkyKSk7IC8vIChhWMKyICsgWcKyKVrCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICAgICAgaWYgKGxlZnQgIT09IHJpZ2h0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgxKScpO1xuICAgICAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgICAgIGNvbnN0IFhZID0gbW9kUChYICogWSk7XG4gICAgICAgICAgICBjb25zdCBaVCA9IG1vZFAoWiAqIFQpO1xuICAgICAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMiknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGlzUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFgxWjIgPSBtb2RQKFgxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWDJaMSA9IG1vZFAoWDIgKiBaMSk7XG4gICAgICAgICAgICBjb25zdCBZMVoyID0gbW9kUChZMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFkyWjEgPSBtb2RQKFkyICogWjEpO1xuICAgICAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgLy8gRmxpcHMgcG9pbnQgc2lnbiB0byBhIG5lZ2F0aXZlIG9uZSAoLXgsIHkgaW4gYWZmaW5lIGNvb3JkcylcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQobW9kUCgtdGhpcy5leCksIHRoaXMuZXksIHRoaXMuZXosIG1vZFAoLXRoaXMuZXQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGRvdWJsaW5nIEV4dGVuZGVkIFBvaW50LlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA0TSArIDRTICsgMSphICsgNmFkZCArIDEqMi5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDEpOyAvLyBBID0gWDEyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkxKTsgLy8gQiA9IFkxMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoXzJuICogbW9kUChaMSAqIFoxKSk7IC8vIEMgPSAyKloxMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoYSAqIEEpOyAvLyBEID0gYSpBXG4gICAgICAgICAgICBjb25zdCB4MXkxID0gWDEgKyBZMTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKG1vZFAoeDF5MSAqIHgxeTEpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKTItQS1CXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEI7IC8vIEcgPSBEK0JcbiAgICAgICAgICAgIGNvbnN0IEYgPSBHIC0gQzsgLy8gRiA9IEctQ1xuICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBCOyAvLyBIID0gRC1CXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNhZGRpdGlvbi1hZGQtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBpc1BvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEsIGV0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiwgZXQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIC8vIEZhc3RlciBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMgd2hlbiBjdXJ2ZSdzIGE9LTEuXG4gICAgICAgICAgICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtNFxuICAgICAgICAgICAgLy8gQ29zdDogOE0gKyA4YWRkICsgMioyLlxuICAgICAgICAgICAgLy8gTm90ZTogSXQgZG9lcyBub3QgY2hlY2sgd2hldGhlciB0aGUgYG90aGVyYCBwb2ludCBpcyB2YWxpZC5cbiAgICAgICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoKFkxIC0gWDEpICogKFkyICsgWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCID0gbW9kUCgoWTEgKyBYMSkgKiAoWTIgLSBYMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEYgPSBtb2RQKEIgLSBBKTtcbiAgICAgICAgICAgICAgICBpZiAoRiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTsgLy8gU2FtZSBwb2ludC4gVGVzdHMgc2F5IGl0IGRvZXNuJ3QgYWZmZWN0IHRpbWluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFoxICogXzJuICogVDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFQxICogXzJuICogWjIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEUgPSBEICsgQztcbiAgICAgICAgICAgICAgICBjb25zdCBHID0gQiArIEE7XG4gICAgICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBDO1xuICAgICAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7XG4gICAgICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoYXNzZXJ0SW5SYW5nZShzY2FsYXIsIENVUlZFX09SREVSKSk7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcCwgZl0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgLy8gSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgLy8gYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24uXG4gICAgICAgIC8vIERvZXMgTk9UIGFsbG93IHNjYWxhcnMgaGlnaGVyIHRoYW4gQ1VSVkUubi5cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgICAgICBsZXQgbiA9IGFzc2VydEdFMChzY2FsYXIpOyAvLyAwIDw9IHNjYWxhciA8IENVUlZFLm5cbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoSSkgfHwgbiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYobikucDtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuICAgICAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBDVVJWRV9PUkRFUikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBleDogeCwgZXk6IHksIGV6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gXzhuIDogRnAuaW52KHopOyAvLyA4IHdhcyBjaG9zZW4gYXJiaXRyYXJpbHlcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gbW9kUCh4ICogaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBtb2RQKHkgKiBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IG1vZFAoeiAqIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgICAgIGlmICh6eiAhPT0gXzFuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgLy8gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4LCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkLCBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4LCBsZW4pOyAvLyBjb3B5IGhleCB0byBhIG5ldyBhcnJheVxuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgYWdhaW4sIHdlJ2xsIG1hbmlwdWxhdGUgaXRcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4W2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgICAgICAgY29uc3QgeSA9IHV0LmJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuICAgICAgICAgICAgaWYgKHkgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIC8vIHk9MCBpcyBhbGxvd2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSRkM4MDMyIHByb2hpYml0cyA+PSBwLCBidXQgWklQMjE1IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICBpZiAoemlwMjE1KVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJblJhbmdlKHksIE1BU0spOyAvLyB6aXAyMTU9dHJ1ZSBbMS4uUC0xXSAoMl4yNTUtMTktMSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEluUmFuZ2UoeSwgRnAuT1JERVIpOyAvLyB6aXAyMTU9ZmFsc2UgWzEuLk1BU0stMV0gKDJeMjU2LTEgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFZDI1NTE5OiB4wrIgPSAoecKyLTEpLyhkecKyKzEpIG1vZCBwLiBFZDQ0ODogeMKyID0gKHnCsi0xKS8oZHnCsi0xKSBtb2QgcC4gR2VuZXJpYyBjYXNlOlxuICAgICAgICAgICAgLy8gYXjCsit5wrI9MStkeMKyecKyID0+IHnCsi0xPWR4wrJ5wrItYXjCsiA9PiB5wrItMT14wrIoZHnCsi1hKSA9PiB4wrI9KHnCsi0xKS8oZHnCsi1hKVxuICAgICAgICAgICAgY29uc3QgeTIgPSBtb2RQKHkgKiB5KTsgLy8gZGVub21pbmF0b3IgaXMgYWx3YXlzIG5vbi0wIG1vZCBwLlxuICAgICAgICAgICAgY29uc3QgdSA9IG1vZFAoeTIgLSBfMW4pOyAvLyB1ID0gecKyIC0gMVxuICAgICAgICAgICAgY29uc3QgdiA9IG1vZFAoZCAqIHkyIC0gYSk7IC8vIHYgPSBkIHnCsiArIDEuXG4gICAgICAgICAgICBsZXQgeyBpc1ZhbGlkLCB2YWx1ZTogeCB9ID0gdXZSYXRpbyh1LCB2KTsgLy8g4oiaKHUvdilcbiAgICAgICAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQuZnJvbUhleDogeD0wIGFuZCB4XzA9MScpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZClcbiAgICAgICAgICAgICAgICB4ID0gbW9kUCgteCk7IC8vIGlmIHhfMCAhPSB4IG1vZCAyLCBzZXQgeCA9IHAteFxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB1dC5udW1iZXJUb0J5dGVzTEUoeSwgRnAuQllURVMpOyAvLyBlYWNoIHkgaGFzIDIgeCB2YWx1ZXMgKHgsIC15KVxuICAgICAgICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gfD0geCAmIF8xbiA/IDB4ODAgOiAwOyAvLyB3aGVuIGNvbXByZXNzaW5nLCBpdCdzIGVub3VnaCB0byBzdG9yZSB5XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7IC8vIGFuZCB1c2UgdGhlIGxhc3QgYnl0ZSB0byBlbmNvZGUgc2lnbiBvZiB4XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7IC8vIFNhbWUgYXMgdG9SYXdCeXRlcywgYnV0IHJldHVybnMgc3RyaW5nLlxuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4sIG1vZFAoQ1VSVkUuR3ggKiBDVVJWRS5HeSkpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTsgLy8gMCwgMSwgMSwgMFxuICAgIGNvbnN0IHsgQkFTRTogRywgWkVSTzogSSB9ID0gUG9pbnQ7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIG5CeXRlTGVuZ3RoICogOCk7XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICAvLyBMaXR0bGUtZW5kaWFuIFNIQTUxMiB3aXRoIG1vZHVsbyBuXG4gICAgZnVuY3Rpb24gbW9kTl9MRShoYXNoKSB7XG4gICAgICAgIHJldHVybiBtb2ROKHV0LmJ5dGVzVG9OdW1iZXJMRShoYXNoKSk7XG4gICAgfVxuICAgIC8qKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjcmVhdGVzIHB1YmxpYyBrZXkgYW5kIG90aGVyIHN0dWZmLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICBrZXkgPSBlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIGxlbik7XG4gICAgICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG4gICAgICAgIC8vIENoZWNrIGJ5dGUgbGVuZ3RoczogZW5zdXJlKDY0LCBoKGVuc3VyZSgzMiwga2V5KSkpXG4gICAgICAgIGNvbnN0IGhhc2hlZCA9IGVuc3VyZUJ5dGVzKCdoYXNoZWQgcHJpdmF0ZSBrZXknLCBjSGFzaChrZXkpLCAyICogbGVuKTtcbiAgICAgICAgY29uc3QgaGVhZCA9IGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZC5zbGljZSgwLCBsZW4pKTsgLy8gY2xlYXIgZmlyc3QgaGFsZiBiaXRzLCBwcm9kdWNlIEZFXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGhhc2hlZC5zbGljZShsZW4sIDIgKiBsZW4pOyAvLyBzZWNvbmQgaGFsZiBpcyBjYWxsZWQga2V5IHByZWZpeCAoNS4xLjYpXG4gICAgICAgIGNvbnN0IHNjYWxhciA9IG1vZE5fTEUoaGVhZCk7IC8vIFRoZSBhY3R1YWwgcHJpdmF0ZSBzY2FsYXJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBHLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvUmF3Qnl0ZXMoKTsgLy8gVWludDhBcnJheSByZXByZXNlbnRhdGlvblxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciwgcG9pbnQsIHBvaW50Qnl0ZXMgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBFZERTQSBwdWIga2V5LiBSRkM4MDMyIDUuMS41LiBQcml2a2V5IGlzIGhhc2hlZC4gVXNlIGZpcnN0IGhhbGYgd2l0aCAzIGJpdHMgY2xlYXJlZFxuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2S2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBuZXcgVWludDhBcnJheSgpLCAuLi5tc2dzKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHV0LmNvbmNhdEJ5dGVzKC4uLm1zZ3MpO1xuICAgICAgICByZXR1cm4gbW9kTl9MRShjSGFzaChkb21haW4obXNnLCBlbnN1cmVCeXRlcygnY29udGV4dCcsIGNvbnRleHQpLCAhIXByZWhhc2gpKSk7XG4gICAgfVxuICAgIC8qKiBTaWducyBtZXNzYWdlIHdpdGggcHJpdmF0ZUtleS4gUkZDODAzMiA1LjEuNiAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnLCBwcml2S2V5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbXNnID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCBldGMuXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEcubXVsdGlwbHkocikudG9SYXdCeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gbW9kTihyICsgayAqIHNjYWxhcik7IC8vIFMgPSAociArIGsgKiBzKSBtb2QgTFxuICAgICAgICBhc3NlcnRHRTAocyk7IC8vIDAgPD0gcyA8IGxcbiAgICAgICAgY29uc3QgcmVzID0gdXQuY29uY2F0Qnl0ZXMoUiwgdXQubnVtYmVyVG9CeXRlc0xFKHMsIEZwLkJZVEVTKSk7XG4gICAgICAgIHJldHVybiBlbnN1cmVCeXRlcygncmVzdWx0JywgcmVzLCBuQnl0ZUxlbmd0aCAqIDIpOyAvLyA2NC1ieXRlIHNpZ25hdHVyZVxuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlPcHRzID0gVkVSSUZZX0RFRkFVTFQ7XG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXksIG9wdGlvbnMgPSB2ZXJpZnlPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgemlwMjE1IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUzsgLy8gVmVyaWZpZXMgRWREU0Egc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBhbmQgcHVibGljIGtleS4gUkZDODAzMiA1LjEuNy5cbiAgICAgICAgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZywgMiAqIGxlbik7IC8vIEFuIGV4dGVuZGVkIGdyb3VwIGVxdWF0aW9uIGlzIGNoZWNrZWQuXG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGgsIGV0Y1xuICAgICAgICBjb25zdCBzID0gdXQuYnl0ZXNUb051bWJlckxFKHNpZy5zbGljZShsZW4sIDIgKiBsZW4pKTtcbiAgICAgICAgLy8gemlwMjE1OiB0cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzIGFuZCBhbGxvd3MgcG9pbnRzIDwgMl4yNTZcbiAgICAgICAgLy8gemlwMjE1OiBmYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUgYW5kIHJlc3RyaWN0cyBwb2ludHMgdG8gQ1VSVkUucFxuICAgICAgICBsZXQgQSwgUiwgU0I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBBID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXksIHppcDIxNSk7XG4gICAgICAgICAgICBSID0gUG9pbnQuZnJvbUhleChzaWcuc2xpY2UoMCwgbGVuKSwgemlwMjE1KTtcbiAgICAgICAgICAgIFNCID0gRy5tdWx0aXBseVVuc2FmZShzKTsgLy8gMCA8PSBzIDwgbCBpcyBkb25lIGluc2lkZVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghemlwMjE1ICYmIEEuaXNTbWFsbE9yZGVyKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCwgUi50b1Jhd0J5dGVzKCksIEEudG9SYXdCeXRlcygpLCBtc2cpO1xuICAgICAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAgICAgLy8gWzhdW1NdQiA9IFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgIH1cbiAgICBHLl9zZXRXaW5kb3dTaXplKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICAvLyBlZDI1NTE5IHByaXZhdGUga2V5cyBhcmUgdW5pZm9ybSAzMmIuIE5vIG5lZWQgdG8gY2hlY2sgZm9yIG1vZHVsbyBiaWFzLCBsaWtlIGluIHNlY3AyNTZrMS5cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gcmFuZG9tQnl0ZXMoRnAuQllURVMpLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uICh1c2VkIGluIGdldFB1YmxpY0tleSBldGMpIHdpdGggcHJlY29tcHV0ZWQgQkFTRV9QT0lOVFxuICAgICAgICAgKiB2YWx1ZXMuIFRoaXMgc2xvd3MgZG93biBmaXJzdCBnZXRQdWJsaWNLZXkoKSBieSBtaWxsaXNlY29uZHMgKHNlZSBTcGVlZCBzZWN0aW9uKSxcbiAgICAgICAgICogYnV0IGFsbG93cyB0byBzcGVlZC11cCBzdWJzZXF1ZW50IGdldFB1YmxpY0tleSgpIGNhbGxzIHVwIHRvIDIweC5cbiAgICAgICAgICogQHBhcmFtIHdpbmRvd1NpemUgMiwgNCwgOCwgMTZcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBFeHRlbmRlZFBvaW50OiBQb2ludCxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkd2FyZHMuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsInV0IiwiZW5zdXJlQnl0ZXMiLCJ3TkFGIiwidmFsaWRhdGVCYXNpYyIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl84biIsIlZFUklGWV9ERUZBVUxUIiwiemlwMjE1IiwidmFsaWRhdGVPcHRzIiwiY3VydmUiLCJvcHRzIiwidmFsaWRhdGVPYmplY3QiLCJoYXNoIiwiYSIsImQiLCJyYW5kb21CeXRlcyIsImFkanVzdFNjYWxhckJ5dGVzIiwiZG9tYWluIiwidXZSYXRpbyIsIm1hcFRvQ3VydmUiLCJPYmplY3QiLCJmcmVlemUiLCJ0d2lzdGVkRWR3YXJkcyIsImN1cnZlRGVmIiwiQ1VSVkUiLCJGcCIsIm4iLCJDVVJWRV9PUkRFUiIsInByZWhhc2giLCJjSGFzaCIsIm5CeXRlTGVuZ3RoIiwiaCIsImNvZmFjdG9yIiwiTUFTSyIsIm1vZFAiLCJjcmVhdGUiLCJ1IiwidiIsImlzVmFsaWQiLCJ2YWx1ZSIsInNxcnQiLCJpbnYiLCJlIiwiYnl0ZXMiLCJkYXRhIiwiY3R4IiwicGhmbGFnIiwibGVuZ3RoIiwiRXJyb3IiLCJpbkJpZyIsImluUmFuZ2UiLCJtYXgiLCJpbjBNYXNrUmFuZ2UiLCJhc3NlcnRJblJhbmdlIiwiYXNzZXJ0R0UwIiwicG9pbnRQcmVjb21wdXRlcyIsIk1hcCIsImlzUG9pbnQiLCJvdGhlciIsIlBvaW50IiwiY29uc3RydWN0b3IiLCJleCIsImV5IiwiZXoiLCJldCIsIngiLCJ0b0FmZmluZSIsInkiLCJmcm9tQWZmaW5lIiwicCIsIm5vcm1hbGl6ZVoiLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiaSIsIl9zZXRXaW5kb3dTaXplIiwid2luZG93U2l6ZSIsIl9XSU5ET1dfU0laRSIsImRlbGV0ZSIsImFzc2VydFZhbGlkaXR5IiwiaXMwIiwiWCIsIlkiLCJaIiwiVCIsIlgyIiwiWTIiLCJaMiIsIlo0IiwiYVgyIiwibGVmdCIsInJpZ2h0IiwiWFkiLCJaVCIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgxWjIiLCJYMloxIiwiWTFaMiIsIlkyWjEiLCJaRVJPIiwibmVnYXRlIiwiZG91YmxlIiwiQSIsIkIiLCJDIiwiRCIsIngxeTEiLCJFIiwiRyIsIkYiLCJIIiwiWDMiLCJZMyIsIlQzIiwiWjMiLCJhZGQiLCJUMSIsIlQyIiwic3VidHJhY3QiLCJ3bmFmIiwid05BRkNhY2hlZCIsIm11bHRpcGx5Iiwic2NhbGFyIiwiZiIsIm11bHRpcGx5VW5zYWZlIiwiSSIsInVuc2FmZUxhZGRlciIsImlzU21hbGxPcmRlciIsImlzVG9yc2lvbkZyZWUiLCJpeiIsInoiLCJheCIsImF5IiwienoiLCJjbGVhckNvZmFjdG9yIiwiZnJvbUhleCIsImhleCIsImxlbiIsIkJZVEVTIiwibm9ybWVkIiwic2xpY2UiLCJsYXN0Qnl0ZSIsImJ5dGVzVG9OdW1iZXJMRSIsIk9SREVSIiwieTIiLCJpc1hPZGQiLCJpc0xhc3RCeXRlT2RkIiwiZnJvbVByaXZhdGVLZXkiLCJwcml2S2V5IiwiZ2V0RXh0ZW5kZWRQdWJsaWNLZXkiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJudW1iZXJUb0J5dGVzTEUiLCJ0b0hleCIsImJ5dGVzVG9IZXgiLCJCQVNFIiwiR3giLCJHeSIsIm1vZE4iLCJtb2ROX0xFIiwia2V5IiwiaGFzaGVkIiwiaGVhZCIsInByZWZpeCIsInBvaW50Qnl0ZXMiLCJnZXRQdWJsaWNLZXkiLCJoYXNoRG9tYWluVG9TY2FsYXIiLCJjb250ZXh0IiwiVWludDhBcnJheSIsIm1zZ3MiLCJtc2ciLCJjb25jYXRCeXRlcyIsInNpZ24iLCJvcHRpb25zIiwiciIsIlIiLCJrIiwicyIsInJlcyIsInZlcmlmeU9wdHMiLCJ2ZXJpZnkiLCJzaWciLCJwdWJsaWNLZXkiLCJTQiIsImVycm9yIiwiUmtBIiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwicHJlY29tcHV0ZSIsIkV4dGVuZGVkUG9pbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/edwards.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQzREO0FBQy9GLDZGQUE2RjtBQUM3RixNQUFNTSxRQUFRTCxzREFBZUE7QUFDN0IsNENBQTRDO0FBQzVDLFNBQVNNLE1BQU1DLEtBQUssRUFBRUMsTUFBTTtJQUN4QixJQUFJRCxRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJQyxRQUFTO1FBQ3pDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFRixNQUFNLFFBQVEsRUFBRUMsT0FBTyxDQUFDO0lBQ3JFO0lBQ0EsTUFBTUUsTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVKO0lBQU8sR0FBR0ssSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSU4sU0FBUyxHQUFHTSxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHUCxRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlRLFdBQVdMO0FBQzFCO0FBQ0EsU0FBU00sT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUosV0FBV0UsRUFBRVQsTUFBTTtJQUNuQyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUcsRUFBRVQsTUFBTSxFQUFFTSxJQUFLO1FBQy9CSyxHQUFHLENBQUNMLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFLEdBQUdJLENBQUMsQ0FBQ0osRUFBRTtJQUN4QjtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTQyxLQUFLQyxJQUFJO0lBQ2QsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE9BQ3RCLE1BQU0sSUFBSVosTUFBTTtBQUN4QjtBQUNBLG9HQUFvRztBQUNwRyx1REFBdUQ7QUFDaEQsU0FBU2UsbUJBQW1CQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxDQUFDO0lBQ3RE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Y3ZFLEdBQUcsRUFBRTBCLE9BQU87WUFDdEIsTUFBTVcsSUFBSWIsY0FBY3hCLEtBQUssR0FBRztnQkFBRSxHQUFHK0QsR0FBRztnQkFBRTlELEtBQUs4RCxJQUFJUyxTQUFTO2dCQUFFLEdBQUc5QyxPQUFPO1lBQUM7WUFDekUsTUFBTTBDLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3pCLENBQUMsQ0FBQyxFQUFFLEdBQUdnQyxhQUFhO1lBQzFERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz8yMGQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGFieXRlcywgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2QiLCJieXRlc1RvTnVtYmVyQkUiLCJhYnl0ZXMiLCJjb25jYXRCeXRlcyIsInV0ZjhUb0J5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJvczJpcCIsImkyb3NwIiwidmFsdWUiLCJsZW5ndGgiLCJFcnJvciIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwiVWludDhBcnJheSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiYW51bSIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJjcmVhdGVIYXNoZXIiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsc0RBQXNEO0FBQ2lGO0FBQ3ZJLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RFLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNSixPQUFPLElBQUlLLE1BQU1MLE9BQU8sSUFBSU0sTUFBTU4sT0FBTztBQUNyRCxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTVAsT0FBTyxJQUFJUSxPQUFPUixPQUFPO0FBQ3JDLHdCQUF3QjtBQUNqQixTQUFTUyxJQUFJQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVWIsTUFBTWEsU0FBU0QsSUFBSUM7QUFDeEM7QUFDQTs7Ozs7Q0FLQyxHQUNELG9DQUFvQztBQUM3QixTQUFTQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxJQUFJQSxVQUFVakIsT0FBT2dCLFFBQVFoQixLQUN6QixNQUFNLElBQUlrQixNQUFNO0lBQ3BCLElBQUlELFdBQVdmLEtBQ1gsT0FBT0Y7SUFDWCxJQUFJbUIsTUFBTWpCO0lBQ1YsTUFBT2MsUUFBUWhCLElBQUs7UUFDaEIsSUFBSWdCLFFBQVFkLEtBQ1JpQixNQUFNLE1BQU9KLE1BQU9FO1FBQ3hCRixNQUFNLE1BQU9BLE1BQU9FO1FBQ3BCRCxVQUFVZDtJQUNkO0lBQ0EsT0FBT2lCO0FBQ1g7QUFDQSwwREFBMEQ7QUFDbkQsU0FBU0MsS0FBS0MsQ0FBQyxFQUFFTCxLQUFLLEVBQUVDLE1BQU07SUFDakMsSUFBSUUsTUFBTUU7SUFDVixNQUFPTCxVQUFVaEIsSUFBSztRQUNsQm1CLE9BQU9BO1FBQ1BBLE9BQU9GO0lBQ1g7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MERBQWVBLENBQUNzSTtJQUMzRCxPQUFPeEgsSUFBSUssS0FBS29ILGFBQWFqSSxPQUFPQTtBQUN4QztBQUNBOzs7OztDQUtDLEdBQ00sU0FBU29JLG9CQUFvQkMsVUFBVTtJQUMxQyxJQUFJLE9BQU9BLGVBQWUsVUFDdEIsTUFBTSxJQUFJckgsTUFBTTtJQUNwQixNQUFNc0gsWUFBWUQsV0FBV3JDLFFBQVEsQ0FBQyxHQUFHaEIsTUFBTTtJQUMvQyxPQUFPa0IsS0FBS0MsSUFBSSxDQUFDbUMsWUFBWTtBQUNqQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGlCQUFpQkYsVUFBVTtJQUN2QyxNQUFNckQsU0FBU29ELG9CQUFvQkM7SUFDbkMsT0FBT3JELFNBQVNrQixLQUFLQyxJQUFJLENBQUNuQixTQUFTO0FBQ3ZDO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU3dELGVBQWVDLEdBQUcsRUFBRUosVUFBVSxFQUFFL0IsT0FBTyxLQUFLO0lBQ3hELE1BQU1vQyxNQUFNRCxJQUFJekQsTUFBTTtJQUN0QixNQUFNMkQsV0FBV1Asb0JBQW9CQztJQUNyQyxNQUFNRixTQUFTSSxpQkFBaUJGO0lBQ2hDLGlHQUFpRztJQUNqRyxJQUFJSyxNQUFNLE1BQU1BLE1BQU1QLFVBQVVPLE1BQU0sTUFDbEMsTUFBTSxJQUFJMUgsTUFBTSxDQUFDLFNBQVMsRUFBRW1ILE9BQU8sMEJBQTBCLEVBQUVPLElBQUksQ0FBQztJQUN4RSxNQUFNN0gsTUFBTXlGLE9BQU81RywwREFBZUEsQ0FBQytJLE9BQU85SSwwREFBZUEsQ0FBQzhJO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVcEksSUFBSUssS0FBS3dILGFBQWFySSxPQUFPQTtJQUM3QyxPQUFPc0csT0FBTzdHLDBEQUFlQSxDQUFDbUosU0FBU0QsWUFBWW5KLDBEQUFlQSxDQUFDb0osU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzPzBjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiYml0TWFzayIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJfOW4iLCJfMTZuIiwibW9kIiwiYSIsImIiLCJyZXN1bHQiLCJwb3ciLCJudW0iLCJwb3dlciIsIm1vZHVsbyIsIkVycm9yIiwicmVzIiwicG93MiIsIngiLCJpbnZlcnQiLCJudW1iZXIiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwidG9uZWxsaVNoYW5rcyIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJ0b25lbGxpRmFzdCIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwibmVnIiwiT05FIiwiZyIsIm11bCIsIlpFUk8iLCJ0MiIsImdlIiwiRnBTcXJ0Iiwic3FydDNtb2Q0IiwiYzEiLCJzcXJ0NW1vZDgiLCJuMiIsIm52IiwiaSIsInN1YiIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwiRnBQb3ciLCJmIiwicCIsImQiLCJGcEludmVydEJhdGNoIiwibnVtcyIsInRtcCIsIkFycmF5IiwibGVuZ3RoIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpczAiLCJpbnZlcnRlZCIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJGcElzU3F1YXJlIiwibGVnZW5kcmVDb25zdCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJGaWVsZCIsImJpdExlbiIsImlzTEUiLCJyZWRlZiIsInNxcnRQIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJjIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwiRnBTcXJ0T2RkIiwiZWxtIiwiRnBTcXJ0RXZlbiIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJoYXNoIiwiZ3JvdXBPcmRlciIsImhhc2hMZW4iLCJtaW5MZW4iLCJnZXRGaWVsZEJ5dGVzTGVuZ3RoIiwiZmllbGRPcmRlciIsImJpdExlbmd0aCIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsImtleSIsImxlbiIsImZpZWxkTGVuIiwicmVkdWNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!***************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: \"bigint\"\n    }, {\n        montgomeryBits: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\",\n        adjustScalarBytes: \"function\",\n        domain: \"function\",\n        powPminus2: \"function\",\n        Gu: \"bigint\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...curve\n    });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */ function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [\n            x_2,\n            x_3\n        ];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === \"bigint\" && _0n <= n && n < P) return n;\n        throw new Error(\"Expected valid scalar 0 < scalar < CURVE.P\");\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */ function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){\n            const k_t = k >> t & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"u coordinate\", uEnc, montgomeryBytes);\n        if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"scalar\", n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen) throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n) throw new Error(\"Invalid private or public key received\");\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey)=>scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey)=>scalarMultBase(privateKey),\n        utils: {\n            randomPrivateKey: ()=>CURVE.randomBytes(CURVE.nByteLength)\n        },\n        GuBytes: GuBytes\n    };\n} //# sourceMappingURL=montgomery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxvRUFBb0UsR0FDNUI7QUFDbUQ7QUFDM0YsTUFBTU0sTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLFNBQVNFLGFBQWFDLEtBQUs7SUFDdkJMLHlEQUFjQSxDQUFDSyxPQUFPO1FBQ2xCQyxHQUFHO0lBQ1AsR0FBRztRQUNDQyxnQkFBZ0I7UUFDaEJDLGFBQWE7UUFDYkMsbUJBQW1CO1FBQ25CQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWkMsSUFBSTtJQUNSO0lBQ0EsZUFBZTtJQUNmLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUFFLEdBQUdULEtBQUs7SUFBQztBQUNwQztBQUNBLDRJQUE0STtBQUM1SSwwQ0FBMEM7QUFDbkMsU0FBU1UsV0FBV0MsUUFBUTtJQUMvQixNQUFNQyxRQUFRYixhQUFhWTtJQUMzQixNQUFNLEVBQUVFLENBQUMsRUFBRSxHQUFHRDtJQUNkLE1BQU1FLE9BQU8sQ0FBQ0MsSUFBTXpCLGdEQUFHQSxDQUFDeUIsR0FBR0Y7SUFDM0IsTUFBTVgsaUJBQWlCVSxNQUFNVixjQUFjO0lBQzNDLE1BQU1jLGtCQUFrQkMsS0FBS0MsSUFBSSxDQUFDaEIsaUJBQWlCO0lBQ25ELE1BQU1pQixXQUFXUCxNQUFNVCxXQUFXO0lBQ2xDLE1BQU1DLG9CQUFvQlEsTUFBTVIsaUJBQWlCLElBQUssRUFBQ2dCLFFBQVVBLEtBQUk7SUFDckUsTUFBTWQsYUFBYU0sTUFBTU4sVUFBVSxJQUFLLEVBQUNlLElBQU05QixnREFBR0EsQ0FBQzhCLEdBQUdSLElBQUloQixPQUFPLElBQUlnQixFQUFDO0lBQ3RFLGtEQUFrRDtJQUNsRDs7Ozs7Ozs7SUFRQSxHQUNBLFNBQVNTLE1BQU1DLElBQUksRUFBRUMsR0FBRyxFQUFFQyxHQUFHO1FBQ3pCLE1BQU1DLFFBQVFaLEtBQUtTLE9BQVFDLENBQUFB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QUFLLGNBQWM7UUFDaEMsT0FBT3pDLDBEQUFlQSxDQUFDeUM7SUFDM0I7SUFDQSxTQUFTdUIsYUFBYXpDLENBQUM7UUFDbkIsTUFBTUssUUFBUTNCLHNEQUFXQSxDQUFDLFVBQVVzQjtRQUNwQyxNQUFNMEMsTUFBTXJDLE1BQU1zQyxNQUFNO1FBQ3hCLElBQUlELFFBQVF6QyxtQkFBbUJ5QyxRQUFRdEMsVUFDbkMsTUFBTSxJQUFJUyxNQUFNLENBQUMsU0FBUyxFQUFFWixnQkFBZ0IsSUFBSSxFQUFFRyxTQUFTLFlBQVksRUFBRXNDLElBQUksQ0FBQztRQUNsRixPQUFPakUsMERBQWVBLENBQUNZLGtCQUFrQmdCO0lBQzdDO0lBQ0EsU0FBU3VDLFdBQVczQixNQUFNLEVBQUVDLENBQUM7UUFDekIsTUFBTUYsU0FBU3VCLGtCQUFrQnJCO1FBQ2pDLE1BQU0yQixVQUFVSixhQUFheEI7UUFDN0IsTUFBTTZCLEtBQUsvQixpQkFBaUJDLFFBQVE2QjtRQUNwQyxrQ0FBa0M7UUFDbEMsc0NBQXNDO1FBQ3RDLElBQUlDLE9BQU9qRSxLQUNQLE1BQU0sSUFBSWdDLE1BQU07UUFDcEIsT0FBT3lCLGtCQUFrQlE7SUFDN0I7SUFDQSxrRkFBa0Y7SUFDbEYsTUFBTUMsVUFBVVQsa0JBQWtCekMsTUFBTUwsRUFBRTtJQUMxQyxTQUFTd0QsZUFBZS9CLE1BQU07UUFDMUIsT0FBTzJCLFdBQVczQixRQUFROEI7SUFDOUI7SUFDQSxPQUFPO1FBQ0hIO1FBQ0FJO1FBQ0FDLGlCQUFpQixDQUFDQyxZQUFZQyxZQUFjUCxXQUFXTSxZQUFZQztRQUNuRUMsY0FBYyxDQUFDRixhQUFlRixlQUFlRTtRQUM3Q0csT0FBTztZQUFFQyxrQkFBa0IsSUFBTXpELE1BQU0wRCxXQUFXLENBQUMxRCxNQUFNVCxXQUFXO1FBQUU7UUFDdEUyRCxTQUFTQTtJQUNiO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzPzczNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbW9kLCBwb3cgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgfSwge1xuICAgICAgICBtb250Z29tZXJ5Qml0czogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICBwb3dQbWludXMyOiAnZnVuY3Rpb24nLFxuICAgICAgICBHdTogJ2JpZ2ludCcsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbi8vIE5PVEU6IG5vdCByZWFsbHkgbW9udGdvbWVyeSBjdXJ2ZSwganVzdCBidW5jaCBvZiB2ZXJ5IHNwZWNpZmljIG1ldGhvZHMgZm9yIFgyNTUxOS9YNDQ4IChSRkMgNzc0OCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc3NDgpXG4vLyBVc2VzIG9ubHkgb25lIGNvb3JkaW5hdGUgaW5zdGVhZCBvZiB0d29cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBDVVJWRS5tb250Z29tZXJ5Qml0cztcbiAgICBjb25zdCBtb250Z29tZXJ5Qnl0ZXMgPSBNYXRoLmNlaWwobW9udGdvbWVyeUJpdHMgLyA4KTtcbiAgICBjb25zdCBmaWVsZExlbiA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuICAgIGNvbnN0IHBvd1BtaW51czIgPSBDVVJWRS5wb3dQbWludXMyIHx8ICgoeCkgPT4gcG93KHgsIFAgLSBCaWdJbnQoMiksIFApKTtcbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDguIEJ1dCBpdCBpcyBub3QgZnJvbSBSRkM3NzQ4IVxuICAgIC8qXG4gICAgICBjc3dhcChzd2FwLCB4XzIsIHhfMyk6XG4gICAgICAgICAgIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAgICB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgICAgIHhfMyA9IHhfMyBYT1IgZHVtbXlcbiAgICAgICAgICAgUmV0dXJuICh4XzIsIHhfMylcbiAgICBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gbW9kUChzd2FwICogKHhfMiAtIHhfMykpO1xuICAgICAgICB4XzIgPSBtb2RQKHhfMiAtIGR1bW15KTtcbiAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7XG4gICAgICAgIHJldHVybiBbeF8yLCB4XzNdO1xuICAgIH1cbiAgICAvLyBBY2NlcHRzIDAgYXMgd2VsbFxuICAgIGZ1bmN0aW9uIGFzc2VydEZpZWxkRWxlbWVudChuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG4gJiYgbiA8IFApXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBzY2FsYXIgMCA8IHNjYWxhciA8IENVUlZFLlAnKTtcbiAgICB9XG4gICAgLy8geDI1NTE5IGZyb20gNFxuICAgIC8vIFRoZSBjb25zdGFudCBhMjQgaXMgKDQ4NjY2MiAtIDIpIC8gNCA9IDEyMTY2NSBmb3IgY3VydmUyNTUxOS9YMjU1MTlcbiAgICBjb25zdCBhMjQgPSAoQ1VSVkUuYSAtIEJpZ0ludCgyKSkgLyBCaWdJbnQoNCk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgdSA9IGFzc2VydEZpZWxkRWxlbWVudChwb2ludFUpO1xuICAgICAgICAvLyBTZWN0aW9uIDU6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLlxuICAgICAgICBjb25zdCBrID0gYXNzZXJ0RmllbGRFbGVtZW50KHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgICAgIGxldCB4XzIgPSBfMW47XG4gICAgICAgIGxldCB6XzIgPSBfMG47XG4gICAgICAgIGxldCB4XzMgPSB1O1xuICAgICAgICBsZXQgel8zID0gXzFuO1xuICAgICAgICBsZXQgc3dhcCA9IF8wbjtcbiAgICAgICAgbGV0IHN3O1xuICAgICAgICBmb3IgKGxldCB0ID0gQmlnSW50KG1vbnRnb21lcnlCaXRzIC0gMSk7IHQgPj0gXzBuOyB0LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtfdCA9IChrID4+IHQpICYgXzFuO1xuICAgICAgICAgICAgc3dhcCBePSBrX3Q7XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgICAgIHhfMiA9IHN3WzBdO1xuICAgICAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKTtcbiAgICAgICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgICAgICBzd2FwID0ga190O1xuICAgICAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG4gICAgICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICAgICAgY29uc3QgQkIgPSBtb2RQKEIgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICAgICAgY29uc3QgQyA9IHhfMyArIHpfMztcbiAgICAgICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQ0IgPSBtb2RQKEMgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IGRhY2IgPSBEQSArIENCO1xuICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICAgICAgeF8zID0gbW9kUChkYWNiICogZGFjYik7XG4gICAgICAgICAgICB6XzMgPSBtb2RQKHhfMSAqIG1vZFAoZGFfY2IgKiBkYV9jYikpO1xuICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcbiAgICAgICAgICAgIHpfMiA9IG1vZFAoRSAqIChBQSArIG1vZFAoYTI0ICogRSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoeF8yLCB4XzMpID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpO1xuICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgIC8vICh6XzIsIHpfMykgPSBjc3dhcChzd2FwLCB6XzIsIHpfMylcbiAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICB6XzMgPSBzd1sxXTtcbiAgICAgICAgLy8gel8yXihwIC0gMilcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7XG4gICAgICAgIC8vIFJldHVybiB4XzIgKiAoel8yXihwIC0gMikpXG4gICAgICAgIHJldHVybiBtb2RQKHhfMiAqIHoyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlVUNvb3JkaW5hdGUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVVDb29yZGluYXRlKHVFbmMpIHtcbiAgICAgICAgLy8gU2VjdGlvbiA1OiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGNvbnN0IHUgPSBlbnN1cmVCeXRlcygndSBjb29yZGluYXRlJywgdUVuYywgbW9udGdvbWVyeUJ5dGVzKTtcbiAgICAgICAgaWYgKGZpZWxkTGVuID09PSAzMilcbiAgICAgICAgICAgIHVbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRSh1KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlU2NhbGFyKG4pIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcygnc2NhbGFyJywgbik7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0gbW9udGdvbWVyeUJ5dGVzICYmIGxlbiAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bW9udGdvbWVyeUJ5dGVzfSBvciAke2ZpZWxkTGVufSBieXRlcywgZ290ICR7bGVufWApO1xuICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckxFKGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHQoc2NhbGFyLCB1KSB7XG4gICAgICAgIGNvbnN0IHBvaW50VSA9IGRlY29kZVVDb29yZGluYXRlKHUpO1xuICAgICAgICBjb25zdCBfc2NhbGFyID0gZGVjb2RlU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHB1ID0gbW9udGdvbWVyeUxhZGRlcihwb2ludFUsIF9zY2FsYXIpO1xuICAgICAgICAvLyBUaGUgcmVzdWx0IHdhcyBub3QgY29udHJpYnV0b3J5XG4gICAgICAgIC8vIGh0dHBzOi8vY3IueXAudG8vZWNkaC5odG1sI3ZhbGlkYXRlXG4gICAgICAgIGlmIChwdSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUgb3IgcHVibGljIGtleSByZWNlaXZlZCcpO1xuICAgICAgICByZXR1cm4gZW5jb2RlVUNvb3JkaW5hdGUocHUpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZS4gQnkgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uIG9mIGJhc2UgcG9pbnQuXG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVVDb29yZGluYXRlKENVUlZFLkd1KTtcbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0QmFzZShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxhck11bHQoc2NhbGFyLCBHdUJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGFyTXVsdCxcbiAgICAgICAgc2NhbGFyTXVsdEJhc2UsXG4gICAgICAgIGdldFNoYXJlZFNlY3JldDogKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gc2NhbGFyTXVsdChwcml2YXRlS2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChwcml2YXRlS2V5KSA9PiBzY2FsYXJNdWx0QmFzZShwcml2YXRlS2V5KSxcbiAgICAgICAgdXRpbHM6IHsgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gQ1VSVkUucmFuZG9tQnl0ZXMoQ1VSVkUubkJ5dGVMZW5ndGgpIH0sXG4gICAgICAgIEd1Qnl0ZXM6IEd1Qnl0ZXMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbnRnb21lcnkuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsInBvdyIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJ2YWxpZGF0ZU9wdHMiLCJjdXJ2ZSIsImEiLCJtb250Z29tZXJ5Qml0cyIsIm5CeXRlTGVuZ3RoIiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJkb21haW4iLCJwb3dQbWludXMyIiwiR3UiLCJPYmplY3QiLCJmcmVlemUiLCJtb250Z29tZXJ5IiwiY3VydmVEZWYiLCJDVVJWRSIsIlAiLCJtb2RQIiwibiIsIm1vbnRnb21lcnlCeXRlcyIsIk1hdGgiLCJjZWlsIiwiZmllbGRMZW4iLCJieXRlcyIsIngiLCJjc3dhcCIsInN3YXAiLCJ4XzIiLCJ4XzMiLCJkdW1teSIsImFzc2VydEZpZWxkRWxlbWVudCIsIkVycm9yIiwiYTI0IiwibW9udGdvbWVyeUxhZGRlciIsInBvaW50VSIsInNjYWxhciIsInUiLCJrIiwieF8xIiwiel8yIiwiel8zIiwic3ciLCJ0Iiwia190IiwiQSIsIkFBIiwiQiIsIkJCIiwiRSIsIkMiLCJEIiwiREEiLCJDQiIsImRhY2IiLCJkYV9jYiIsInoyIiwiZW5jb2RlVUNvb3JkaW5hdGUiLCJkZWNvZGVVQ29vcmRpbmF0ZSIsInVFbmMiLCJkZWNvZGVTY2FsYXIiLCJsZW4iLCJsZW5ndGgiLCJzY2FsYXJNdWx0IiwiX3NjYWxhciIsInB1IiwiR3VCeXRlcyIsInNjYWxhck11bHRCYXNlIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUtleSIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsInJhbmRvbUJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/montgomery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDBFQUEwRTtBQUMxRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLHVDQUF1QztBQUN2QyxNQUFNQSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNaLFNBQVNHLFFBQVFDLENBQUM7SUFDckIsT0FBUUEsYUFBYUMsY0FDaEJELEtBQUssUUFBUSxPQUFPQSxNQUFNLFlBQVlBLEVBQUVFLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3RFO0FBQ08sU0FBU0MsT0FBT0MsSUFBSTtJQUN2QixJQUFJLENBQUNOLFFBQVFNLE9BQ1QsTUFBTSxJQUFJQyxNQUFNO0FBQ3hCO0FBQ0Esd0RBQXdEO0FBQ3hELE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO0FBQy9GOztDQUVDLEdBQ00sU0FBU0MsV0FBV0MsS0FBSztJQUM1QlosT0FBT1k7SUFDUCxvQ0FBb0M7SUFDcEMsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJSSxNQUFNTixNQUFNLEVBQUVFLElBQUs7UUFDbkNLLE9BQU9WLEtBQUssQ0FBQ1MsS0FBSyxDQUFDSixFQUFFLENBQUM7SUFDMUI7SUFDQSxPQUFPSztBQUNYO0FBQ08sU0FBU0Msb0JBQW9CQyxHQUFHO0lBQ25DLE1BQU1GLE1BQU1FLElBQUlOLFFBQVEsQ0FBQztJQUN6QixPQUFPSSxJQUFJUCxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRU8sSUFBSSxDQUFDLEdBQUdBO0FBQ3hDO0FBQ08sU0FBU0csWUFB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QUFTO1lBQ3hCLE1BQU0sSUFBSWxHLE1BQU0sQ0FBQyxjQUFjLEVBQUUrRyxPQUFPSixXQUFXLENBQUMsRUFBRWxCLElBQUksRUFBRSxFQUFFLE9BQU9BLElBQUksWUFBWSxFQUFFbUIsS0FBSyxDQUFDO1FBQ2pHO0lBQ0o7SUFDQSxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJSSxPQUFPQyxPQUFPLENBQUNULFlBQzNDRSxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlJLE9BQU9DLE9BQU8sQ0FBQ1IsZUFDM0NDLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsT0FBT1Y7QUFDWCxFQUNBLHNCQUFzQjtDQUN0Qix1RUFBdUU7Q0FDdkUsZ0ZBQWdGO0NBQ2hGLDRCQUE0QjtDQUM1QiwyREFBMkQ7Q0FDM0QscUVBQXFFO0NBQ3JFLCtEQUErRDtDQUMvRCw0REFBNEQ7Q0FDNUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/Yjc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhYnl0ZXMiLCJpdGVtIiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsImhleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXhUb051bWJlciIsImFzY2lpcyIsIl8wIiwiXzkiLCJfQSIsIl9GIiwiX2EiLCJfZiIsImFzY2lpVG9CYXNlMTYiLCJjaGFyIiwiaGV4VG9CeXRlcyIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsInJldmVyc2UiLCJudW1iZXJUb0J5dGVzQkUiLCJuIiwibGVuIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJ0aXRsZSIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwic3VtIiwicGFkIiwic2V0IiwiZXF1YWxCeXRlcyIsImIiLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJpdExlbiIsImJpdEdldCIsInBvcyIsImJpdFNldCIsInZhbHVlIiwiYml0TWFzayIsInU4biIsImRhdGEiLCJ1OGZyIiwiYXJyIiwiY3JlYXRlSG1hY0RyYmciLCJoYXNoTGVuIiwicUJ5dGVMZW4iLCJobWFjRm4iLCJ2IiwiayIsInJlc2V0IiwiZmlsbCIsImgiLCJyZXNlZWQiLCJzZWVkIiwiZ2VuIiwib3V0Iiwic2wiLCJzbGljZSIsInB1c2giLCJnZW5VbnRpbCIsInByZWQiLCJ2YWxpZGF0b3JGbnMiLCJiaWdpbnQiLCJ2YWwiLCJmdW5jdGlvbiIsImJvb2xlYW4iLCJzdHJpbmciLCJzdHJpbmdPclVpbnQ4QXJyYXkiLCJpc1NhZmVJbnRlZ2VyIiwiTnVtYmVyIiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsNERBQTREO0FBQ3hCO0FBQ0g7QUFDUTtBQUNRO0FBQ2pELFNBQVNLLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNQyxPQUFPSCx3REFBYUEsQ0FBQ0U7SUFDM0JMLHFEQUFpQixDQUFDTSxNQUFNO1FBQ3BCRSxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHRjtJQUN4QixJQUFJVyxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0csT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR25CLElBQUk7SUFBQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQixNQUFNLEVBQUVvQixpQkFBaUJDLEdBQUcsRUFBRUMsWUFBWUMsR0FBRyxFQUFFLEdBQUc3QixzQ0FBRUE7QUFDN0MsTUFBTThCLE1BQU07SUFDZiwyQkFBMkI7SUFDM0JDLEtBQUssTUFBTUMsZUFBZVg7UUFDdEJZLFlBQVlDLElBQUksRUFBRSxDQUFFO1lBQ2hCLEtBQUssQ0FBQ0E7UUFDVjtJQUNKO0lBQ0FDLFdBQVVDLElBQUk7UUFDVixNQUFNLEVB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QUVoTixPQUFPLEVBQUV1TixLQUFLLEVBQUUsR0FBR1gsVUFBVUcsS0FBS2MsTUFBTSxpREFBaUQ7UUFDakc3UCxJQUFJN0QsR0FBR3FFLEdBQUcsQ0FBQ3NPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEN08sSUFBSTdELEdBQUdxRSxHQUFHLENBQUNSLEdBQUd1UCxRQUFRLG1CQUFtQjtRQUN6Q3hQLElBQUk1RCxHQUFHaVQsSUFBSSxDQUFDclAsR0FBR2lQLEtBQUtoTixVQUFVLHdDQUF3QztRQUN0RWhDLElBQUk3RCxHQUFHaVQsSUFBSSxDQUFDcFAsR0FBR3VQLE9BQU92TixVQUFVLHVDQUF1QztRQUN2RSxNQUFNc04sS0FBS25ULEdBQUdzSCxLQUFLLENBQUNvTCxPQUFPMVMsR0FBR3NILEtBQUssQ0FBQ3pELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJN0QsR0FBR2lULElBQUksQ0FBQ2pULEdBQUdpSSxHQUFHLENBQUNwRSxJQUFJQSxHQUFHc1AsS0FBSyw0QkFBNEI7UUFDM0R2UCxJQUFJNUQsR0FBRzJULEdBQUcsQ0FBQy9QLEdBQUdtUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVuUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9iNThiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsibW9kIiwidXQiLCJlbnN1cmVCeXRlcyIsIndOQUYiLCJ2YWxpZGF0ZUJhc2ljIiwidmFsaWRhdGVQb2ludE9wdHMiLCJjdXJ2ZSIsIm9wdHMiLCJ2YWxpZGF0ZU9iamVjdCIsImEiLCJiIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJpc1RvcnNpb25GcmVlIiwiY2xlYXJDb2ZhY3RvciIsImFsbG93SW5maW5pdHlQb2ludCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJlbmRvIiwiRnAiLCJlcWwiLCJaRVJPIiwiRXJyb3IiLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJPYmplY3QiLCJmcmVlemUiLCJieXRlc1RvTnVtYmVyQkUiLCJiMm4iLCJoZXhUb0J5dGVzIiwiaDJiIiwiREVSIiwiRXJyIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiX3BhcnNlSW50IiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJsZW4iLCJyZXMiLCJzdWJhcnJheSIsImQiLCJsIiwidG9TaWciLCJoZXgiLCJhYnl0ZXMiLCJyIiwic0J5dGVzIiwicyIsInJCeXRlc0xlZnQiLCJoZXhGcm9tU2lnIiwic2lnIiwic2xpY2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImgiLCJudW0iLCJ0b1N0cmluZyIsInNobCIsInJobCIsInNsIiwicmwiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiVWludDhBcnJheSIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwibiIsImFzc2VydEdFIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsImtleSIsImxlbmd0aHMiLCJuQnl0ZUxlbmd0aCIsImlzQnl0ZXMiLCJieXRlc1RvSGV4IiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVycm9yIiwicG9pbnRQcmVjb21wdXRlcyIsIk1hcCIsImFzc2VydFByalBvaW50Iiwib3RoZXIiLCJQb2ludCIsInB4IiwicHkiLCJweiIsImlzVmFsaWQiLCJmcm9tQWZmaW5lIiwicCIsImlzMCIsImkiLCJPTkUiLCJub3JtYWxpemVaIiwicG9pbnRzIiwidG9JbnYiLCJpbnZlcnRCYXRjaCIsIm1hcCIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJfV0lORE9XX1NJWkUiLCJkZWxldGUiLCJsZWZ0IiwicmlnaHQiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsIm5lZyIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJ3bmFmIiwid05BRkNhY2hlZCIsImNvbXAiLCJtdWx0aXBseVVuc2FmZSIsIkkiLCJ1bnNhZmVMYWRkZXIiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsInVuZGVmaW5lZCIsIml6IiwieiIsImludiIsImF4IiwiYXkiLCJ6eiIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsImlzQ29tcHJlc3NlZCIsInRvSGV4IiwiX2JpdHMiLCJuQml0TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJQcm9qZWN0aXZlUG9pbnQiLCJ2YWxpZGF0ZU9wdHMiLCJoYXNoIiwiaG1hYyIsInJhbmRvbUJ5dGVzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibG93UyIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwiT1JERVIiLCJtb2ROIiwiaW52TiIsImludmVydCIsImNhdCIsImhlYWQiLCJ5MiIsInNxcnQiLCJzcXJ0RXJyb3IiLCJzdWZmaXgiLCJtZXNzYWdlIiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsInByZWhhc2giLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsImNyZWF0ZUhtYWNEcmJnIiwib3V0cHV0TGVuIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJpcyIsInYiLCJTV1VGcFNxcnRSYXRpbyIsIloiLCJvIiwiYzEiLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsInBvdyIsImM3Iiwic3FydFJhdGlvIiwidSIsInR2MSIsInR2MiIsInR2MyIsInR2NSIsInR2NCIsImlzUVIiLCJjbW92IiwidHZ2NSIsImUxIiwidmFsdWUiLCJ5MSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJ2YWxpZGF0ZUZpZWxkIiwiQSIsIkIiLCJ0djYiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/ed25519.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/curves/esm/ed25519.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */ const ED25519_P = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\");\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P; // x^3, 11\n    const b4 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n    const b5 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x % P; // x^31\n    const b10 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5 % P;\n    const b20 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10 % P;\n    const b40 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20 % P;\n    const b80 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40 % P;\n    const b160 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80 % P;\n    const b240 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80 % P;\n    const b250 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v³\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    \"0100000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n    \"0000000000000000000000000000000000000000000000000000000000000080\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n    \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n];\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1),\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt(\"7237005577332262213973186563042994240857116359379907606001950938285454250989\"),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n    Gy: BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\"),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio\n};\nconst ed25519 = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255) throw new Error(\"Context is too big\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n        phflag ? 1 : 0,\n        ctx.length\n    ]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain\n});\nconst ed25519ph = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512\n});\nconst x25519 = /* @__PURE__ */ (()=>(0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n        P: ED25519_P,\n        a: BigInt(486662),\n        montgomeryBits: 255,\n        nByteLength: 32,\n        Gu: BigInt(9),\n        powPminus2: (x)=>{\n            const P = ED25519_P;\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n        },\n        adjustScalarBytes,\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes\n    }))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */ function edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */ function edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return {\n        xMn: xn,\n        xMd: xd,\n        yMn: y,\n        yMd: _1n\n    }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([\n        xd,\n        yd\n    ]); // batch division\n    return {\n        x: Fp.mul(xn, inv[0]),\n        y: Fp.mul(yn, inv[1])\n    }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {\n        DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n        encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint)) throw new Error(\"RistrettoPoint expected\");\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n// 1-d²\nconst ONE_MINUS_D_SQ = BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n// (d-1)²\nconst D_MINUS_ONE_SQ = BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n// Calculates 1/√(number)\nconst invertSqrt = (number)=>uvRatio(_1n, number);\nconst MAX_255B = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst bytes255ToNumberLE = (bytes)=>ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_; // 7\n    if (!Ns_D_is_sq) c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */ class RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep){\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */ static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHash\", hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */ static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHex\", hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = \"RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint\";\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */ toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P)) y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (()=>{\n    if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options)=>{\n    const d = options.DST;\n    const DST = typeof d === \"string\" ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n //# sourceMappingURL=ed25519.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUN0QjtBQUM4QjtBQUNyQjtBQUNEO0FBQzZCO0FBQzBCO0FBQzlCO0FBQy9FOzs7OztDQUtDLEdBQ0QsTUFBTWtCLFlBQVlDLE9BQU87QUFDekIsaUNBQWlDO0FBQ2pDLE1BQU1DLGtCQUFrQkQsT0FBTztBQUMvQixrQkFBa0I7QUFDbEIsTUFBTUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPLElBQUlJLE1BQU1KLE9BQU8sSUFBSUssTUFBTUwsT0FBTztBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTU0sT0FBT04sT0FBTyxLQUFLTyxPQUFPUCxPQUFPLEtBQUtRLE9BQU9SLE9BQU8sS0FBS1MsT0FBT1QsT0FBTztBQUM3RSxTQUFTVSxvQkFBb0JDLENBQUM7SUFDMUIsTUFBTUMsSUFBSWI7SUFDVixNQUFNYyxLQUFLLElBQUtGLElBQUtDO0lBQ3JCLE1BQU1FLEtBQUssS0FBTUgsSUFBS0MsR0FBRyxVQUFVO0lBQ25DLE1BQU1HLEtBQUssMkRBQU1ELElBQUlWLEtBQUtRLEtBQUtFLEtBQU1GLEdBQUcsYUFBYTtJQUNyRCxNQUFNSSxLQUFLLDJEQUFNRCxJQUFJWixLQUFLUyxLQUFLRCxJQUFLQyxHQUFHLE9BQU87SUFDOUMsTUFBTUssTUFBTSwyREFBTUQsSUFBSVgsS0FBS08sS0FBS0ksS0FBTUo7SUFDdEMsTUFBTU0sTUFBTSwyREFBTUQsS0FBS1gsTUFBTU0sS0FBS0ssTUFBT0w7SUFDekMsTUFBTU8sTUFBTSwyREFBTUQsS0FBS1gsTUFBTUssS0FBS00sTUFBT047SUFDekMsTUFBTVEsTUFBTSwyREFBTUQsS0FBS1gsTUFBTUksS0FBS08sTUFBT1A7SUFDekMsTUFBTVMsT0FBTywyREFBTUQsS0FBS1gsTUFBTUcsS0FBS1EsTUFBT1I7SUFDMUMsTUFBTVUsT0FBTywyREFBTUQs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LGdCQUFnQjlOLDhFQUFrQkEsQ0FBQzROLEtBQUt0RixLQUFLLElBQUl2Six3REFBTUE7SUFDN0QsTUFBTStCLElBQUlrSSxVQUFVSixXQUFXLENBQUNrRjtJQUNoQyxPQUFPaE47QUFDWCxFQUFFO0FBQ0ssTUFBTWlOLHVCQUF1QkosbUJBQW1CLENBQUMsU0FBUztDQUNqRSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzP2E2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGE1MTInO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgdHdpc3RlZEVkd2FyZHMgfSBmcm9tICcuL2Fic3RyYWN0L2Vkd2FyZHMuanMnO1xuaW1wb3J0IHsgbW9udGdvbWVyeSB9IGZyb20gJy4vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgRnBTcXJ0RXZlbiwgaXNOZWdhdGl2ZUxFLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKi9cbmNvbnN0IEVEMjU1MTlfUCA9IEJpZ0ludCgnNTc4OTYwNDQ2MTg2NTgwOTc3MTE3ODU0OTI1MDQzNDM5NTM5MjY2MzQ5OTIzMzI4MjAyODIwMTk3Mjg3OTIwMDM5NTY1NjQ4MTk5NDknKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IEVEMjU1MTlfU1FSVF9NMSA9IEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzVuID0gQmlnSW50KDUpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMTBuID0gQmlnSW50KDEwKSwgXzIwbiA9IEJpZ0ludCgyMCksIF80MG4gPSBCaWdJbnQoNDApLCBfODBuID0gQmlnSW50KDgwKTtcbmZ1bmN0aW9uIGVkMjU1MTlfcG93XzJfMjUyXzMoeCkge1xuICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgY29uc3QgeDIgPSAoeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGI0ID0gKHBvdzIoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuLCBQKSAqIHgpICUgUDsgLy8geF4zMVxuICAgIGNvbnN0IGIxMCA9IChwb3cyKGI1LCBfNW4sIFApICogYjUpICUgUDtcbiAgICBjb25zdCBiMjAgPSAocG93MihiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCBfMjBuLCBQKSAqIGIyMCkgJSBQO1xuICAgIGNvbnN0IGI4MCA9IChwb3cyKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcbiAgICBjb25zdCBiMTYwID0gKHBvdzIoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNDAgPSAocG93MihiMTYwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNTAgPSAocG93MihiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IHBvd19wXzVfOCA9IChwb3cyKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gICAgLy8gXiBUbyBwb3cgdG8gKHArMykvOCwgbXVsdGlwbHkgaXQgYnkgeC5cbiAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG59XG5mdW5jdGlvbiBhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykge1xuICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcbiAgICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgICBieXRlc1swXSAmPSAyNDg7IC8vIDBiMTExMV8xMDAwXG4gICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuICAgIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgLy8gc2V0IHRoZSBzZWNvbmQgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSB0byAxXG4gICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIHJldHVybiBieXRlcztcbn1cbi8vIHNxcnQodS92KVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB2MyA9IG1vZCh2ICogdiAqIHYsIFApOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9IG1vZCh2MyAqIHYzICogdiwgUCk7IC8vIHbigbdcbiAgICAvLyAocCszKS84IGFuZCAocC01KS84XG4gICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcbiAgICBsZXQgeCA9IG1vZCh1ICogdjMgKiBwb3csIFApOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBtb2QodiAqIHggKiB4LCBQKTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9IG1vZCh4ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3QgdXNlUm9vdDEgPSB2eDIgPT09IHU7IC8vIElmIHZ4wrIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSBtb2QoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImigtMSlcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgeCA9IG1vZCgteCwgUCk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59XG4vLyBKdXN0IGluIGNhc2VcbmV4cG9ydCBjb25zdCBFRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBbXG4gICAgJzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwMzdhJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjMDUnLFxuICAgICdlY2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwM2ZhJyxcbl07XG5jb25zdCBGcCA9IEZpZWxkKEVEMjU1MTlfUCwgdW5kZWZpbmVkLCB0cnVlKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IHtcbiAgICAvLyBQYXJhbTogYVxuICAgIGE6IEJpZ0ludCgtMSksIC8vIEZwLmNyZWF0ZSgtMSkgaXMgcHJvcGVyOyBvdXIgd2F5IHN0aWxsIHdvcmtzIGFuZCBpcyBmYXN0ZXJcbiAgICAvLyBkIGlzIGVxdWFsIHRvIC0xMjE2NjUvMTIxNjY2IG92ZXIgZmluaXRlIGZpZWxkLlxuICAgIC8vIE5lZ2F0aXZlIG51bWJlciBpcyBQIC0gbnVtYmVyLCBhbmQgZGl2aXNpb24gaXMgaW52ZXJ0KG51bWJlciwgUClcbiAgICBkOiBCaWdJbnQoJzM3MDk1NzA1OTM0NjY5NDM5MzQzMTM4MDgzNTA4NzU0NTY1MTg5NTQyMTEzODc5ODQzMjE5MDE2Mzg4Nzg1NTMzMDg1OTQwMjgzNTU1JyksXG4gICAgLy8gRmluaXRlIGZpZWxkIPCdlL1wIG92ZXIgd2hpY2ggd2UnbGwgZG8gY2FsY3VsYXRpb25zOyAybioqMjU1biAtIDE5blxuICAgIEZwLFxuICAgIC8vIFN1Ymdyb3VwIG9yZGVyOiBob3cgbWFueSBwb2ludHMgY3VydmUgaGFzXG4gICAgLy8gMm4qKjI1Mm4gKyAyNzc0MjMxNzc3NzM3MjM1MzUzNTg1MTkzNzc5MDg4MzY0ODQ5M247XG4gICAgbjogQmlnSW50KCc3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5JyksXG4gICAgLy8gQ29mYWN0b3JcbiAgICBoOiBCaWdJbnQoOCksXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG4gICAgR3k6IEJpZ0ludCgnNDYzMTY4MzU2OTQ5MjY0NzgxNjk0MjgzOTQwMDM0NzUxNjMxNDEzMDc5OTM4NjYyNTYyMjU2MTU3ODMwMzM2MDMxNjUyNTE4NTU5NjAnKSxcbiAgICBoYXNoOiBzaGE1MTIsXG4gICAgcmFuZG9tQnl0ZXMsXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgLy8gZG9tMlxuICAgIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAvLyBDb25zdGFudC10aW1lLCB1L+KImnZcbiAgICB1dlJhdGlvLFxufTtcbmV4cG9ydCBjb25zdCBlZDI1NTE5ID0gLyogQF9fUFVSRV9fICovIHR3aXN0ZWRFZHdhcmRzKGVkMjU1MTlEZWZhdWx0cyk7XG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhLCBjdHgsIHBoZmxhZykge1xuICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgaXMgdG9vIGJpZycpO1xuICAgIHJldHVybiBjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMnKSwgbmV3IFVpbnQ4QXJyYXkoW3BoZmxhZyA/IDEgOiAwLCBjdHgubGVuZ3RoXSksIGN0eCwgZGF0YSk7XG59XG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyB0d2lzdGVkRWR3YXJkcyh7XG4gICAgLi4uZWQyNTUxOURlZmF1bHRzLFxuICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG59KTtcbmV4cG9ydCBjb25zdCBlZDI1NTE5cGggPSAvKiBAX19QVVJFX18gKi8gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxuICAgIHByZWhhc2g6IHNoYTUxMixcbn0pO1xuZXhwb3J0IGNvbnN0IHgyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbW9udGdvbWVyeSh7XG4gICAgUDogRUQyNTUxOV9QLFxuICAgIGE6IEJpZ0ludCg0ODY2NjIpLFxuICAgIG1vbnRnb21lcnlCaXRzOiAyNTUsIC8vIG4gaXMgMjUzIGJpdHNcbiAgICBuQnl0ZUxlbmd0aDogMzIsXG4gICAgR3U6IEJpZ0ludCg5KSxcbiAgICBwb3dQbWludXMyOiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuICAgICAgICAvLyB4XihwLTIpIGFrYSB4XigyXjI1NS0yMSlcbiAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICByZXR1cm4gbW9kKHBvdzIocG93X3BfNV84LCBCaWdJbnQoMyksIFApICogYjIsIFApO1xuICAgIH0sXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgcmFuZG9tQnl0ZXMsXG59KSkoKTtcbi8qKlxuICogQ29udmVydHMgZWQyNTUxOSBwdWJsaWMga2V5IHRvIHgyNTUxOSBwdWJsaWMga2V5LiBVc2VzIGZvcm11bGE6XG4gKiAqIGAodSwgdikgPSAoKDEreSkvKDEteSksIHNxcnQoLTQ4NjY2NCkqdS94KWBcbiAqICogYCh4LCB5KSA9IChzcXJ0KC00ODY2NjQpKnUvdiwgKHUtMSkvKHUrMSkpYFxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSBlZDI1NTE5LmdldFB1YmxpY0tleShlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gKiAgIGNvbnN0IGFQcml2ID0geDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqICAgeDI1NTE5LmdldFNoYXJlZFNlY3JldChhUHJpdiwgZWR3YXJkc1RvTW9udGdvbWVyeVB1Yihzb21lb25lc1B1YikpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKGVkd2FyZHNQdWIpIHtcbiAgICBjb25zdCB7IHkgfSA9IGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KGVkd2FyZHNQdWIpO1xuICAgIGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbiAgICByZXR1cm4gRnAudG9CeXRlcyhGcC5jcmVhdGUoKF8xbiArIHkpICogRnAuaW52KF8xbiAtIHkpKSk7XG59XG5leHBvcnQgY29uc3QgZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7IC8vIGRlcHJlY2F0ZWRcbi8qKlxuICogQ29udmVydHMgZWQyNTUxOSBzZWNyZXQga2V5IHRvIHgyNTUxOSBzZWNyZXQga2V5LlxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xuICogICBjb25zdCBhUHJpdiA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGFQcml2KSwgc29tZW9uZXNQdWIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIGNvbnN0IGhhc2hlZCA9IGVkMjU1MTlEZWZhdWx0cy5oYXNoKGVkd2FyZHNQcml2LnN1YmFycmF5KDAsIDMyKSk7XG4gICAgcmV0dXJuIGVkMjU1MTlEZWZhdWx0cy5hZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQpLnN1YmFycmF5KDAsIDMyKTtcbn1cbi8vIEhhc2ggVG8gQ3VydmUgRWxsaWdhdG9yMiBNYXAgKE5PVEU6IGRpZmZlcmVudCBmcm9tIHJpc3RyZXR0bzI1NSBlbGxpZ2F0b3IpXG4vLyBOT1RFOiB2ZXJ5IGltcG9ydGFudCBwYXJ0IGlzIHVzYWdlIG9mIEZwU3FydEV2ZW4gZm9yIEVMTDJfQzFfRURXQVJEUywgc2luY2Vcbi8vIFNhZ2VNYXRoIHJldHVybnMgZGlmZmVyZW50IHJvb3QgZmlyc3QgYW5kIGV2ZXJ5dGhpbmcgZmFsbHMgYXBhcnRcbmNvbnN0IEVMTDJfQzEgPSAoRnAuT1JERVIgKyBCaWdJbnQoMykpIC8gQmlnSW50KDgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0MyID0gRnAucG93KF8ybiwgRUxMMl9DMSk7IC8vIDIuIGMyID0gMl5jMVxuY29uc3QgRUxMMl9DMyA9IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG5jb25zdCBFTEwyX0M0ID0gKEZwLk9SREVSIC0gQmlnSW50KDUpKSAvIEJpZ0ludCg4KTsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuY29uc3QgRUxMMl9KID0gQmlnSW50KDQ4NjY2Mik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gRnBTcXJ0RXZlbihGcCwgRnAubmVnKEJpZ0ludCg0ODY2NjQpKSk7IC8vIHNnbjAoYzEpIE1VU1QgZXF1YWwgMFxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfZWR3YXJkczI1NTE5KHUpIHtcbiAgICBjb25zdCB7IHhNbiwgeE1kLCB5TW4sIHlNZCB9ID0gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KTsgLy8gIDEuICAoeE1uLCB4TWQsIHlNbiwgeU1kKSA9XG4gICAgLy8gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KVxuICAgIGxldCB4biA9IEZwLm11bCh4TW4sIHlNZCk7IC8vICAyLiAgeG4gPSB4TW4gKiB5TWRcbiAgICB4biA9IEZwLm11bCh4biwgRUxMMl9DMV9FRFdBUkRTKTsgLy8gIDMuICB4biA9IHhuICogYzFcbiAgICBsZXQgeGQgPSBGcC5tdWwoeE1kLCB5TW4pOyAvLyAgNC4gIHhkID0geE1kICogeU1uICAgICMgeG4gLyB4ZCA9IGMxICogeE0gLyB5TVxuICAgIGxldCB5biA9IEZwLnN1Yih4TW4sIHhNZCk7IC8vICA1LiAgeW4gPSB4TW4gLSB4TWRcbiAgICBsZXQgeWQgPSBGcC5hZGQoeE1uLCB4TWQpOyAvLyAgNi4gIHlkID0geE1uICsgeE1kICAgICMgKG4gLyBkIC0gMSkgLyAobiAvIGQgKyAxKSA9IChuIC0gZCkgLyAobiArIGQpXG4gICAgbGV0IHR2MSA9IEZwLm11bCh4ZCwgeWQpOyAvLyAgNy4gdHYxID0geGQgKiB5ZFxuICAgIGxldCBlID0gRnAuZXFsKHR2MSwgRnAuWkVSTyk7IC8vICA4LiAgIGUgPSB0djEgPT0gMFxuICAgIHhuID0gRnAuY21vdih4biwgRnAuWkVSTywgZSk7IC8vICA5LiAgeG4gPSBDTU9WKHhuLCAwLCBlKVxuICAgIHhkID0gRnAuY21vdih4ZCwgRnAuT05FLCBlKTsgLy8gIDEwLiB4ZCA9IENNT1YoeGQsIDEsIGUpXG4gICAgeW4gPSBGcC5jbW92KHluLCBGcC5PTkUsIGUpOyAvLyAgMTEuIHluID0gQ01PVih5biwgMSwgZSlcbiAgICB5ZCA9IEZwLmNtb3YoeWQsIEZwLk9ORSwgZSk7IC8vICAxMi4geWQgPSBDTU9WKHlkLCAxLCBlKVxuICAgIGNvbnN0IGludiA9IEZwLmludmVydEJhdGNoKFt4ZCwgeWRdKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIGludlswXSksIHk6IEZwLm11bCh5biwgaW52WzFdKSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihlZDI1NTE5LkV4dGVuZGVkUG9pbnQsIChzY2FsYXJzKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdlZHdhcmRzMjU1MTlfWE1EOlNIQS01MTJfRUxMMl9ST18nLFxuICAgIGVuY29kZURTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuZnVuY3Rpb24gYXNzZXJ0UnN0UG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RQb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG4vLyAxIC8g4oiaKGEtZClcbmNvbnN0IElOVlNRUlRfQV9NSU5VU19EID0gQmlnSW50KCc1NDQ2OTMwNzAwODkwOTMxNjkyMDk5NTgxMzg2ODc0NTE0MTYwNTM5MzU5NzI5MjkyNzQ1NjkyMTIwNTMxMjg5NjMxMTcyMTAxNzU3OCcpO1xuLy8gMS1kwrJcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbi8vIENhbGN1bGF0ZXMgMS/iiJoobnVtYmVyKVxuY29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXIpID0+IHV2UmF0aW8oXzFuLCBudW1iZXIpO1xuY29uc3QgTUFYXzI1NUIgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuY29uc3QgYnl0ZXMyNTVUb051bWJlckxFID0gKGJ5dGVzKSA9PiBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoYnl0ZXMpICYgTUFYXzI1NUIpO1xuLy8gQ29tcHV0ZXMgRWxsaWdhdG9yIG1hcCBmb3IgUmlzdHJldHRvXG4vLyBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgIGNvbnN0IHsgZCB9ID0gZWQyNTUxOS5DVVJWRTtcbiAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICBjb25zdCByID0gbW9kKFNRUlRfTTEgKiByMCAqIHIwKTsgLy8gMVxuICAgIGNvbnN0IE5zID0gbW9kKChyICsgXzFuKSAqIE9ORV9NSU5VU19EX1NRKTsgLy8gMlxuICAgIGxldCBjID0gQmlnSW50KC0xKTsgLy8gM1xuICAgIGNvbnN0IEQgPSBtb2QoKGMgLSBkICogcikgKiBtb2QociArIGQpKTsgLy8gNFxuICAgIGxldCB7IGlzVmFsaWQ6IE5zX0RfaXNfc3EsIHZhbHVlOiBzIH0gPSB1dlJhdGlvKE5zLCBEKTsgLy8gNVxuICAgIGxldCBzXyA9IG1vZChzICogcjApOyAvLyA2XG4gICAgaWYgKCFpc05lZ2F0aXZlTEUoc18sIFApKVxuICAgICAgICBzXyA9IG1vZCgtc18pO1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgcyA9IHNfOyAvLyA3XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBjID0gcjsgLy8gOFxuICAgIGNvbnN0IE50ID0gbW9kKGMgKiAociAtIF8xbikgKiBEX01JTlVTX09ORV9TUSAtIEQpOyAvLyA5XG4gICAgY29uc3QgczIgPSBzICogcztcbiAgICBjb25zdCBXMCA9IG1vZCgocyArIHMpICogRCk7IC8vIDEwXG4gICAgY29uc3QgVzEgPSBtb2QoTnQgKiBTUVJUX0FEX01JTlVTX09ORSk7IC8vIDExXG4gICAgY29uc3QgVzIgPSBtb2QoXzFuIC0gczIpOyAvLyAxMlxuICAgIGNvbnN0IFczID0gbW9kKF8xbiArIHMyKTsgLy8gMTNcbiAgICByZXR1cm4gbmV3IGVkMjU1MTkuRXh0ZW5kZWRQb2ludChtb2QoVzAgKiBXMyksIG1vZChXMiAqIFcxKSwgbW9kKFcxICogVzMpLCBtb2QoVzAgKiBXMikpO1xufVxuLyoqXG4gKiBFYWNoIGVkMjU1MTkvRXh0ZW5kZWRQb2ludCBoYXMgOCBkaWZmZXJlbnQgZXF1aXZhbGVudCBwb2ludHMuIFRoaXMgY2FuIGJlXG4gKiBhIHNvdXJjZSBvZiBidWdzIGZvciBwcm90b2NvbHMgbGlrZSByaW5nIHNpZ25hdHVyZXMuIFJpc3RyZXR0byB3YXMgY3JlYXRlZCB0byBzb2x2ZSB0aGlzLlxuICogUmlzdHJldHRvIHBvaW50IG9wZXJhdGVzIGluIFg6WTpaOlQgZXh0ZW5kZWQgY29vcmRpbmF0ZXMgbGlrZSBFeHRlbmRlZFBvaW50LFxuICogYnV0IGl0IHNob3VsZCB3b3JrIGluIGl0cyBvd24gbmFtZXNwYWNlOiBkbyBub3QgY29tYmluZSB0aG9zZSB0d28uXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1yaXN0cmV0dG8yNTUtZGVjYWY0NDhcbiAqL1xuY2xhc3MgUmlzdFBvaW50IHtcbiAgICAvLyBQcml2YXRlIHByb3BlcnR5IHRvIGRpc2NvdXJhZ2UgY29tYmluaW5nIEV4dGVuZGVkUG9pbnQgKyBSaXN0cmV0dG9Qb2ludFxuICAgIC8vIEFsd2F5cyB1c2UgUmlzdHJldHRvIGVuY29kaW5nL2RlY29kaW5nIGluc3RlYWQuXG4gICAgY29uc3RydWN0b3IoZXApIHtcbiAgICAgICAgdGhpcy5lcCA9IGVwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShhcCkge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1bmlmb3JtIG91dHB1dCBvZiA2NC1ieXRlIGhhc2ggZnVuY3Rpb24gbGlrZSBzaGE1MTIgYW5kIGNvbnZlcnRzIGl0IHRvIGBSaXN0cmV0dG9Qb2ludGAuXG4gICAgICogVGhlIGhhc2gtdG8tZ3JvdXAgb3BlcmF0aW9uIGFwcGxpZXMgRWxsaWdhdG9yIHR3aWNlIGFuZCBhZGRzIHRoZSByZXN1bHRzLlxuICAgICAqICoqTm90ZToqKiB0aGlzIGlzIG9uZS13YXkgbWFwLCB0aGVyZSBpcyBubyBjb252ZXJzaW9uIGZyb20gcG9pbnQgdG8gaGFzaC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuICAgICAqIEBwYXJhbSBoZXggNjQtYnl0ZSBvdXRwdXQgb2YgYSBoYXNoIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncmlzdHJldHRvSGFzaCcsIGhleCwgNjQpO1xuICAgICAgICBjb25zdCByMSA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgUjEgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgICAgICAgY29uc3QgcjIgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICBjb25zdCBSMiA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChSMS5hZGQoUjIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcmlzdHJldHRvLWVuY29kZWQgc3RyaW5nIHRvIHJpc3RyZXR0byBwb2ludC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9kZWNvZGluZy5odG1sXG4gICAgICogQHBhcmFtIGhleCBSaXN0cmV0dG8tZW5jb2RlZCAzMiBieXRlcy4gTm90IGV2ZXJ5IDMyLWJ5dGUgc3RyaW5nIGlzIHZhbGlkIHJpc3RyZXR0byBlbmNvZGluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncmlzdHJldHRvSGV4JywgaGV4LCAzMik7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gZWQyNTUxOS5DVVJWRTtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTkuQ1VSVkUuRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICBjb25zdCBlbXNnID0gJ1Jpc3RyZXR0b1BvaW50LmZyb21IZXg6IHRoZSBoZXggaXMgbm90IHZhbGlkIGVuY29kaW5nIG9mIFJpc3RyZXR0b1BvaW50JztcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXgpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKG51bWJlclRvQnl0ZXNMRShzLCAzMiksIGhleCkgfHwgaXNOZWdhdGl2ZUxFKHMsIFApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgICAgICBjb25zdCBzMiA9IG1vZChzICogcyk7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKF8xbiArIGEgKiBzMik7IC8vIDQgKGEgaXMgLTEpXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKF8xbiAtIGEgKiBzMik7IC8vIDVcbiAgICAgICAgY29uc3QgdTFfMiA9IG1vZCh1MSAqIHUxKTtcbiAgICAgICAgY29uc3QgdTJfMiA9IG1vZCh1MiAqIHUyKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZChhICogZCAqIHUxXzIgLSB1Ml8yKTsgLy8gNlxuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlOiBJIH0gPSBpbnZlcnRTcXJ0KG1vZCh2ICogdTJfMikpOyAvLyA3XG4gICAgICAgIGNvbnN0IER4ID0gbW9kKEkgKiB1Mik7IC8vIDhcbiAgICAgICAgY29uc3QgRHkgPSBtb2QoSSAqIER4ICogdik7IC8vIDlcbiAgICAgICAgbGV0IHggPSBtb2QoKHMgKyBzKSAqIER4KTsgLy8gMTBcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgICAgIHggPSBtb2QoLXgpOyAvLyAxMFxuICAgICAgICBjb25zdCB5ID0gbW9kKHUxICogRHkpOyAvLyAxMVxuICAgICAgICBjb25zdCB0ID0gbW9kKHggKiB5KTsgLy8gMTJcbiAgICAgICAgaWYgKCFpc1ZhbGlkIHx8IGlzTmVnYXRpdmVMRSh0LCBQKSB8fCB5ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KG5ldyBlZDI1NTE5LkV4dGVuZGVkUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZW5jb2RpbmcuaHRtbFxuICAgICAqL1xuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGxldCB7IGV4OiB4LCBleTogeSwgZXo6IHosIGV0OiB0IH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKG1vZCh6ICsgeSkgKiBtb2QoeiAtIHkpKTsgLy8gMVxuICAgICAgICBjb25zdCB1MiA9IG1vZCh4ICogeSk7IC8vIDJcbiAgICAgICAgLy8gU3F1YXJlIHJvb3QgYWx3YXlzIGV4aXN0c1xuICAgICAgICBjb25zdCB1MnNxID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBpbnZzcXJ0IH0gPSBpbnZlcnRTcXJ0KG1vZCh1MSAqIHUyc3EpKTsgLy8gM1xuICAgICAgICBjb25zdCBEMSA9IG1vZChpbnZzcXJ0ICogdTEpOyAvLyA0XG4gICAgICAgIGNvbnN0IEQyID0gbW9kKGludnNxcnQgKiB1Mik7IC8vIDVcbiAgICAgICAgY29uc3QgekludiA9IG1vZChEMSAqIEQyICogdCk7IC8vIDZcbiAgICAgICAgbGV0IEQ7IC8vIDdcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh0ICogekludiwgUCkpIHtcbiAgICAgICAgICAgIGxldCBfeCA9IG1vZCh5ICogU1FSVF9NMSk7XG4gICAgICAgICAgICBsZXQgX3kgPSBtb2QoeCAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgeCA9IF94O1xuICAgICAgICAgICAgeSA9IF95O1xuICAgICAgICAgICAgRCA9IG1vZChEMSAqIElOVlNRUlRfQV9NSU5VU19EKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEQgPSBEMjsgLy8gOFxuICAgICAgICB9XG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCAqIHpJbnYsIFApKVxuICAgICAgICAgICAgeSA9IG1vZCgteSk7IC8vIDlcbiAgICAgICAgbGV0IHMgPSBtb2QoKHogLSB5KSAqIEQpOyAvLyAxMCAoY2hlY2sgZm9vdGVyJ3Mgbm90ZSwgbm8gc3FydCgtYSkpXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICBzID0gbW9kKC1zKTtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNMRShzLCAzMik7IC8vIDExXG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIgfSA9IG90aGVyLmVwO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgLy8gKHgxICogeTIgPT0geTEgKiB4MikgfCAoeTEgKiB5MiA9PSB4MSAqIHgyKVxuICAgICAgICBjb25zdCBvbmUgPSBtb2QoWDEgKiBZMikgPT09IG1vZChZMSAqIFgyKTtcbiAgICAgICAgY29uc3QgdHdvID0gbW9kKFkxICogWTIpID09PSBtb2QoWDEgKiBYMik7XG4gICAgICAgIHJldHVybiBvbmUgfHwgdHdvO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLmFkZChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuc3VidHJhY3Qob3RoZXIuZXApKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLm11bHRpcGx5VW5zYWZlKHNjYWxhcikpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuZG91YmxlKCkpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBSaXN0cmV0dG9Qb2ludCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGlmICghUmlzdFBvaW50LkJBU0UpXG4gICAgICAgIFJpc3RQb2ludC5CQVNFID0gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuQkFTRSk7XG4gICAgaWYgKCFSaXN0UG9pbnQuWkVSTylcbiAgICAgICAgUmlzdFBvaW50LlpFUk8gPSBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5aRVJPKTtcbiAgICByZXR1cm4gUmlzdFBvaW50O1xufSkoKTtcbi8vIEhhc2hpbmcgdG8gcmlzdHJldHRvMjU1LiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNhcHBlbmRpeC1CXG5leHBvcnQgY29uc3QgaGFzaFRvUmlzdHJldHRvMjU1ID0gKG1zZywgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGQgPSBvcHRpb25zLkRTVDtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhkKSA6IGQ7XG4gICAgY29uc3QgdW5pZm9ybV9ieXRlcyA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgNjQsIHNoYTUxMik7XG4gICAgY29uc3QgUCA9IFJpc3RQb2ludC5oYXNoVG9DdXJ2ZSh1bmlmb3JtX2J5dGVzKTtcbiAgICByZXR1cm4gUDtcbn07XG5leHBvcnQgY29uc3QgaGFzaF90b19yaXN0cmV0dG8yNTUgPSBoYXNoVG9SaXN0cmV0dG8yNTU7IC8vIGxlZ2FjeVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWQyNTUxOS5qcy5tYXAiXSwibmFtZXMiOlsic2hhNTEyIiwiY29uY2F0Qnl0ZXMiLCJyYW5kb21CeXRlcyIsInV0ZjhUb0J5dGVzIiwidHdpc3RlZEVkd2FyZHMiLCJtb250Z29tZXJ5IiwiRmllbGQiLCJGcFNxcnRFdmVuIiwiaXNOZWdhdGl2ZUxFIiwibW9kIiwicG93MiIsImJ5dGVzVG9IZXgiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsImVxdWFsQnl0ZXMiLCJudW1iZXJUb0J5dGVzTEUiLCJjcmVhdGVIYXNoZXIiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJFRDI1NTE5X1AiLCJCaWdJbnQiLCJFRDI1NTE5X1NRUlRfTTEiLCJfMG4iLCJfMW4iLCJfMm4iLCJfNW4iLCJfMTBuIiwiXzIwbiIsIl80MG4iLCJfODBuIiwiZWQyNTUxOV9wb3dfMl8yNTJfMyIsIngiLCJQIiwieDIiLCJiMiIsImI0IiwiYjUiLCJiMTAiLCJiMjAiLCJiNDAiLCJiODAiLCJiMTYwIiwiYjI0MCIsImIyNTAiLCJwb3dfcF81XzgiLCJhZGp1c3RTY2FsYXJCeXRlcyIsImJ5dGVzIiwidXZSYXRpbyIsInUiLCJ2IiwidjMiLCJ2NyIsInBvdyIsInZ4MiIsInJvb3QxIiwicm9vdDIiLCJ1c2VSb290MSIsInVzZVJvb3QyIiwibm9Sb290IiwiaXNWYWxpZCIsInZhbHVlIiwiRUQyNTUxOV9UT1JTSU9OX1NVQkdST1VQIiwiRnAiLCJ1bmRlZmluZWQiLCJlZDI1NTE5RGVmYXVsdHMiLCJhIiwiZCIsIm4iLCJoIiwiR3giLCJHeSIsImhhc2giLCJlZDI1NTE5IiwiZWQyNTUxOV9kb21haW4iLCJkYXRhIiwiY3R4IiwicGhmbGFnIiwibGVuZ3RoIiwiRXJyb3IiLCJVaW50OEFycmF5IiwiZWQyNTUxOWN0eCIsImRvbWFpbiIsImVkMjU1MTlwaCIsInByZWhhc2giLCJ4MjU1MTkiLCJtb250Z29tZXJ5Qml0cyIsIm5CeXRlTGVuZ3RoIiwiR3UiLCJwb3dQbWludXMyIiwiZWR3YXJkc1RvTW9udGdvbWVyeVB1YiIsImVkd2FyZHNQdWIiLCJ5IiwiRXh0ZW5kZWRQb2ludCIsImZyb21IZXgiLCJ0b0J5dGVzIiwiY3JlYXRlIiwiaW52IiwiZWR3YXJkc1RvTW9udGdvbWVyeSIsImVkd2FyZHNUb01vbnRnb21lcnlQcml2IiwiZWR3YXJkc1ByaXYiLCJoYXNoZWQiLCJzdWJhcnJheSIsIkVMTDJfQzEiLCJPUkRFUiIsIkVMTDJfQzIiLCJFTEwyX0MzIiwic3FydCIsIm5lZyIsIk9ORSIsIkVMTDJfQzQiLCJFTEwyX0oiLCJtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5IiwidHYxIiwic3FyIiwibXVsIiwieGQiLCJhZGQiLCJ4MW4iLCJ0djIiLCJneGQiLCJneDEiLCJ0djMiLCJ5MTEiLCJ5MTIiLCJlMSIsImVxbCIsInkxIiwiY21vdiIsIngybiIsInkyMSIsInkyMiIsImd4MiIsImUyIiwieTIiLCJlMyIsInhuIiwiZTQiLCJpc09kZCIsInhNbiIsInhNZCIsInlNbiIsInlNZCIsIkVMTDJfQzFfRURXQVJEUyIsIm1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSIsInluIiwic3ViIiwieWQiLCJlIiwiWkVSTyIsImludmVydEJhdGNoIiwiaHRmIiwic2NhbGFycyIsIkRTVCIsImVuY29kZURTVCIsInAiLCJtIiwiayIsImV4cGFuZCIsImhhc2hUb0N1cnZlIiwiZW5jb2RlVG9DdXJ2ZSIsImFzc2VydFJzdFBvaW50Iiwib3RoZXIiLCJSaXN0UG9pbnQiLCJTUVJUX00xIiwiU1FSVF9BRF9NSU5VU19PTkUiLCJJTlZTUVJUX0FfTUlOVVNfRCIsIk9ORV9NSU5VU19EX1NRIiwiRF9NSU5VU19PTkVfU1EiLCJpbnZlcnRTcXJ0IiwibnVtYmVyIiwiTUFYXzI1NUIiLCJieXRlczI1NVRvTnVtYmVyTEUiLCJDVVJWRSIsImNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAiLCJyMCIsInIiLCJOcyIsImMiLCJEIiwiTnNfRF9pc19zcSIsInMiLCJzXyIsIk50IiwiczIiLCJXMCIsIlcxIiwiVzIiLCJXMyIsImNvbnN0cnVjdG9yIiwiZXAiLCJmcm9tQWZmaW5lIiwiYXAiLCJoZXgiLCJyMSIsInNsaWNlIiwiUjEiLCJyMiIsIlIyIiwiZW1zZyIsInUxIiwidTIiLCJ1MV8yIiwidTJfMiIsIkkiLCJEeCIsIkR5IiwidCIsInRvUmF3Qnl0ZXMiLCJleCIsImV5IiwiZXoiLCJ6IiwiZXQiLCJ1MnNxIiwiaW52c3FydCIsIkQxIiwiRDIiLCJ6SW52IiwiX3giLCJfeSIsInRvSGV4IiwidG9TdHJpbmciLCJlcXVhbHMiLCJYMSIsIlkxIiwiWDIiLCJZMiIsIm9uZSIsInR3byIsInN1YnRyYWN0IiwibXVsdGlwbHkiLCJzY2FsYXIiLCJtdWx0aXBseVVuc2FmZSIsImRvdWJsZSIsIm5lZ2F0ZSIsIlJpc3RyZXR0b1BvaW50IiwiQkFTRSIsImhhc2hUb1Jpc3RyZXR0bzI1NSIsIm1zZyIsIm9wdGlvbnMiLCJ1bmlmb3JtX2J5dGVzIiwiaGFzaF90b19yaXN0cmV0dG8yNTUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/ed25519.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r)) return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    } catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3RCO0FBQ0k7QUFDTztBQUNPO0FBQ2lDO0FBQzFCO0FBQ3RCO0FBQ2pELE1BQU1hLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksYUFBYSxDQUFDQyxHQUFHQyxJQUFNLENBQUNELElBQUlDLElBQUlILEdBQUUsSUFBS0c7QUFDN0M7OztDQUdDLEdBQ0QsU0FBU0MsUUFBUUMsQ0FBQztJQUNkLE1BQU1DLElBQUlWO0lBQ1Ysa0JBQWtCO0lBQ2xCLE1BQU1XLE1BQU1WLE9BQU8sSUFBSVcsTUFBTVgsT0FBTyxJQUFJWSxPQUFPWixPQUFPLEtBQUthLE9BQU9iLE9BQU87SUFDekUsa0JBQWtCO0lBQ2xCLE1BQU1jLE9BQU9kLE9BQU8sS0FBS2UsT0FBT2YsT0FBTyxLQUFLZ0IsT0FBT2hCLE9BQU87SUFDMUQsTUFBTWlCLEtBQUssSUFBS1QsSUFBSUEsSUFBS0MsR0FBRyxVQUFVO0lBQ3RDLE1BQU1TLEtBQUssS0FBTUQsS0FBS1QsSUFBS0MsR0FBRyxNQUFNO0lBQ3BDLE1BQU1VLEtBQUssMkRBQU1ELElBQUlSLEtBQUtELEtBQUtTLEtBQU1UO0lBQ3JDLE1BQU1XLEtBQUssMkRBQU1ELElBQUlULEtBQUtELEtBQUtTLEtBQU1UO0lBQ3JDLE1BQU1ZLE1BQU0sMkRBQU1ELElBQUlqQixLQUFLTSxLQUFLUSxLQUFNUjtJQUN0QyxNQUFNYSxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNSCxLQUFLWSxNQUFPWjtJQUN6QyxNQUFNYyxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNSixLQUFLYSxNQUFPYjtJQUN6QyxNQUFNZSxNQUFNLDJEQUFNRCxLQUFLUixNQUFNTixLQUFLYyxNQUFPZDtJQUN6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O0lBQ3JCLEdBQUc7UUFDQ29JLEtBQUs7UUFDTEMsV0FBVztRQUNYcEQsR0FBRzFELEdBQUcrRyxLQUFLO1FBQ1h0QyxHQUFHO1FBQ0gxRCxHQUFHO1FBQ0hpRyxRQUFRO1FBQ1JDLE1BQU05Six3REFBTUE7SUFDaEIsRUFBQztBQUNNLE1BQU0rSixjQUE4QixhQUFILEdBQUksS0FBTVAsSUFBSU8sV0FBVyxJQUFJO0FBQzlELE1BQU1DLGdCQUFnQyxhQUFILEdBQUksS0FBTVIsSUFBSVEsYUFBYSxJQUFJLENBQ3pFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz9kMTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcCwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJGaWVsZCIsIm1vZCIsInBvdzIiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJjcmVhdGVDdXJ2ZSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnAiLCJlcWwiLCJzcXIiLCJFcnJvciIsInVuZGVmaW5lZCIsInNxcnQiLCJzZWNwMjU2azEiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJrMiIsImsxbmVnIiwiazJuZWciLCJfMG4iLCJmZSIsIngiLCJnZSIsIlRBR0dFRF9IQVNIX1BSRUZJWEVTIiwidGFnZ2VkSGFzaCIsInRhZyIsIm1lc3NhZ2VzIiwidGFnUCIsInRhZ0giLCJVaW50OEFycmF5IiwiZnJvbSIsImMiLCJjaGFyQ29kZUF0IiwicG9pbnRUb0J5dGVzIiwicG9pbnQiLCJ0b1Jhd0J5dGVzIiwic2xpY2UiLCJudW1UbzMyYiIsIm1vZFAiLCJtb2ROIiwiUG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJHbXVsQWRkIiwiUSIsIkJBU0UiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInNjaG5vcnJHZXRFeHRQdWJLZXkiLCJwcml2IiwiZF8iLCJ1dGlscyIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJwIiwiZnJvbVByaXZhdGVLZXkiLCJzY2FsYXIiLCJoYXNFdmVuWSIsImJ5dGVzIiwibGlmdF94IiwieHgiLCJhc3NlcnRWYWxpZGl0eSIsImNoYWxsZW5nZSIsImFyZ3MiLCJzY2hub3JyR2V0UHVibGljS2V5IiwicHJpdmF0ZUtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJrXyIsInJ4IiwiZSIsInNpZyIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJzY2hub3JyIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsInZlcmlmeSIsInJhbmRvbVByaXZhdGVLZXkiLCJpc29NYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLFNBQVNBLE9BQU9DLENBQUM7SUFDYixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sQ0FBQywrQkFBK0IsRUFBRUgsRUFBRSxDQUFDO0FBQzdEO0FBQ0EsU0FBU0ksS0FBS0MsQ0FBQztJQUNYLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUYsTUFBTSxDQUFDLHNCQUFzQixFQUFFRSxFQUFFLENBQUM7QUFDcEQ7QUFDQSxvQkFBb0I7QUFDYixTQUFTQyxRQUFRQyxDQUFDO0lBQ3JCLE9BQVFBLGFBQWFDLGNBQ2hCRCxLQUFLLFFBQVEsT0FBT0EsTUFBTSxZQUFZQSxFQUFFRSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN0RTtBQUNBLFNBQVNDLE1BQU1OLENBQUMsRUFBRSxHQUFHTyxPQUFPO0lBQ3hCLElBQUksQ0FBQ04sUUFBUUQsSUFDVCxNQUFNLElBQUlGLE1BQU07SUFDcEIsSUFBSVMsUUFBUUMsTUFBTSxHQUFHLEtBQUssQ0FBQ0QsUUFBUUUsUUFBUSxDQUFDVCxFQUFFUSxNQUFNLEdBQ2hELE1BQU0sSUFBSVYsTUFBTSxDQUFDLDhCQUE4QixFQUFFUyxRQUFRLGdCQUFnQixFQUFFUCxFQUFFUSxNQUFNLENBQUMsQ0FBQztBQUM3RjtBQUNBLFNBQVNFLEtBQUtDLENBQUM7SUFDWCxJQUFJLE9BQU9BLE1BQU0sY0FBYyxPQUFPQSxFQUFFQyxNQUFNLEtBQUssWUFDL0MsTUFBTSxJQUFJZCxNQUFNO0lBQ3BCSixPQUFPaUIsRUFBRUUsU0FBUztJQUNsQm5CLE9BQU9pQixFQUFFRyxRQUFRO0FBQ3JCO0FBQ0EsU0FBU0MsT0FBT0MsUUFBUSxFQUFFQyxnQkFBZ0IsSUFBSTtJQUMxQyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSXBCLE1BQU07SUFDcEIsSUFBSW1CLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUlyQixNQUFNO0FBQ3hCO0FBQ0EsU0FBU3NCLE9BQU9DLEdBQUcsRUFBRUwsUUFBUTtJQUN6QlYsTUFBTWU7SUFDTixNQUFNQyxNQUFNTixTQUFTSCxTQUFTO0lBQzlCLElBQUlRLElBQUliLE1BQU0sR0FBR2MsS0FBSztRQUNsQixNQUFNLElBQUl4QixNQUFNLENBQUMsc0RBQXNELEVBQUV3QixJQUFJLENBQUM7SUFDbEY7QUFDSjtBQUNxRDtBQUNyRCxNQUFNQyxTQUFTO0lBQUU3QjtJQUFRSztJQUFNTztJQUFPSTtJQUFNSztJQUFRSztBQUFPO0FBQzNELGlFQUFlRyxNQUFNQSxFQUFDLENBQ3RCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MjcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYm9vbCIsImIiLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJieXRlcyIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImhhc2giLCJoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJleGlzdHMiLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dHB1dCIsIm91dCIsIm1pbiIsImFzc2VydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n} //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQseUJBQXlCO0FBQ3pCLFNBQVNLLGFBQWFDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDL0MsSUFBSSxPQUFPSCxLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDRSxZQUFZQyxPQUFPQztJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPTixRQUFRSTtJQUMxQixNQUFNSSxJQUFJUCxPQUFPLElBQUk7SUFDckIsTUFBTVEsSUFBSVIsT0FBTyxJQUFJO0lBQ3JCSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFTLEdBQUdILElBQUlKO0lBQ25DSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFVLEdBQUdGLElBQUlOO0FBQ3ZDO0FBQ0Esb0JBQW9CO0FBQ2IsTUFBTVUsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU0sQ0FBQ0QsSUFBSUUsRUFBRztBQUNuRCxvREFBb0Q7QUFDN0MsTUFBTUMsTUFBTSxDQUFDSCxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDLEVBQUc7QUFDNUQ7OztDQUdDLEdBQ00sTUFBTUUsZUFBZXRCLDJDQUFJQTtJQUM1QnVCLFlBQVlDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVuQixJQUFJLENBQUU7UUFDOUMsS0FBSztRQUNMLElBQUksQ0FBQ2lCLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNuQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFD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QixJQUFJRixTQUFTQyxNQUFNdkIsTUFBTSxFQUNyQixNQUFNLElBQUlxQixNQUFNO1FBQ3BCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJRyxRQUFRSCxJQUN4QkMsTUFBTWhDLFNBQVMsQ0FBQyxJQUFJK0IsR0FBR0ksS0FBSyxDQUFDSixFQUFFLEVBQUV4QztJQUN6QztJQUNBOEMsU0FBUztRQUNMLE1BQU0sRUFBRXRCLE1BQU0sRUFBRU4sU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUNtQixVQUFVLENBQUNiO1FBQ2hCLE1BQU11QixNQUFNdkIsT0FBT3dCLEtBQUssQ0FBQyxHQUFHOUI7UUFDNUIsSUFBSSxDQUFDK0IsT0FBTztRQUNaLE9BQU9GO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1hBLE1BQU9BLENBQUFBLEtBQUssSUFBSSxJQUFJLENBQUNuQyxXQUFXLEVBQUM7UUFDakNtQyxHQUFHakIsR0FBRyxJQUFJLElBQUksQ0FBQ1csR0FBRztRQUNsQixNQUFNLEVBQUU1QixRQUFRLEVBQUVPLE1BQU0sRUFBRUgsTUFBTSxFQUFFRCxRQUFRLEVBQUVHLFNBQVMsRUFBRUQsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNuRTZCLEdBQUc5QixNQUFNLEdBQUdBO1FBQ1o4QixHQUFHN0IsR0FBRyxHQUFHQTtRQUNUNkIsR0FBRy9CLFFBQVEsR0FBR0E7UUFDZCtCLEdBQUc1QixTQUFTLEdBQUdBO1FBQ2YsSUFBSUYsU0FBU0osVUFDVGtDLEdBQUczQixNQUFNLENBQUNVLEdBQUcsQ0FBQ1Y7UUFDbEIsT0FBTzJCO0lBQ1g7QUFDSixFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcz9hMDg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuZXhwb3J0IGNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5leHBvcnQgY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbImV4aXN0cyIsIm91dHB1dCIsIkhhc2giLCJjcmVhdGVWaWV3IiwidG9CeXRlcyIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwidmFsdWUiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiQ2hpIiwiYSIsImIiLCJjIiwiTWFqIiwiSGFzaE1EIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZE9mZnNldCIsImZpbmlzaGVkIiwibGVuZ3RoIiwicG9zIiwiZGVzdHJveWVkIiwiYnVmZmVyIiwiVWludDhBcnJheSIsInVwZGF0ZSIsImRhdGEiLCJsZW4iLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImRhdGFWaWV3IiwicHJvY2VzcyIsInNldCIsInN1YmFycmF5Iiwicm91bmRDbGVhbiIsImRpZ2VzdEludG8iLCJvdXQiLCJmaWxsIiwiaSIsIm92aWV3IiwiRXJyb3IiLCJvdXRMZW4iLCJzdGF0ZSIsImdldCIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLGFBQWEsYUFBYSxHQUFHQyxPQUFPLEtBQUssS0FBSztBQUNwRCxNQUFNQyxPQUFPLGFBQWEsR0FBR0QsT0FBTztBQUNwQywrRUFBK0U7QUFDL0UsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlKO1FBQWFRLEdBQUdELE9BQU8sS0FBTUwsT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVNLEdBQUdDLE9BQU8sS0FBTUwsT0FBUUYsY0FBYztRQUFHUSxHQUFHRCxPQUFPSCxJQUFJSixjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTUyxNQUFNQyxHQUFHLEVBQUVMLEtBQUssS0FBSztJQUMxQixJQUFJTSxLQUFLLElBQUlDLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSUMsS0FBSyxJQUFJRixZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQUs7UUFDakMsTUFBTSxFQUFFVCxDQUFDLEVBQUVFLENBQUMsRUFBRSxHQUFHTCxRQUFRTyxHQUFHLENBQUNLLEVBQUUsRUFBRVY7UUFDakMsQ0FBQ00sRUFBRSxDQUFDSSxFQUFFLEVBQUVELEVBQUUsQ0FBQ0MsRUFBRSxDQUFDLEdBQUc7WUFBQ1Q7WUFBR0U7U0FBRTtJQUMzQjtJQUNBLE9BQU87UUFBQ0c7UUFBSUc7S0FBRztBQUNuQjtBQUNBLE1BQU1FLFFBQVEsQ0FBQ1YsR0FBR0UsSUFBTSxPQUFRRixNQUFNLE1BQU1KLE9BQVFELE9BQU9PLE1BQU07QUFDakUsdUJBQXVCO0FBQ3ZCLE1BQU1TLFFBQVEsQ0FBQ1gsR0FBR1ksSUFBSUMsSUFBTWIsTUFBTWE7QUFDbEMsTUFBTUMs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Z0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzdkYzAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsImZyb21CaWciLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsInNwbGl0IiwibHN0IiwiQWgiLCJVaW50MzJBcnJheSIsImxlbmd0aCIsIkFsIiwiaSIsInRvQmlnIiwic2hyU0giLCJfbCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJfaCIsInJvdHIzMkwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJhZGQiLCJCaCIsIkJsIiwiYWRkM0wiLCJDbCIsImFkZDNIIiwibG93IiwiQ2giLCJhZGQ0TCIsIkRsIiwiYWRkNEgiLCJEaCIsImFkZDVMIiwiRWwiLCJhZGQ1SCIsIkVoIiwidTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxvRkFBb0Y7QUFDcEYsNEJBQTRCO0FBQzVCLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ3FCO0FBQzNCLE1BQU1DLFNBQVNELDJNQUFFQSxJQUFJLE9BQU9BLDJNQUFFQSxLQUFLLFlBQVksME5BQWlCQSxHQUFHQSxrREFBWSxHQUFHRyxVQUFVLENBQ25HLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanM/ZGE1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsibmMiLCJjcnlwdG8iLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/hkdf.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hkdf.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */ function extract(hash, ikm, salt) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([\n    0\n]);\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */ function expand(hash, prk, info, length = 32) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(length);\n    if (length > 255 * hash.outputLen) throw new Error(\"Length should be <= 255*HashLen\");\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined) info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for(let counter = 0; counter < blocks; counter++){\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */ const hkdf = (hash, ikm, salt, info, length)=>expand(hash, extract(hash, ikm, salt), info, length); //# sourceMappingURL=hkdf.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEU7QUFDckM7QUFDSjtBQUNqQyxrQkFBa0I7QUFDbEIscURBQXFEO0FBQ3JEOzs7Ozs7O0NBT0MsR0FDTSxTQUFTTSxRQUFRTixJQUFJLEVBQUVPLEdBQUcsRUFBRUMsSUFBSTtJQUNuQ1AsZ0RBQVVBLENBQUNEO0lBQ1gsa0VBQWtFO0lBQ2xFLHNEQUFzRDtJQUN0RCwrQ0FBK0M7SUFDL0MsSUFBSVEsU0FBU0MsV0FDVEQsT0FBTyxJQUFJRSxXQUFXVixLQUFLVyxTQUFTLEdBQUcsMERBQTBEO0lBQ3JHLE9BQU9OLDhDQUFJQSxDQUFDTCxNQUFNSSxrREFBT0EsQ0FBQ0ksT0FBT0osa0RBQU9BLENBQUNHO0FBQzdDO0FBQ0EsbUNBQW1DO0FBQ25DLE1BQU1LLGVBQWUsYUFBYSxHQUFHLElBQUlGLFdBQVc7SUFBQztDQUFFO0FBQ3ZELE1BQU1HLGVBQWUsYUFBYSxHQUFHLElBQUlIO0FBQ3pDOzs7OztDQUtDLEdBQ00sU0FBU0ksT0FBT2QsSUFBSSxFQUFFZSxHQUFHLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFO0lBQy9DaEIsZ0RBQVVBLENBQUNEO0lBQ1hHLGtEQUFZQSxDQUFDYztJQUNiLElBQUlBLFNBQVMsTUFBTWpCLEtBQUtXLFNBQVMsRUFDN0IsTUFBTSxJQUFJTyxNQUFNO0lBQ3BCLE1BQU1DLFNBQVNDLEtBQUtDLElBQUksQ0FBQ0osU0FBU2pCLEtBQUtXLFNBQVM7SUFDaEQsSUFBSUssU0FBU1AsV0FDVE8sT0FBT0g7SUFDWCw2QkFBNkI7SUFDN0IsTUFBTVMsTUFBTSxJQUFJWixXQUFXUyxTQUFTbkIsS0FBS1csU0FBUztJQUNsRCxzQ0FBc0M7SUFDdEMsTUFBTVksT0FBT2xCLDBDQUFJQSxDQUFDbUIsTUFBTSxDQUFDeEIsTUFBTWU7SUFDL0IsTUFBTVUsVUFBVUYsS0FBS0csVUFBVTtJQUMvQixNQUFNQyxJQUFJLElBQUlqQixXQUFXYSxLQUFLWixTQUFTO0lBQ3ZDLElBQUssSUFBSWlCLFVBQVUsR0FBR0EsVUFBVVQsUUFBUVMsVUFBVztRQUMvQ2hCLFlBQVksQ0FBQyxFQUFFLEdBQUdnQixVQUFVO1FBQzVCLG9DQUFvQztRQUNwQywyQ0FBMkM7UUFDM0NILFFBQVFJLE1BQU0sQ0FBQ0QsWUFBWSxJQUFJZixlQUFlYyxHQUN6Q0UsTUFBTSxDQUFDYixNQUNQYSxNQUFNLENBQUNqQixjQUNQa0IsVUFBVSxDQUFDSDtRQUNoQkwsSUFBSVMsR0FBRyxDQUFDSixHQUFHM0IsS0FBS1csU0FBUyxHQUFHaUI7UUFDNUJMLEtBQUtHLFVBQVUsQ0FBQ0Q7SUFDcEI7SUFDQUYsS0FBS1MsT0FBTztJQUNaUCxRQUFRTyxPQUFPO0lBQ2ZMLEVBQUVNLElBQUksQ0FBQztJQUNQckIsYUFBYXFCLElBQUksQ0FBQztJQUNsQixPQUFPWCxJQUFJWSxLQUFLLENBQUMsR0FBR2pCO0FBQ3hCO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1rQixPQUFPLENBQUNuQyxNQUFNTyxLQUFLQyxNQUFNUSxNQUFNQyxTQUFXSCxPQUFPZCxNQUFNTSxRQUFRTixNQUFNTyxLQUFLQyxPQUFPUSxNQUFNQyxRQUFRLENBQzVHLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2hrZGYuanM/OWU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJy4vaG1hYy5qcyc7XG4vLyBIS0RGIChSRkMgNTg2OSlcbi8vIGh0dHBzOi8vc29hdG9rLmJsb2cvMjAyMS8xMS8xNy91bmRlcnN0YW5kaW5nLWhrZGYvXG4vKipcbiAqIEhLREYtRXh0cmFjdChJS00sIHNhbHQpIC0+IFBSS1xuICogQXJndW1lbnRzIHBvc2l0aW9uIGRpZmZlcnMgZnJvbSBzcGVjIChJS00gaXMgZmlyc3Qgb25lLCBzaW5jZSBpdCBpcyBub3Qgb3B0aW9uYWwpXG4gKiBAcGFyYW0gaGFzaFxuICogQHBhcmFtIGlrbVxuICogQHBhcmFtIHNhbHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCkge1xuICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgLy8gTk9URTogc29tZSBsaWJyYXJpZXMgdHJlYXQgemVyby1sZW5ndGggYXJyYXkgYXMgJ25vdCBwcm92aWRlZCc7XG4gICAgLy8gd2UgZG9uJ3QsIHNpbmNlIHdlIGhhdmUgdW5kZWZpbmVkIGFzICdub3QgcHJvdmlkZWQnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcbiAgICBpZiAoc2FsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaC5vdXRwdXRMZW4pOyAvLyBpZiBub3QgcHJvdmlkZWQsIGl0IGlzIHNldCB0byBhIHN0cmluZyBvZiBIYXNoTGVuIHplcm9zXG4gICAgcmV0dXJuIGhtYWMoaGFzaCwgdG9CeXRlcyhzYWx0KSwgdG9CeXRlcyhpa20pKTtcbn1cbi8vIEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNXG5jb25zdCBIS0RGX0NPVU5URVIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgpO1xuLyoqXG4gKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLlxuICogQHBhcmFtIHByayAtIGEgcHNldWRvcmFuZG9tIGtleSBvZiBhdCBsZWFzdCBIYXNoTGVuIG9jdGV0cyAodXN1YWxseSwgdGhlIG91dHB1dCBmcm9tIHRoZSBleHRyYWN0IHN0ZXApXG4gKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uIChjYW4gYmUgYSB6ZXJvLWxlbmd0aCBzdHJpbmcpXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIG91dHB1dCBrZXlpbmcgbWF0ZXJpYWwgaW4gb2N0ZXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmQoaGFzaCwgcHJrLCBpbmZvLCBsZW5ndGggPSAzMikge1xuICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IDI1NSAqIGhhc2gub3V0cHV0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBzaG91bGQgYmUgPD0gMjU1Kkhhc2hMZW4nKTtcbiAgICBjb25zdCBibG9ja3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaC5vdXRwdXRMZW4pO1xuICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgIGluZm8gPSBFTVBUWV9CVUZGRVI7XG4gICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBoYXNoLm91dHB1dExlbik7XG4gICAgLy8gUmUtdXNlIEhNQUMgaW5zdGFuY2UgYmV0d2VlbiBibG9ja3NcbiAgICBjb25zdCBITUFDID0gaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgaGFzaC5vdXRwdXRMZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBULmZpbGwoMCk7XG4gICAgSEtERl9DT1VOVEVSLmZpbGwoMCk7XG4gICAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1NilcbiAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvblxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhrZGYuanMubWFwIl0sIm5hbWVzIjpbImhhc2giLCJhc3NlcnRIYXNoIiwibnVtYmVyIiwiYXNzZXJ0TnVtYmVyIiwidG9CeXRlcyIsImhtYWMiLCJleHRyYWN0IiwiaWttIiwic2FsdCIsInVuZGVmaW5lZCIsIlVpbnQ4QXJyYXkiLCJvdXRwdXRMZW4iLCJIS0RGX0NPVU5URVIiLCJFTVBUWV9CVUZGRVIiLCJleHBhbmQiLCJwcmsiLCJpbmZvIiwibGVuZ3RoIiwiRXJyb3IiLCJibG9ja3MiLCJNYXRoIiwiY2VpbCIsIm9rbSIsIkhNQUMiLCJjcmVhdGUiLCJITUFDVG1wIiwiX2Nsb25lSW50byIsIlQiLCJjb3VudGVyIiwidXBkYXRlIiwiZGlnZXN0SW50byIsInNldCIsImRlc3Ryb3kiLCJmaWxsIiwic2xpY2UiLCJoa2RmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDLGtCQUFrQjtBQUNYLE1BQU1RLGFBQWFGLDJDQUFJQTtJQUMxQkcsWUFBWVQsSUFBSSxFQUFFVSxJQUFJLENBQUU7UUFDcEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCWCxnREFBVUEsQ0FBQ0Q7UUFDWCxNQUFNYSxNQUFNTixrREFBT0EsQ0FBQ0c7UUFDcEIsSUFBSSxDQUFDSSxLQUFLLEdBQUdkLEtBQUtlLE1BQU07UUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDRSxNQUFNLEtBQUssWUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxRQUFRO1FBQ25DLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxTQUFTO1FBQ3JDLE1BQU1ELFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE1BQU1FLE1BQU0sSUFBSUMsV0FBV0g7UUFDM0Isd0NBQXdDO1FBQ3hDRSxJQUFJRSxHQUFHLENBQUNULElBQUlVLE1BQU0sR0FBR0wsV0FBV2xCLEtBQUtlLE1BQU0sR0FBR0MsTUFBTSxDQUFDSCxLQUFLVyxNQUFNLEtBQUtYO1FBQ3JFLElBQUssSUFBSVksSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSTtRQUNkLElBQUksQ0FBQ1gsS0FBSyxDQUFDRSxNQUFNLENBQUNJO1FBQ2xCLG1IQUFtSDtRQUNuSCxJQUFJLENBQUNNLEtBQUssR0FBRzFCLEtBQUtlLE1BQU07UUFDeEIsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSSxPQUFPO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixNQUFNLENBQUNJO1FBQ2xCQSxJQUFJTyxJQUFJLENBQUM7SUFDYjtJQUNBWCxPQUFPWSxHQUFHLEVBQUU7UUFDUnZCLGtEQUFZQSxDQUFDLElBQUk7UUFDakIsSUFBSSxDQUFDUyxLQUFLLENBQUNFLE1BQU0sQ0FBQ1k7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsV0FBV0MsR0FBRyxFQUFFO1FBQ1p6QixrREFBWUEsQ0FBQyxJQUFJO1FBQ2pCRixpREFBV0EsQ0FBQzJCLEtBQUssSUFBSSxDQUFDWCxTQUFTO1FBQy9CLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0csS0FBSyxDQUFDZSxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0osS0FBSyxDQUFDVixNQUFNLENBQUNjO1FBQ2xCLElBQUksQ0FBQ0osS0FBSyxDQUFDRyxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTztJQUNoQjtJQUNBUCxTQUFTO1FBQ0wsTUFBTU0sTUFBTSxJQUFJVCxXQUFXLElBQUksQ0FBQ0ssS0FBSyxDQUFDUCxTQUFTO1FBQy9DLElBQUksQ0FBQ1UsVUFBVSxDQUFDQztRQUNoQixPQUFPQTtJQUNYO0lBQ0FFLFdBQVdDLEVBQUUsRUFBRTtRQUNYLG1HQUFtRztRQUNuR0EsTUFBT0EsQ0FBQUEsS0FBS0MsT0FBT25CLE1BQU0sQ0FBQ21CLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFDO1FBQ3pELE1BQU0sRUFBRVQsS0FBSyxFQUFFWixLQUFLLEVBQUVILFFBQVEsRUFBRUMsU0FBUyxFQUFFTSxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDdkVjLEtBQUtBO1FBQ0xBLEdBQUd0QixRQUFRLEdBQUdBO1FBQ2RzQixHQUFHckIsU0FBUyxHQUFHQTtRQUNmcUIsR0FBR2YsUUFBUSxHQUFHQTtRQUNkZSxHQUFHZCxTQUFTLEdBQUdBO1FBQ2ZjLEdBQUdQLEtBQUssR0FBR0EsTUFBTU0sVUFBVSxDQUFDQyxHQUFHUCxLQUFLO1FBQ3BDTyxHQUFHbkIsS0FBSyxHQUFHQSxNQUFNa0IsVUFBVSxDQUFDQyxHQUFHbkIsS0FBSztRQUNwQyxPQUFPbUI7SUFDWDtJQUNBRixVQUFVO1FBQ04sSUFBSSxDQUFDbkIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2MsS0FBSyxDQUFDSyxPQUFPO1FBQ2xCLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ2lCLE9BQU87SUFDdEI7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sTUFBTUssT0FBTyxDQUFDcEMsTUFBTWEsS0FBS3dCLFVBQVksSUFBSTdCLEtBQUtSLE1BQU1hLEtBQUtHLE1BQU0sQ0FBQ3FCLFNBQVNiLE1BQU0sR0FBRztBQUN6RlksS0FBS3JCLE1BQU0sR0FBRyxDQUFDZixNQUFNYSxNQUFRLElBQUlMLEtBQUtSLE1BQU1hLE1BQzVDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/MGNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiaGFzaCIsImFzc2VydEhhc2giLCJieXRlcyIsImFzc2VydEJ5dGVzIiwiZXhpc3RzIiwiYXNzZXJ0RXhpc3RzIiwiSGFzaCIsInRvQnl0ZXMiLCJITUFDIiwiY29uc3RydWN0b3IiLCJfa2V5IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJrZXkiLCJpSGFzaCIsImNyZWF0ZSIsInVwZGF0ZSIsIkVycm9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWQiLCJVaW50OEFycmF5Iiwic2V0IiwibGVuZ3RoIiwiZGlnZXN0IiwiaSIsIm9IYXNoIiwiZmlsbCIsImJ1ZiIsImRpZ2VzdEludG8iLCJvdXQiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJobWFjIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10\n    }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return {\n        c,\n        dkLen,\n        asyncTick,\n        DK,\n        PRF,\n        PRFSalt\n    };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW) prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */ function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for(let ui = 1; ui < c; ui++){\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, ()=>{\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n} //# sourceMappingURL=pbkdf2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vcGJrZGYyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBFO0FBQ3pDO0FBQ3NDO0FBQ3ZFLHdEQUF3RDtBQUN4RCxTQUFTUyxXQUFXVCxJQUFJLEVBQUVVLFNBQVMsRUFBRUMsS0FBSyxFQUFFQyxLQUFLO0lBQzdDWCxnREFBVUEsQ0FBQ0Q7SUFDWCxNQUFNYSxPQUFPTixvREFBU0EsQ0FBQztRQUFFTyxPQUFPO1FBQUlDLFdBQVc7SUFBRyxHQUFHSDtJQUNyRCxNQUFNLEVBQUVJLENBQUMsRUFBRUYsS0FBSyxFQUFFQyxTQUFTLEVBQUUsR0FBR0Y7SUFDaENWLGtEQUFZQSxDQUFDYTtJQUNiYixrREFBWUEsQ0FBQ1c7SUFDYlgsa0RBQVlBLENBQUNZO0lBQ2IsSUFBSUMsSUFBSSxHQUNKLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixNQUFNQyxXQUFXWixrREFBT0EsQ0FBQ0k7SUFDekIsTUFBTVMsT0FBT2Isa0RBQU9BLENBQUNLO0lBQ3JCLDhDQUE4QztJQUM5QyxNQUFNUyxLQUFLLElBQUlDLFdBQVdQO0lBQzFCLDBDQUEwQztJQUMxQyxNQUFNUSxNQUFNbEIsMENBQUlBLENBQUNtQixNQUFNLENBQUN2QixNQUFNa0I7SUFDOUIsTUFBTU0sVUFBVUYsSUFBSUcsVUFBVSxHQUFHQyxNQUFNLENBQUNQO0lBQ3hDLE9BQU87UUFBRUg7UUFBR0Y7UUFBT0M7UUFBV0s7UUFBSUU7UUFBS0U7SUFBUTtBQUNuRDtBQUNBLFNBQVNHLGFBQWFMLEdBQUcsRUFBRUUsT0FBTyxFQUFFSixFQUFFLEVBQUVRLElBQUksRUFBRUMsQ0FBQztJQUMzQ1AsSUFBSVEsT0FBTztJQUNYTixRQUFRTSxPQUFPO0lBQ2YsSUFBSUYsTUFDQUEsS0FBS0UsT0FBTztJQUNoQkQsRUFBRUUsSUFBSSxDQUFDO0lBQ1AsT0FBT1g7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNZLE9BQU9oQyxJQUFJLEVBQUVrQixRQUFR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QztBQUNoRCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcz9mNGYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgbnVtYmVyIGFzIGFzc2VydE51bWJlciB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbmltcG9ydCB7IGNyZWF0ZVZpZXcsIHRvQnl0ZXMsIGNoZWNrT3B0cywgYXN5bmNMb29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgY29uc3Qgb3B0cyA9IGNoZWNrT3B0cyh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBfb3B0cyk7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xuICAgIGFzc2VydE51bWJlcihjKTtcbiAgICBhc3NlcnROdW1iZXIoZGtMZW4pO1xuICAgIGFzc2VydE51bWJlcihhc3luY1RpY2spO1xuICAgIGlmIChjIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQktERjI6IGl0ZXJhdGlvbnMgKGMpIHNob3VsZCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSB0b0J5dGVzKF9wYXNzd29yZCk7XG4gICAgY29uc3Qgc2FsdCA9IHRvQnl0ZXMoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgdS5maWxsKDApO1xuICAgIHJldHVybiBESztcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzd29yZCBmcm9tIHdoaWNoIGEgZGVyaXZlZCBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxuICogQHBhcmFtIG9wdHMgLSB7YywgZGtMZW59IHdoZXJlIGMgaXMgd29yayBmYWN0b3IgYW5kIGRrTGVuIGlzIG91dHB1dCBtZXNzYWdlIHNpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKGMgLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIl0sIm5hbWVzIjpbImhhc2giLCJhc3NlcnRIYXNoIiwibnVtYmVyIiwiYXNzZXJ0TnVtYmVyIiwiaG1hYyIsImNyZWF0ZVZpZXciLCJ0b0J5dGVzIiwiY2hlY2tPcHRzIiwiYXN5bmNMb29wIiwicGJrZGYySW5pdCIsIl9wYXNzd29yZCIsIl9zYWx0IiwiX29wdHMiLCJvcHRzIiwiZGtMZW4iLCJhc3luY1RpY2siLCJjIiwiRXJyb3IiLCJwYXNzd29yZCIsInNhbHQiLCJESyIsIlVpbnQ4QXJyYXkiLCJQUkYiLCJjcmVhdGUiLCJQUkZTYWx0IiwiX2Nsb25lSW50byIsInVwZGF0ZSIsInBia2RmMk91dHB1dCIsInByZlciLCJ1IiwiZGVzdHJveSIsImZpbGwiLCJwYmtkZjIiLCJhcnIiLCJ2aWV3Iiwib3V0cHV0TGVuIiwidGkiLCJwb3MiLCJUaSIsInN1YmFycmF5Iiwic2V0SW50MzIiLCJkaWdlc3RJbnRvIiwic2V0IiwibGVuZ3RoIiwidWkiLCJpIiwicGJrZGYyQXN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDTztBQUNuRCxnRUFBZ0U7QUFDaEUsMERBQTBEO0FBQzFELG1CQUFtQjtBQUNuQix5RkFBeUY7QUFDekYsa0JBQWtCO0FBQ2xCLE1BQU1LLFdBQVcsYUFBYSxHQUFHLElBQUlDLFlBQVk7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsaUJBQWlCO0FBQ2pCLHdGQUF3RjtBQUN4RixrQkFBa0I7QUFDbEIsTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUQsWUFBWTtJQUM5QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNERBQTREO0FBQzVELG1EQUFtRDtBQUNuRCxNQUFNRSxXQUFXLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQ2pELE1BQU1HLGVBQWVULDBDQUFNQTtJQUN2QlUsYUFBYztRQUNWLEtBQUssQ0FBQyxJQUFJLElBQUksR0FBRztRQUNqQixtRUFBbUU7UUFDbkUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQ0MsQ0FBQyxHQUFHSixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0ssQ0FBQyxHQUFHTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ00sQ0FBQyxHQUFHTixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ08sQ0FBQyxHQUFHUCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ1EsQ0FBQyxHQUFHUixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ1MsQ0FBQyxHQUFHVCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ1UsQ0FBQyxHQUFHVixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ1csQ0FBQyxHQUFHWCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzVCO0lBQ0FZLE1BQU07UUFDRixNQUFNLEVBQUVSLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSTtRQUN2QyxPQUFPO1lBQUNQO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1NBQUU7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEJFLElBQUlULENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ3hCLElBQUksQ0FBQ1AsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7SUFDakI7SUFDQUcsUUFBUUMsSUFBSSxFQUFFQyxNQUFNLEVBQUU7UUFDbEIsZ0dBQWdHO1FBQ2hHLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUtELFVBQVUsRUFDbkNmLFFBQVEsQ0FBQ2dCLEVBQUUsR0FBR0YsS0FBS0csU0FBUyxDQUFDRixRQUFRO1FBQ3pDLElBQUssSUFBSUMsSUFBSSxJQUFJQSxJQUFJLElBQUlBLElBQUs7WUFDMUIsTUFBTUUsTUFBTWxCLFFBQVEsQ0FBQ2dCLElBQUksR0FBRztZQUM1QixNQUFNRyxLQUFLbkIsUUFBUSxDQUFDZ0IsSUFBSSxFQUFFO1lBQzFCLE1BQU1JLEtBQUt6QiwrQ0FBSUEsQ0FBQ3VCLEtBQUssS0FBS3ZCLCtDQUFJQSxDQUFDdUIsS0FBSyxNQUFPQSxRQUFRO1lBQ25ELE1BQU1HLEtBQUsxQiwrQ0FBSUEsQ0FBQ3dCLElBQUksTUFBTXhCLCtDQUFJQSxDQUFDd0IsSUFBSSxNQUFPQSxPQUFPO1lBQ2pEbkIsUUFBUSxDQUFDZ0IsRUFBRSxHQUFHLEtBQU1oQixRQUFRLENBQUNnQixJQUFJLEVBQUUsR0FBR0ksS0FBS3BCLFFBQVEsQ0FBQ2dCLElBQUksR0FBRyxHQUFJO1FBQ25FO1FBQ0EsNENBQTRDO1FBQzVDLElBQUksRUFBRWIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBRyxJQUFJO1FBQ3JDLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7WUFDekIsTUFBTU0sU0FBUzNCLCtDQUFJQSxDQUFDWSxHQUFHLEtBQUtaLCtDQUFJQSxDQUFDWSxHQUFHLE1BQU1aLCtDQUFJQSxDQUFDWSxHQUFHO1lBQ2xELE1BQU1nQixLQUFLLElBQUtELFNBQVM3QiwyQ0FBR0EsQ0FBQ2MsR0FBR0MsR0FBR0MsS0FBS1osUUFBUSxDQUFDbUIsRUFBRSxHQUFHaEIsUUFBUSxDQUFDZ0IsRUFBRSxHQUFJO1lBQ3JFLE1BQU1RLFNBQVM3QiwrQ0FBSUEsQ0FBQ1EsR0FBRyxLQUFLUiwrQ0FBSUEsQ0FBQ1EsR0FBRyxNQUFNUiwrQ0FBSUEsQ0FBQ1EsR0FBRztZQUNsRCxNQUFNc0IsS0FBSyxTQUFVL0IsMkNBQUdBLENBQUNTLEdBQUdDLEdBQUdDLEtBQU07WUFDckNLLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUksSUFBS2dCLEtBQU07WUFDZmpCLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUksS0FBTXNCLEtBQU07UUFDcEI7UUFDQSxxREFBcUQ7UUFDckR0QixJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CQyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CQyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQixJQUFJLENBQUNFLEdBQUcsQ0FBQ1QsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0M7SUFDbEM7SUFDQWdCLGFBQWE7UUFDVDFCLFNBQVMyQixJQUFJLENBQUM7SUFDbEI7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ2hCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQzlCLElBQUksQ0FBQ2lCLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDO0lBQ3JCO0FBQ0o7QUFDQSw0RUFBNEU7QUFDNUUsTUFBTUcsZUFBZTdCO0lBQ2pCQyxhQUFjO1FBQ1YsS0FBSztRQUNMLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNxQixTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLFNBQVMsYUFBYSxHQUFHcEMsMERBQWVBLENBQUMsSUFBTSxJQUFJSyxVQUFVO0FBQ25FLE1BQU1nQyxTQUFTLGFBQWEsR0FBR3JDLDBEQUFlQSxDQUFDLElBQU0sSUFBSWtDLFVBQVUsQ0FDMUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmx1c2gtbm90ZXMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzPzZmMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1ELCBDaGksIE1haiB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIkhhc2hNRCIsIkNoaSIsIk1haiIsInJvdHIiLCJ3cmFwQ29uc3RydWN0b3IiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiU0hBMjU2X0lWIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJjb25zdHJ1Y3RvciIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTIyNCIsIm91dHB1dExlbiIsInNoYTI1NiIsInNoYTIyNCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor(){\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA384()); //# sourceMappingURL=sha512.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ047QUFDaUI7QUFDN0MsMEdBQTBHO0FBQzFHLGtCQUFrQjtBQUNsQixNQUFNLENBQUNHLFdBQVdDLFVBQVUsR0FBbUIsYUFBSCxHQUFJLEtBQU1ILHFEQUFTLENBQUM7UUFDNUQ7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7S0FDckUsQ0FBQ0ssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQyxPQUFPRCxJQUFHO0FBQ3JCLDREQUE0RDtBQUM1RCxNQUFNRSxhQUFhLGFBQWEsR0FBRyxJQUFJQyxZQUFZO0FBQ25ELE1BQU1DLGFBQWEsYUFBYSxHQUFHLElBQUlELFlBQVk7QUFDNUMsTUFBTUUsZUFBZVosMENBQU1BO0lBQzlCYSxhQUFjO1FBQ1YsS0FBSyxDQUFDLEtBQUssSUFBSSxJQUFJO1FBQ25CLHdIQUF3SDtRQUN4SCxx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RUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNrRCxTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNPLE1BQU1HLFNBQVMsYUFBYSxHQUFHaEYsMERBQWVBLENBQUMsSUFBTSxJQUFJVSxVQUFVO0FBQ25FLE1BQU11RSxhQUFhLGFBQWEsR0FBR2pGLDBEQUFlQSxDQUFDLElBQU0sSUFBSTRFLGNBQWM7QUFDM0UsTUFBTU0sYUFBYSxhQUFhLEdBQUdsRiwwREFBZUEsQ0FBQyxJQUFNLElBQUk4RSxjQUFjO0FBQzNFLE1BQU1LLFNBQVMsYUFBYSxHQUFHbkYsMERBQWVBLENBQUMsSUFBTSxJQUFJK0UsVUFBVSxDQUMxRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/YTNlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNoTUQgfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEzODQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbIkhhc2hNRCIsInU2NCIsIndyYXBDb25zdHJ1Y3RvciIsIlNIQTUxMl9LaCIsIlNIQTUxMl9LbCIsInNwbGl0IiwibWFwIiwibiIsIkJpZ0ludCIsIlNIQTUxMl9XX0giLCJVaW50MzJBcnJheSIsIlNIQTUxMl9XX0wiLCJTSEE1MTIiLCJjb25zdHJ1Y3RvciIsIkFoIiwiQWwiLCJCaCIsIkJsIiwiQ2giLCJDbCIsIkRoIiwiRGwiLCJFaCIsIkVsIiwiRmgiLCJGbCIsIkdoIiwiR2wiLCJIaCIsIkhsIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1aCIsIlcxNWwiLCJzMGgiLCJyb3RyU0giLCJzaHJTSCIsInMwbCIsInJvdHJTTCIsInNoclNMIiwiVzJoIiwiVzJsIiwiczFoIiwicm90ckJIIiwiczFsIiwicm90ckJMIiwiU1VNbCIsImFkZDRMIiwiU1VNaCIsImFkZDRIIiwic2lnbWExaCIsInNpZ21hMWwiLCJDSEloIiwiQ0hJbCIsIlQxbGwiLCJhZGQ1TCIsIlQxaCIsImFkZDVIIiwiVDFsIiwic2lnbWEwaCIsInNpZ21hMGwiLCJNQUpoIiwiTUFKbCIsImgiLCJsIiwiYWRkIiwiQWxsIiwiYWRkM0wiLCJhZGQzSCIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTUxMl8yMjQiLCJvdXRwdXRMZW4iLCJTSEE1MTJfMjU2IiwiU0hBMzg0Iiwic2hhNTEyIiwic2hhNTEyXzIyNCIsInNoYTUxMl8yNTYiLCJzaGEzODQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDJFQUEyRTtBQUM3QjtBQUNDO0FBQy9DLDBDQUEwQztBQUMxQyxvRkFBb0Y7QUFDN0UsU0FBU0csUUFBUUMsQ0FBQztJQUNyQixPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQSwrQkFBK0I7QUFDeEIsTUFBTUMsS0FBSyxDQUFDQyxNQUFRLElBQUlKLFdBQVdJLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRixJQUFJRyxVQUFVLEVBQUU7QUFDL0UsTUFBTUMsTUFBTSxDQUFDSixNQUFRLElBQUlLLFlBQVlMLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFSSxLQUFLQyxLQUFLLENBQUNQLElBQUlHLFVBQVUsR0FBRyxJQUFJO0FBQ3hHLHFCQUFxQjtBQUNkLE1BQU1LLGFBQWEsQ0FBQ1IsTUFBUSxJQUFJUyxTQUFTVCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQzVGLCtEQUErRDtBQUN4RCxNQUFNTyxPQUFPLENBQUNDLE1BQU1DLFFBQVUsUUFBVSxLQUFLQSxRQUFXRCxTQUFTQyxNQUFPO0FBQy9FLDZEQUE2RDtBQUN0RCxNQUFNQyxPQUFPLENBQUNGLE1BQU1DLFFBQVUsUUFBU0EsUUFBVSxTQUFXLEtBQUtBLFVBQVksRUFBRztBQUNoRixNQUFNRSxPQUFPLElBQUlsQixXQUFXLElBQUlTLFlBQVk7SUFBQztDQUFXLEVBQUVKLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFL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TUwsU0FBUyxDQUFDO0lBQ3RCQyxNQUFNSyxTQUFTLEdBQUdELElBQUlDLFNBQVM7SUFDL0JMLE1BQU1NLFFBQVEsR0FBR0YsSUFBSUUsUUFBUTtJQUM3Qk4sTUFBTU8sTUFBTSxHQUFHLENBQUNkLE9BQVNNLFNBQVNOO0lBQ2xDLE9BQU9PO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLGNBQWMsRUFBRTtJQUN4QyxJQUFJdkcsd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUN3RyxlQUFlLEtBQUssWUFBWTtRQUN4RCxPQUFPeEcsd0RBQU1BLENBQUN3RyxlQUFlLENBQUMsSUFBSW5HLFdBQVdrRztJQUNqRDtJQUNBLE1BQU0sSUFBSXZELE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz9lZjdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImNyeXB0byIsImJ5dGVzIiwiYWJ5dGVzIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwidTgiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInUzMiIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiY3JlYXRlVmlldyIsIkRhdGFWaWV3Iiwicm90ciIsIndvcmQiLCJzaGlmdCIsInJvdGwiLCJpc0xFIiwiYnl0ZVN3YXAiLCJieXRlU3dhcElmQkUiLCJuIiwiYnl0ZVN3YXAzMiIsImkiLCJsZW5ndGgiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImhleCIsImFzY2lpcyIsIl8wIiwiXzkiLCJfQSIsIl9GIiwiX2EiLCJfZiIsImFzY2lpVG9CYXNlMTYiLCJjaGFyIiwiaGV4VG9CeXRlcyIsIkVycm9yIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwibmV4dFRpY2siLCJhc3luY0xvb3AiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwidG9CeXRlcyIsImRhdGEiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInN1bSIsInJlcyIsInBhZCIsInNldCIsIkhhc2giLCJjbG9uZSIsIl9jbG9uZUludG8iLCJ0b1N0ciIsImNoZWNrT3B0cyIsImRlZmF1bHRzIiwib3B0cyIsImNhbGwiLCJtZXJnZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJ3cmFwQ29uc3RydWN0b3IiLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJjcmVhdGUiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwicmFuZG9tQnl0ZXMiLCJieXRlc0xlbmd0aCIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/secp256k1/lib/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/secp256k1/lib/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signSync: () => (/* binding */ signSync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ \nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: _1n,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\")\n});\nconst divNearest = (a, b)=>(a + b / _2n) / b;\nconst endo = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar (k) {\n        const { n } = CURVE;\n        const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n        const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n        const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n        const b2 = a1;\n        const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\");\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error(\"splitScalarEndo: Endomorphism failed, k=\" + k);\n        }\n        return {\n            k1neg,\n            k1,\n            k2neg,\n            k2\n        };\n    }\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\n\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message){\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError(\"JacobianPoint expected\");\n}\nclass JacobianPoint {\n    constructor(x, y, z){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError(\"JacobianPoint#fromAffine: expected Point\");\n        }\n        if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p)=>p.z));\n        return points.map((p, i)=>p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n) return this;\n        if (X1 === _0n || Y1 === _0n) return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            } else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === \"bigint\" && scalar === _0n) return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n) return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while(k1 > _0n || k2 > _0n){\n            if (k1 & _1n) k1p = k1p.add(d);\n            if (k2 & _1n) k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg) k1p = k1p.negate();\n        if (k2neg) k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            for(let i = 1; i < 2 ** (W - 1); i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n        if (256 % W) {\n            throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for(let window = 0; window < windows; window++){\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            } else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return {\n            p,\n            f\n        };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        } else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([\n            point,\n            fake\n        ])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null) invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0) return Point.ZERO;\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd) y = mod(-y);\n        } else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd) y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen) return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![\n            0,\n            1,\n            2,\n            3\n        ].includes(recovery)) throw new Error(\"Cannot recover: invalid recovery bit\");\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? \"03\" : \"02\";\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q) throw new Error(\"Cannot recover signature: point at infinify\");\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? \"02\" : \"03\";\n            return `${prefix}${x}`;\n        } else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = \"Point is not on elliptic curve\";\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? \"00\" + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error(\"Invalid signature integer: trailing length\");\n    }\n    return {\n        data: bytesToNumber(res),\n        left: data.subarray(len + 2)\n    };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error(\"Invalid signature: incorrect length\");\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return {\n        r,\n        s\n    };\n}\nclass Signature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = \"Signature.fromCompact\";\n        if (typeof hex !== \"string\" && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== \"string\" && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r)) throw new Error(\"Invalid Signature: r must be 0 < r < n\");\n        if (!isWithinCurveOrder(s)) throw new Error(\"Invalid Signature: s must be 0 < s < n\");\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b)=>b instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    let hex = \"\";\n    for(let i = 0; i < uint8a.length; i++){\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt(\"0x10000000000000000000000000000000000000000000000000000000000000000\");\nfunction numTo32bStr(num) {\n    if (typeof num !== \"bigint\") throw new Error(\"Expected bigint\");\n    if (!(_0n <= num && num < POW_2_256)) throw new Error(\"Expected number 0 <= n < 2^256\");\n    return num.toString(16).padStart(64, \"0\");\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32) throw new Error(\"Error: expected 32 bytes\");\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToNumber: expected string, got \" + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToBytes: expected string, got \" + typeof hex);\n    }\n    if (hex.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\" + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === \"number\" && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n    if (typeof num === \"bigint\" && isWithinCurveOrder(num)) return num;\n    throw new TypeError(\"Expected valid private scalar: 0 < scalar < curve.n\");\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = x * x * x % P;\n    const b3 = b2 * b2 * x % P;\n    const b6 = pow2(b3, _3n) * b3 % P;\n    const b9 = pow2(b6, _3n) * b3 % P;\n    const b11 = pow2(b9, _2n) * b2 % P;\n    const b22 = pow2(b11, _11n) * b11 % P;\n    const b44 = pow2(b22, _22n) * b22 % P;\n    const b88 = pow2(b44, _44n) * b44 % P;\n    const b176 = pow2(b88, _88n) * b88 % P;\n    const b220 = pow2(b176, _44n) * b44 % P;\n    const b223 = pow2(b220, _3n) * b3 % P;\n    const t1 = pow2(b223, _23n) * b22 % P;\n    const t2 = pow2(t1, _6n) * b2 % P;\n    const rt = pow2(t2, _2n);\n    const xc = rt * rt % P;\n    if (xc !== x) throw new Error(\"Cannot find square root\");\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (num === _0n) return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i)=>{\n        if (num === _0n) return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly) return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen){\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n        if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== \"function\") throw new ShaError(\"hmacSha256Sync needs to be set\");\n    }\n    incr() {\n        if (this.counter >= 1000) throw new Error(\"Tried 1,000 k values for sign(), all were invalid\");\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([\n            0x00\n        ]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0) return;\n        this.k = await this.hmac(this.v, Uint8Array.from([\n            0x01\n        ]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([\n            0x00\n        ]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0) return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([\n            0x01\n        ]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while(len < this.qByteLen){\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while(len < this.qByteLen){\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k)) return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n) return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n) return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return {\n        sig,\n        recovery\n    };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === \"bigint\") {\n        num = key;\n    } else if (typeof key === \"number\" && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    } else if (typeof key === \"string\") {\n        if (key.length !== 2 * groupLen) throw new Error(\"Expected 32 bytes of private key\");\n        num = hexToNumber(key);\n    } else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen) throw new Error(\"Expected 32 bytes of private key\");\n        num = bytesToNumber(key);\n    } else {\n        throw new TypeError(\"Expected valid private key\");\n    }\n    if (!isWithinCurveOrder(num)) throw new Error(\"Expected private key: 0 < key < n\");\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    } else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    } catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === \"string\";\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point) return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA)) throw new TypeError(\"getSharedSecret: first arg must be private key\");\n    if (!isProbPub(publicB)) throw new TypeError(\"getSharedSecret: second arg must be public key\");\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [\n        int2octets(d),\n        bits2octets(h1)\n    ];\n    if (extraEntropy != null) {\n        if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return {\n        seed,\n        m,\n        d\n    };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({\n        canonical: true,\n        der: true\n    }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [\n        hashed,\n        recovery\n    ] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while(!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while(!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\n\nconst vopts = {\n    strict: true\n};\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    } catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS()) return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    } catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R) return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error(\"Invalid signature\");\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()){\n        if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32) throw new TypeError(\"sign: Expected 32 bytes of aux randomness\");\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return {\n            point,\n            scalar,\n            x: point.toRawX()\n        };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n) throw new Error(\"sign: Creation of signature failed. k is zero\");\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return {\n            R,\n            rx,\n            k\n        };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error(\"sign: Invalid signature produced\");\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!await schnorrVerify(sig, m, px)) this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px)) this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw) sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey)\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r) return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n        if (error instanceof ShaError) throw error;\n        return false;\n    }\n}\nconst schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined\n};\nconst TAGS = {\n    challenge: \"BIP0340/challenge\",\n    aux: \"BIP0340/aux\",\n    nonce: \"BIP0340/nonce\"\n};\nconst TAGGED_HASH_PREFIXES = {};\nconst utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey (privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash)=>{\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32)=>{\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        } else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        } else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: ()=>utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute (windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages)=>{\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest(\"SHA-256\", concatBytes(...messages));\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash(\"sha256\");\n            messages.forEach((m)=>hash.update(m));\n            return Uint8Array.from(hash.digest());\n        } else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages)=>{\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey(\"raw\", key, {\n                name: \"HMAC\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            }, false, [\n                \"sign\"\n            ]);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign(\"HMAC\", ckey, message);\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac(\"sha256\", key);\n            messages.forEach((m)=>hash.update(m));\n            return Uint8Array.from(hash.digest());\n        } else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages)=>{\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages)=>{\n        if (typeof _sha256Sync !== \"function\") throw new ShaError(\"sha256Sync is undefined, you need to set it\");\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get () {\n            return _sha256Sync;\n        },\n        set (val) {\n            if (!_sha256Sync) _sha256Sync = val;\n        }\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get () {\n            return _hmacSha256Sync;\n        },\n        set (val) {\n            if (!_hmacSha256Sync) _hmacSha256Sync = val;\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1RUFBdUUsR0FDbEM7QUFDckMsTUFBTUMsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxNQUFNSixPQUFPO0FBQ25CLE1BQU1LLFFBQVFDLE9BQU9DLE1BQU0sQ0FBQztJQUN4QkMsR0FBR1Q7SUFDSFUsR0FBR1QsT0FBTztJQUNWVSxHQUFHVixPQUFPO0lBQ1ZXLEdBQUdYLE9BQU87SUFDVlksR0FBR1g7SUFDSFksSUFBSWIsT0FBTztJQUNYYyxJQUFJZCxPQUFPO0lBQ1hlLE1BQU1mLE9BQU87QUFDakI7QUFDQSxNQUFNZ0IsYUFBYSxDQUFDUixHQUFHQyxJQUFNLENBQUNELElBQUlDLElBQUlQLEdBQUUsSUFBS087QUFDN0MsTUFBTVEsT0FBTztJQUNURixNQUFNZixPQUFPO0lBQ2JrQixhQUFZQyxDQUFDO1FBQ1QsTUFBTSxFQUFFUixDQUFDLEVBQUUsR0FBR047UUFDZCxNQUFNZSxLQUFLcEIsT0FBTztRQUNsQixNQUFNcUIsS0FBSyxDQUFDcEIsTUFBTUQsT0FBTztRQUN6QixNQUFNc0IsS0FBS3RCLE9BQU87UUFDbEIsTUFBTXVCLEtBQUtIO1FBQ1gsTUFBTUksWUFBWXhCLE9BQU87UUFDekIsTUFBTXlCLEtBQUtULFdBQVdPLEtBQUtKLEdBQUdSO1FBQzlCLE1BQU1lLEtBQUtWLFdBQVcsQ0FBQ0ssS0FBS0YsR0FBR1I7UUFDL0IsSUFBSWdCLEtBQUtDLElBQUlULElBQUlNLEtBQUtMLEtBQUtNLEtBQUtKLElBQUlYO1FBQ3BDLElBQUlrQixLQUFLRCxJQUFJLENBQUNILEtBQUtKLEtBQUtLLEtBQUtILElBQUlaO1FBQ2pDLE1BQU1tQixRQUFRSCxLQUFLSDtRQUNuQixNQUFN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L0Bub2JsZS9zZWNwMjU2azEvbGliL2VzbS9pbmRleC5qcz80MzY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1zZWNwMjU2azEgLSBNSVQgTGljZW5zZSAoYykgMjAxOSBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCAqIGFzIG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmNvbnN0IF84biA9IEJpZ0ludCg4KTtcbmNvbnN0IENVUlZFID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYTogXzBuLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBQOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gICAgaDogXzFuLFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxufSk7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuY29uc3QgZW5kbyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIHNwbGl0U2NhbGFyKGspIHtcbiAgICAgICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgIH0sXG59O1xuY29uc3QgZmllbGRMZW4gPSAzMjtcbmNvbnN0IGdyb3VwTGVuID0gMzI7XG5jb25zdCBoYXNoTGVuID0gMzI7XG5jb25zdCBjb21wcmVzc2VkTGVuID0gZmllbGRMZW4gKyAxO1xuY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIGZpZWxkTGVuICsgMTtcbmV4cG9ydCB7IENVUlZFIH07XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyh4KSB7XG4gICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICBjb25zdCB4MiA9IG1vZCh4ICogeCk7XG4gICAgY29uc3QgeDMgPSBtb2QoeDIgKiB4KTtcbiAgICByZXR1cm4gbW9kKHgzICsgYSAqIHggKyBiKTtcbn1cbmNvbnN0IFVTRV9FTkRPTU9SUEhJU00gPSBDVVJWRS5hID09PSBfMG47XG5jbGFzcyBTaGFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEphY1BvaW50KG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBKYWNvYmlhblBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCBleHBlY3RlZCcpO1xufVxuY2xhc3MgSmFjb2JpYW5Qb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgeikge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0phY29iaWFuUG9pbnQjZnJvbUFmZmluZTogZXhwZWN0ZWQgUG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5lcXVhbHMoUG9pbnQuWkVSTykpXG4gICAgICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQocC54LCBwLnksIF8xbik7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FmZmluZUJhdGNoKHBvaW50cykge1xuICAgICAgICBjb25zdCB0b0ludiA9IGludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAueikpO1xuICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpO1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQudG9BZmZpbmVCYXRjaChwb2ludHMpLm1hcChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0SmFjUG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgcmV0dXJuIFUxID09PSBVMiAmJiBTMSA9PT0gUzI7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpLCB0aGlzLnopO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgQSA9IG1vZChYMSAqIFgxKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IG1vZChCICogQik7XG4gICAgICAgIGNvbnN0IHgxYiA9IFgxICsgQjtcbiAgICAgICAgY29uc3QgRCA9IG1vZChfMm4gKiAobW9kKHgxYiAqIHgxYikgLSBBIC0gQykpO1xuICAgICAgICBjb25zdCBFID0gbW9kKF8zbiAqIEEpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEUgKiBFKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QoRiAtIF8ybiAqIEQpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChFICogKEQgLSBYMykgLSBfOG4gKiBDKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoXzJuICogWTEgKiBaMSk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydEphY1BvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHg6IFgyLCB5OiBZMiwgejogWjIgfSA9IG90aGVyO1xuICAgICAgICBpZiAoWDIgPT09IF8wbiB8fCBZMiA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChYMSA9PT0gXzBuIHx8IFkxID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgSCA9IG1vZChVMiAtIFUxKTtcbiAgICAgICAgY29uc3QgciA9IG1vZChTMiAtIFMxKTtcbiAgICAgICAgaWYgKEggPT09IF8wbikge1xuICAgICAgICAgICAgaWYgKHIgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBISCA9IG1vZChIICogSCk7XG4gICAgICAgIGNvbnN0IEhISCA9IG1vZChIICogSEgpO1xuICAgICAgICBjb25zdCBWID0gbW9kKFUxICogSEgpO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChyICogciAtIEhISCAtIF8ybiAqIFYpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChyICogKFYgLSBYMykgLSBTMSAqIEhISCk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKFoxICogWjIgKiBIKTtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgUDAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGFyID09PSAnYmlnaW50JyAmJiBzY2FsYXIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBQMDtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIVVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGxldCBwID0gUDA7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgIGxldCBrMXAgPSBQMDtcbiAgICAgICAgbGV0IGsycCA9IFAwO1xuICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIGVuZG8uYmV0YSksIGsycC55LCBrMnAueik7XG4gICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgfVxuICAgIHByZWNvbXB1dGVXaW5kb3coVykge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gVVNFX0VORE9NT1JQSElTTSA/IDEyOCAvIFcgKyAxIDogMjU2IC8gVyArIDE7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDIgKiogKFcgLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgd05BRihuLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBpZiAoIWFmZmluZVBvaW50ICYmIHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuQkFTRSkpXG4gICAgICAgICAgICBhZmZpbmVQb2ludCA9IFBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFcgPSAoYWZmaW5lUG9pbnQgJiYgYWZmaW5lUG9pbnQuX1dJTkRPV19TSVpFKSB8fCAxO1xuICAgICAgICBpZiAoMjU2ICUgVykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCN3TkFGOiBJbnZhbGlkIHByZWNvbXB1dGF0aW9uIHdpbmRvdywgbXVzdCBiZSBwb3dlciBvZiAyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNvbXB1dGVzID0gYWZmaW5lUG9pbnQgJiYgcG9pbnRQcmVjb21wdXRlcy5nZXQoYWZmaW5lUG9pbnQpO1xuICAgICAgICBpZiAoIXByZWNvbXB1dGVzKSB7XG4gICAgICAgICAgICBwcmVjb21wdXRlcyA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhXKTtcbiAgICAgICAgICAgIGlmIChhZmZpbmVQb2ludCAmJiBXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSBKYWNvYmlhblBvaW50Lm5vcm1hbGl6ZVoocHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KGFmZmluZVBvaW50LCBwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGxldCBmID0gSmFjb2JpYW5Qb2ludC5CQVNFO1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gMSArIChVU0VfRU5ET01PUlBISVNNID8gMTI4IC8gVyA6IDI1NiAvIFcpO1xuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxO1xuICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhciwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICBsZXQgZmFrZTtcbiAgICAgICAgaWYgKFVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBrMXAgPSBjb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICBrMnAgPSBjb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBlbmRvLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52Wikge1xuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTyk7XG4gICAgICAgIGlmIChpbnZaID09IG51bGwpXG4gICAgICAgICAgICBpbnZaID0gaXMwID8gXzhuIDogaW52ZXJ0KHopO1xuICAgICAgICBjb25zdCBpejEgPSBpbnZaO1xuICAgICAgICBjb25zdCBpejIgPSBtb2QoaXoxICogaXoxKTtcbiAgICAgICAgY29uc3QgaXozID0gbW9kKGl6MiAqIGl6MSk7XG4gICAgICAgIGNvbnN0IGF4ID0gbW9kKHggKiBpejIpO1xuICAgICAgICBjb25zdCBheSA9IG1vZCh5ICogaXozKTtcbiAgICAgICAgY29uc3QgenogPSBtb2QoeiAqIGl6MSk7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChheCwgYXkpO1xuICAgIH1cbn1cbkphY29iaWFuUG9pbnQuQkFTRSA9IG5ldyBKYWNvYmlhblBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuKTtcbkphY29iaWFuUG9pbnQuWkVSTyA9IG5ldyBKYWNvYmlhblBvaW50KF8wbiwgXzFuLCBfMG4pO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICUgXzJuID09PSBfMG47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcHJlc3NlZEhleChieXRlcykge1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gYnl0ZXMubGVuZ3RoID09PSAzMjtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoaXNTaG9ydCA/IGJ5dGVzIDogYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzKHgpO1xuICAgICAgICBsZXQgeSA9IHNxcnRNb2QoeTIpO1xuICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgaWYgKGlzU2hvcnQpIHtcbiAgICAgICAgICAgIGlmIChpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0Qnl0ZU9kZCA9IChieXRlc1swXSAmIDEpID09PSAxO1xuICAgICAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VbmNvbXByZXNzZWRIZXgoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMuc3ViYXJyYXkoMSwgZmllbGRMZW4gKyAxKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KGZpZWxkTGVuICsgMSwgZmllbGRMZW4gKiAyICsgMSkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGJ5dGVzWzBdO1xuICAgICAgICBpZiAobGVuID09PSBmaWVsZExlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZGVyID09PSAweDAyIHx8IGhlYWRlciA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZGVyID09PSAweDA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuY29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQuZnJvbUhleDogcmVjZWl2ZWQgaW52YWxpZCBwb2ludC4gRXhwZWN0ZWQgMzItJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXMsIG5vdCAke2xlbn1gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjb3ZlcnkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlcjogaW52YWxpZCByZWNvdmVyeSBiaXQnKTtcbiAgICAgICAgY29uc3QgaCA9IHRydW5jYXRlSGFzaChlbnN1cmVCeXRlcyhtc2dIYXNoKSk7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHJhZGogPSByZWNvdmVyeSA9PT0gMiB8fCByZWNvdmVyeSA9PT0gMyA/IHIgKyBuIDogcjtcbiAgICAgICAgY29uc3QgcmludiA9IGludmVydChyYWRqLCBuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoLWggKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgdTIgPSBtb2QocyAqIHJpbnYsIG4pO1xuICAgICAgICBjb25zdCBwcmVmaXggPSByZWNvdmVyeSAmIDEgPyAnMDMnIDogJzAyJztcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG8zMmJTdHIocmFkaikpO1xuICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpO1xuICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWNvdmVyIHNpZ25hdHVyZTogcG9pbnQgYXQgaW5maW5pZnknKTtcbiAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvSGV4KGlzQ29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICB0b0hleChpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB4ID0gbnVtVG8zMmJTdHIodGhpcy54KTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNFdmVuWSgpID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7eH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAwNCR7eH0ke251bVRvMzJiU3RyKHRoaXMueSl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0hleFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KHRydWUpLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0b1Jhd1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCBtc2cgPSAnUG9pbnQgaXMgbm90IG9uIGVsbGlwdGljIGN1cnZlJztcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkgfHwgIWlzVmFsaWRGaWVsZEVsZW1lbnQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IG1vZCh5ICogeSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3MoeCk7XG4gICAgICAgIGlmIChtb2QobGVmdCAtIHJpZ2h0KSAhPT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmRvdWJsZSgpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmFkZChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUob3RoZXIpKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5tdWx0aXBseShzY2FsYXIsIHRoaXMpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgUCA9IEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKTtcbiAgICAgICAgY29uc3QgYVAgPSBhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8IHRoaXMgIT09IFBvaW50LkJBU0UgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKTtcbiAgICAgICAgY29uc3QgYlEgPSBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUoUSkubXVsdGlwbHlVbnNhZmUoYik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGFQLmFkZChiUSk7XG4gICAgICAgIHJldHVybiBzdW0uZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTykgPyB1bmRlZmluZWQgOiBzdW0udG9BZmZpbmUoKTtcbiAgICB9XG59XG5Qb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSk7XG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzBuKTtcbmZ1bmN0aW9uIHNsaWNlREVSKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSA+PSA4ID8gJzAwJyArIHMgOiBzO1xufVxuZnVuY3Rpb24gcGFyc2VERVJJbnQoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnOiAke2J5dGVzVG9IZXgoZGF0YSl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGhgKTtcbiAgICB9XG4gICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiByZXNbMV0gPD0gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHRyYWlsaW5nIGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBieXRlc1RvTnVtYmVyKHJlcyksIGxlZnQ6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlREVSU2lnbmF0dXJlKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT0gMHgzMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIHRhZzogJHtieXRlc1RvSGV4KGRhdGEpfWApO1xuICAgIH1cbiAgICBpZiAoZGF0YVsxXSAhPT0gZGF0YS5sZW5ndGggLSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhOiByLCBsZWZ0OiBzQnl0ZXMgfSA9IHBhcnNlREVSSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgIGNvbnN0IHsgZGF0YTogcywgbGVmdDogckJ5dGVzTGVmdCB9ID0gcGFyc2VERVJJbnQoc0J5dGVzKTtcbiAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nOiAke2J5dGVzVG9IZXgockJ5dGVzTGVmdCl9YCk7XG4gICAgfVxuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKHIsIHMpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAnU2lnbmF0dXJlLmZyb21Db21wYWN0JztcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnICYmICFhcnIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke25hbWV9OiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCBzdHIgPSBhcnIgPyBieXRlc1RvSGV4KGhleCkgOiBoZXg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxMjgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IEV4cGVjdGVkIDY0LWJ5dGUgaGV4YCk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGhleFRvTnVtYmVyKHN0ci5zbGljZSgwLCA2NCkpLCBoZXhUb051bWJlcihzdHIuc2xpY2UoNjQsIDEyOCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2lnbmF0dXJlLmZyb21ERVI6IEV4cGVjdGVkIHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gcGFyc2VERVJTaWduYXR1cmUoYXJyID8gaGV4IDogaGV4VG9CeXRlcyhoZXgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tREVSKGhleCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZTogciBtdXN0IGJlIDAgPCByIDwgbicpO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHMgbXVzdCBiZSAwIDwgcyA8IG4nKTtcbiAgICB9XG4gICAgaGFzSGlnaFMoKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRS5uID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIHRoaXMucyA+IEhBTEY7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kKC10aGlzLnMsIENVUlZFLm4pKSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgICBjb25zdCBzSGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnMpKTtcbiAgICAgICAgY29uc3QgckhleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5yKSk7XG4gICAgICAgIGNvbnN0IHNIZXhMID0gc0hleC5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBySGV4TCA9IHJIZXgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc0xlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoc0hleEwpO1xuICAgICAgICBjb25zdCByTGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChySGV4TCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleEwgKyBzSGV4TCArIDQpO1xuICAgICAgICByZXR1cm4gYDMwJHtsZW5ndGh9MDIke3JMZW59JHtySGV4fTAyJHtzTGVufSR7c0hleH1gO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUlJhd0J5dGVzKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUkhleCgpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiU3RyKHRoaXMucikgKyBudW1UbzMyYlN0cih0aGlzLnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChiKSA9PiBiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgaWYgKCEodWludDhhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmNvbnN0IFBPV18yXzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuZnVuY3Rpb24gbnVtVG8zMmJTdHIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJpZ2ludCcpO1xuICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgUE9XXzJfMjU2KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBudW1iZXIgMCA8PSBuIDwgMl4yNTYnKTtcbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbn1cbmZ1bmN0aW9uIG51bVRvMzJiKG51bSkge1xuICAgIGNvbnN0IGIgPSBoZXhUb0J5dGVzKG51bVRvMzJiU3RyKG51bSkpO1xuICAgIGlmIChiLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IGV4cGVjdGVkIDMyIGJ5dGVzJyk7XG4gICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvTnVtYmVyOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYDB4JHtoZXh9YCk7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcgKyBoZXgubGVuZ3RoKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGhleCkge1xuICAgIHJldHVybiBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gVWludDhBcnJheS5mcm9tKGhleCkgOiBoZXhUb0J5dGVzKGhleCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY2FsYXIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID4gMClcbiAgICAgICAgcmV0dXJuIEJpZ0ludChudW0pO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB2YWxpZCBwcml2YXRlIHNjYWxhcjogMCA8IHNjYWxhciA8IGN1cnZlLm4nKTtcbn1cbmZ1bmN0aW9uIG1vZChhLCBiID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3FydE1vZCh4KSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBjb25zdCBfNm4gPSBCaWdJbnQoNik7XG4gICAgY29uc3QgXzExbiA9IEJpZ0ludCgxMSk7XG4gICAgY29uc3QgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyk7XG4gICAgY29uc3QgXzQ0biA9IEJpZ0ludCg0NCk7XG4gICAgY29uc3QgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeCAqIHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHgpICUgUDtcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybikgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4bikgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0bikgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82bikgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJ0ID0gcG93Mih0MiwgXzJuKTtcbiAgICBjb25zdCB4YyA9IChydCAqIHJ0KSAlIFA7XG4gICAgaWYgKHhjICE9PSB4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJ0O1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHNjcmF0Y2ggPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChudW0gPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHNjcmF0Y2hbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBfMW4pO1xuICAgIGNvbnN0IGludmVydGVkID0gaW52ZXJ0KGxhc3RNdWx0aXBsaWVkLCBwKTtcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gbW9kKGFjYyAqIHNjcmF0Y2hbaV0sIHApO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiBzY3JhdGNoO1xufVxuZnVuY3Rpb24gYml0czJpbnRfMihieXRlcykge1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIGdyb3VwTGVuICogODtcbiAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiB0cnVuY2F0ZUhhc2goaGFzaCwgdHJ1bmNhdGVPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBoID0gYml0czJpbnRfMihoYXNoKTtcbiAgICBpZiAodHJ1bmNhdGVPbmx5KVxuICAgICAgICByZXR1cm4gaDtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIHJldHVybiBoID49IG4gPyBoIC0gbiA6IGg7XG59XG5sZXQgX3NoYTI1NlN5bmM7XG5sZXQgX2htYWNTaGEyNTZTeW5jO1xuY2xhc3MgSG1hY0RyYmcge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hMZW4sIHFCeXRlTGVuKSB7XG4gICAgICAgIHRoaXMuaGFzaExlbiA9IGhhc2hMZW47XG4gICAgICAgIHRoaXMucUJ5dGVMZW4gPSBxQnl0ZUxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDEpO1xuICAgICAgICB0aGlzLmsgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDApO1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIH1cbiAgICBobWFjKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gdXRpbHMuaG1hY1NoYTI1Nih0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGhtYWNTeW5jKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gX2htYWNTaGEyNTZTeW5jKHRoaXMuaywgLi4udmFsdWVzKTtcbiAgICB9XG4gICAgY2hlY2tTeW5jKCkge1xuICAgICAgICBpZiAodHlwZW9mIF9obWFjU2hhMjU2U3luYyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGFFcnJvcignaG1hY1NoYTI1NlN5bmMgbmVlZHMgdG8gYmUgc2V0Jyk7XG4gICAgfVxuICAgIGluY3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgMSwwMDAgayB2YWx1ZXMgZm9yIHNpZ24oKSwgYWxsIHdlcmUgaW52YWxpZCcpO1xuICAgICAgICB0aGlzLmNvdW50ZXIgKz0gMTtcbiAgICB9XG4gICAgYXN5bmMgcmVzZWVkKHNlZWQgPSBuZXcgVWludDhBcnJheSgpKSB7XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAxXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICB9XG4gICAgcmVzZWVkU3luYyhzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmhtYWNTeW5jKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAwXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbmNyKCk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHRoaXMucUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB0aGlzLnYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVN5bmMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCB0aGlzLnFCeXRlTGVuKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHRoaXMudi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHRoaXMudi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5QO1xufVxuZnVuY3Rpb24ga21kVG9TaWcoa0J5dGVzLCBtLCBkLCBsb3dTID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgayA9IHRydW5jYXRlSGFzaChrQnl0ZXMsIHRydWUpO1xuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qga2ludiA9IGludmVydChrLCBuKTtcbiAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKTtcbiAgICBjb25zdCByID0gbW9kKHEueCwgbik7XG4gICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBtb2Qoa2ludiAqIG1vZChtICsgZCAqIHIsIG4pLCBuKTtcbiAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gc2lnLnIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTtcbiAgICBpZiAobG93UyAmJiBzaWcuaGFzSGlnaFMoKSkge1xuICAgICAgICBzaWcgPSBzaWcubm9ybWFsaXplUygpO1xuICAgICAgICByZWNvdmVyeSBePSAxO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWcsIHJlY292ZXJ5IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcml2YXRlS2V5KGtleSkge1xuICAgIGxldCBudW07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIG51bSA9IGtleTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoa2V5KSAmJiBrZXkgPiAwKSB7XG4gICAgICAgIG51bSA9IEJpZ0ludChrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMiAqIGdyb3VwTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAzMiBieXRlcyBvZiBwcml2YXRlIGtleScpO1xuICAgICAgICBudW0gPSBoZXhUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSBncm91cExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gYnl0ZXNUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcml2YXRlIGtleTogMCA8IGtleSA8IG4nKTtcbiAgICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHVibGljS2V5KHB1YmxpY0tleSkge1xuICAgIGlmIChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICBwdWJsaWNLZXkuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgc2lnbmF0dXJlLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihzaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzaWduYXR1cmUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVNpZ25hdHVyZShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICBpZiAoc3RyKVxuICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuICogMiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbiAqIDI7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXRTaGFyZWRTZWNyZXQ6IHNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgY29uc3QgYiA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNCKTtcbiAgICBiLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBieXRlcy5sZW5ndGggPiBmaWVsZExlbiA/IGJ5dGVzLnNsaWNlKDAsIGZpZWxkTGVuKSA6IGJ5dGVzO1xuICAgIHJldHVybiBieXRlc1RvTnVtYmVyKHNsaWNlKTtcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzKGJ5dGVzKSB7XG4gICAgY29uc3QgejEgPSBiaXRzMmludChieXRlcyk7XG4gICAgY29uc3QgejIgPSBtb2QoejEsIENVUlZFLm4pO1xuICAgIHJldHVybiBpbnQyb2N0ZXRzKHoyIDwgXzBuID8gejEgOiB6Mik7XG59XG5mdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgIHJldHVybiBudW1UbzMyYihudW0pO1xufVxuZnVuY3Rpb24gaW5pdFNpZ0FyZ3MobXNnSGFzaCwgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5KSB7XG4gICAgaWYgKG1zZ0hhc2ggPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduOiBleHBlY3RlZCB2YWxpZCBtZXNzYWdlIGhhc2gsIG5vdCBcIiR7bXNnSGFzaH1cImApO1xuICAgIGNvbnN0IGgxID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgZCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgYml0czJvY3RldHMoaDEpXTtcbiAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dHJhRW50cm9weSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGV4dHJhRW50cm9weSA9IHV0aWxzLnJhbmRvbUJ5dGVzKGZpZWxkTGVuKTtcbiAgICAgICAgY29uc3QgZSA9IGVuc3VyZUJ5dGVzKGV4dHJhRW50cm9weSk7XG4gICAgICAgIGlmIChlLmxlbmd0aCAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ246IEV4cGVjdGVkICR7ZmllbGRMZW59IGJ5dGVzIG9mIGV4dHJhIGRhdGFgKTtcbiAgICAgICAgc2VlZEFyZ3MucHVzaChlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTtcbiAgICBjb25zdCBtID0gYml0czJpbnQoaDEpO1xuICAgIHJldHVybiB7IHNlZWQsIG0sIGQgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2lnKHJlY1NpZywgb3B0cykge1xuICAgIGNvbnN0IHsgc2lnLCByZWNvdmVyeSB9ID0gcmVjU2lnO1xuICAgIGNvbnN0IHsgZGVyLCByZWNvdmVyZWQgfSA9IE9iamVjdC5hc3NpZ24oeyBjYW5vbmljYWw6IHRydWUsIGRlcjogdHJ1ZSB9LCBvcHRzKTtcbiAgICBjb25zdCBoYXNoZWQgPSBkZXIgPyBzaWcudG9ERVJSYXdCeXRlcygpIDogc2lnLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgcmV0dXJuIHJlY292ZXJlZCA/IFtoYXNoZWQsIHJlY292ZXJ5XSA6IGhhc2hlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBzZWVkLCBtLCBkIH0gPSBpbml0U2lnQXJncyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzLmV4dHJhRW50cm9weSk7XG4gICAgY29uc3QgZHJiZyA9IG5ldyBIbWFjRHJiZyhoYXNoTGVuLCBncm91cExlbik7XG4gICAgYXdhaXQgZHJiZy5yZXNlZWQoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhhd2FpdCBkcmJnLmdlbmVyYXRlKCksIG0sIGQsIG9wdHMuY2Fub25pY2FsKSkpXG4gICAgICAgIGF3YWl0IGRyYmcucmVzZWVkKCk7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnKHNpZywgb3B0cyk7XG59XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKGhhc2hMZW4sIGdyb3VwTGVuKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhkcmJnLmdlbmVyYXRlU3luYygpLCBtLCBkLCBvcHRzLmNhbm9uaWNhbCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydCB7IHNpZ24sIHNpZ25TeW5jIH07XG5jb25zdCB2b3B0cyA9IHsgc3RyaWN0OiB0cnVlIH07XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gdm9wdHMpIHtcbiAgICBsZXQgc2lnO1xuICAgIHRyeSB7XG4gICAgICAgIHNpZyA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIGlmIChvcHRzLnN0cmljdCAmJiBzaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2gobXNnSGFzaCk7XG4gICAgbGV0IFA7XG4gICAgdHJ5IHtcbiAgICAgICAgUCA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IHNpbnYgPSBpbnZlcnQocywgbik7XG4gICAgY29uc3QgdTEgPSBtb2QoaCAqIHNpbnYsIG4pO1xuICAgIGNvbnN0IHUyID0gbW9kKHIgKiBzaW52LCBuKTtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpO1xuICAgIGlmICghUilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHYgPSBtb2QoUi54LCBuKTtcbiAgICByZXR1cm4gdiA9PT0gcjtcbn1cbmZ1bmN0aW9uIHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuY2xhc3MgU2Nobm9yclNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4OiBleHBlY3RlZCA2NCBieXRlcywgbm90ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQocikgfHwgIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleCgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdYKCk7XG59XG5jbGFzcyBJbnRlcm5hbFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSB1dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzaWduOiBFeHBlY3RlZCB2YWxpZCBtZXNzYWdlLCBub3QgXCIke21lc3NhZ2V9XCJgKTtcbiAgICAgICAgdGhpcy5tID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgeCwgc2NhbGFyIH0gPSB0aGlzLmdldFNjYWxhcihub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgdGhpcy5weCA9IHg7XG4gICAgICAgIHRoaXMuZCA9IHNjYWxhcjtcbiAgICAgICAgdGhpcy5yYW5kID0gZW5zdXJlQnl0ZXMoYXV4UmFuZCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmQubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpZ246IEV4cGVjdGVkIDMyIGJ5dGVzIG9mIGF1eCByYW5kb21uZXNzJyk7XG4gICAgfVxuICAgIGdldFNjYWxhcihwcml2KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdik7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHBvaW50Lmhhc0V2ZW5ZKCkgPyBwcml2IDogQ1VSVkUubiAtIHByaXY7XG4gICAgICAgIHJldHVybiB7IHBvaW50LCBzY2FsYXIsIHg6IHBvaW50LnRvUmF3WCgpIH07XG4gICAgfVxuICAgIGluaXROb25jZShkLCB0MGgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyKHQwaCkpO1xuICAgIH1cbiAgICBmaW5hbGl6ZU5vbmNlKGswaCkge1xuICAgICAgICBjb25zdCBrMCA9IG1vZChieXRlc1RvTnVtYmVyKGswaCksIENVUlZFLm4pO1xuICAgICAgICBpZiAoazAgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogQ3JlYXRpb24gb2Ygc2lnbmF0dXJlIGZhaWxlZC4gayBpcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IHsgcG9pbnQ6IFIsIHg6IHJ4LCBzY2FsYXI6IGsgfSA9IHRoaXMuZ2V0U2NhbGFyKGswKTtcbiAgICAgICAgcmV0dXJuIHsgUiwgcngsIGsgfTtcbiAgICB9XG4gICAgZmluYWxpemVTaWcoUiwgaywgZSwgZCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaG5vcnJTaWduYXR1cmUoUi54LCBtb2QoayArIGUgKiBkLCBDVVJWRS5uKSkudG9SYXdCeXRlcygpO1xuICAgIH1cbiAgICBlcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSB1dGlscy50YWdnZWRIYXNoO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgYXdhaXQgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZShhd2FpdCB0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIShhd2FpdCBzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgY2FsY1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHsgbSwgZCwgcHgsIHJhbmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IHV0aWxzLnRhZ2dlZEhhc2hTeW5jO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZSh0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZSh0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIXNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJTaWduKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsYygpO1xufVxuZnVuY3Rpb24gc2Nobm9yclNpZ25TeW5jKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsY1N5bmMoKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmF3ID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2Nobm9yclNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWcgPSByYXcgPyBzaWduYXR1cmUgOiBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICBpZiAocmF3KVxuICAgICAgICBzaWcuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zaWcsXG4gICAgICAgIG06IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpLFxuICAgICAgICBQOiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpIHtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCBub3JtYWxpemVQcml2YXRlS2V5KHMpLCBtb2QoLWUsIENVUlZFLm4pKTtcbiAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB1dGlscy50YWdnZWRIYXNoKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnlTeW5jKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByLCBzLCBtLCBQIH0gPSBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUodXRpbHMudGFnZ2VkSGFzaFN5bmMoVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTaGFFcnJvcilcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSB7XG4gICAgU2lnbmF0dXJlOiBTY2hub3JyU2lnbmF0dXJlLFxuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgc2lnblN5bmM6IHNjaG5vcnJTaWduU3luYyxcbiAgICB2ZXJpZnlTeW5jOiBzY2hub3JyVmVyaWZ5U3luYyxcbn07XG5Qb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IG5vZGVDcnlwdG8sXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IFRBR1MgPSB7XG4gICAgY2hhbGxlbmdlOiAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAgIGF1eDogJ0JJUDAzNDAvYXV4JyxcbiAgICBub25jZTogJ0JJUDAzNDAvbm9uY2UnLFxufTtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzLFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIG1vZCxcbiAgICBpbnZlcnQsXG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYmlnaW50VG8zMkJ5dGVzOiBudW1UbzMyYixcbiAgICBfbm9ybWFsaXplUHJpdmF0ZUtleTogbm9ybWFsaXplUHJpdmF0ZUtleSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbiA9IGdyb3VwTGVuICsgODtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoIDwgbWluTGVuIHx8IGhhc2gubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODZgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBtb2QoYnl0ZXNUb051bWJlcihoYXNoKSwgQ1VSVkUubiAtIF8xbikgKyBfMW47XG4gICAgICAgIHJldHVybiBudW1UbzMyYihudW0pO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aCA9IDMyKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21CeXRlcyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB1dGlscy5oYXNoVG9Qcml2YXRlS2V5KHV0aWxzLnJhbmRvbUJ5dGVzKGdyb3VwTGVuICsgOCkpLFxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBwb2ludCA9PT0gUG9pbnQuQkFTRSA/IHBvaW50IDogbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjYWNoZWQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgIGNhY2hlZC5tdWx0aXBseShfM24pO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0sXG4gICAgc2hhMjU2OiBhc3luYyAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by53ZWIuc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNvbmNhdEJ5dGVzKC4uLm1lc3NhZ2VzKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIYXNoIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHNoYTI1NiBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG1hY1NoYTI1NjogYXN5bmMgKGtleSwgLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNrZXkgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnSE1BQycsIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0gfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb25jYXRCeXRlcyguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5zaWduKCdITUFDJywgY2tleSwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIbWFjIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4gaGFzaC51cGRhdGUobSkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgaG1hYy1zaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICBobWFjU2hhMjU2U3luYzogdW5kZWZpbmVkLFxuICAgIHRhZ2dlZEhhc2g6IGFzeW5jICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IGF3YWl0IHV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2hhMjU2KHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIHRhZ2dlZEhhc2hTeW5jOiAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF9zaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoYUVycm9yKCdzaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IF9zaGEyNTZTeW5jKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2hhMjU2U3luYyh0YWdQLCAuLi5tZXNzYWdlcyk7XG4gICAgfSxcbiAgICBfSmFjb2JpYW5Qb2ludDogSmFjb2JpYW5Qb2ludCxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyh1dGlscywge1xuICAgIHNoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaGEyNTZTeW5jO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICBpZiAoIV9zaGEyNTZTeW5jKVxuICAgICAgICAgICAgICAgIF9zaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgaG1hY1NoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9obWFjU2hhMjU2U3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfaG1hY1NoYTI1NlN5bmMpXG4gICAgICAgICAgICAgICAgX2htYWNTaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG59KTtcbiJdLCJuYW1lcyI6WyJub2RlQ3J5cHRvIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzhuIiwiQ1VSVkUiLCJPYmplY3QiLCJmcmVlemUiLCJhIiwiYiIsIlAiLCJuIiwiaCIsIkd4IiwiR3kiLCJiZXRhIiwiZGl2TmVhcmVzdCIsImVuZG8iLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJiMiIsIlBPV18yXzEyOCIsImMxIiwiYzIiLCJrMSIsIm1vZCIsImsyIiwiazFuZWciLCJrMm5lZyIsIkVycm9yIiwiZmllbGRMZW4iLCJncm91cExlbiIsImhhc2hMZW4iLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwid2VpZXJzdHJhc3MiLCJ4IiwieDIiLCJ4MyIsIlVTRV9FTkRPTU9SUEhJU00iLCJTaGFFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImFzc2VydEphY1BvaW50Iiwib3RoZXIiLCJKYWNvYmlhblBvaW50IiwiVHlwZUVycm9yIiwieSIsInoiLCJmcm9tQWZmaW5lIiwicCIsIlBvaW50IiwiZXF1YWxzIiwiWkVSTyIsInRvQWZmaW5lQmF0Y2giLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiaSIsInRvQWZmaW5lIiwibm9ybWFsaXplWiIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIloxWjEiLCJaMloyIiwiVTEiLCJVMiIsIlMxIiwiUzIiLCJuZWdhdGUiLCJkb3VibGUiLCJBIiwiQiIsIkMiLCJ4MWIiLCJEIiwiRSIsIkYiLCJYMyIsIlkzIiwiWjMiLCJhZGQiLCJIIiwiciIsIkhIIiwiSEhIIiwiViIsInN1YnRyYWN0IiwibXVsdGlwbHlVbnNhZmUiLCJzY2FsYXIiLCJQMCIsIm5vcm1hbGl6ZVNjYWxhciIsImQiLCJrMXAiLCJrMnAiLCJwcmVjb21wdXRlV2luZG93IiwiVyIsIndpbmRvd3MiLCJiYXNlIiwid2luZG93IiwicHVzaCIsIndOQUYiLCJhZmZpbmVQb2ludCIsIkJBU0UiLCJfV0lORE9XX1NJWkUiLCJwcmVjb21wdXRlcyIsInBvaW50UHJlY29tcHV0ZXMiLCJnZXQiLCJzZXQiLCJmIiwid2luZG93U2l6ZSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsIk1hdGgiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHkiLCJwb2ludCIsImZha2UiLCJmMXAiLCJmMnAiLCJpbnZaIiwiaXMwIiwiaW52ZXJ0IiwiaXoxIiwiaXoyIiwiaXozIiwiYXgiLCJheSIsInp6IiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIldlYWtNYXAiLCJfc2V0V2luZG93U2l6ZSIsImRlbGV0ZSIsImhhc0V2ZW5ZIiwiZnJvbUNvbXByZXNzZWRIZXgiLCJieXRlcyIsImlzU2hvcnQiLCJsZW5ndGgiLCJieXRlc1RvTnVtYmVyIiwic3ViYXJyYXkiLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwieTIiLCJzcXJ0TW9kIiwiaXNZT2RkIiwiaXNGaXJzdEJ5dGVPZGQiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21VbmNvbXByZXNzZWRIZXgiLCJmcm9tSGV4IiwiaGV4IiwiZW5zdXJlQnl0ZXMiLCJsZW4iLCJoZWFkZXIiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJub3JtYWxpemVQcml2YXRlS2V5IiwiZnJvbVNpZ25hdHVyZSIsIm1zZ0hhc2giLCJzaWduYXR1cmUiLCJyZWNvdmVyeSIsInMiLCJub3JtYWxpemVTaWduYXR1cmUiLCJpbmNsdWRlcyIsInRydW5jYXRlSGFzaCIsInJhZGoiLCJyaW52IiwidTEiLCJ1MiIsInByZWZpeCIsIlIiLCJudW1UbzMyYlN0ciIsIlEiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJoZXhUb0J5dGVzIiwidG9IZXgiLCJ0b0hleFgiLCJzbGljZSIsInRvUmF3WCIsIm1zZyIsImxlZnQiLCJyaWdodCIsImFQIiwiYlEiLCJzdW0iLCJ1bmRlZmluZWQiLCJzbGljZURFUiIsInBhcnNlSW50IiwicGFyc2VERVJJbnQiLCJkYXRhIiwiYnl0ZXNUb0hleCIsInJlcyIsInBhcnNlREVSU2lnbmF0dXJlIiwic0J5dGVzIiwickJ5dGVzTGVmdCIsIlNpZ25hdHVyZSIsImZyb21Db21wYWN0IiwiYXJyIiwiVWludDhBcnJheSIsIm5hbWUiLCJzdHIiLCJoZXhUb051bWJlciIsImZyb21ERVIiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJoYXNIaWdoUyIsIkhBTEYiLCJub3JtYWxpemVTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4Iiwic0hleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJySGV4Iiwic0hleEwiLCJySGV4TCIsInNMZW4iLCJyTGVuIiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsImV2ZXJ5IiwicmVkdWNlIiwicmVzdWx0IiwicGFkIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJ2IiwidG9TdHJpbmciLCJwYWRTdGFydCIsInVpbnQ4YSIsIlBPV18yXzI1NiIsIm51bSIsIm51bVRvMzJiIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsImJ5dGUiLCJpc05hTiIsImlzU2FmZUludGVnZXIiLCJwb3cyIiwicG93ZXIiLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJydCIsInhjIiwibnVtYmVyIiwibW9kdWxvIiwidSIsInEiLCJtIiwiZ2NkIiwibnVtcyIsInNjcmF0Y2giLCJsYXN0TXVsdGlwbGllZCIsImFjYyIsImludmVydGVkIiwicmVkdWNlUmlnaHQiLCJiaXRzMmludF8yIiwiZGVsdGEiLCJoYXNoIiwidHJ1bmNhdGVPbmx5IiwiX3NoYTI1NlN5bmMiLCJfaG1hY1NoYTI1NlN5bmMiLCJIbWFjRHJiZyIsInFCeXRlTGVuIiwiZmlsbCIsImNvdW50ZXIiLCJobWFjIiwidmFsdWVzIiwidXRpbHMiLCJobWFjU2hhMjU2IiwiaG1hY1N5bmMiLCJjaGVja1N5bmMiLCJpbmNyIiwicmVzZWVkIiwic2VlZCIsInJlc2VlZFN5bmMiLCJnZW5lcmF0ZSIsIm91dCIsInNsIiwiZ2VuZXJhdGVTeW5jIiwia21kVG9TaWciLCJrQnl0ZXMiLCJsb3dTIiwia2ludiIsInNpZyIsImtleSIsIm5vcm1hbGl6ZVB1YmxpY0tleSIsInB1YmxpY0tleSIsImVycm9yIiwiZ2V0UHVibGljS2V5IiwicmVjb3ZlclB1YmxpY0tleSIsImlzUHJvYlB1YiIsImdldFNoYXJlZFNlY3JldCIsInByaXZhdGVBIiwicHVibGljQiIsImJpdHMyaW50IiwiYml0czJvY3RldHMiLCJ6MSIsInoyIiwiaW50Mm9jdGV0cyIsImluaXRTaWdBcmdzIiwiZXh0cmFFbnRyb3B5IiwiaDEiLCJzZWVkQXJncyIsInJhbmRvbUJ5dGVzIiwiZSIsImZpbmFsaXplU2lnIiwicmVjU2lnIiwib3B0cyIsImRlciIsInJlY292ZXJlZCIsImFzc2lnbiIsImNhbm9uaWNhbCIsImhhc2hlZCIsInNpZ24iLCJwcml2S2V5IiwiZHJiZyIsInNpZ25TeW5jIiwidm9wdHMiLCJzdHJpY3QiLCJ2ZXJpZnkiLCJzaW52Iiwic2Nobm9yckNoYWxsZW5nZUZpbmFsaXplIiwiY2giLCJTY2hub3JyU2lnbmF0dXJlIiwic2Nobm9yckdldFB1YmxpY0tleSIsIkludGVybmFsU2Nobm9yclNpZ25hdHVyZSIsImF1eFJhbmQiLCJnZXRTY2FsYXIiLCJweCIsInJhbmQiLCJwcml2IiwiaW5pdE5vbmNlIiwidDBoIiwiZmluYWxpemVOb25jZSIsImswaCIsImswIiwicngiLCJjYWxjIiwidGFnIiwidGFnZ2VkSGFzaCIsInQiLCJUQUdTIiwiYXV4Iiwibm9uY2UiLCJjaGFsbGVuZ2UiLCJzY2hub3JyVmVyaWZ5IiwiY2FsY1N5bmMiLCJ0YWdnZWRIYXNoU3luYyIsInNjaG5vcnJWZXJpZnlTeW5jIiwic2Nobm9yclNpZ24iLCJzY2hub3JyU2lnblN5bmMiLCJpbml0U2Nobm9yclZlcmlmeSIsInJhdyIsImZpbmFsaXplU2Nobm9yclZlcmlmeSIsInNjaG5vcnIiLCJ2ZXJpZnlTeW5jIiwiY3J5cHRvIiwibm9kZSIsIndlYiIsInNlbGYiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsImlzVmFsaWRQcml2YXRlS2V5IiwiX2JpZ2ludFRvMzJCeXRlcyIsIl9ub3JtYWxpemVQcml2YXRlS2V5IiwiaGFzaFRvUHJpdmF0ZUtleSIsIm1pbkxlbiIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tUHJpdmF0ZUtleSIsInByZWNvbXB1dGUiLCJjYWNoZWQiLCJzaGEyNTYiLCJtZXNzYWdlcyIsImJ1ZmZlciIsInN1YnRsZSIsImRpZ2VzdCIsImNyZWF0ZUhhc2giLCJmb3JFYWNoIiwidXBkYXRlIiwiY2tleSIsImltcG9ydEtleSIsImNyZWF0ZUhtYWMiLCJzaGEyNTZTeW5jIiwiaG1hY1NoYTI1NlN5bmMiLCJ0YWdQIiwidGFnSCIsImMiLCJjaGFyQ29kZUF0IiwiX0phY29iaWFuUG9pbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwidmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/secp256k1/lib/esm/index.js\n");

/***/ })

};
;