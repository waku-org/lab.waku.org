"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/trough";
exports.ids = ["vendor-chunks/trough"];
exports.modules = {

/***/ "(ssr)/./node_modules/trough/index.js":
/*!**************************************!*\
  !*** ./node_modules/trough/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trough: () => (/* binding */ trough),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */ /**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */ function trough() {\n    /** @type {Array<Middleware>} */ const fns = [];\n    /** @type {Pipeline} */ const pipeline = {\n        run,\n        use\n    };\n    return pipeline;\n    /** @type {Run} */ function run(...values) {\n        let middlewareIndex = -1;\n        /** @type {Callback} */ const callback = values.pop();\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"Expected function as last argument, not \" + callback);\n        }\n        next(null, ...values);\n        /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */ function next(error, ...output) {\n            const fn = fns[++middlewareIndex];\n            let index = -1;\n            if (error) {\n                callback(error);\n                return;\n            }\n            // Copy non-nullish input into values.\n            while(++index < values.length){\n                if (output[index] === null || output[index] === undefined) {\n                    output[index] = values[index];\n                }\n            }\n            // Save the newly created `output` for the next call.\n            values = output;\n            // Next or done.\n            if (fn) {\n                wrap(fn, next)(...output);\n            } else {\n                callback(null, ...output);\n            }\n        }\n    }\n    /** @type {Use} */ function use(middelware) {\n        if (typeof middelware !== \"function\") {\n            throw new TypeError(\"Expected `middelware` to be a function, not \" + middelware);\n        }\n        fns.push(middelware);\n        return pipeline;\n    }\n}\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */ function wrap(middleware, callback) {\n    /** @type {boolean} */ let called;\n    return wrapped;\n    /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */ function wrapped(...parameters) {\n        const fnExpectsCallback = middleware.length > parameters.length;\n        /** @type {any} */ let result;\n        if (fnExpectsCallback) {\n            parameters.push(done);\n        }\n        try {\n            result = middleware.apply(this, parameters);\n        } catch (error) {\n            const exception = /** @type {Error} */ error;\n            // Well, this is quite the pickle.\n            // `middleware` received a callback and called it synchronously, but that\n            // threw an error.\n            // The only thing left to do is to throw the thing instead.\n            if (fnExpectsCallback && called) {\n                throw exception;\n            }\n            return done(exception);\n        }\n        if (!fnExpectsCallback) {\n            if (result instanceof Promise) {\n                result.then(then, done);\n            } else if (result instanceof Error) {\n                done(result);\n            } else {\n                then(result);\n            }\n        }\n    }\n    /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */ function done(error, ...output) {\n        if (!called) {\n            called = true;\n            callback(error, ...output);\n        }\n    }\n    /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */ function then(value) {\n        done(null, value);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbHVzaC1ub3Rlcy8uL25vZGVfbW9kdWxlcy90cm91Z2gvaW5kZXguanM/M2M3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHsoZXJyb3I/OiBFcnJvcnxudWxsfHVuZGVmaW5lZCwgLi4ub3V0cHV0OiBBcnJheTxhbnk+KSA9PiB2b2lkfSBDYWxsYmFja1xuICogQHR5cGVkZWYgeyguLi5pbnB1dDogQXJyYXk8YW55PikgPT4gYW55fSBNaWRkbGV3YXJlXG4gKlxuICogQHR5cGVkZWYgeyguLi5pbnB1dDogQXJyYXk8YW55PikgPT4gdm9pZH0gUnVuXG4gKiAgIENhbGwgYWxsIG1pZGRsZXdhcmUuXG4gKiBAdHlwZWRlZiB7KGZuOiBNaWRkbGV3YXJlKSA9PiBQaXBlbGluZX0gVXNlXG4gKiAgIEFkZCBgZm5gIChtaWRkbGV3YXJlKSB0byB0aGUgbGlzdC5cbiAqIEB0eXBlZGVmIHt7cnVuOiBSdW4sIHVzZTogVXNlfX0gUGlwZWxpbmVcbiAqICAgTWlkZGxld2FyZS5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBuZXcgbWlkZGxld2FyZS5cbiAqXG4gKiBAcmV0dXJucyB7UGlwZWxpbmV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cm91Z2goKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8TWlkZGxld2FyZT59ICovXG4gIGNvbnN0IGZucyA9IFtdXG4gIC8qKiBAdHlwZSB7UGlwZWxpbmV9ICovXG4gIGNvbnN0IHBpcGVsaW5lID0ge3J1biwgdXNlfVxuXG4gIHJldHVybiBwaXBlbGluZVxuXG4gIC8qKiBAdHlwZSB7UnVufSAqL1xuICBmdW5jdGlvbiBydW4oLi4udmFsdWVzKSB7XG4gICAgbGV0IG1pZGRsZXdhcmVJbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtDYWxsYmFja30gKi9cbiAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlcy5wb3AoKVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZnVuY3Rpb24gYXMgbGFzdCBhcmd1bWVudCwgbm90ICcgKyBjYWxsYmFjaylcbiAgICB9XG5cbiAgICBuZXh0KG51bGwsIC4uLnZhbHVlcylcblxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgbmV4dCBgZm5gLCBvciB3ZeKAmXJlIGRvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yfG51bGx8dW5kZWZpbmVkfSBlcnJvclxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gb3V0cHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV4dChlcnJvciwgLi4ub3V0cHV0KSB7XG4gICAgICBjb25zdCBmbiA9IGZuc1srK21pZGRsZXdhcmVJbmRleF1cbiAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgbm9uLW51bGxpc2ggaW5wdXQgaW50byB2YWx1ZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG91dHB1dFtpbmRleF0gPT09IG51bGwgfHwgb3V0cHV0W2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3V0cHV0W2luZGV4XSA9IHZhbHVlc1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIHRoZSBuZXdseSBjcmVhdGVkIGBvdXRwdXRgIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAgdmFsdWVzID0gb3V0cHV0XG5cbiAgICAgIC8vIE5leHQgb3IgZG9uZS5cbiAgICAgIGlmIChmbikge1xuICAgICAgICB3cmFwKGZuLCBuZXh0KSguLi5vdXRwdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsLCAuLi5vdXRwdXQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtVc2V9ICovXG4gIGZ1bmN0aW9uIHVzZShtaWRkZWx3YXJlKSB7XG4gICAgaWYgKHR5cGVvZiBtaWRkZWx3YXJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYG1pZGRlbHdhcmVgIHRvIGJlIGEgZnVuY3Rpb24sIG5vdCAnICsgbWlkZGVsd2FyZVxuICAgICAgKVxuICAgIH1cblxuICAgIGZucy5wdXNoKG1pZGRlbHdhcmUpXG4gICAgcmV0dXJuIHBpcGVsaW5lXG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwIGBtaWRkbGV3YXJlYC5cbiAqIENhbiBiZSBzeW5jIG9yIGFzeW5jOyByZXR1cm4gYSBwcm9taXNlLCByZWNlaXZlIGEgY2FsbGJhY2ssIG9yIHJldHVybiBuZXdcbiAqIHZhbHVlcyBhbmQgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7TWlkZGxld2FyZX0gbWlkZGxld2FyZVxuICogQHBhcmFtIHtDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAobWlkZGxld2FyZSwgY2FsbGJhY2spIHtcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgY2FsbGVkXG5cbiAgcmV0dXJuIHdyYXBwZWRcblxuICAvKipcbiAgICogQ2FsbCBgbWlkZGxld2FyZWAuXG4gICAqIEB0aGlzIHthbnl9XG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IGZuRXhwZWN0c0NhbGxiYWNrID0gbWlkZGxld2FyZS5sZW5ndGggPiBwYXJhbWV0ZXJzLmxlbmd0aFxuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgIGxldCByZXN1bHRcblxuICAgIGlmIChmbkV4cGVjdHNDYWxsYmFjaykge1xuICAgICAgcGFyYW1ldGVycy5wdXNoKGRvbmUpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG1pZGRsZXdhcmUuYXBwbHkodGhpcywgcGFyYW1ldGVycylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXhjZXB0aW9uID0gLyoqIEB0eXBlIHtFcnJvcn0gKi8gKGVycm9yKVxuXG4gICAgICAvLyBXZWxsLCB0aGlzIGlzIHF1aXRlIHRoZSBwaWNrbGUuXG4gICAgICAvLyBgbWlkZGxld2FyZWAgcmVjZWl2ZWQgYSBjYWxsYmFjayBhbmQgY2FsbGVkIGl0IHN5bmNocm9ub3VzbHksIGJ1dCB0aGF0XG4gICAgICAvLyB0aHJldyBhbiBlcnJvci5cbiAgICAgIC8vIFRoZSBvbmx5IHRoaW5nIGxlZnQgdG8gZG8gaXMgdG8gdGhyb3cgdGhlIHRoaW5nIGluc3RlYWQuXG4gICAgICBpZiAoZm5FeHBlY3RzQ2FsbGJhY2sgJiYgY2FsbGVkKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9uZShleGNlcHRpb24pXG4gICAgfVxuXG4gICAgaWYgKCFmbkV4cGVjdHNDYWxsYmFjaykge1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4odGhlbiwgZG9uZSlcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZG9uZShyZXN1bHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGVuKHJlc3VsdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBgY2FsbGJhY2tgLCBvbmx5IG9uY2UuXG4gICAqIEB0eXBlIHtDYWxsYmFja31cbiAgICovXG4gIGZ1bmN0aW9uIGRvbmUoZXJyb3IsIC4uLm91dHB1dCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlXG4gICAgICBjYWxsYmFjayhlcnJvciwgLi4ub3V0cHV0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkb25lYCB3aXRoIG9uZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAgICovXG4gIGZ1bmN0aW9uIHRoZW4odmFsdWUpIHtcbiAgICBkb25lKG51bGwsIHZhbHVlKVxuICB9XG59XG4iXSwibmFtZXMiOlsidHJvdWdoIiwiZm5zIiwicGlwZWxpbmUiLCJydW4iLCJ1c2UiLCJ2YWx1ZXMiLCJtaWRkbGV3YXJlSW5kZXgiLCJjYWxsYmFjayIsInBvcCIsIlR5cGVFcnJvciIsIm5leHQiLCJlcnJvciIsIm91dHB1dCIsImZuIiwiaW5kZXgiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ3cmFwIiwibWlkZGVsd2FyZSIsInB1c2giLCJtaWRkbGV3YXJlIiwiY2FsbGVkIiwid3JhcHBlZCIsInBhcmFtZXRlcnMiLCJmbkV4cGVjdHNDYWxsYmFjayIsInJlc3VsdCIsImRvbmUiLCJhcHBseSIsImV4Y2VwdGlvbiIsIlByb21pc2UiLCJ0aGVuIiwiRXJyb3IiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/trough/index.js\n");

/***/ })

};
;