"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/merge-options";
exports.ids = ["vendor-chunks/merge-options"];
exports.modules = {

/***/ "(ssr)/./node_modules/merge-options/index.js":
/*!*********************************************!*\
  !*** ./node_modules/merge-options/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst isOptionObject = __webpack_require__(/*! is-plain-obj */ \"(ssr)/./node_modules/is-plain-obj/index.js\");\nconst { hasOwnProperty } = Object.prototype;\nconst { propertyIsEnumerable } = Object;\nconst defineProperty = (object, name, value)=>Object.defineProperty(object, name, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n    });\nconst globalThis1 = void 0;\nconst defaultMergeOptions = {\n    concatArrays: false,\n    ignoreUndefined: false\n};\nconst getEnumerableOwnPropertyKeys = (value)=>{\n    const keys = [];\n    for(const key in value){\n        if (hasOwnProperty.call(value, key)) {\n            keys.push(key);\n        }\n    }\n    /* istanbul ignore else  */ if (Object.getOwnPropertySymbols) {\n        const symbols = Object.getOwnPropertySymbols(value);\n        for (const symbol of symbols){\n            if (propertyIsEnumerable.call(value, symbol)) {\n                keys.push(symbol);\n            }\n        }\n    }\n    return keys;\n};\nfunction clone(value) {\n    if (Array.isArray(value)) {\n        return cloneArray(value);\n    }\n    if (isOptionObject(value)) {\n        return cloneOptionObject(value);\n    }\n    return value;\n}\nfunction cloneArray(array) {\n    const result = array.slice(0, 0);\n    getEnumerableOwnPropertyKeys(array).forEach((key)=>{\n        defineProperty(result, key, clone(array[key]));\n    });\n    return result;\n}\nfunction cloneOptionObject(object) {\n    const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n    getEnumerableOwnPropertyKeys(object).forEach((key)=>{\n        defineProperty(result, key, clone(object[key]));\n    });\n    return result;\n}\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */ const mergeKeys = (merged, source, keys, config)=>{\n    keys.forEach((key)=>{\n        if (typeof source[key] === \"undefined\" && config.ignoreUndefined) {\n            return;\n        }\n        // Do not recurse into prototype chain of merged\n        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n            defineProperty(merged, key, merge(merged[key], source[key], config));\n        } else {\n            defineProperty(merged, key, clone(source[key]));\n        }\n    });\n    return merged;\n};\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */ const concatArrays = (merged, source, config)=>{\n    let result = merged.slice(0, 0);\n    let resultIndex = 0;\n    [\n        merged,\n        source\n    ].forEach((array)=>{\n        const indices = [];\n        // `result.concat(array)` with cloning\n        for(let k = 0; k < array.length; k++){\n            if (!hasOwnProperty.call(array, k)) {\n                continue;\n            }\n            indices.push(String(k));\n            if (array === merged) {\n                // Already cloned\n                defineProperty(result, resultIndex++, array[k]);\n            } else {\n                defineProperty(result, resultIndex++, clone(array[k]));\n            }\n        }\n        // Merge non-index keys\n        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key)=>!indices.includes(key)), config);\n    });\n    return result;\n};\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */ function merge(merged, source, config) {\n    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n        return concatArrays(merged, source, config);\n    }\n    if (!isOptionObject(source) || !isOptionObject(merged)) {\n        return clone(source);\n    }\n    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\nmodule.exports = function(...options) {\n    const config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);\n    let merged = {\n        _: {}\n    };\n    for (const option of options){\n        if (option === undefined) {\n            continue;\n        }\n        if (!isOptionObject(option)) {\n            throw new TypeError(\"`\" + option + \"` is not an Option Object\");\n        }\n        merged = merge(merged, {\n            _: option\n        }, config);\n    }\n    return merged._;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVyZ2Utb3B0aW9ucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGlCQUFpQkMsbUJBQU9BLENBQUM7QUFFL0IsTUFBTSxFQUFDQyxjQUFjLEVBQUMsR0FBR0MsT0FBT0MsU0FBUztBQUN6QyxNQUFNLEVBQUNDLG9CQUFvQixFQUFDLEdBQUdGO0FBQy9CLE1BQU1HLGlCQUFpQixDQUFDQyxRQUFRQyxNQUFNQyxRQUFVTixPQUFPRyxjQUFjLENBQUNDLFFBQVFDLE1BQU07UUFDbkZDO1FBQ0FDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO0lBQ2Y7QUFFQSxNQUFNQyxjQUFhO0FBQ25CLE1BQU1DLHNCQUFzQjtJQUMzQkMsY0FBYztJQUNkQyxpQkFBaUI7QUFDbEI7QUFFQSxNQUFNQywrQkFBK0JSLENBQUFBO0lBQ3BDLE1BQU1TLE9BQU8sRUFBRTtJQUVmLElBQUssTUFBTUMsT0FBT1YsTUFBTztRQUN4QixJQUFJUCxlQUFla0IsSUFBSSxDQUFDWCxPQUFPVSxNQUFNO1lBQ3BDRCxLQUFLRyxJQUFJLENBQUNGO1FBQ1g7SUFDRDtJQUVBLHlCQUF5QixHQUN6QixJQUFJaEIsT0FBT21CLHFCQUFxQixFQUFFO1FBQ2pDLE1BQU1DLFVBQVVwQixPQUFPbUIscUJBQXFCLENBQUNiO1FBRTdDLEtBQUssTUFBTWUsVUFBVUQsUUFBUztZQUM3QixJQUFJbEIscUJBQXFCZSxJQUFJLENBQUNYLE9BQU9lLFNBQVM7Z0JBQzdDTixLQUFLRyxJQUFJLENBQUNHO1lBQ1g7UUFDRDtJQUNEO0lBRUEsT0FBT047QUFDUjtBQUVBLFNBQVNPLE1BQU1oQixLQUFLO0lBQ25CLElBQUlpQixNQUFNQyxPQUFPLENBQUNsQixRQUFRO1FBQ3pCLE9BQU9tQixXQUFXbkI7SUFDbkI7SUFFQSxJQUFJVCxlQUFlUyxRQUFRO1FBQzFCLE9BQU9vQixrQkFBa0JwQjtJQUMxQjtJQUVBLE9BQU9BO0FBQ1I7QUFFQSxTQUFTbUIsV0FB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QUssQ0FBQyxHQUFHQztJQUN0RixJQUFJdUIsU0FBUztRQUFDYyxHQUFHLENBQUM7SUFBQztJQUVuQixLQUFLLE1BQU1DLFVBQVVGLFFBQVM7UUFDN0IsSUFBSUUsV0FBV0MsV0FBVztZQUN6QjtRQUNEO1FBRUEsSUFBSSxDQUFDckQsZUFBZW9ELFNBQVM7WUFDNUIsTUFBTSxJQUFJRSxVQUFVLE1BQU1GLFNBQVM7UUFDcEM7UUFFQWYsU0FBU0csTUFBTUgsUUFBUTtZQUFDYyxHQUFHQztRQUFNLEdBQUdiO0lBQ3JDO0lBRUEsT0FBT0YsT0FBT2MsQ0FBQztBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL21lcmdlLW9wdGlvbnMvaW5kZXguanM/YTI0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBpc09wdGlvbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iaicpO1xuXG5jb25zdCB7aGFzT3duUHJvcGVydHl9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtwcm9wZXJ0eUlzRW51bWVyYWJsZX0gPSBPYmplY3Q7XG5jb25zdCBkZWZpbmVQcm9wZXJ0eSA9IChvYmplY3QsIG5hbWUsIHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdHZhbHVlLFxuXHR3cml0YWJsZTogdHJ1ZSxcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuY29uc3QgZ2xvYmFsVGhpcyA9IHRoaXM7XG5jb25zdCBkZWZhdWx0TWVyZ2VPcHRpb25zID0ge1xuXHRjb25jYXRBcnJheXM6IGZhbHNlLFxuXHRpZ25vcmVVbmRlZmluZWQ6IGZhbHNlXG59O1xuXG5jb25zdCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzID0gdmFsdWUgPT4ge1xuXHRjb25zdCBrZXlzID0gW107XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuXHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0Y29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuXG5cdFx0Zm9yIChjb25zdCBzeW1ib2wgb2Ygc3ltYm9scykge1xuXHRcdFx0aWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbCkpIHtcblx0XHRcdFx0a2V5cy5wdXNoKHN5bWJvbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGtleXM7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVBcnJheSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAoaXNPcHRpb25PYmplY3QodmFsdWUpKSB7XG5cdFx0cmV0dXJuIGNsb25lT3B0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnJheSkge1xuXHRjb25zdCByZXN1bHQgPSBhcnJheS5zbGljZSgwLCAwKTtcblxuXHRnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGNsb25lKGFycmF5W2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xvbmVPcHRpb25PYmplY3Qob2JqZWN0KSB7XG5cdGNvbnN0IHJlc3VsdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGNsb25lKG9iamVjdFtrZXldKSk7XG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBtZXJnZWQgYWxyZWFkeSBjbG9uZWRcbiAqIEBwYXJhbSB7Kn0gc291cmNlIHNvbWV0aGluZyB0byBtZXJnZVxuICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5cyBrZXlzIHRvIG1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm5zIHsqfSBjbG9uZWQgT2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlS2V5cyA9IChtZXJnZWQsIHNvdXJjZSwga2V5cywgY29uZmlnKSA9PiB7XG5cdGtleXMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5pZ25vcmVVbmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEbyBub3QgcmVjdXJzZSBpbnRvIHByb3RvdHlwZSBjaGFpbiBvZiBtZXJnZWRcblx0XHRpZiAoa2V5IGluIG1lcmdlZCAmJiBtZXJnZWRba2V5XSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1lcmdlZCkpIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBtZXJnZShtZXJnZWRba2V5XSwgc291cmNlW2tleV0sIGNvbmZpZykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShtZXJnZWQsIGtleSwgY2xvbmUoc291cmNlW2tleV0pKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBtZXJnZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbWVyZ2VkIGFscmVhZHkgY2xvbmVkXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBzb21ldGhpbmcgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqXG4gKiBzZWUgW0FycmF5LnByb3RvdHlwZS5jb25jYXQgKCAuLi5hcmd1bWVudHMgKV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXQpXG4gKi9cbmNvbnN0IGNvbmNhdEFycmF5cyA9IChtZXJnZWQsIHNvdXJjZSwgY29uZmlnKSA9PiB7XG5cdGxldCByZXN1bHQgPSBtZXJnZWQuc2xpY2UoMCwgMCk7XG5cdGxldCByZXN1bHRJbmRleCA9IDA7XG5cblx0W21lcmdlZCwgc291cmNlXS5mb3JFYWNoKGFycmF5ID0+IHtcblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHQvLyBgcmVzdWx0LmNvbmNhdChhcnJheSlgIHdpdGggY2xvbmluZ1xuXHRcdGZvciAobGV0IGsgPSAwOyBrIDwgYXJyYXkubGVuZ3RoOyBrKyspIHtcblx0XHRcdGlmICghaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaykpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGluZGljZXMucHVzaChTdHJpbmcoaykpO1xuXG5cdFx0XHRpZiAoYXJyYXkgPT09IG1lcmdlZCkge1xuXHRcdFx0XHQvLyBBbHJlYWR5IGNsb25lZFxuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHJlc3VsdEluZGV4KyssIGFycmF5W2tdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgY2xvbmUoYXJyYXlba10pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNZXJnZSBub24taW5kZXgga2V5c1xuXHRcdHJlc3VsdCA9IG1lcmdlS2V5cyhyZXN1bHQsIGFycmF5LCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5maWx0ZXIoa2V5ID0+ICFpbmRpY2VzLmluY2x1ZGVzKGtleSkpLCBjb25maWcpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG1lcmdlZCBhbHJlYWR5IGNsb25lZFxuICogQHBhcmFtIHsqfSBzb3VyY2Ugc29tZXRoaW5nIHRvIG1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm5zIHsqfSBjbG9uZWQgT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKG1lcmdlZCwgc291cmNlLCBjb25maWcpIHtcblx0aWYgKGNvbmZpZy5jb25jYXRBcnJheXMgJiYgQXJyYXkuaXNBcnJheShtZXJnZWQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuXHRcdHJldHVybiBjb25jYXRBcnJheXMobWVyZ2VkLCBzb3VyY2UsIGNvbmZpZyk7XG5cdH1cblxuXHRpZiAoIWlzT3B0aW9uT2JqZWN0KHNvdXJjZSkgfHwgIWlzT3B0aW9uT2JqZWN0KG1lcmdlZCkpIHtcblx0XHRyZXR1cm4gY2xvbmUoc291cmNlKTtcblx0fVxuXG5cdHJldHVybiBtZXJnZUtleXMobWVyZ2VkLCBzb3VyY2UsIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoc291cmNlKSwgY29uZmlnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLi4ub3B0aW9ucykge1xuXHRjb25zdCBjb25maWcgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRpb25zKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdGlvbnMpO1xuXHRsZXQgbWVyZ2VkID0ge186IHt9fTtcblxuXHRmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzT3B0aW9uT2JqZWN0KG9wdGlvbikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2AnICsgb3B0aW9uICsgJ2AgaXMgbm90IGFuIE9wdGlvbiBPYmplY3QnKTtcblx0XHR9XG5cblx0XHRtZXJnZWQgPSBtZXJnZShtZXJnZWQsIHtfOiBvcHRpb259LCBjb25maWcpO1xuXHR9XG5cblx0cmV0dXJuIG1lcmdlZC5fO1xufTtcbiJdLCJuYW1lcyI6WyJpc09wdGlvbk9iamVjdCIsInJlcXVpcmUiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJvYmplY3QiLCJuYW1lIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnbG9iYWxUaGlzIiwiZGVmYXVsdE1lcmdlT3B0aW9ucyIsImNvbmNhdEFycmF5cyIsImlnbm9yZVVuZGVmaW5lZCIsImdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMiLCJrZXlzIiwia2V5IiwiY2FsbCIsInB1c2giLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltYm9sIiwiY2xvbmUiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZUFycmF5IiwiY2xvbmVPcHRpb25PYmplY3QiLCJhcnJheSIsInJlc3VsdCIsInNsaWNlIiwiZm9yRWFjaCIsImdldFByb3RvdHlwZU9mIiwiY3JlYXRlIiwibWVyZ2VLZXlzIiwibWVyZ2VkIiwic291cmNlIiwiY29uZmlnIiwibWVyZ2UiLCJyZXN1bHRJbmRleCIsImluZGljZXMiLCJrIiwibGVuZ3RoIiwiU3RyaW5nIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsIl8iLCJvcHRpb24iLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merge-options/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merge-options/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/merge-options/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/merge-options/index.js\");\n/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */ \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVyZ2Utb3B0aW9ucy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OztDQUlDLEdBRXFDO0FBQ3RDLGlFQUFlQSxzQ0FBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsdXNoLW5vdGVzLy4vbm9kZV9tb2R1bGVzL21lcmdlLW9wdGlvbnMvaW5kZXgubWpzP2EzOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGluIEVTTSB3cmFwcGVyIGZvciBDSlMgbmFtZWQgZXhwb3J0cy5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vcmVkZmluLmVuZ2luZWVyaW5nL25vZGUtbW9kdWxlcy1hdC13YXItd2h5LWNvbW1vbmpzLWFuZC1lcy1tb2R1bGVzLWNhbnQtZ2V0LWFsb25nLTk2MTcxMzVlZWNhMVxuICovXG5cbmltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnLi9pbmRleC5qcyc7XG5leHBvcnQgZGVmYXVsdCBtZXJnZU9wdGlvbnM7XG4iXSwibmFtZXMiOlsibWVyZ2VPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merge-options/index.mjs\n");

/***/ })

};
;